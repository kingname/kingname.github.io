<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="https://www.kingname.info/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2023-02-25T03:02:37.234Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>青南</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一日一技：【最新】再次突破CloudFlare五秒盾付费版</title>
    <link href="https://www.kingname.info/2023/02/25/crack-cf-2/"/>
    <id>https://www.kingname.info/2023/02/25/crack-cf-2/</id>
    <published>2023-02-25T03:01:20.000Z</published>
    <updated>2023-02-25T03:02:37.234Z</updated>
    
    <content type="html"><![CDATA[<p>去年我写了一篇文章：<a href="https://mp.weixin.qq.com/s/zwmatF3yTgSyS0gz8sinaA">一日一技：如何捅穿Cloud Flare的5秒盾</a> ，这篇文章使用的第三方库『cloudscraper』可以绕过免费版的五秒盾。但遇到付费版就无能为力了。</p><span id="more"></span><p>最近在爬币圈的网站，其中有一个网站叫做：<a href="https://www.coinbase.com/ventures/content">Codebase</a>使用的就是付费版的CloudFlare五秒盾。当我们使用CloudScraper去爬时，报错如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230225100842.png"></p><p>那么现阶段，付费版的CloudFlare五秒盾，有没有什么办法绕过呢？其实方法非常简单。只需要使用Docker运行一个容器就可以了。启动命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=flaresolverr \</span><br><span class="line">  -p 8191:8191 \</span><br><span class="line">  -e LOG_LEVEL=info \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  ghcr.io/flaresolverr/flaresolverr:latest</span><br></pre></td></tr></table></figure><p>这个容器启动以后，会开启8191端口。我们通过往这个端口发送http请求，让他转发请求给目标网站，就可以绕过五秒盾。</p><p>具体使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://localhost:8191/v1&quot;</span></span><br><span class="line"></span><br><span class="line">payload = json.dumps(&#123;</span><br><span class="line">  <span class="string">&quot;cmd&quot;</span>: <span class="string">&quot;request.get&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.coinbase.com/ventures/content&quot;</span>,</span><br><span class="line">  <span class="string">&quot;maxTimeout&quot;</span>: <span class="number">60000</span></span><br><span class="line">&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, headers=headers, data=payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个Docker镜像启动的接口，返回的数据是JOSN，网页源代码在其中的.solution.response中</span></span><br><span class="line"><span class="built_in">print</span>(response.json()[<span class="string">&#x27;solution&#x27;</span>][<span class="string">&#x27;response&#x27;</span>])</span><br></pre></td></tr></table></figure><p>访问效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230225101520.png"></p><p>我们再写几行代码来提取一下标题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230225104136.png"></p><p>我们启动的这个容器，为什么可以绕过CloudFlare的五秒盾呢，关键原因就在这个项目中：<a href="https://github.com/FlareSolverr/FlareSolverr">FlareSolverr</a>。大家可以阅读他的源代码，看看他是怎么绕过的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年我写了一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/zwmatF3yTgSyS0gz8sinaA&quot;&gt;一日一技：如何捅穿Cloud Flare的5秒盾&lt;/a&gt; ，这篇文章使用的第三方库『cloudscraper』可以绕过免费版的五秒盾。但遇到付费版就无能为力了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="5秒盾" scheme="https://www.kingname.info/tags/5%E7%A7%92%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Flask中如何嵌套启动子线程？</title>
    <link href="https://www.kingname.info/2023/01/14/nested-thread-in-flask/"/>
    <id>https://www.kingname.info/2023/01/14/nested-thread-in-flask/</id>
    <published>2023-01-14T11:31:48.000Z</published>
    <updated>2023-01-14T14:16:11.551Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在Flask中启动过子线程，然后在子线程中读写过<code>g</code>对象或者尝试从<code>request</code>对象中读取url参数，那么，你肯定对下面这个报错不陌生：<code>RuntimeError: Working outside of request context.</code>.</p><p>例如下面这段Flask代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inner_func</span>():</span><br><span class="line">    doc_id = request.args.get(<span class="string">&#x27;doc_id&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;用户ID为：<span class="subst">&#123;doc_id&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/start_thread&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_thread</span>():</span><br><span class="line">    thread = threading.Thread(target=inner_func)</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;success&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;获取用户ID成功！&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>请求<code>/start_thread</code>接口就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114194618.png"></p><p>如果你在网上搜索<code>flask thread RuntimeError: Working outside of request context. </code>，那么你可能会看到官方文档或者StackOverFlow上面提供了一个装饰器<code>@copy_current_request_context</code>。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114194838.png"></p><p>照着它这样写，确实能解决问题，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301141950772.png"></p><p>但无论是官网还是StackOverFlow，它的例子都非常简单。但是我们知道，启动线程有很多种方法，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一，启动简单线程</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">job = threading.Thread(target=函数名, args=(参数<span class="number">1</span>, 参数<span class="number">2</span>), kwargs=&#123;<span class="string">&#x27;参数3&#x27;</span>: xxx, <span class="string">&#x27;参数4&#x27;</span>: yyy&#125;)</span><br><span class="line">job.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2，使用类定义线程</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, 参数</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;子线程开始运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">job = Job(参数)</span><br><span class="line">job.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3，使用线程池</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line">pool = Pool(<span class="number">5</span>)  <span class="comment"># 5个线程的线程池</span></span><br><span class="line">pool.<span class="built_in">map</span>(函数名, 参数列表)</span><br></pre></td></tr></table></figure><p>网上的方法只能解决第一种写法的问题。如果想使用方法2和方法3启动子线程，代码应该怎么写呢？如果在子线程中又启动子线程，再用一次<code>@copy_current_request_context</code>还行吗？</p><p>相信我，你在网上搜索一下午，只有两种结果：一是找不到答案，二是找到的答案是晚于2023年1月14日的，因为是别人看了我这篇文章以后，再写的。</p><span id="more"></span><p>解答上面的问题前，还是说明一下我对于在后端启动子线程这个行为的观点。例如有些人喜欢在后端挂一个爬虫，请求接口以后，通过线程启动爬虫，爬虫开始爬数据。又或者，有些人在后端上面挂了一些复杂的程序代码，请求接口以后，后端启动子线程，在子线程中运行这些代码。</p><p>我一向是不建议在后端又启动子线程去做复杂操作的。无论你使用的是Flask还是Django还是FastAPI。正确的做法应该是使用消息队列，后端只是把触发任务的相关参数发送到消息队列中。下游真正的运行程序从消息队列读取到触发参数以后，开始运行。</p><p>但有时候，你可能综合考虑性价比，觉得再增加一个消息队列，成本太高；或者干脆是要赶工期，不得不先暂时使用多线程来解决问题，那么这篇文章将会极大帮助到你。</p><h2 id="尽量不要在子线程中读取请求相关的参数"><a href="#尽量不要在子线程中读取请求相关的参数" class="headerlink" title="尽量不要在子线程中读取请求相关的参数"></a>尽量不要在子线程中读取请求相关的参数</h2><p>如果你的子线程不需要读写<code>g</code>对象，也不需要从请求中读取各种参数，那么你就可以关闭这篇文章了。因为你的子线程可以直接运行，不会遇到什么的问题，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301142017952.png"></p><p>所以最好的解决方法，就是在启动子线程之前，提前先获取到子线程需要的每一个参数，然后把这些参数在启动子线程的时候作为函数参数传进去。如果你是从零开始写代码，那么一开始这样做，就可以帮你避免很多麻烦。</p><p>但如果你是修改已有的代码，并且嵌套太深，已经没有办法一层一层传入参数，或者代码量太大，不知道哪些地方悄悄调用了<code>g</code>对象或者读写了请求上下文，那么你可以继续往下看。</p><h2 id="装饰闭包函数而不是一级函数"><a href="#装饰闭包函数而不是一级函数" class="headerlink" title="装饰闭包函数而不是一级函数"></a>装饰闭包函数而不是一级函数</h2><p>上面的简单多线程写法，有一个地方需要特别注意，被<code>@copy_current_request_context</code>装饰的子线程入口函数<code>inner_func</code>，必须是闭包函数，不能是一级函数。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301142008230.png"></p><p>如果不小心装饰了一级函数，就会报如下的错误：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301142010857.png"></p><h2 id="线程池复制请求上下文"><a href="#线程池复制请求上下文" class="headerlink" title="线程池复制请求上下文"></a>线程池复制请求上下文</h2><p>当我们使用<code>multiprocessing.dummy</code>来实现线程池时，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, copy_current_request_context, g</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/start_thread&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_thread</span>():</span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">crawl</span>(<span class="params">doc_id</span>):</span><br><span class="line">        url_template = request.json.get(<span class="string">&#x27;url_template&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        url = url_template.<span class="built_in">format</span>(doc_id=doc_id)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;开始爬取：<span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    doc_id_list = [<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>, <span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>]</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(crawl, doc_id_list)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;success&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;爬取文章成功！&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301142029736.png"></p><p>写法上整体跟<code>threading.Thread</code>启动简单线程的方法差不多。</p><h2 id="用类定义线程时复制请求上下文"><a href="#用类定义线程时复制请求上下文" class="headerlink" title="用类定义线程时复制请求上下文"></a>用类定义线程时复制请求上下文</h2><p>当我们额外定义了一个线程类时，需要把被装饰的闭包函数传入到子线程中，然后在子线程的<code>run()</code>方法中运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, copy_current_request_context</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Job</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/start_thread&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_thread</span>():</span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runner</span>():</span><br><span class="line">        doc_id = request.json.get(<span class="string">&#x27;doc_id&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;docId的值是：<span class="subst">&#123;doc_id&#125;</span>&#x27;</span>)</span><br><span class="line">    job = Job(runner)</span><br><span class="line">    job.start()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;success&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;读取文章成功！&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301142051481.png"></p><h2 id="嵌套子线程复制请求上下文"><a href="#嵌套子线程复制请求上下文" class="headerlink" title="嵌套子线程复制请求上下文"></a>嵌套子线程复制请求上下文</h2><p>有时候，我们先创建了一个子线程，然后在子线程中，又需要创建孙线程。并且在孙线程中读取请求上下文。例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, copy_current_request_context</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deep_func_runner</span>(<span class="params">doc_id_list</span>):</span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deep_func</span>(<span class="params">doc_id</span>):</span><br><span class="line">        category = request.args.get(<span class="string">&#x27;category&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        url = <span class="string">f&#x27;https://www.kingname.info/<span class="subst">&#123;category&#125;</span>/<span class="subst">&#123;doc_id&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;开始爬取：<span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(deep_func, doc_id_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/start_thread&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_thread</span>():</span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runner</span>():</span><br><span class="line">        doc_id_list = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>, <span class="number">555</span>, <span class="number">666</span>, <span class="number">777</span>, <span class="number">888</span>, <span class="number">999</span>]</span><br><span class="line">        deep_func_runner(doc_id_list)</span><br><span class="line"></span><br><span class="line">    job = threading.Thread(target=runner)</span><br><span class="line">    job.start()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;success&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;读取文章成功！&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>此时使用<code>@copy_current_request_context</code>就会报您一个错误：<code>ValueError: &lt;Token var=&lt;ContextVar name=&#39;flask.request_ctx&#39; at 0x103ef69a0&gt; at 0x104446700&gt; was created in a different Context</code>。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114213320.png"></p><p>这个时候，我们就需要额外再创建一个装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copy_current_app_context</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">from</span> flask.<span class="built_in">globals</span> <span class="keyword">import</span> _app_ctx_stack</span><br><span class="line">    appctx = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">with</span> appctx:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> _</span><br></pre></td></tr></table></figure><p><code>@copy_current_app_context</code>这个装饰器需要放到孙线程里面<code>@copy_current_request_context</code>的上面。完整的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, copy_current_request_context</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_current_app_context</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">from</span> flask.<span class="built_in">globals</span> <span class="keyword">import</span> _app_ctx_stack</span><br><span class="line">    appctx = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">with</span> appctx:</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> _</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deep_func_runner</span>(<span class="params">doc_id_list</span>):</span><br><span class="line"><span class="meta">    @copy_current_app_context</span></span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deep_func</span>(<span class="params">doc_id</span>):</span><br><span class="line">        category = request.args.get(<span class="string">&#x27;category&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        url = <span class="string">f&#x27;https://www.kingname.info/<span class="subst">&#123;category&#125;</span>/<span class="subst">&#123;doc_id&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;开始爬取：<span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">    pool = Pool(<span class="number">3</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(deep_func, doc_id_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/start_thread&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_thread</span>():</span><br><span class="line"><span class="meta">    @copy_current_request_context</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">runner</span>():</span><br><span class="line">        doc_id_list = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>, <span class="number">555</span>, <span class="number">666</span>, <span class="number">777</span>, <span class="number">888</span>, <span class="number">999</span>]</span><br><span class="line">        deep_func_runner(doc_id_list)</span><br><span class="line"></span><br><span class="line">    job = threading.Thread(target=runner)</span><br><span class="line">    job.start()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;success&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;读取文章成功！&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，孙线程也正常启动了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114213630.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>非必要不在后端中创建子线程</li><li>创建子线程时，如果能把参数从外面传入，就不要让子线程自己去Flask的上下文读取</li><li><code>@copy_current_request_context</code>需要装饰闭包函数，不能装饰一级函数</li><li>嵌套子线程需要同时使用<code>@copy_current_app_context</code>和<code>@copy_current_request_context</code>两个装饰器来装饰孙线程的闭包函数</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你在Flask中启动过子线程，然后在子线程中读写过&lt;code&gt;g&lt;/code&gt;对象或者尝试从&lt;code&gt;request&lt;/code&gt;对象中读取url参数，那么，你肯定对下面这个报错不陌生：&lt;code&gt;RuntimeError: Working outside of request context.&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;例如下面这段Flask代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Flask, request&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;inner_func&lt;/span&gt;():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doc_id = request.args.get(&lt;span class=&quot;string&quot;&gt;&amp;#x27;doc_id&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;f&amp;#x27;用户ID为：&lt;span class=&quot;subst&quot;&gt;&amp;#123;doc_id&amp;#125;&lt;/span&gt;&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;/start_thread&amp;#x27;&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;start_thread&lt;/span&gt;():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread = threading.Thread(target=inner_func)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    thread.start()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;success&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;msg&amp;#x27;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;获取用户ID成功！&amp;#x27;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;请求&lt;code&gt;/start_thread&lt;/code&gt;接口就会报错，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114194618.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你在网上搜索&lt;code&gt;flask thread RuntimeError: Working outside of request context. &lt;/code&gt;，那么你可能会看到官方文档或者StackOverFlow上面提供了一个装饰器&lt;code&gt;@copy_current_request_context&lt;/code&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20230114194838.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;照着它这样写，确实能解决问题，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/202301141950772.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;但无论是官网还是StackOverFlow，它的例子都非常简单。但是我们知道，启动线程有很多种方法，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 方法一，启动简单线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job = threading.Thread(target=函数名, args=(参数&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, 参数&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), kwargs=&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;参数3&amp;#x27;&lt;/span&gt;: xxx, &lt;span class=&quot;string&quot;&gt;&amp;#x27;参数4&amp;#x27;&lt;/span&gt;: yyy&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job.start()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 方法2，使用类定义线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Job&lt;/span&gt;(threading.Thread):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, 参数&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;super&lt;/span&gt;().__init__()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;子线程开始运行&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job = Job(参数)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job.start()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 方法3，使用线程池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; multiprocessing.dummy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Pool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pool = Pool(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 5个线程的线程池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pool.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(函数名, 参数列表)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;网上的方法只能解决第一种写法的问题。如果想使用方法2和方法3启动子线程，代码应该怎么写呢？如果在子线程中又启动子线程，再用一次&lt;code&gt;@copy_current_request_context&lt;/code&gt;还行吗？&lt;/p&gt;
&lt;p&gt;相信我，你在网上搜索一下午，只有两种结果：一是找不到答案，二是找到的答案是晚于2023年1月14日的，因为是别人看了我这篇文章以后，再写的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="Flask" scheme="https://www.kingname.info/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何正确为历史遗留代码补充单元测试？</title>
    <link href="https://www.kingname.info/2023/01/01/add-unit-test-for-old-code/"/>
    <id>https://www.kingname.info/2023/01/01/add-unit-test-for-old-code/</id>
    <published>2023-01-01T06:54:12.000Z</published>
    <updated>2023-01-01T06:59:52.837Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在软件工程中，单元测试是保证软件质量的重要手段之一。一个优秀的代码，单元测试的代码量，经常会超过被测试的代码本身。一个理想化的开发团队，可能有三分之二的时间是在写测试，剩下的三分之一时间才是写业务代码。</p><span id="more"></span><p>如果你的项目是从一开始就写单元测试，那么你写起来应该轻松又愉快，因为单元测试会促使你的代码自身变成可测试的代码。</p><p>但如果你接手了一个大项目，里面已经有几十万行代码了，那么给这些代码补单元测试会让你知道什么叫做痛不欲生。你会发现有一些函数，它让你不知道怎么写测试代码。</p><p>我们来看一个例子：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825225545.png"></p><p>我想测试的是<code>business_code</code>里面，<code>check_data_dup</code>分别返回True或者False的时候，下面代码的逻辑。也就是说，我只关心第18-27行的逻辑。这个时候不关心MySQL和Redis。但是每次测试都要从他们里面读取数据，这样就会导致测试代码依赖外部环境。如果MySQL或者Redis挂了，那么测试代码就会运行失败。</p><p>而且，就算Redis和MySQL没有故障，你怎么知道你的data_id和pk，在数据库中对应的是什么数据？为了分别走到特定的分支，你还需要去检测数据库中特定数据的id。万一是测试环境，别人修改了里面的数据，你的测试也可能会挂掉。</p><p>如果直接使用Pytest来写测试案例，代码是这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825230624.png"></p><p>可以看到，我运行Pytest以后，成功了一个，失败了一个。这里我模拟出数据库中没有数据能够让<code>check_data_dup</code>走到返回<code>True</code>逻辑的情况。</p><p>难道为了让单元测试进行下去，我还要去数据库构造一条特定的数据？这只是单元测试，又不是集成测试。</p><p>为了解决这个问题，我们就可以使用<code>mock</code>模块。这是Python自带的一个模块，可以动态替换函数。</p><p>它的写法非常简单：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825232830.png"></p><p>我们只需要使用<code>@mock.patch</code>装饰器，装饰测试函数就可以了。这个装饰器接收两个参数，第一个参数是被模拟的函数的路径，以点分割；第二个参数是你想让它返回的值。</p><p>从上图可以看到，<code>test_runner.py</code>运行以后，原本在<code>read_data_from_redis</code>和<code>read_data_from_mysql</code>中打印的两段文字都没有打印，说明这两个函数已经被动态替换了，他们内部的代码不会运行。只会直接返回我们预设的这个返回值。这样一来就跟数据库解耦了。</p><p>注意，在上图中，由于我们已经mock了<code>check_data_dup</code>，因此<code>read_data_from_redis</code>和<code>read_data_from_mysql</code>两个函数随便返回什么值都可以。如果你想顺带也测试一下<code>check_data_dup</code>，那么可以不mock它，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825233357.png"></p><p>在<code>check_data_dup</code>函数的逻辑中，如果<code>data</code>参数含有字符<code>x</code>，并且<code>user_id</code>是偶数，就返回<code>True</code>，否则返回<code>False</code>。我们通过mock两个读数据的函数，分别设置不同的返回值，就能满足让<code>check_data_dup</code>返回不同值的条件。</p><p><code>mock.path</code>有一个小坑，一定要注意。我们来看看下面这个文件结构：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825234500.png"></p><p><code>read_data_from_redis</code>和<code>read_data_from_mysql</code>两个函数分布在了不同的文件里面。在<code>runner.py</code>中导入并使用了他们。<code>test_runner.py</code>中，我们使用<code>@mock.patch</code>对这两个函数定义的路径打补丁进行替换。可是替换了以后，运行Pytest，会发现这两个函数竟然正常运行了。也就是说我们的替换失败了。</p><p>之所以会出现这种情况，是因为我们要打补丁的并不是这两个函数定义的地方，而是使用的地方。我们在<code>runner.py</code>中，分别使用如下两个语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mysql_util.SqlUtil <span class="keyword">import</span> read_data_from_mysql</span><br><span class="line"><span class="keyword">from</span> controller.lib.redis.RedisUtil <span class="keyword">import</span> read_data_from_redis</span><br></pre></td></tr></table></figure><p>导入了这两个函数，我们也是在<code>runner.py</code>中使用他们的。因此，<code>@mock.patch</code>的第一个参数，依然应该是<code>runner.read_data_from_redis</code>和<code>runner.read_data_from_mysql</code>。</p><p>正确的做法如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220825234131.png"></p><p><code>mock.patch</code>还有更多高级用法，例如替换类，替换实例方法等等。可以在<a href="https://docs.python.org/dev/library/unittest.mock.html">unittest.mock</a>中找到他。从Python 3.3开始，官方自带了<code>unittest.mock</code>，它跟直接<code>import mock</code>的效果是一样的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道，在软件工程中，单元测试是保证软件质量的重要手段之一。一个优秀的代码，单元测试的代码量，经常会超过被测试的代码本身。一个理想化的开发团队，可能有三分之二的时间是在写测试，剩下的三分之一时间才是写业务代码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="单元测试" scheme="https://www.kingname.info/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>长见识，让大家看看什么是垃圾代码</title>
    <link href="https://www.kingname.info/2023/01/01/trash-code/"/>
    <id>https://www.kingname.info/2023/01/01/trash-code/</id>
    <published>2023-01-01T06:54:02.000Z</published>
    <updated>2023-01-01T06:58:18.377Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的文章中，在微信群中，我多次强调，写函数的时候，不要把所有参数放到一个大字典里面作为参数到处传，否则时间久了以后，根本不知道字典里面有哪些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">data</span>):</span><br><span class="line">    name = data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    age = data[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    xxx = data[<span class="string">&#x27;xx&#x27;</span>]</span><br></pre></td></tr></table></figure><p>上面这样写，对原作者来说确实简单，但是如果代码还有别人来维护，他就根本不知道这个字典里面有哪些数据。必须要一层一层查找调用链，费时费力。</p><span id="more"></span><p>但我是真的万万没想到，还有比上面这种写法更傻X的代码。真的可以称得上是垃圾中的垃圾。我们来看看下面这段代码。</p><p>现在有一个类A，里面有两千多行代码。还有一个类B，里面有三千多行代码。这两个类里面有一些实例方法，有700多行代码。这些我都忍了。</p><p>更要命的是，初始化类B的时候，需要传入一个字典。这个字典有80多个Key。并且，他们是下面这样写的。</p><p>B类在xxx.py文件里面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, query_dict</span>):</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> query_dict.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, key, value)</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure><p>A类在yyy.py文件里面，它的代码是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, instance</span>): <span class="comment"># instance是类B的实例对象</span></span><br><span class="line">        self.__dict__.update(instance.__dict__)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.something)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>A类中，有很多地方就像实例方法<code>methid_x()</code>一样，直接调用了一些看起来像是实例属性的东西，例如上面这个<code>self.something</code>。这些长得像实例属性的东西，在PyCharm会直接报属性没有定义。但是运行却没有问题。因为这些<code>something</code>是初始化B类的时候，传入的那个字典中的一个key。</p><p>外界都在说Python不适合做大项目，因为代码规模大了以后难以维护。你们看看上面这段代码，写成这个鬼样子，要容易维护才有鬼了。</p><p>我之前就说过：</p><ol><li>如果是一个人写项目那用Python又快又好。</li><li>如果是很多个非常厉害的人写项目，用Python也是又快又好。</li><li>如果很多人中，但凡有一个人是拖后腿捣乱的，那还是别用Python了，用Java可以防止这个人捣乱。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在以前的文章中，在微信群中，我多次强调，写函数的时候，不要把所有参数放到一个大字典里面作为参数到处传，否则时间久了以后，根本不知道字典里面有哪些数据：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = data[&lt;span class=&quot;string&quot;&gt;&amp;#x27;name&amp;#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age = data[&lt;span class=&quot;string&quot;&gt;&amp;#x27;age&amp;#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xxx = data[&lt;span class=&quot;string&quot;&gt;&amp;#x27;xx&amp;#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面这样写，对原作者来说确实简单，但是如果代码还有别人来维护，他就根本不知道这个字典里面有哪些数据。必须要一层一层查找调用链，费时费力。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="上古代码漫游记" scheme="https://www.kingname.info/tags/%E4%B8%8A%E5%8F%A4%E4%BB%A3%E7%A0%81%E6%BC%AB%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：用一个奇技淫巧把字符串转成特定类型</title>
    <link href="https://www.kingname.info/2023/01/01/replace-string-type/"/>
    <id>https://www.kingname.info/2023/01/01/replace-string-type/</id>
    <published>2023-01-01T06:53:51.000Z</published>
    <updated>2023-01-01T06:57:23.914Z</updated>
    
    <content type="html"><![CDATA[<p>我们有时候可能会需要把一个字符串转换成对应的类型。例如，把<code>&#39;123&#39;</code>转换为<code>int</code>类型的<code>123</code>；或者把<code>&#39;3.14&#39;</code>转成浮点数<code>3.14</code>。</p><span id="more"></span><p>前提条件是不能使用<code>eval</code>或者<code>exec</code>。</p><p>这是一个非常简单的功能，常规做法直接使用<code>if</code>判断就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">data, target_type</span>):</span><br><span class="line">    <span class="keyword">if</span> target_type == <span class="string">&#x27;int&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(data)</span><br><span class="line">    <span class="keyword">elif</span> target_type == <span class="string">&#x27;float&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(data)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>有些同学觉得写if判断麻烦，也可能会用字典来处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">data, target_type</span>):</span><br><span class="line">    type_map = &#123;</span><br><span class="line">        <span class="string">&#x27;int&#x27;</span>: <span class="built_in">int</span>,</span><br><span class="line">        <span class="string">&#x27;float&#x27;</span>: <span class="built_in">float</span>,</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type_map.get(target_type, <span class="built_in">str</span>)(data)</span><br></pre></td></tr></table></figure><p>但是这样做有个弊端，就是你需要把能够转换的格式都列出来。如果新增了一个格式，你还需要改动代码增加一个<code>elif</code>分支或者在字典新增一个键值对。</p><p>那么有没有什么办法，能够在不改动代码的情况下，完成转换呢？</p><p>一开始我也想不到什么好办法。直到今天看<a href="https://github.com/scrapy/scrapy/blob/master/scrapy/utils/conf.py#L50">Scrapy源代码</a>的时候，发现了一段代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220813152820.png"></p><p>这段代码中的<code>type(custom)(convert(c) for c in custom)</code>看起来很奇怪，但是只要解构一下，就会变得很简单。今天我们要解决的问题，就是这一行代码的一部分。</p><p>先来看前半截的写法：<code>type(custom)()</code>。怎么<code>type</code>后面有两个括号？我们知道<code>type(xxx)</code>是返回<code>xxx</code>这个数据的类型：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220813153147.png"></p><p>有些人以为，<code>type(xxx)</code>返回的是一个字符串。但实际上，它返回的就是类型本身：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220813153310.png"></p><p>既然我们可以使用<code>int(&#39;123&#39;)</code>把字符串转换为int，那么我们也可以使用<code>type(1)(&#39;123&#39;)</code>，把字符串<code>&#39;123&#39;</code>转换为int。</p><p>所以，今天我们的这个问题，解法就很简单了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">data, sample</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(sample)(data)</span><br></pre></td></tr></table></figure><p>调用的时候，传入两个参数。第一个参数是需要转换的字符串，第二个参数，是任意目标类型的数据。运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220813153815.png"></p><p>本来文章到这里就结束了。但考虑到有同学可能不明白上面代码<code>type(custom)(convert(c) for c in custom)</code>中的<code>convert(c) for c in custom</code>看起来像是列表推导式，却少了方括号，我再解释一下。</p><p>例如当你一个只含有数字的列表，你要把每一个数字乘以2，然后再传到函数里面，你一般会这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_one_ele</span>(<span class="params">data_list: <span class="type">List</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;具体的执行代码&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">get_one_ele([x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a])</span><br></pre></td></tr></table></figure><p>但是如果函数只有这一个参数时，你可以省略外层的方括号，简写为：<code>get_one_ele(x * 2 for x in a)</code>。所以上面的代码<code>type(custom)(convert(c) for c in custom)</code>等效为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [convert(c) <span class="keyword">for</span> c <span class="keyword">in</span> custom]</span><br><span class="line"><span class="built_in">type</span>(custom)(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们有时候可能会需要把一个字符串转换成对应的类型。例如，把&lt;code&gt;&amp;#39;123&amp;#39;&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;类型的&lt;code&gt;123&lt;/code&gt;；或者把&lt;code&gt;&amp;#39;3.14&amp;#39;&lt;/code&gt;转成浮点数&lt;code&gt;3.14&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Python如何动态替换对象的方法？</title>
    <link href="https://www.kingname.info/2023/01/01/python-replace-method/"/>
    <id>https://www.kingname.info/2023/01/01/python-replace-method/</id>
    <published>2023-01-01T06:53:32.000Z</published>
    <updated>2023-01-01T06:56:41.911Z</updated>
    
    <content type="html"><![CDATA[<p>今天有同学在公众号粉丝群问了这样一个问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719112119.png"></p><span id="more"></span><p>他的问题，简单来说，就是想动态替换一个对象的实例方法，简化代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self, job</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在<span class="subst">&#123;job&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self, job1, job2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在同时做两个工作，分别是<span class="subst">&#123;job1&#125;</span>和<span class="subst">&#123;job2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Test(<span class="string">&#x27;kingname&#x27;</span>)</span><br><span class="line">t.work = work</span><br></pre></td></tr></table></figure><p>当我们在替换之前，直接运行<code>t.work(&#39;job&#39;)</code>，效果如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719112403.png"></p><p>这个同学期望在替换以后，运行<code>t.work(&#39;job1&#39;, &#39;job2&#39;)</code>，能够输出：<code>kingname正在同时做两个工作，分别是job1和job2</code>。但上面的代码，直接运行以后会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719112613.png"></p><p>这说明，替换以后，在调用<code>t.work</code>的时候，Python 不会自动把<code>self</code>传入到第一个参数。</p><p>在以前的文章里面，我们已经讲过，实例方法的第一个参数<code>self</code>，就是这个实例对象自身。我们可以写一段代码来验证这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self, job</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在<span class="subst">&#123;job&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;self的内存地址是：<span class="subst">&#123;<span class="built_in">id</span>(self)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;instance 的内存地址是：<span class="subst">&#123;<span class="built_in">id</span>(instance)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self与 instance 就是同一个对象：&#x27;</span>, self <span class="keyword">is</span> instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test(<span class="string">&#x27;kingname&#x27;</span>)</span><br><span class="line">t.check(t)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719112903.png"></p><p>知道这一点以后，要解决动态替换以后报错的问题，最简单的方法就是手动把实例对象作为第一个参数传入进去，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719113047.png"></p><p>但这样做显然很麻烦，每次都要手动传入第一个实例对象。有没有什么办法能省略它呢？这个时候，如果你记得我公众号里面的这篇文章<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g">偏函数：在Python中设定默认参数的另一种办法</a>，那么你就有办法了。使用偏函数，提前把第一个参数固定下来，就能解决问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self, job1, job2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在同时做两个工作，分别是<span class="subst">&#123;job1&#125;</span>和<span class="subst">&#123;job2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">simple_work = partial(work, t)</span><br><span class="line">t.work = simple_work</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719113543.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天有同学在公众号粉丝群问了这样一个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220719112119.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>写在我的30岁。</title>
    <link href="https://www.kingname.info/2022/09/24/in-my-30/"/>
    <id>https://www.kingname.info/2022/09/24/in-my-30/</id>
    <published>2022-09-24T06:54:41.000Z</published>
    <updated>2023-01-01T07:01:10.595Z</updated>
    
    <content type="html"><![CDATA[<p>到今天就满30岁了。</p><span id="more"></span><p>这十年，大学毕业，在成都工作两年，在北京工作一年，在杭州工作两年，在上海工作两年。见过北方秋冬的萧瑟，见过江南初春的烟雨。</p><p>这十年，去过大大小小的公司。中国的外资的、卷的和不卷的。有工作体验极好的团队，让人想在这干一辈子；也有工作体验极差的部门，入职第一天就想离开。有人说，愿意主动跳出舒适圈的人，本质上都是抖M。</p><p>这十年，出版了两本书、讲过很多课、写了几百篇公众号原创文章，开源项目拿到过几千Star、还当了微软最有价值专家。不断提升自己的同时，也帮助了很多人。</p><p>这十年，幸好有七年自由自在的时光。我的大学，能在校园里充分度过；工作以后，也能在任何时候说走就走，去看佛罗伦萨的教堂、去泰国和越南的沙滩奔跑，去参加几万人的演唱会。</p><p>五年前，只身一人开始北漂，没有钱也没有认识的人。现在，虽然没有回到成都，但已经在上海成家。有一个爱我的妻子，有一群很好的朋友，有一个还算不错的工作。</p><p>四年前，我认识了我现在妻子。她是目前为止我见过的最好的产品经理（实话实说，不带光环）。也是我见过最会人际沟通的人。她不仅会做产品，还会做设计，做运营。文章写得非常好。作为美术生，只用半年的学习就能上211。她拥有我从来都学不会的社交技能。我不是一个懂得享受生活的人，但是有她在的日子里，我的生活比之前精彩了很多。</p><p>这十年，我从一个需要被人带的应届生，一步一步走过来。虽然很多人现在叫我大佬，但我觉得我距离大佬还差很多。我高中同学，从程序转成产品，现在已经做到了某大厂一人之下万人之上的位置。而我现在还是一个小小的螺丝钉。</p><p>总结起来，这十年里，虽有遗憾，并无后悔。</p><p>满30岁了，三十而立。立什么呢？立志、立身、立言。加油吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到今天就满30岁了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>统计千行代码Bug率，有没有意义？</title>
    <link href="https://www.kingname.info/2022/07/13/bug-rate/"/>
    <id>https://www.kingname.info/2022/07/13/bug-rate/</id>
    <published>2022-07-13T12:42:24.000Z</published>
    <updated>2022-07-13T12:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的结论是：统计Bug率有意义。但是统计千行代码Bug率没有意义。</p><span id="more"></span><h2 id="为什么千行代码Bug率是没有意义的？"><a href="#为什么千行代码Bug率是没有意义的？" class="headerlink" title="为什么千行代码Bug率是没有意义的？"></a>为什么千行代码Bug率是没有意义的？</h2><p>某公司最近出了一个方案，用来量化程序员的工作绩效。叫做<code>千行代码Bug率</code>。在一个统计周期内，程序员每增加或者修改的代码行数与QA发现的Bug数，根据如下规则计算Bug率：</p><ul><li>1000行代码，1个bug，那么Bug率是100%；</li><li>2000行代码，4个bug，那么Bug率是200%；</li><li>5000行代码，3个Bug，那么Bug率是60%</li><li>n行代码，m个Bug，那么Bug率是<code>m / n * 1000</code></li></ul><p>先不考虑这个规则本身是否有问题。我觉得，所有和代码行数挂钩的绩效统计，都是没什么意义的。因为代码行数是可以刷的。如果某个绩效需要代码行数越少越好，那么可以使用行数少的写法；某个绩效需要代码行数越多越好，那么可以使用行数多的写法。</p><p>例如，对于字符串赋值：<code>a = &#39;今天天气竟然有40度，我要被烤化了。&#39;</code>，可以把它扩写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="string">&#x27;今天天气&#x27;</span></span><br><span class="line">     <span class="string">&#x27;竟然有40&#x27;</span></span><br><span class="line">     <span class="string">&#x27;度，我要&#x27;</span></span><br><span class="line">     <span class="string">&#x27;被烤化了。&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>甚至再进一步，扩写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;今天天气&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;竟然有40&#x27;</span></span><br><span class="line">c = <span class="string">&#x27;度，我要&#x27;</span></span><br><span class="line">d = <span class="string">&#x27;被烤化了。&#x27;</span></span><br><span class="line"></span><br><span class="line">e = (a </span><br><span class="line">     + b</span><br><span class="line">     + c</span><br><span class="line">     + d</span><br><span class="line">     )</span><br><span class="line">a = e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这三种写法的效果完全一样。</p><p>还有些功能，原本就一行原生代码搞定。但是为了增加行数，故意使用第三方库。这样第三方库的代码行数也就统计进去了。代码总行数增加，相当于分母增大，千行代码Bug率就降下来了。</p><p>要缩写也简单，在Python里面，如果使用lambda表达式，通过非常炫技反人类的写法，你可以把常规要40行的代码缩成1行。但是这样的一行代码根本没法维护。</p><h2 id="为什么Bug率是有意义的？"><a href="#为什么Bug率是有意义的？" class="headerlink" title="为什么Bug率是有意义的？"></a>为什么Bug率是有意义的？</h2><p>对于一个有实际用处的项目代码来说，Bug数是一个系统误差，只能设法减少，但是没有办法变成0。</p><p>同样实现一个功能，好的程序员能提前预判到别人会怎么使用，提前处理好非法逻辑和不合理的数据流程，从而降低Bug数。而差的程序员，写出来的代码，别人一用就出问题。因此，用Bug率来评判程序员水平，我觉得是合理的。但是从Bug数到Bug率，这个计算方法应该要精心设计。</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>如果公司有QA的话，在软件开发阶段，一般产品经理会先提出需求，然后拉上开发和QA一起评测需求。QA会在需求评审会后，设计测试案例。这些测试案例是公开的，每个开发都会看到。</p><p>这些公开的测试案例，我觉得可以用来作为分母。程序员写好了代码，却无法通过其中的部分测试案例。那就是程序员的水平不行。<code>失败的测试案例数/所有公开的测试案例数</code>。可以作为衡量程序员水平的参考指标之一。好的程序员应该尽量让这个比值为0.</p><p>但有时候，在测试的过程中，QA可能会临时增加测试案例，这些案例是程序员提前不知道的。那么这些案例如果测试失败了，也可以作为一个评判指标，用来评判程序员是否有提前预防的能力。但公平起见，可以给他乘以一个<code>小于1</code>的系数，降低它的权重：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发阶段Bug率 = (已经公开的测试案例数 + 系数 × 临时增加的测试案例数) / 总测试案例数</span><br></pre></td></tr></table></figure><p>说个题外话，今天我们不考虑单元测试数、单元测试覆盖率这种问题。因为据我所知，国内互联网公司会主动写单元测试的程序员太少了。有时候，一个原本要写单元测试的优秀程序员，进了某些大厂以后，迫于业务和工期压力，也逐渐放弃了。所以我们今天只考虑QA的测试案例。</p><h2 id="线上阶段"><a href="#线上阶段" class="headerlink" title="线上阶段"></a>线上阶段</h2><p>如果只看QA的测试案例，可能会出现面向QA编程的问题。因为人是很聪明的，上有政策，下有对策。QA的一个测试API接口的案例，输入5，输出10.程序员直接在代码里面判断，如果输入是5，直接返回10，跳过中间的所有逻辑。这样就能100%通过QA的所有测试案例。但是这样做对产品本身是没有价值的。</p><p>市场是检验代码质量的重要标准。程序质量好不好，上线以后，让用户来评测。</p><blockquote><p>你永远不知道你的用户有多蠢，你永远猜不透用户会怎么使用你的产品。</p></blockquote><p>用户反馈的Bug，也可以用来评价代码的好坏，进而反映出程序员的能力高低。但需要考虑下面两个情况：</p><p>同一个功能，两个程序员实现：</p><ul><li>A程序员写出的功能一上线，用户一用就报Bug</li><li>B程序员写出的功能上线很久了。几十万个用户都正常使用，有个沙雕用户乱操作，偶然暴露出了一个Bug。</li></ul><p>大家凭主观判断都知道，B程序员应该比A程序员好。</p><p>我们再来考虑第二种情况，A程序员实现X功能，B程序员实现Y功能：</p><ul><li>X功能每天会被使用几百万次，一周就发现了二十多个Bug</li><li>Y功能一个月总共就被用了3次。没有发现Bug</li></ul><p>这种情况下，我们没有办法根据Bug数来判断AB两个程序员谁更好。也许B程序员去写X功能，一天就会被发现上百个Bug也说不定。</p><p>因此，根据这两种情况，我拍脑袋总结了一个经验公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某功能线上Bug率 = Bug数 / (log(功能使用次数 + 1) + 1)</span><br></pre></td></tr></table></figure><p>其中的<code>log</code>是以10为底的对数。因为一个功能很轻松就能使用上百上千次，而Bug数一般来说就是个位数或者两位数。因此对使用次数求个对数，避免Bug率太小。公式中的两次<code>+1</code>。一次是因为不能对0求对数，另一次是分母不能为0.</p><p>对程序员开发的多个线上功能的Bug率统计，我们可以这样计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序员线上Bug率 = A功能线上Bug率 * 功能重要性系数 + B功能线上Bug率 * 功能重要性系数 + ……</span><br></pre></td></tr></table></figure><p>其中，相同重要性的功能，他们的功能重要性系数应该是相同的。不同重要性的功能，功能越重要，这个系数就越大。</p><p>这里，这个系数应该用<code>功能重要性系数</code>还是<code>功能复杂性系数</code>，我们可以讨论一下。我个人是觉得用重要性比较好。 一方面是代码复杂性不好量化。第二是因为程序员的代码质量和业务是不能分开看的。对于重要的功能，应该优先做，应该更用心。在更用心的情况下bug还那么多，不就说明能力差吗。对于不重要的功能，最后做，可能后面时间来不及了，赶工完成有一些Bug。但是因为这个功能没什么人用，对业务影响不大，有一些Bug也没什么。</p><h2 id="拍脑袋综合公式"><a href="#拍脑袋综合公式" class="headerlink" title="拍脑袋综合公式"></a>拍脑袋综合公式</h2><p>综合开发阶段与线上阶段，我们可以得出一个综合公式。由于一般来说，某某率的值范围应该是0-100%，这两个公式合在一起以后，结果很可能大于1.因此我们改个名字，叫做<code>程序员Bug指数</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序员Bug指数 = 开发阶段Bug率 * 开发阶段系数 + 程序员线上Bug率 * 线上阶段系数</span><br></pre></td></tr></table></figure><p>这个指数越高，说明程序员能力越差。</p><p>最后还是强调一下，以上公式是我拍脑袋想出来的，仅做参考。但我认为它的价值应该比千行代码Bug率高得多。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的结论是：统计Bug率有意义。但是统计千行代码Bug率没有意义。&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://www.kingname.info/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件工程" scheme="https://www.kingname.info/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：把自然语言描述的时间转成标准格式</title>
    <link href="https://www.kingname.info/2022/07/13/nlp-datetime/"/>
    <id>https://www.kingname.info/2022/07/13/nlp-datetime/</id>
    <published>2022-07-13T12:42:17.000Z</published>
    <updated>2022-07-13T12:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你使用过嘀嗒清单或者Todoist，那你应该知道他们有一个很好用的功能，那就是自动识别任务中的时间，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下周二下午三点给老板发邮件</span><br></pre></td></tr></table></figure><p>它会自动识别为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220707211422.png"></p><p>今天，公众号粉丝群里面，有一个叫做NowAnti的同学推荐了一个项目，叫做<a href="https://github.com/yiyujianghu/sinan">司南</a>，它就可以让Python实现这样的功能。</p><span id="more"></span><p>我们来看看这个第三方库怎么使用。首先pip安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install sinan</span><br></pre></td></tr></table></figure><p>安装完成以后，使用方法非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sinan <span class="keyword">import</span> Sinan</span><br><span class="line">obj = Sinan(<span class="string">&#x27;下周二下午三点给老板发邮件&#x27;</span>)</span><br><span class="line">result = obj.parse()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220707212153.png"></p><p>这个库不仅可以解析时间，它还可以解析更复杂的语句，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Sinan(<span class="string">&#x27;明天晚上八点提十公斤的礼物，徒步往西走两公里，原地等待三个小时，如果发 现温度低于十六度，就给我打电话，我的手机号是：16758493028&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.parse()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220707212802.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你使用过嘀嗒清单或者Todoist，那你应该知道他们有一个很好用的功能，那就是自动识别任务中的时间，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下周二下午三点给老板发邮件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;它会自动识别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220707211422.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天，公众号粉丝群里面，有一个叫做NowAnti的同学推荐了一个项目，叫做&lt;a href=&quot;https://github.com/yiyujianghu/sinan&quot;&gt;司南&lt;/a&gt;，它就可以让Python实现这样的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="NLP" scheme="https://www.kingname.info/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何实现带timeout的input？</title>
    <link href="https://www.kingname.info/2022/07/13/input-timeout/"/>
    <id>https://www.kingname.info/2022/07/13/input-timeout/</id>
    <published>2022-07-13T12:42:10.000Z</published>
    <updated>2022-07-13T12:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在Python里面，可以使用<code>input</code>获取用户的输入。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220627211414.png"></p><p>但有一个问题，如果你什么都不输入，程序会永远卡在这里。有没有什么办法，可以给<code>input</code>设置超时时间呢？如果用户在一定时间内不输入，就自动使用默认值。</p><span id="more"></span><p>要实现这个需求，在Linux&#x2F;macOS系统下面，我们可以使用<code>selectors</code>。这是Python自带的模块，不需要额外安装。对应的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeout_input</span>(<span class="params">msg, default=<span class="string">&#x27;&#x27;</span>, timeout=<span class="number">5</span></span>):</span><br><span class="line">    sys.stdout.write(msg)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    sel = selectors.DefaultSelector()</span><br><span class="line">    sel.register(sys.stdin, selectors.EVENT_READ)</span><br><span class="line">    events = sel.select(timeout)</span><br><span class="line">    <span class="keyword">if</span> events:</span><br><span class="line">        key, _ = events[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> key.fileobj.readline().rstrip()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220627214433.png"></p><p><a href="https://docs.python.org/3.8/library/selectors.html">selectors</a>这个模块，可以使用系统层级的<code>select</code>，实现IO多路复用。</p><p>这段代码来自<a href="https://github.com/johejo/inputimeout/blob/master/inputimeout/inputimeout.py">inputimeout</a>。上面除了Linux&#x2F;macOS版本外，还有Windows版本。大家有兴趣可以看一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道，在Python里面，可以使用&lt;code&gt;input&lt;/code&gt;获取用户的输入。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220627211414.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;但有一个问题，如果你什么都不输入，程序会永远卡在这里。有没有什么办法，可以给&lt;code&gt;input&lt;/code&gt;设置超时时间呢？如果用户在一定时间内不输入，就自动使用默认值。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：二分偏左，二分搜索在分布式系统里面也有用？</title>
    <link href="https://www.kingname.info/2022/06/22/bisect-left/"/>
    <id>https://www.kingname.info/2022/06/22/bisect-left/</id>
    <published>2022-06-22T14:10:36.000Z</published>
    <updated>2022-06-22T14:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家都知道二分搜索，在一个有序的列表中，使用二分搜索，能够以O(logN)的时间复杂度快速确定目标是不是在列表中。</p><span id="more"></span><p>二分搜索的代码非常简单，使用递归只需要几行代码就能搞定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">sorted_list, target</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    sorted_list是单调递增的列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sorted_list:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    mid = <span class="built_in">len</span>(sorted_list) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> target &gt; sorted_list[mid]:</span><br><span class="line">        <span class="keyword">return</span> binary_search(sorted_list[mid + <span class="number">1</span>:], target)</span><br><span class="line">    <span class="keyword">elif</span> target &lt; sorted_list[mid]:</span><br><span class="line">        <span class="keyword">return</span> binary_search(sorted_list[:mid], target)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622195247.png"></p><p>Python自带了一个二分搜索的模块，叫做<code>bisect</code>，它也能实现二分搜索，但是它的执行结果跟我们上面代码的效果有点不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">a = [<span class="number">41</span>, <span class="number">46</span>, <span class="number">67</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">80</span>, <span class="number">86</span>, <span class="number">92</span>, <span class="number">100</span>]</span><br><span class="line">index = bisect.bisect(a, <span class="number">75</span>)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"></span><br><span class="line">index = bisect.bisect(a, <span class="number">82</span>)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622195723.png"></p><p>可以看到，<code>bisect.bisect()</code>返回一个索引。如果要搜索的数已经在列表里面了，那么它返回的是这个数在列表中，<code>最右边</code>的这个目标数的索引+1. 以列表<code>[41, 46, 67, 74, 75, 76, 80, 86, 92, 100]</code>为例，要搜索<code>75</code>。由于<code>75</code>在原来列表中的索引是<code>4</code>。因此返回<code>索引+1</code>也就是5. 如果原来列表中，<code>75</code>出现了多次，比如<code>[41, 46, 67, 74, 75, 75, 76, 80, 86, 92, 100]</code>那么返回的是<code>最右边</code>那个<code>75</code>对应的索引<code>+1</code>，也就是<code>6</code>。</p><p>如果要找的数字不在原来列表中，那么<code>bisect.bisect()</code>会返回一个索引，当我们把目标数字插入到这个列表中对应索引的位置时，列表依然有序。例如<code>[41, 46, 67, 74, 75, 76, 80, 86, 92, 100]</code>中，我们找<code>82</code>。它返回的是<code>7</code>。原来列表里面索引为7的位置是数字<code>86</code>，我们把82插入到这个位置，原有的数据依次后移一位，此时列表依然有序。</p><p><code>bisect</code>这个模块还有一个函数，叫做<code>bisect.bisect_left()</code>。如果目标数字在原来的列表中，那么返回的是最左边那个数字对应的索引.如果不在列表中，那么返回的索引插入目标数字以后依然有序，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622201213.png"></p><p>这个函数看起来非常简单，但你可能不知道，它在分布式系统中也有重要的用途。</p><p>假设现在你有10个Redis的单节点用来做分布式缓存。因为某种原因，你不能做集群。当你要搜索一个数据的时候，你要先确定这个数据在不在Redis中。如果在，就直接从Redis中读取数据；如果不在，就先去数据库里面读取，然后缓存到Redis中。</p><p>因为数据量很大，你不能把同一份数据同时存在10个Redis节点里面，因此你需要设计一个算法，不同的数据存放在不同的Redis节点中。</p><p>当你要查询数据的时候，你能根据这个算法查询到数据（如果在缓存中）应该存放在哪个Redis中。</p><p>稍微有一点分布式系统设计经验的同学肯定会想到，这个简单啊，10个Redis节点编号0-9.对<code>key</code>计算Hash值，这个哈希值是32位的十六进制数，可以转换成十进制以后对10求余数，余数是多少，就放到对应的节点里面。</p><p>这样一来，只要来了一个新的数据，你只需要去余数对应的Redis中判断它有没有缓存就可以了。</p><p>但问题来了，如果你开始使用这个方法，Redis中已经有数据了，那么你的Redis节点数就不能变了。一旦你增加或者减少1个节点，所有余数全部变了，新来的数据找到的Redis节点肯定是错的。例如key的Hash值原来除以10，余数是2，现在除以9，余数是1.那本来你应该去2号Redis找缓存，现在却跑到1号Redis找缓存，那一定找不到。</p><p>这个问题要怎么解决呢？我们用一个简单的例子来做演示。假设我现在有一个列表：<code>[200, 250, 300, 400, 500, 530, 600]</code>。每个数字代表这个价位的房子。单位是万。你想买一个房子，但便宜的房子太破，好的房子又太贵。因此你只找价格等于你的期望，或者虽然比你的期望略高但差距最小的房子。</p><p>假设现在你的期望是250万，而正好有个房子卖250万，因此你可以买它。</p><p>假设现在你的期望是470万，那么你唯一的选择是500万的房子。</p><p>到目前为止应该非常好理解，那么我们来增加或者减少候选项：</p><ol><li>500万的房子被别人买走了。列表变成<code>[200, 250, 300, 400, 530, 600]</code>，因此唯一适合你的是530万的房子。</li><li>如果现在250万的房子被人买走了，列表变成<code>[200, 300, 400, 500, 530, 600]</code>。此时对你<strong>没有任何影响</strong>，适合你的房子还是500万的房子。</li><li>如果现在增加了一个480万的房子，列表变成<code>[200, 250, 300, 400, 480, 500, 530, 600]</code>。那么现在适合你的房子变成了480万。</li><li>如果现在增加了一个240万的房子，列表变成<code>[200, 240, 250, 300, 400, 500, 530, 600]</code>。此时对你<strong>没有任何影响</strong>，适合你的还是500万的房子。</li></ol><p>这个场景，我们正好可以使用<code>bisect.bisect_left()</code>！效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622205247.png"></p><p>当备选项发生改变的时候，只有你目标选项附近的房子受到了影响。而小于你候选项的房子和贵的多的房子的变动，对你没有任何影响。</p><p>你注意到了吗，这个场景跟我们分布式缓存增减Redis节点的场景非常像。我们原来有10台Redis，现在新增了一台，变成11台了。那么<strong>只有一台</strong>Redis的<strong>部分缓存</strong>会迁移到这个新增的Redis中。而其它9台Redis的缓存不需要做任何改变。</p><p>同理，当我们删除一台Redis节点时，这个被删除的节点里面的数据，只需要同步到它旁边的另一台Redis节点中就可以了。另外8个Redis节点不需要做任何修改！（也可以不同步，只有一小部分key会因为删除这个节点导致找不到数据，而重新读数据库。80%的缓存不会受到任何影响。）</p><p>这就是<strong>一致性Hash</strong>的算法。</p><p>我来简单描述一下这个算法的实现过程。首先，我们使用<code>redis.Redis(不同redis的连接参数)</code>创建10个连接对象。然后把每个连接对象和一个Hash值创建映射，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622210646.png"></p><p>然后，我们把这10个Hash值排序以后放到一个列表中。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622210719.png"></p><p>现在，来了一条新的缓存查询需求，我们计算key对应的Hash值，然后使用<code>bisect.bisect_left()</code>到列表中去寻找它对应的Redis节点的Hash值的索引。如果返回的索引等于列表的长度，那么让索引等于0. 找到索引以后，拿到对应的Redis节点的Hash，最后再用这个Hash去找到对应的Redis节点，简化代码如下：</p><p>&#96;<img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622211401.png"></p><p>如果新增或者删除了Redis节点，那么只需要更新<code>node_map</code>和<code>cycle</code>就可以了。只会发生很小的数据迁移，对绝大部分的缓存都不会造成任何影响。例如我现在把<code>第1个Redis链接对象</code>对应的Hash：<code>fbef6b15be1abe9edc8f6aaac6a86357</code>从<code>node_map</code>和<code>cycle</code>中删除。再进行查询，会发现依然找到的是编号为6的Redis节点。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220622212427.png"></p><p>一致性Hash在分布式系统中有广泛的应用。但你可能想不到，它的核心原理就是二分搜索里面的<code>bisect_left</code>。</p><p>当然，上面只是简化算法。一致性Hash的完整算法还涉及到虚拟节点和避免数据倾斜的算法。如果大家有兴趣的话，我也可以写一篇文章，完整解释它的算法实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信大家都知道二分搜索，在一个有序的列表中，使用二分搜索，能够以O(logN)的时间复杂度快速确定目标是不是在列表中。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式系统" scheme="https://www.kingname.info/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="二分搜索" scheme="https://www.kingname.info/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
    <category term="一致性哈希" scheme="https://www.kingname.info/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
    <category term="分布式系统" scheme="https://www.kingname.info/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用Python翻译HTML中的文本字符串</title>
    <link href="https://www.kingname.info/2022/06/20/translate-html/"/>
    <id>https://www.kingname.info/2022/06/20/translate-html/</id>
    <published>2022-06-20T11:33:01.000Z</published>
    <updated>2022-06-20T11:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家都用过浏览器的翻译网页功能，例如对于下图这个英文网页：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620174708.png"></p><p>一键翻译成中文以后是这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620174756.png"></p><p>你可能会觉得这个功能很简单，不就是字符串替换吗？那你可以试一试把下面这个HTML片段中的<code>&lt;p&gt;</code>标签下面的英文翻译成中文。其它标签中的不要改动：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>if you want to parse date and time, your could use <span class="tag">&lt;<span class="name">em</span>&gt;</span>datetime<span class="tag">&lt;/<span class="name">em</span>&gt;</span>, by use this library, you can generate now time by one line code <span class="tag">&lt;<span class="name">span</span>&gt;</span>datetime.datetime.now()<span class="tag">&lt;/<span class="name">span</span>&gt;</span> this is so easy.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;em&gt;</code>标签中的<code>datetime</code>和<code>&lt;span&gt;</code>标签中的<code>datetime.datetime.now()</code>不需要翻译。</p><span id="more"></span><p>你一拍脑袋，马上写出了下面这几行代码（假设你已经有了一个现成的<code>translate()</code>函数，传入英文，输出中文）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line">source = <span class="string">&#x27;&#x27;&#x27;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;if you want to parse date and time, your could use &lt;em&gt;datetime&lt;/em&gt;, by use this library, you can generate now time by one line code &lt;span&gt;datetime.datetime.now()&lt;/span&gt; this is so easy.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">selector = fromstring(source)</span><br><span class="line">text_list = selector.xpath(<span class="string">&#x27;//p/text()&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> text_list:</span><br><span class="line">    chinese = translate(text)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>当你写到这里，你应该会愣一下。因为你突然发现一个问题，怎么把中文替换回去？</p><p><strong>不用尝试去百度了。在今天（2022-06-20）之前，整个中文网络里面，你找不到解决方法。</strong></p><p>一个比较笨的办法是直接对原始的HTML字符串进行文本替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> text_list:</span><br><span class="line">    chinese = translate(text)</span><br><span class="line">    source = source.replace(text, chinese)</span><br></pre></td></tr></table></figure><p>但这样做，效率非常低。因为你要不停扫描整个HTML字符串。一般一个中型网站的HTML就有几千上万行，十几二十万个字符。你每翻译一小段就全文替换一次，这个时间会非常漫长。</p><p>那有没有办法只对当前这一个<code>&lt;p&gt;</code>标签里面的文本进行替换呢？关键的问题来了，你替换可以，但是怎么才能不影响这个<code>&lt;p&gt;</code>标签下面的两个子标签？要保证文本和子标签的相对位置不改变。</p><p>如果<code>&lt;p&gt;</code>标签下面只有一段文本，没有子标签，那么非常简单，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620181207.png"></p><p>但现在的问题是，<code>&lt;p&gt;</code>标签下面有三段文本。每段文本之间还插入了其它的子标签。我们怎么样对每一段文本进行替换，但是又保持文本的相对顺序，并且还不能影响子标签？</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620181532.png"></p><p><code>p.text</code>这种写法首先就可以排除了，因为它没有办法指定替换第几段文本。</p><p>你之所以会觉得这个问题很难解决，是因为你有一个错觉，请看上面这张截图，我打印了<code>text_list</code>。打印出来是一个包含字符串的列表。所以你可能会觉得。使用lxml写Xpath的时候，<code>/text()</code>返回的总是包含字符串的列表。</p><p>但实际上，返回的列表里面的元素并不是字符串，而是<code>_ElementUnicodeResult</code>对象。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620182342.png"></p><p>不是字符串就简单了，那么我们可以获取每一个文本对象的父标签。然后修改父标签下面的文本就可以了。</p><p>看到这里，你肯定会问，这三个文本节点的父标签，不都是同一个<code>&lt;p&gt;</code>吗？如果你觉得是，那你就犯了想当然的错误。我们用代码来看看：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620182718.png"></p><p>其实只有第一段文本的父标签是<code>&lt;p&gt;</code>。第二段文本的父标签，竟然是<code>&lt;p&gt;</code>的子标签<code>&lt;em&gt;</code>。第三段文本的父标签，是<code>&lt;span&gt;</code>。</p><p>等等，如果第二段文本的父标签是<code>&lt;em&gt;</code>，那么<code>&lt;em&gt;datetime&lt;/em&gt;</code>里面的<code>datetime</code>的父标签是什么？它的父标签也是<code>&lt;em&gt;</code>！那么问题来了，<code>&lt;em&gt;</code>的<code>text()</code>文本节点，怎么可能又是<code>datetime</code>，又是<code>&lt;p&gt;</code>下面的第二段文本呢？</p><p>实际上，<code>&lt;em&gt;</code>的<code>text()</code>始终都是<code>datetime</code>。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620183224.png"></p><p>那么，<code>&lt;p&gt;</code>的第二段文本跟这个<code>&lt;em&gt;</code>标签是什么关系？实际上，这个关系叫做<code>tail</code>。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620185753.png"></p><p>在一个标签里面，只有第一段<code>text</code>是它真正的<code>text()</code>，如果这个标签有子标签，那么位于子标签后面的文本，是这个子标签的<code>tail</code>。只不过当我们在正则表达式里面写<code>/text()</code>的时候，lxml会帮我们把所有子标签的<code>tail</code>都算作当前标签的text。</p><p>我们可以使用文本节点的<code>.is_text</code>和<code>.is_tail</code>来判断它属于哪种文本。最终运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620190408.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信大家都用过浏览器的翻译网页功能，例如对于下图这个英文网页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620174708.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一键翻译成中文以后是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220620174756.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可能会觉得这个功能很简单，不就是字符串替换吗？那你可以试一试把下面这个HTML片段中的&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签下面的英文翻译成中文。其它标签中的不要改动：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;if you want to parse date and time, your could use &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;datetime&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;em&lt;/span&gt;&amp;gt;&lt;/span&gt;, by use this library, you can generate now time by one line code &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;datetime.datetime.now()&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt; this is so easy.&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签中的&lt;code&gt;datetime&lt;/code&gt;和&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签中的&lt;code&gt;datetime.datetime.now()&lt;/code&gt;不需要翻译。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="XPath" scheme="https://www.kingname.info/tags/XPath/"/>
    
    <category term="lxml" scheme="https://www.kingname.info/tags/lxml/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Bug分析，假删除导致文章发布成功却打不开的问题</title>
    <link href="https://www.kingname.info/2022/06/20/fake-delete/"/>
    <id>https://www.kingname.info/2022/06/20/fake-delete/</id>
    <published>2022-06-20T11:32:53.000Z</published>
    <updated>2022-06-20T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司有一个内部博客，大家可以在上面创建自己的账号，然后写文章在全公司分享。昨天这个内部博客开通了API，因此我准备写一个Python程序，把自己公众号文章都搬运上去。</p><span id="more"></span><p>然后我就发现这个API接口有一个bug。并且根据它的现象，猜到它问题出在哪里。</p><p>我先来简单描述一下现象。</p><p>假设我硬盘上现在有50个Markdown文件。现在我要把它发布到网站上。简化代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> glob.glob(<span class="string">&#x27;blog/*.md&#x27;</span>):</span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">        article = f.read()</span><br><span class="line">    requests.post(<span class="string">&#x27;https://xxx.yyy.com/post?token=abcasdf&#x27;</span>, json=&#123;<span class="string">&#x27;content&#x27;</span>: content&#125;)</span><br></pre></td></tr></table></figure><p>发布完成以后，文章确实都已经在网页上出现了，并且<strong>每篇文章都能正常显示</strong>。但我粗略浏览了一下，发现里面有一些文章的末尾带上来我的微信公众号二维码。我不想让公司的人知道我的公众号，所以准备修改一下文章。</p><p>有一些文章有二维码，有一些没有，一个一个改起来很麻烦，所以我做了两步操作。首先写了一个程序，扫描所有Markdown文件，发现二维码就删掉。然后，我直接在网站上把刚刚发布的所有文章都删了（懒得去看哪篇有二维码，哪篇没有，干脆全删了重发）。</p><p>接下来，我再次运行程序批量重新发布文章。2秒钟以后发布完成。</p><p>本来一切看起来都很正常，但是当我到网站上查看的时候，发现有很多文章点开以后，都提示『该文章已经删除』。</p><p>我一开始在想是不是我的程序写的不对，漏掉了这些文章。我重新单独一篇一篇发布这篇文章，API接口返回发布成功，可在网页上还是显示文章已经删除。</p><p>然后我一篇一篇检查这些发布失败的文章，发现有一个共同的特点：他们是一开始就没有二维码的文章。相当于这些文章我在网站上删除以后原样重新又发了一次。</p><p>那我就有了一个初步的猜测，大概知道原因是什么了：</p><ol><li>因为每篇文章有一个docid，当第一次发布文章的时候，这个docid就是文章正文内容的md5值。只要文章完全一样，连续发多少次，它的docid都一样。这样就可以防止出现重复文章。（更新的时候，需要用户主动提供docid，避免重新生成新的）。</li><li>这个网站的删除功能，肯定是假删除。也就是当我点了删除文章的按钮时，文章其实依然在数据库里面，只不过增加了一个字段<code>removed=True</code>。网页显示文章的时候，查询条件肯定是<code>col.find(&#123;&#39;removed&#39;: &#123;&quot;$ne&quot;: True&#125;&#125;)</code>，所以就不会把这些被软删除的文章显示出来。</li><li>API发布新文章的时候，肯定使用的是更新操作。并且使用了<code>upsert=True</code>。</li></ol><p>以MongoDB为例，这个API背后的逻辑肯定是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">post_article</span>(<span class="params">docid, article_info</span>):</span><br><span class="line">      mongo.update_one(&#123;<span class="string">&#x27;_id&#x27;</span>: docid&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: article_info&#125;, upsert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>upsert=True</code>的作用，是先检查数据是否存在，如果存在就更新，如果不存在就插入。</p><p>第一次发布的时候，文章不存在，直接插入，正常。如果用户正常使用修改接口，修改了正文，因为用户主动提供了docid，所以也能正常更新。</p><p>但如果用户先删除了数据，此时数据库中，增加了一个字段<code>removed=True</code>。然后用户又原封不动重新发一次文章。那么docid肯定还是原来那个。这条文章已经在数据库中存在了。于是逐一更新了每个字段。但是新发布的字段里面是没有<code>removed</code>这个字段的，所以更新的时候不会更新它，它还在数据库里面。所以就出现了发布成功，但是打开新闻又提示文章已经删除。</p><p>我去问了一下做这个API的同学，果然它的bug原因跟我设想的一模一样。</p><p>这个bug解决方法非常简单，发布新文章的时候，把<code>update_one</code>改成<code>replace_one</code>就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">post_article</span>(<span class="params">docid, article_info</span>):</span><br><span class="line">      mongo.replace_one(&#123;<span class="string">&#x27;_id&#x27;</span>: docid&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: article_info&#125;, upsert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;公司有一个内部博客，大家可以在上面创建自己的账号，然后写文章在全公司分享。昨天这个内部博客开通了API，因此我准备写一个Python程序，把自己公众号文章都搬运上去。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.kingname.info/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="软件设计" scheme="https://www.kingname.info/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="后端" scheme="https://www.kingname.info/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：让你的正则表达式可读性提高一百倍</title>
    <link href="https://www.kingname.info/2022/06/20/readable-re/"/>
    <id>https://www.kingname.info/2022/06/20/readable-re/</id>
    <published>2022-06-20T11:32:44.000Z</published>
    <updated>2022-06-20T11:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式这个东西，强大是强大，但写出来跟个表情符号一样。自己写的表达式，过一个月来看，自己都不记得是什么意思了。比如下面这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;((?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?)(.*?)(?=(?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?(?![^\w\s])|$)&quot;</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>有没有什么办法提高正则表达式的可读性呢？我们知道，提高代码可读性的方法之一就是写注释，那么正则表达式能不能写注释呢？</p><p>例如对于下面这个句子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;我叫青南，我的密码是:123kingname456,请注意保密。&#x27;</span></span><br></pre></td></tr></table></figure><p>我要提取其中的密码<code>123kingname456</code>，那么我的正则表达式可能是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;:(.*?),&#x27;</span></span><br></pre></td></tr></table></figure><p>我能不能把它写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">:  # 开始标志</span></span><br><span class="line"><span class="string">(.*?)  #从开始标志的下一个字符开始的任意字符</span></span><br><span class="line"><span class="string">,  #遇到英文逗号就停止</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样写就清晰多了，每个部分是什么作用全都清清楚楚。</p><p>但显然直接使用肯定什么都提取不到，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220610105224.png"></p><p>但我今天在逛Python<a href="https://docs.python.org/3/library/re.html#re.VERBOSE">正则表达式文档</a>的时候，发现了一个好东西：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220610105723.png"></p><p>使用它，可以让你的正则表达式拥有注释，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220610105851.png"></p><p><code>re.VERBOSE</code>也可以简称为<code>re.X</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220610105935.png"></p><p>本文最开头的复杂正则表达式，使用了注释以后，就会变的更可读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(                       # code (capture)</span></span><br><span class="line"><span class="string">    # BEGIN multicode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?: \( \s* )?       # maybe open paren and maybe space</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # code</span></span><br><span class="line"><span class="string">    [A-Z]*H  # prefix</span></span><br><span class="line"><span class="string">    \d+      # digits</span></span><br><span class="line"><span class="string">    [a-z]*   # suffix</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?:                 # maybe followed by other codes,</span></span><br><span class="line"><span class="string">        \s* \+ \s*      # ... plus-separated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # code</span></span><br><span class="line"><span class="string">        [A-Z]*H  # prefix</span></span><br><span class="line"><span class="string">        \d+      # digits</span></span><br><span class="line"><span class="string">        [a-z]*   # suffix</span></span><br><span class="line"><span class="string">    )*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?: \s* [\):+] )?   # maybe space and maybe close paren or colon or plus</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # END multicode</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">( .*? )                 # message (capture): everything ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(?=                     # ... up to (but excluding) ...</span></span><br><span class="line"><span class="string">    # ... the next code</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # BEGIN multicode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?: \( \s* )?       # maybe open paren and maybe space</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # code</span></span><br><span class="line"><span class="string">    [A-Z]*H  # prefix</span></span><br><span class="line"><span class="string">    \d+      # digits</span></span><br><span class="line"><span class="string">    [a-z]*   # suffix</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?:                 # maybe followed by other codes,</span></span><br><span class="line"><span class="string">        \s* \+ \s*      # ... plus-separated</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # code</span></span><br><span class="line"><span class="string">        [A-Z]*H  # prefix</span></span><br><span class="line"><span class="string">        \d+      # digits</span></span><br><span class="line"><span class="string">        [a-z]*   # suffix</span></span><br><span class="line"><span class="string">    )*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (?: \s* [\):+] )?   # maybe space and maybe close paren or colon or plus</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # END multicode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # (but not when followed by punctuation)</span></span><br><span class="line"><span class="string">        (?! [^\w\s] )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # ... or the end</span></span><br><span class="line"><span class="string">    | $</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;正则表达式这个东西，强大是强大，但写出来跟个表情符号一样。自己写的表达式，过一个月来看，自己都不记得是什么意思了。比如下面这个：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pattern = &lt;span class=&quot;string&quot;&gt;r&amp;quot;((?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?)(.*?)(?=(?:\(\s*)?[A-Z]*H\d+[a-z]*(?:\s*\+\s*[A-Z]*H\d+[a-z]*)*(?:\s*[\):+])?(?![^\w\s])|$)&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何让自己的工具函数在Python全局可用？</title>
    <link href="https://www.kingname.info/2022/06/20/utility-anywhere/"/>
    <id>https://www.kingname.info/2022/06/20/utility-anywhere/</id>
    <published>2022-06-20T11:32:32.000Z</published>
    <updated>2022-06-20T11:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发Python项目的时候，经常会写一些工具函数。为了在项目里面多个.py文件中使用这个工具函数，就不得不在多个地方都导入它，非常麻烦。</p><span id="more"></span><p>例如下面这个例子：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220609210015.png"></p><p>在<code>A.py</code>和<code>C.py</code>文件都要使用<code>clean_msg</code>这个工具函数，那么他们就都要从<code>util.py</code>中导入<code>clean_msg</code>。这似乎理所当然。</p><p>但今天我在看<a href="https://github.com/gruns/icecream/blob/master/icecream/builtins.py">icecream&#x2F;builtins.py</a>源代码的时候，突然发现了一个高级用法，可以让我们使用工具函数的时候，就像使用Python的<code>print</code>函数一样，不用导入，而是直接使用。</p><p>我们先来看看效果：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220609211901.png"></p><p>大家注意<code>A.py</code>和<code>C.py</code>，我并没有导入<code>clean_msg</code>而是直接使用了这个函数。并且运行完全正常。</p><p>关键原理就在入口文件<code>main.py</code>，被我框住的3行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> clean_msg</span><br><span class="line"><span class="built_in">setattr</span>(builtins, <span class="string">&#x27;clean_msg&#x27;</span>, clean_msg)</span><br></pre></td></tr></table></figure><p>在Python里面，所有内置的函数或者类都在<code>builtins</code>模块中，因此在代码里面可以直接使用而不用导入。现在只需要把我们自定义的工具函数注册到<code>builtins</code>模块中，就能让它跟内置函数有相同的效果。</p><p>如果想把一个工具函数注册成为内置函数，只需要在入口文件中导入它，然后使用<code>setattr</code>把它设置成<code>builtins</code>模块的一个属性。第二个参数是你想全局调用的时候的名字，第三个参数就是你需要注册的工具函数。名字可以跟工具函数的名字不相同，只要不跟已有的内置函数重复就好了。</p><p>注册完成以后，在这个项目的整个运行时中，任何<code>.py</code>文件里面都可以直接通过注册的名字调用这个工具函数，就跟调用内置函数一样。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在开发Python项目的时候，经常会写一些工具函数。为了在项目里面多个.py文件中使用这个工具函数，就不得不在多个地方都导入它，非常麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《从论文到代码，学术研究的工程化落地实践》直播录屏</title>
    <link href="https://www.kingname.info/2022/05/29/gne-origin/"/>
    <id>https://www.kingname.info/2022/05/29/gne-origin/</id>
    <published>2022-05-29T12:25:05.000Z</published>
    <updated>2022-06-20T11:38:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220529195530.png"></p><span id="more"></span><p>PyCon China Python Meetup 2021 原计划2021年线下举行。由于疫情不可抗力，被延期到了今天线上举办。</p><p>我今天分享的题目是《从论文到代码，学术研究的工程化落地实践》。介绍了Gne的起源——如何从一篇论文，发展到现在能够每天入库100万篇新闻的通用爬虫系统的故事。</p><p>在分享中，我说明了学术研究与工程实践有哪些差异，在理论落地中，我们将会遇到哪些挑战。为什么有些领域，学术研究非常成熟了，但目前市面上还没有一家公司在这些领域落地成功。</p><p>请大家<a href="https://live.csdn.net/room/pyconchina/kzYMmmqM">点击观看</a>。我的分享从04:41:47开始。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220529195530.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="直播" scheme="https://www.kingname.info/categories/%E7%9B%B4%E6%92%AD/"/>
    
    
    <category term="Gne" scheme="https://www.kingname.info/tags/Gne/"/>
    
    <category term="直播" scheme="https://www.kingname.info/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Any与TypeVar，让IDE的自动补全更好用</title>
    <link href="https://www.kingname.info/2022/05/29/any-vs-typevar/"/>
    <id>https://www.kingname.info/2022/05/29/any-vs-typevar/</id>
    <published>2022-05-29T12:24:54.000Z</published>
    <updated>2022-05-29T12:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信有很多同学在写Python的时候，会使用类型标注来提高代码的可读性，同时还能帮助IDE实现自动补全。</p><span id="more"></span><p>假设我们现在获得了一个对象，这个对象可能是列表也可能是生成器，我写一个函数，获取它的第一个元素。代码很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>正在走路&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_element</span>(<span class="params">ele_list</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(ele_list, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">return</span> ele_list[<span class="number">0</span>] <span class="keyword">if</span> ele_list <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(ele_list, Iterator):</span><br><span class="line">        <span class="keyword">with</span> suppress(Exception):</span><br><span class="line">            value = <span class="built_in">next</span>(ele_list)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    kingname = People(<span class="string">&#x27;kingname&#x27;</span>)</span><br><span class="line">    pm = People(<span class="string">&#x27;pm&#x27;</span>)</span><br><span class="line">    people_list = [kingname, pm]</span><br><span class="line"></span><br><span class="line">    obj = get_first_element(people_list)</span><br><span class="line">    <span class="keyword">if</span> obj:</span><br><span class="line">        <span class="built_in">print</span>(obj.)</span><br></pre></td></tr></table></figure><p>代码写好了，但是当我获取第一个元素，想打印它里面的数据的时候，我发现我忘记了People这个类有哪些属性了，而此时PyCharm的自动补全也失效了，我不得不把代码往回翻，去寻找People定义的位置，效率非常低。如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528174322.png"></p><p>如果我们使用了类型标注，就能解决这个问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528174204.png"></p><p>这个常规用法，大家肯定都知道。</p><p>现在问题来了，我们除了<code>People</code>类，还有<code>Cat</code>类，并且列表里面的元素可能全是<code>People</code>类的实例，也可能全是<code>Cat</code>类实例，这种情况怎么办呢？</p><p>首先你遇到了第一个问题，<code>get_first_element</code>的参数的类型标注怎么写？</p><p>你可能会写成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_element</span>(<span class="params">ele_list: <span class="type">Union</span>[<span class="type">List</span>[<span class="type">Union</span>[People, Cat]], Iterator[<span class="type">Union</span>[People, Cat]]]</span>)</span><br></pre></td></tr></table></figure><p>那如果还有一个<code>Dog</code>类呢？</p><p>为了简化操作，你可能会用<code>Any</code>，类型，于是<code>get_first_element</code>变成了下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_element</span>(<span class="params">ele_list: <span class="type">Union</span>[<span class="type">List</span>[<span class="type">Any</span>], Iterator[<span class="type">Any</span>]]</span>) -&gt; <span class="type">Optional</span>[<span class="type">Any</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(ele_list, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">return</span> ele_list[<span class="number">0</span>] <span class="keyword">if</span> ele_list <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(ele_list, Iterator):</span><br><span class="line">        <span class="keyword">with</span> suppress(Exception):</span><br><span class="line">            value = <span class="built_in">next</span>(ele_list)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>现在你发现问题又来了，PyCharm的自动补全又坏了。因为Any是任何类型，所以在代码运行前，它其实不知道你返回的是什么东西。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528174553.png"></p><p>这种情况下，你就需要使用Python类型标注中的<code>泛型</code>了。我们知道，泛型是静态语言中的概念，Python由于使用了类型标注，也有了类型。于是也就借用了这个概念。</p><p>我们来看看怎么使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意这里的变量名<code>T</code>和TypeVar的参数<code>&#39;T&#39;</code>可以同时写成任意字符串，但变量名要与参数保持一致。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GodType = TypeVar(<span class="string">&#x27;GodType&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后把T当做<code>Any</code>一样使用就可以。我们来看看效果：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528173945.png"></p><p>可以看到，PyCharm又能自动补全了。使用<code>TypeVar</code>，可以告诉PyCharm，返回的类型跟传入参数中的<code>T</code>对应位置的类型保持一致。例如传入参数中，<code>T</code>在<code>List[T]</code>或者<code>Generator[T]</code>中，所以返回的参数需要与列表中的元素或者生成器中的元素类型保持一致。</p><p>我们用Cat生成器来测试一下，发现也能自动补全：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528172546.png"></p><p>还有更厉害的，如果我的列表里面既有<code>Cat</code>的实例，又有<code>People</code>的实例怎么办？这个时候，PyCharm会直接把两个实例的可能补全都给你列出来：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220528172902.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信有很多同学在写Python的时候，会使用类型标注来提高代码的可读性，同时还能帮助IDE实现自动补全。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="type hint" scheme="https://www.kingname.info/tags/type-hint/"/>
    
    <category term="PyCharm" scheme="https://www.kingname.info/tags/PyCharm/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：用Python做游戏有多简单</title>
    <link href="https://www.kingname.info/2022/05/22/learn-pygame/"/>
    <id>https://www.kingname.info/2022/05/22/learn-pygame/</id>
    <published>2022-05-22T00:59:32.000Z</published>
    <updated>2022-05-22T01:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>我520的公众号图片发了以后，有很多同学问我这个游戏是怎么做的，难不难。我就用两篇文章来介绍一下，如果使用Python做游戏。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220520111927.png"></p><p>这个游戏是使用PyGame做的，贴图素材是从<a href="https://itch.io/game-assets">itch.io</a>找的。我之前也没有用过PyGame，这次属于是现学现用，参考的教程是<a href="https://realpython.com/pygame-a-primer">PyGame: A Primer on Game Programming in Python</a>。</p><p>用PyGame做游戏非常简单，我们今天第一篇文章，让大家实现一个可以在地图上移动的小猪。</p><span id="more"></span><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>首先，无论你是做什么游戏，别管三七二十一，先把下面这段代码复制粘贴到你的编辑器里面。所有游戏都需要这几行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;未闻Code：青南做的游戏&#x27;</span>)  <span class="comment"># 游戏标题</span></span><br><span class="line">    win = pygame.display.set_mode((<span class="number">800</span>, <span class="number">600</span>))  <span class="comment"># 窗口尺寸，宽800高600</span></span><br><span class="line">    running = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:  <span class="comment"># 点击左上角或者右上角的x关闭窗口时，停止程序</span></span><br><span class="line">                running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521213043.png"></p><h2 id="加载素材"><a href="#加载素材" class="headerlink" title="加载素材"></a>加载素材</h2><p>现在，我们随便找两张图片，一张作为背景，一张作为主角。尺寸不用太在意，差不多就可以了，因为我们可以用代码动态调整。下面两张图是我随便找的素材，大家注意图中红框框住的地方，是这两张图片的尺寸。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521213601.png"></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521213806.png"></p><p>我们使用如下代码加载图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_surf = pygame.image.load(<span class="string">&#x27;图片地址&#x27;</span>).convert_alpha()</span><br></pre></td></tr></table></figure><p>其中的<code>.convert_alpha()</code>是保留png图片的透明背景。如果你加载的图片不png图片，可以把<code>convert_alpha()</code>改成<code>convert()</code>。</p><p>如果要修改图片尺寸，使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_surf = pygame.transform.scale(img_surf, (宽, 高))</span><br></pre></td></tr></table></figure><p>要把图片显示在窗口中，使用下面两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">win.blit(素材对象, (素材左上角的横坐标, 素材左上角的纵坐标))</span><br><span class="line">pygame.display.flip()</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;未闻Code：青南做的游戏&#x27;</span>)  <span class="comment"># 游戏标题</span></span><br><span class="line">    win = pygame.display.set_mode((<span class="number">800</span>, <span class="number">600</span>))  <span class="comment"># 窗口尺寸</span></span><br><span class="line">    bg_small = pygame.image.load(<span class="string">&#x27;bg.png&#x27;</span>).convert_alpha()</span><br><span class="line">    bg_big = pygame.transform.scale(bg_small, (<span class="number">800</span>, <span class="number">600</span>))</span><br><span class="line">    pig = pygame.image.load(<span class="string">&#x27;pig_in_car.png&#x27;</span>).convert_alpha()</span><br><span class="line">    running = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:  <span class="comment"># 点击左上角或者右上角的x关闭窗口时，停止程序</span></span><br><span class="line">                running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        win.blit(bg_big, (<span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># 背景图最先加载，坐标是(left, top)</span></span><br><span class="line">        win.blit(pig, (<span class="number">200</span>, <span class="number">300</span>))</span><br><span class="line">        pygame.display.flip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521214515.png"></p><p>需要注意的是，<code>win.blit</code>和<code>pygame.display.flip()</code>都要放到while循环里面。其中<code>win.blit</code>的第一个参数是我们刚刚加载的素材对象。第二个参数是一个元组，标记这个图片左上角在画布上面的坐标。整个画布左上角对应坐标<code>(0, 0)</code>。由于背景图的尺寸也是<code>(800, 600)</code>，所以背景图的左上角放到<code>(0, 0)</code>，就刚好可以铺满整个画布。</p><h2 id="哪里找素材？"><a href="#哪里找素材？" class="headerlink" title="哪里找素材？"></a>哪里找素材？</h2><p>我们做的是一个像素风格的游戏，可以到<code>itch.io</code>上面找素材：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521215428.png"></p><p>这个网站提高了大量的游戏素材，并且绝大部分素材，在个人非商业用途的情况下是免费的。你找到自己喜欢的素材以后，就可以直接下载，整个过程你甚至都不需要登录（比国内的垃圾素材网站可良心多了）。</p><h2 id="怎么我的素材长这样？"><a href="#怎么我的素材长这样？" class="headerlink" title="怎么我的素材长这样？"></a>怎么我的素材长这样？</h2><p>你下载了素材以后，可能会发现一件非常奇怪的事情，怎么素材全部画在一张图上？</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521215738.png"></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521215813.png"></p><p>实际上，这就是业界惯例，做素材的人会把每一类素材排列到一张图片上，你要用的时候，需要自己去裁剪。例如所有植物放在一张图上，所有雕像放在一张图上，地基贴图也放在一张图上。</p><p>上面我们演示用的背景图，初看起来是一张绿色的图，但是它实际上包含了多个地基元素，请注意我用红框框住的部分：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521220139.png"></p><p>在正式游戏中，我们要把每一个基本元素拆出来，重新组合起来使用。重组的时候，有些元素要复制多份重复使用，有些元素要旋转缩放。最终组合成下面这样看起来<code>好看</code>的地图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521220249.png"></p><p>一般来说，像素风格的素材，尺寸大多是<code>16x16</code>，<code>32x32</code>，<code>64x64</code>，<code>128x128</code>。素材作者正常情况下会提供裁剪说明。如果没有提供的话，你也可以肉眼观察，然后猜一猜。</p><p>例如我要从雕像素材里面剪切出红框框住的女神像：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521220810.png"></p><p>那么，我可以这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_surf = pygame.image.load(<span class="string">&#x27;雕像素材.png&#x27;</span>).convert_alpha()</span><br><span class="line">goddess= img_surf.subsurface(( 女神像左上角的横坐标 , 女神像左上角的纵坐标, 女神像的宽, 女神像的高))</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521221607.png"></p><p>可能有同学问：为什么女神的坐标是这样的呢？我只能说，这个坐标是我试了很多次，试出来的。</p><h2 id="使用小精灵来管理对象"><a href="#使用小精灵来管理对象" class="headerlink" title="使用小精灵来管理对象"></a>使用小精灵来管理对象</h2><p>除了背景图，我们添加的每一个元素都是一个对象，例如上面的小猪和女神像。原则上来讲，上面的代码就足够让你把游戏做得漂亮了，想加什么东西，就不停加载图片素材，然后放到合适的位置就可以了。</p><p>但我们可以使用面向对象的设计方法，让代码更容易维护，也更简单。PyGame里面，有一个类叫做<code>Sprite</code>，我们可以为每一个对象实现一个类，继承<code>Sprite</code>，然后把对象的素材设置成<code>.surf</code>属性，把对象的位置设置为<code>.rect</code>属性。例如上面的代码，我们修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bg</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Bg, self).__init__()</span><br><span class="line">        bg_small = pygame.image.load(<span class="string">&#x27;bg.png&#x27;</span>).convert_alpha()</span><br><span class="line">        grass_land = bg_small.subsurface((<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">        self.surf = pygame.transform.scale(grass_land, (<span class="number">800</span>, <span class="number">600</span>))</span><br><span class="line">        self.rect = self.surf.get_rect(left=<span class="number">0</span>, top=<span class="number">0</span>)  <span class="comment"># 左上角定位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Pig, self).__init__()</span><br><span class="line">        self.surf = pygame.image.load(<span class="string">&#x27;pig_in_car.png&#x27;</span>).convert_alpha()</span><br><span class="line">        self.rect = self.surf.get_rect(center=(<span class="number">400</span>, <span class="number">300</span>))  <span class="comment"># 中心定位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goddess</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Goddess, self).__init__()</span><br><span class="line">        building = pygame.image.load(<span class="string">&#x27;building.png&#x27;</span>).convert_alpha()</span><br><span class="line">        self.surf = building.subsurface(((<span class="number">7</span> * <span class="number">64</span> - <span class="number">10</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)))</span><br><span class="line">        self.rect = self.surf.get_rect(center=(<span class="number">500</span>, <span class="number">430</span>))  <span class="comment"># 女神像的中心放到画布(500, 430)的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;未闻Code：青南做的游戏&#x27;</span>)  <span class="comment"># 游戏标题</span></span><br><span class="line">    win = pygame.display.set_mode((<span class="number">800</span>, <span class="number">600</span>))  <span class="comment"># 窗口尺寸</span></span><br><span class="line"></span><br><span class="line">    bg = Bg()</span><br><span class="line">    goddess = Goddess()</span><br><span class="line">    pig = Pig()</span><br><span class="line">    all_sprites = [bg, goddess, pig]  <span class="comment"># 注意添加顺序，后添加的对象图层在先添加的对象的图层上面</span></span><br><span class="line"></span><br><span class="line">    running = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:  <span class="comment"># 点击左上角或者右上角的x关闭窗口时，停止程序</span></span><br><span class="line">                running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sprite <span class="keyword">in</span> all_sprites:</span><br><span class="line">            win.blit(sprite.surf, sprite.rect)</span><br><span class="line">        pygame.display.flip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220521223325.png"></p><p>注意代码中的<code>all_sprites = [bg, goddess, pig]</code>，这里我使用的是列表。后面会有更高级的数据结构<code>SpriteGroup</code>来储存他们。今天使用列表就足够了。</p><p><code>素材对象.get_rect()</code>会返回一个坐标定位对象，这个对象有多个属性，例如<code>.left</code>, <code>.top</code>, <code>.center</code>, <code>.width</code>, <code>.height</code>。在不传参数的情况下，默认<code>.left=0</code>, <code>.top=0</code>，PyGame会自动根据这个对象的尺寸计算<code>.width</code>，<code>.height</code>和<code>.center</code>。我们可以通过传入参数的形式主动设定。当你设定左上角的时候，它自动就能算出中心点的坐标；当你传入中心坐标的时候，它自动就能算出左上角的坐标。</p><p>理论上来讲，在每个类里面，素材对象可以用任何名字，不一定要用<code>.surf</code>。坐标定位对象也不一定要用<code>.rect</code>，只要你在<code>win.blit</code>的时候对应起来就可以了。但是如果你统一使用<code>.surf</code>和<code>.rect</code>会给你带来很多好处。这一点我们到物体碰撞那个地方再讲。因此我建议你就使用这两个名字。</p><h2 id="让小猪动起来"><a href="#让小猪动起来" class="headerlink" title="让小猪动起来"></a>让小猪动起来</h2><p>既然是游戏，那肯定要按键盘让主角动起来。否则跟一幅画有什么区别呢？大家注意<code>main()</code>函数里面的<code>while running</code>这个循环，如果你在循环里面加上一行代码：<code>print(111)</code>，你会发现当你运行这个游戏的时候，<code>111</code>会一直不停的打印出来。</p><p>PyGame本质上，就是通过<code>win.blit</code>不停地画图，由于这个<code>while</code>循环每秒要运行很多次，如果每次运行的时候，我们让<code>win.blit</code>的第二个参数，也就是素材对象的坐标有细微的差异，那么在人眼看起来，这个素材对象就在运动了。</p><p>我们的目标是按住键盘的上下左右方向键，小猪向4个不同的方向移动。在PyGame里面，获得键盘按住不放的键，使用如下代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys = pygame.key.get_pressed()</span><br></pre></td></tr></table></figure><p>它返回的是一个长得像列表的对象（但不是列表），当我们要判断某个键是否被按下的时候，只需要判断<code>if keys[想要判断的键]</code>，如果返回<code>True</code>，说明被按住了。基于这个原理，我们来写两段代码。首先修改<code>Pig</code>类，新增一个<code>.update</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Pig, self).__init__()</span><br><span class="line">        self.surf = pygame.image.load(<span class="string">&#x27;pig_in_car.png&#x27;</span>).convert_alpha()</span><br><span class="line">        self.rect = self.surf.get_rect(center=(<span class="number">400</span>, <span class="number">300</span>))  <span class="comment"># 中心定位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys</span>):</span><br><span class="line">        <span class="keyword">if</span> keys[pygame.K_LEFT]:</span><br><span class="line">            self.rect.move_ip((-<span class="number">5</span>, <span class="number">0</span>))  <span class="comment"># 横坐标向左</span></span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_RIGHT]:</span><br><span class="line">            self.rect.move_ip((<span class="number">5</span>, <span class="number">0</span>))  <span class="comment"># 横坐标向右</span></span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_UP]:</span><br><span class="line">            self.rect.move_ip((<span class="number">0</span>, -<span class="number">5</span>))  <span class="comment">#纵坐标向上</span></span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_DOWN]:</span><br><span class="line">            self.rect.move_ip((<span class="number">0</span>, <span class="number">5</span>))  <span class="comment"># 纵坐标向下</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 防止小猪跑到屏幕外面</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left &lt; <span class="number">0</span>:</span><br><span class="line">            self.rect.left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.right &gt; <span class="number">800</span>:</span><br><span class="line">            self.rect.right = <span class="number">800</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.top &lt; <span class="number">0</span>:</span><br><span class="line">            self.rect.top = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.bottom &gt; <span class="number">600</span>:</span><br><span class="line">            self.rect.bottom = <span class="number">600</span></span><br></pre></td></tr></table></figure><p><code>.update</code>方法接收一个参数<code>keys</code>，就是我们按键返回的长得像列表的对象。然后判断是哪个方向键被按下了。根据被按下的键，<code>.rect</code>坐标定位对象修改相应方向的值。<code>rect.move_ip</code>这里的<code>ip</code>是<code>inplace</code>的简写，也就是修改<code>.rect</code>这个属性自身。它的参数是一个元组，对应横坐标和纵坐标。横纵坐标小于0表示向左或者向上，大于0表示向右或者向下。</p><p>原来的<code>main()</code>函数只需要在<code>win.blit</code>之前增加两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = pygame.key.get_pressed()</span><br><span class="line">pig.update(keys)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bg</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Bg, self).__init__()</span><br><span class="line">        bg_small = pygame.image.load(<span class="string">&#x27;bg.png&#x27;</span>).convert_alpha()</span><br><span class="line">        grass_land = bg_small.subsurface((<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">        self.surf = pygame.transform.scale(grass_land, (<span class="number">800</span>, <span class="number">600</span>))</span><br><span class="line">        self.rect = self.surf.get_rect(left=<span class="number">0</span>, top=<span class="number">0</span>)  <span class="comment"># 左上角定位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Pig, self).__init__()</span><br><span class="line">        self.surf = pygame.image.load(<span class="string">&#x27;pig_in_car.png&#x27;</span>).convert_alpha()</span><br><span class="line">        self.rect = self.surf.get_rect(center=(<span class="number">400</span>, <span class="number">300</span>))  <span class="comment"># 中心定位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys</span>):</span><br><span class="line">        <span class="keyword">if</span> keys[pygame.K_LEFT]:</span><br><span class="line">            self.rect.move_ip((-<span class="number">5</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_RIGHT]:</span><br><span class="line">            self.rect.move_ip((<span class="number">5</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_UP]:</span><br><span class="line">            self.rect.move_ip((<span class="number">0</span>, -<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">elif</span> keys[pygame.K_DOWN]:</span><br><span class="line">            self.rect.move_ip((<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 防止小猪跑到屏幕外面</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.left &lt; <span class="number">0</span>:</span><br><span class="line">            self.rect.left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.right &gt; <span class="number">800</span>:</span><br><span class="line">            self.rect.right = <span class="number">800</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.top &lt; <span class="number">0</span>:</span><br><span class="line">            self.rect.top = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.bottom &gt; <span class="number">600</span>:</span><br><span class="line">            self.rect.bottom = <span class="number">600</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goddess</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Goddess, self).__init__()</span><br><span class="line">        building = pygame.image.load(<span class="string">&#x27;building.png&#x27;</span>).convert_alpha()</span><br><span class="line">        self.surf = building.subsurface(((<span class="number">7</span> * <span class="number">64</span> - <span class="number">10</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)))</span><br><span class="line">        self.rect = self.surf.get_rect(center=(<span class="number">500</span>, <span class="number">430</span>))  <span class="comment"># 女神像的中心放到画布(500, 430)的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pygame.init()</span><br><span class="line">    pygame.display.set_caption(<span class="string">&#x27;未闻Code：青南做的游戏&#x27;</span>)  <span class="comment"># 游戏标题</span></span><br><span class="line">    win = pygame.display.set_mode((<span class="number">800</span>, <span class="number">600</span>))  <span class="comment"># 窗口尺寸</span></span><br><span class="line"></span><br><span class="line">    bg = Bg()</span><br><span class="line">    goddess = Goddess()</span><br><span class="line">    pig = Pig()</span><br><span class="line">    all_sprites = [bg, goddess, pig]  <span class="comment"># 注意添加顺序，后添加的对象图层在先添加的对象的图层上面</span></span><br><span class="line"></span><br><span class="line">    running = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:  <span class="comment"># 点击左上角或者右上角的x关闭窗口时，停止程序</span></span><br><span class="line">                running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        keys = pygame.key.get_pressed()</span><br><span class="line">        pig.update(keys)</span><br><span class="line">        <span class="keyword">for</span> sprite <span class="keyword">in</span> all_sprites:</span><br><span class="line">            win.blit(sprite.surf, sprite.rect)</span><br><span class="line">        pygame.display.flip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>最后的运行效果如下面这个视频所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/pig_game.gif"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PyGame做游戏真的非常简单，只要会加载素材，就能做出一个还能看得过去的游戏。今天我们学会了怎么添加素材，怎么捕获键盘事件。</p><p>PyGame可以读取Gif图片，但是你会发现加载进来以后，Gif不会动。下一篇文章，我们来讲讲如何让你控制的角色动起来，例如控制一个小娃娃，移动的时候，它的脚也跟着动。以及对象的碰撞检测。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我520的公众号图片发了以后，有很多同学问我这个游戏是怎么做的，难不难。我就用两篇文章来介绍一下，如果使用Python做游戏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220520111927.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个游戏是使用PyGame做的，贴图素材是从&lt;a href=&quot;https://itch.io/game-assets&quot;&gt;itch.io&lt;/a&gt;找的。我之前也没有用过PyGame，这次属于是现学现用，参考的教程是&lt;a href=&quot;https://realpython.com/pygame-a-primer&quot;&gt;PyGame: A Primer on Game Programming in Python&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;用PyGame做游戏非常简单，我们今天第一篇文章，让大家实现一个可以在地图上移动的小猪。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="PyGame" scheme="https://www.kingname.info/tags/PyGame/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何从大量商品数据里面找到降价商品？</title>
    <link href="https://www.kingname.info/2022/05/22/find-discount/"/>
    <id>https://www.kingname.info/2022/05/22/find-discount/</id>
    <published>2022-05-22T00:59:16.000Z</published>
    <updated>2022-05-22T01:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多做爬虫的同学都会爬电商网站，每天爬一次，然后监控商品是否降价。如果你只监控一个商品，那么是否降价这非常容易判断，但如果你要找到这个网站里面所有降价的商品，那就非常麻烦了。</p><p>如下图所示，是美国电商沃尔玛的全站商品数据：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220516193731.png"></p><p>每个商品每天都会爬一次，一共有61w+条数据。里面有N个商品降价了，现在需要把这些降价的商品找出来。</p><span id="more"></span><p>商品有十几万个，如果你分别找到每个商品的ID，然后用ID再找到这个商品每一天的数据，最后看它是否降价，这个工作量非常大，速度也会非常慢。</p><p>Pandas内部使用了SIMB技术来对并行计算进行优化，我们需要尽量在不使用for循环的情况下，完成这个任务。</p><p>为了简单起见，我们假设降价就是指今天比昨天的价格低，不考虑先涨价再降价的情况。</p><p>要解决这个问题，我们需要使用DataFrame的<code>pct_change()</code>方法。它就像是<code>reduce</code>一样，给出一系列数据，它会计算数据改变量的百分比——第二条相对于第一条数据的改变，第三条数据相对于第二条数据的改变，第四条数据相对于第三条数据的改变。</p><p>首先我们使用<code>date</code>字段对数据进行排序，确保价格是按时间排列的。然后对商品的<code>id</code>进行分组，这样就能拿到每一个商品每天的价格了。然后对<code>price</code>字段使用<code>pct_change()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2[<span class="string">&#x27;pct&#x27;</span>] = df2.sort_values([<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;id&#x27;</span>]).groupby([<span class="string">&#x27;id&#x27;</span>]).price.pct_change()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220516195027.png"></p><p>图中最右侧<code>pct</code>字段是NaN，是因为这是这些商品的第一条数据，所以始终是NaN.</p><p>我们筛选出今天（2022-05-16），pct小于0的商品：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220516195318.png"></p><p>这些就是降价的商品了。我们可以随便筛选一个商品来检查一下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220516195454.png"></p><p>使用<code>pct_change()</code>速度非常快，60w数据几乎秒出。比for循环快多了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信很多做爬虫的同学都会爬电商网站，每天爬一次，然后监控商品是否降价。如果你只监控一个商品，那么是否降价这非常容易判断，但如果你要找到这个网站里面所有降价的商品，那就非常麻烦了。&lt;/p&gt;
&lt;p&gt;如下图所示，是美国电商沃尔玛的全站商品数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220516193731.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个商品每天都会爬一次，一共有61w+条数据。里面有N个商品降价了，现在需要把这些降价的商品找出来。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="Pandas" scheme="https://www.kingname.info/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何批量给PDF添加水印？</title>
    <link href="https://www.kingname.info/2022/05/05/add-watermark-on-pdf/"/>
    <id>https://www.kingname.info/2022/05/05/add-watermark-on-pdf/</id>
    <published>2022-05-05T02:53:12.000Z</published>
    <updated>2022-05-05T02:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们有时候需要把一些机密文件发给多个客户，为了避免客户泄露文件，会在机密文件中添加水印。每个客户收到的文件内容相同，但是水印都不相同。这样一来，如果资料泄露了，通过水印就知道是从谁手上泄露的。</p><p>今天，一个做市场的朋友找我咨询一个加水印的问题，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503222817.png"></p><p>他有一个Excel文件，文件里面有10000个经销商的名字，他要把价目表PDF发给这些经销商，每个经销商收到的PDF文件上面的水印都是这个经销商自己的名字。</p><p>这个需求手动操作肯定要累死人。但是如果用Python来做，就非常简单。代码不超过30行。</p><span id="more"></span><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>要完成这个需求，需要安装两个模块，分别叫做<code>reportlab</code>和<code>pikepdf</code>。使用Pip安装就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install reportlab pikepdf</span><br></pre></td></tr></table></figure><p>然后，需要找到一个<code>.ttf</code>或者<code>.ttc</code>格式的中文字体。你可以直接从网上下载中文字体文件。也可以使用系统自带的中文字体。这里以寻找macOS系统默认的宋体为例。</p><p>macOS系统字体在<code>/System/Library/Fonts</code>，宋体对应的<code>.ttc</code>文件地址是<code>/System/Library/Fonts/Supplemental/Songti.ttc</code>。对于系统默认的字体，我们只需要知道它的对应的文件名叫做<code>Songti.ttc</code>就可以了。如果是从网上下载的第三方字体，需要使用绝对路径或者相对于项目代码的相对路径。</p><h2 id="获得经销商名字对应的列表"><a href="#获得经销商名字对应的列表" class="headerlink" title="获得经销商名字对应的列表"></a>获得经销商名字对应的列表</h2><p>由于这位朋友不会使用pandas，那么我们就尽量使用Python原生的方法来获得经销商名字列表。假设经销商信息对应的Excel如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224007.png"></p><p>我们首先把这个Excel文件导出成csv文件：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224408.png"></p><p>然后，我们用Python读取这个csv文件，获得经销商名字列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;经销商信息.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    name_list = [x[<span class="string">&#x27;经销商名字&#x27;</span>] <span class="keyword">for</span> x <span class="keyword">in</span> reader]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224437.png"></p><h2 id="生成水印PDF"><a href="#生成水印PDF" class="headerlink" title="生成水印PDF"></a>生成水印PDF</h2><p>一般来说，我们不能直接把一段文字作为水印添加到另一个PDF文件中。我们只有先把这段文字生成图片或者生成水印PDF文件，然后把这个图片或者水印PDF作为『图层』覆盖到目标PDF上面。</p><p>因此，现在需要把给每一个经销商生成对应的水印PDF文件。这个PDF中只含有水印文字。效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503225754.png"></p><p>对应的代码<code>create_watermark.py</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> reportlab.lib <span class="keyword">import</span> units</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfgen <span class="keyword">import</span> canvas</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfbase <span class="keyword">import</span> pdfmetrics</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfbase.ttfonts <span class="keyword">import</span> TTFont</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;经销商信息.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    name_list = [x[<span class="string">&#x27;经销商名字&#x27;</span>] <span class="keyword">for</span> x <span class="keyword">in</span> reader]</span><br><span class="line"></span><br><span class="line">pdfmetrics.registerFont(TTFont(<span class="string">&#x27;Songti&#x27;</span>, <span class="string">&#x27;Songti.ttc&#x27;</span>)) <span class="comment"># 加载中文字体</span></span><br><span class="line"></span><br><span class="line">water_mark_folder = Path(<span class="string">&#x27;water_pdf&#x27;</span>) <span class="comment"># 用一个文件夹存放所有的水印PDF</span></span><br><span class="line">water_mark_folder.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    path = <span class="built_in">str</span>(water_mark_folder / Path(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>.pdf&#x27;</span>))</span><br><span class="line">    c = canvas.Canvas(path, pagesize=(<span class="number">200</span> * units.mm, <span class="number">200</span> * units.mm)) <span class="comment"># 生成画布，长宽都是200毫米</span></span><br><span class="line">    c.translate(<span class="number">0.1</span> * <span class="number">200</span> * units.mm, <span class="number">0.1</span> * <span class="number">200</span> * units.mm)  </span><br><span class="line">    c.rotate(<span class="number">45</span>)  <span class="comment"># 把水印文字旋转45°</span></span><br><span class="line">    c.setFont(<span class="string">&#x27;Songti&#x27;</span>, <span class="number">35</span>)  <span class="comment"># 字体大小</span></span><br><span class="line">    c.setStrokeColorRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 设置字体颜色</span></span><br><span class="line">    c.setFillColorRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 设置填充颜色</span></span><br><span class="line">    c.setFillAlpha(<span class="number">0.3</span>)  <span class="comment"># 设置透明度，越小越透明</span></span><br><span class="line">    c.drawString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>专用价目表，严禁泄露！&#x27;</span>)</span><br><span class="line">    c.save()</span><br></pre></td></tr></table></figure><p>代码的具体作用，已经写到注释中了。运行以后会在当前项目根目录生成<code>water_pdf</code>文件夹，里面就是生成的水印PDF。</p><h2 id="合并水印与目标PDF"><a href="#合并水印与目标PDF" class="headerlink" title="合并水印与目标PDF"></a>合并水印与目标PDF</h2><p>最后一步，把每一个经销商的水印PDF与目标PDF进行合并。水印PDF作为一个图层覆盖到目标PDF上面。</p><p>使用<code>pikepdf</code>完成这个工作非常简单，编写一个<code>combine.py</code>文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> pikepdf <span class="keyword">import</span> Pdf, Page, Rectangle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">water_pdf_list = glob.glob(<span class="string">&#x27;water_pdf/*.pdf&#x27;</span>)</span><br><span class="line">result = Path(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">result.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">col = <span class="number">2</span>  <span class="comment"># 每页多少列水印</span></span><br><span class="line">row = <span class="number">3</span>  <span class="comment"># 每页多少行水印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> water_pdf_list:</span><br><span class="line">    target = Pdf.<span class="built_in">open</span>(<span class="string">&#x27;./PythonisinstanceGolang.pdf&#x27;</span>)  <span class="comment"># 必须每次重新打开PDF，因为添加水印是inplace的操作</span></span><br><span class="line">    file = Path(path)</span><br><span class="line">    name = file.stem</span><br><span class="line">    water_mark_pdf = Pdf.<span class="built_in">open</span>(path)</span><br><span class="line">    water_mark = water_mark_pdf.pages[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> target.pages:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(col):  <span class="comment"># 每一行显示多少列水印</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(row): <span class="comment"># 每一页显示多少行PDF</span></span><br><span class="line">                page.add_overlay(water_mark,</span><br><span class="line">                                 Rectangle(page.trimbox[<span class="number">2</span>] * x / col,</span><br><span class="line">                                           page.trimbox[<span class="number">3</span>] * y / row,</span><br><span class="line">                                           page.trimbox[<span class="number">2</span>] * (x + <span class="number">1</span>) / col,</span><br><span class="line">                                           page.trimbox[<span class="number">3</span>] * (y + <span class="number">1</span>) / row))</span><br><span class="line"></span><br><span class="line">    result_name = Path(<span class="string">&#x27;result&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>_添加水印.pdf&#x27;</span>)</span><br><span class="line">    target.save(<span class="built_in">str</span>(result_name))</span><br></pre></td></tr></table></figure><p>运行以后，会在项目根目录生成一个<code>result</code>文件夹，里面就是添加了水印的PDF文件了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503231815.png"></p><p>这里有必要对代码中的一些地方进行解释。带上行号的代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503232736.png"></p><p>代码第21行和22行，有两个<code>for</code>循环，他们的作用是给一个页面上添加多个水印。请大家注意下图我画圈的地方：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503232313.png"></p><p>每一页都有6个水印，分成3行2列。其中的3行对应了变量<code>row</code>的值。2列对应了变量col的值。大家也可以根据自己的需要修改这两个数字。甚至每一页的水印随机变换位置，防止被去水印的程序移除。</p><p><code>page.trimbox[2]</code>是PDF页面的宽度，<code>page.trimbox[3]</code>是PDF页面的高度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大家注意在这篇文章中，我把任务分成了3个部分，分别是：</p><ul><li>Excel转CSV，让Python方便读取</li><li>Python读取CSV生成水印PDF</li><li>水印PDF与目标PDF文件合并</li></ul><p>这三个部分的代码是可以合并在一个<code>.py</code>文件里面的，但是我没有这样做，是考虑到问这个问题的同学不是程序员，Python水平只是入门，如果合并在一起，代码量多了以后，出问题都不知道错在哪里。</p><p>在计算机领域，所有问题都可以通过把问题拆分成多个部分分别单独运行或者增加若干个中间层来解决。今天用的方法就是把问题拆分的方法。对于初学者来说，每一步都是相对独立的，都能立刻看到效果。第二步只需要依赖第一步的结果，第三步只需要依赖第二步的结果，这样每一步的输入输出非常清楚，可以显著降低问题的复杂度。如果报错了，也更容易知道是哪个地方有问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们有时候需要把一些机密文件发给多个客户，为了避免客户泄露文件，会在机密文件中添加水印。每个客户收到的文件内容相同，但是水印都不相同。这样一来，如果资料泄露了，通过水印就知道是从谁手上泄露的。&lt;/p&gt;
&lt;p&gt;今天，一个做市场的朋友找我咨询一个加水印的问题，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503222817.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;他有一个Excel文件，文件里面有10000个经销商的名字，他要把价目表PDF发给这些经销商，每个经销商收到的PDF文件上面的水印都是这个经销商自己的名字。&lt;/p&gt;
&lt;p&gt;这个需求手动操作肯定要累死人。但是如果用Python来做，就非常简单。代码不超过30行。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
    <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
    <category term="水印" scheme="https://www.kingname.info/tags/%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
</feed>
