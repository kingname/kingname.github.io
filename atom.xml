<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kingname.info/"/>
  <updated>2018-03-17T03:32:01.282Z</updated>
  <id>https://kingname.info/</id>
  
  <author>
    <name>Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Workflowy到印象笔记</title>
    <link href="https://kingname.info/2018/03/17/from-workflowy-to-evernote/"/>
    <id>https://kingname.info/2018/03/17/from-workflowy-to-evernote/</id>
    <published>2018-03-17T02:05:54.000Z</published>
    <updated>2018-03-17T03:32:01.282Z</updated>
    
    <content type="html"><![CDATA[<p>Workflowy是一个极简风格的大纲写作工具，使用它提供的无限层级缩进和各种快捷键，可以非常方便的理清思路，写出一个好看而实用的大纲。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-17-58.png" alt=""></p>
<p>印象笔记更是家喻户晓，无人不知。虽然有很多竞争产品在和印象笔记争抢市场，但是印象笔记强大的搜索功能还是牢牢抓住了不少用户。</p>
<p>如果能够把用Workflowy写大纲的便利性，与印象笔记强大的搜索功能结合起来，那岂不是如虎添翼？如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-21-31.png" alt=""></p>
<p>EverFlowy就是这样一个小工具。它可以自动把Workflowy上面的条目拉下来再同步到印象笔记中。如果Workflowy有更新，再运行一下这个小工具，它就会同步更新印象笔记上面的内容。Workflowy负责写，印象笔记负责存，各尽其能，各得其所。</p>
<a id="more"></a>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>Everflowy基于Python 3开发，代码托管在Github中，地址为：<a href="https://github.com/kingname/EverFlowy" target="_blank" rel="external">https://github.com/kingname/EverFlowy</a>这个小工具在持续在开发中，目前可以实现Workflowy单向同步到印象笔记和差异更新。由于印象笔记的Oauth验证方式需要申请才能对正式的账号使用，但它又不会通过这种个人小工具的申请，所以目前暂时使用开发者Token。关于如何申请开通正式账号的开发者Token，在后文会有详细的说明。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要保证电脑中安装了Python 3，否则无法运行这个小工具。代码的依赖关系使用Pipenv来管理，所以需要首先使用pip安装pipenv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 -m pip install pipenv</div></pre></td></tr></table></figure>
<p>有了Pipenv以后，使用Git把代码拉到本地再安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/kingname/EverFlowy.git</div><div class="line"><span class="built_in">cd</span> EverFlowy</div><div class="line">pipenv install</div><div class="line">pipenv shell</div></pre></td></tr></table></figure>
<p>运行了上面的4条命令以后，你的终端窗口应该如下图类似。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-43-11.png" alt=""></p>
<p>Pipenv会自动创建一个基于Virtualenv的虚拟环境，然后把EverFlowy依赖的第三方库自动安装到这个虚拟环境中，再自动激活这个虚拟环境。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在代码的根目录，有一个config.json文件，打开以后如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-46-26.png" alt=""></p>
<p>你需要修改三个地方，分别是<code>username</code>，<code>password</code>和<code>dev_token</code>。其中<code>username</code>和<code>password</code>分别对应了Workflowy的用户名和密码，而<code>dev_token</code>是印象笔记的开发者Token。</p>
<p>这里需要说明一下印象笔记的开发者Token。印象笔记的开发者Token有两套，分别是沙盒环境的开发者Token和生产环境的开发者Token。所谓沙盒环境，就是一个测试开发环境，这个环境是专门为了快速开发印象笔记App而设计的，它的地址为：<a href="https://sandbox.evernote.com" target="_blank" rel="external">https://sandbox.evernote.com</a>。打开这个网址，可以看到页面上弹出了警告，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-56-01.png" alt=""></p>
<p>无论你之前是否有印象笔记的账号，要使用沙盒环境，都必需重新注册。注册完成以后，通过访问<a href="https://sandbox.evernote.com/api/DeveloperToken.action" target="_blank" rel="external">https://sandbox.evernote.com/api/DeveloperToken.action</a>获取沙盒环境的开发者Token。</p>
<p>关于印象笔记的沙盒环境，我将另外开一篇文章来说明。本文主要介绍如何申请生产环境的开发者Token，从而可以使用正式的印象笔记账号。</p>
<p>在2017年6月以后，印象笔记关闭了生产环境开发者Token的申请通道，如果打开申请网址：<a href="https://app.yinxiang.com/api/DeveloperToken.action" target="_blank" rel="external">https://app.yinxiang.com/api/DeveloperToken.action</a>，你会发现申请的按钮是灰色的且无法点击。要解决这个问题，就需要让印象笔记的客服帮忙。</p>
<p>登录自己的印象笔记正式账号，打开印象笔记首页，把页面拉到最下面，可以看到有一个“联系我们”，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-11-13-41.png" alt=""></p>
<p>进入“联系我们”，点击“联系客服”，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-11-14-06.png" alt=""></p>
<p>在联系客服的页面填写如下信息，最后一项“简要描述问题”填写“我需要基于印象笔记API开发，请帮我开通生产环境开发者Token”并提交。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-11-17-01.png" alt=""></p>
<p>大约24小时内，就可以受到客服回复的邮件，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-11-19-02.png" alt=""></p>
<p>此时再次打开<a href="https://app.yinxiang.com/api/DeveloperToken.action" target="_blank" rel="external">https://app.yinxiang.com/api/DeveloperToken.action</a>就可以申请开发者Token了，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-11-20-23.png" alt=""></p>
<p>需要注意的是，开发者Token只会显示一次，所以你需要立刻把它记录下来。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了生产环境的开发者Token以后，把它填写到config.json中，配置就算完成了。在终端输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 EverFlowy.py</div></pre></td></tr></table></figure>
<p>程序就可以开始同步Workflowy的数据到印象笔记了。</p>
<p>同步完成以后，你会发现程序的根目录出现了一个history.db文件。这是一个sqllite的文件，里面就是你在Workflowy中的所有大纲内容和对应的印象笔记GUID和enml格式的内容。这是为了实现数据的差异更新而生成的。你可以使用各种能够浏览sqllite的工具来查看里面的内容。</p>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul>
<li>如果删除了history.db，那么再次运行Everflowy，Workflowy中的所有内容都会再次写入印象笔记。</li>
<li>如果单独删除了EverFlowy写入印象笔记中的某一条目，却不删除history.db中的对应条目，WorkFlowy会因为找不到GUID而抛出异常。</li>
<li>没有测试国际版印象笔记账号是否可用。</li>
<li>如过你想测试沙盒环境的开发者账号，请修改<code>evernote_util/EverNoteUtil.py</code>第98行，把</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = EvernoteClient(token=self.dev_token, sandbox=<span class="keyword">False</span>, service_host=<span class="string">'app.yinxiang.com'</span>)</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = EvernoteClient(token=self.dev_token)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Workflowy是一个极简风格的大纲写作工具，使用它提供的无限层级缩进和各种快捷键，可以非常方便的理清思路，写出一个好看而实用的大纲。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-17-58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;印象笔记更是家喻户晓，无人不知。虽然有很多竞争产品在和印象笔记争抢市场，但是印象笔记强大的搜索功能还是牢牢抓住了不少用户。&lt;/p&gt;
&lt;p&gt;如果能够把用Workflowy写大纲的便利性，与印象笔记强大的搜索功能结合起来，那岂不是如虎添翼？如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-03-17-10-21-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;EverFlowy就是这样一个小工具。它可以自动把Workflowy上面的条目拉下来再同步到印象笔记中。如果Workflowy有更新，再运行一下这个小工具，它就会同步更新印象笔记上面的内容。Workflowy负责写，印象笔记负责存，各尽其能，各得其所。&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Workflowy" scheme="https://kingname.info/tags/Workflowy/"/>
    
      <category term="Evernote" scheme="https://kingname.info/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>任务管理，项目管理和目标管理</title>
    <link href="https://kingname.info/2018/01/01/task-project-target/"/>
    <id>https://kingname.info/2018/01/01/task-project-target/</id>
    <published>2018-01-01T02:11:14.000Z</published>
    <updated>2018-03-17T02:06:59.789Z</updated>
    
    <content type="html"><![CDATA[<p>我是一个工具控，经常尝试各种生产力工具。我发现任务管理App汗牛充栋，项目管理工具乏善可陈，而目标管理App更是少得可怜。</p>
<a id="more"></a>
<h2 id="任务管理App"><a href="#任务管理App" class="headerlink" title="任务管理App"></a>任务管理App</h2><p>任务管理App，包括常见的Things 3，Todoist，Teambition，Trello。其中Things 3和Todoist，本质上就像是一个增强版的提醒工具，你要做什么事情，填上去，设置好Deadline，事情做完了勾掉。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-10-22-53.png" alt=""></p>
<p>但这种类型的App有一个缺点——任务只有<code>未做</code>和<code>完成</code>两个状态，没有<code>正在做</code>的状态。</p>
<p>而Teambition与Trello稍微进步一点，引入了看板的概念，于是能够显示任务在各个阶段的状态，如下图所示。这张图是少数派的Trello看板，用来让作者选题。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-10-26-51.png" alt=""></p>
<p>这种类型的App有一个很大的问题：你做了很多任务，但是你不知道你做这些任务是为了什么。任务管理类App适合用来记录和追踪各种琐碎的任务和相关性不强的任务。就像是少数派的每一篇文章，文章与文章之间不是一个系列的关系，他们各自独立，谁都可以领选题写文章，哪个选题先写哪个选题后写，关系不大。</p>
<p>一旦要规划一个项目，对于规划项目的人和做项目的人，用任务管理类App都会让人觉得使不上劲。对于做任务的人，看到每一个独立的任务，对项目没有整体的概念；对于规划项目的人，不知道任务是不是已经切分得足够细，是否有遗漏。举一个例子，下面是一些任务：</p>
<ul>
<li>找IT申请服务器</li>
<li>配置Dockerfile</li>
<li>配置Docker Swarm</li>
<li>搭建Jenkins</li>
<li>配置Github Hook</li>
<li>选择三个Repo测试</li>
</ul>
<p>现在看到上面的几个任务，你知道我是想做什么吗？我想实现持续集成（CI），实现开发人员把代码一推到Github，系统自动使用Jenkins把代码拉到测试服务器，检查代码风格，做单元测试，做功能测试，自动生成Code Review申请发送给相关人员，Code Review以后自动把代码集成到主干并部署。但是对于做任务的人，却很难根据上面的任务发现要做这个事情。对于规划任务的人，也很难发现是否漏掉了任务，以及是否其中的一个或者多个任务可以继续拆分。</p>
<p>再一个问题，在为每一个任务设定时间的时候，任务一旦多，很难把控每个任务的具体时长。也难以发现哪些任务可以同时做，哪些任务有依赖必需先做这个再做那个，前置任务必需按时完成。即使设置了任务优先级，但是对于同级的任务谁先做谁后做，你却无法把控，只有看App上哪个排前面就先做哪个。</p>
<p>我曾经有一篇文章，就是因为考虑到Teambition的这个问题，所以把Teambition与大纲工具Workflowy结合起来使用。文章地址为：<a href="https://kingname.info/2017/10/03/teamflowy/">TeamFlowy——结合Teambition与Workflowy
</a></p>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>正是由于任务管理App存在诸多不便，于是在规划一个项目的时候，必需使用一些项目管理的方法或者软件来提高效率。</p>
<p>关于项目管理，我个人最推崇使用甘特图。在我的另一篇文章<a href="https://kingname.info/2017/12/31/you-should-use-gantt/">不用甘特图，你做什么项目管理</a>中，我讲到了从一张甘特图里面，你将会额外获得哪些信息。</p>
<p>甘特图是一张二维的图表，它的横轴是时间，纵轴是任务。从甘特图上可以一目了然看到一个任务从什么时候开始什么时候结束，不同任务之间是否有时间重叠，以及哪些任务可以同时做哪些任务必需有先后顺序。</p>
<p>我个人认为，在项目管理中，任务周期是非常重要的，任务的开始时间和结束时间一定要把控好。使用甘特图就可以实现这样一个目的。</p>
<p>对于规划任务的人，在用甘特图规划任务的时候，如果你发现一个任务时间太长，无论怎么调整都会和后面的任务有重叠，那么你就会发现这个任务可能需要拆分为更小的任务。而且由于甘特图立足于项目的整体，你也可以更容易发现是否有任务漏掉了。</p>
<p>对于做任务的人，甘特图也可以帮他们了解到他们所做的任务在整个项目中处于一个什么样的位置，从而让他们知道自己正在做的任务是不是非常重要必需按时完成。</p>
<p>如果你是要开发一个App，或者是要写一本书，或者是要做一个其他什么项目，只要它是由一系列不同的任务构成的，那么你就可以考虑使用甘特图来帮你提高效率。</p>
<h2 id="目标管理"><a href="#目标管理" class="headerlink" title="目标管理"></a>目标管理</h2><p>今天是2018年第一天，不知道有多少人把2017年第一天许下的新年愿望原封不动的搬到了今天。为什么很多人的目标总是不能实现呢？因为他们没有做好目标管理。</p>
<p>关于目标管理，我推崇的是OKR系统。这虽然是一个发源于Intel后被Google发扬光大的企业管理系统，但是对个人依然有用。OKR的意思是<code>Objective and Key Results</code>目标和关键成果。很多人的目标之所以没有实现，是因为他们只设定目标，却不设定成果检查。例如一个人的目标是打算学好英语，但是由于没有设定结果，那么他在设定目标的第二天背了三个单词，在他的潜意识里面就会认为自己已经完成了这个任务，自然后面就会越来越松懈。但如果一个人设定目标为学好英语，再设定几个关键成果，例如：</p>
<ul>
<li>4月1之前，与10个以上美国人聊天</li>
<li>在3月10日节之前，单词书随意翻开一页，这一页的单词至少认识90%</li>
<li>在4月1日前面试三个国外的公司，不为工作就为面着玩</li>
</ul>
<p>这样的目标，就更容易实现了。</p>
<p>使用OKR方法，用纸和笔就可以完成，在设定目标关键结果的时候，一定要使用<code>Smart</code>法则：</p>
<ul>
<li>Specific-具体的</li>
<li>Measurable-可衡量的</li>
<li>Attainable-可实现的</li>
<li>Relevant-相关的</li>
<li>Time-based-有时限的</li>
</ul>
<p>关键结果要足够具体，这样它才是可衡量的。而所谓的可衡量，自然就是可以量化的，可以用数字来定量的检查这个关键结果是否完成，如果没有完全完成，那么完成了多少。如果目标是学好英语，那么关键结果里面肯定不能是“每个月吃一次素菜”。因为这个关键结果和这个目标无关。最后也是非常重要的一点，设定Deadline，防止拖延。</p>
<p>如果你基于OKR系统订好了几个目标和他们的关键结果，然后你100%完成了所有目标。那么恭喜你，你的这个OKR系统是<code>不成功</code>的。100%完成的基于OKR系统的目标对你的帮助不会太大，因为你设定得太简单了。一个完美的<code>OKR</code>系统，应该是在你用尽全力绞尽脑汁的情况下，完成了70%的目标。这样它才会促使你不断挑战自己的极限，不断变得更好。</p>
<p>基于OKR系统的目标，时间也不应该设置太长，以季度为节点检查一次，增加新的目标或者关键结果。最长也需要保证半年至少检查一次，否则很容易出现赶Deadline的情况。</p>
<h2 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h2><p>一个目标，最终会被拆分为一个或者多个项目，每个项目又会被拆分为一个或者多个具体的任务。所以在我自己的实践中，我会把本文讲到的三个东西结合起来。通过OKR系统制定我的目标，使用甘特图来规划我的项目，而使用Todoist来做任务管理。</p>
<p>当我形成了这样一个工作流以后，我发现他们之间可以合作得很好，并不会让人手忙脚乱。我在季度开始的时候制定OKR，然后每周检查一次。在绘制好甘特图以后，我每天也只在下班的时候看一次，更新好项目进度，然后把明天要做的任务添加到Todoist里面。所以我每天使用最多的，更新得最多的还是Todoist。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一个工具控，经常尝试各种生产力工具。我发现任务管理App汗牛充栋，项目管理工具乏善可陈，而目标管理App更是少得可怜。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="生产力" scheme="https://kingname.info/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="效率" scheme="https://kingname.info/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>不用甘特图，你做什么项目管理</title>
    <link href="https://kingname.info/2017/12/31/you-should-use-gantt/"/>
    <id>https://kingname.info/2017/12/31/you-should-use-gantt/</id>
    <published>2017-12-31T14:45:55.000Z</published>
    <updated>2017-12-31T16:32:10.641Z</updated>
    
    <content type="html"><![CDATA[<p>我非常喜欢使用甘特图来做项目管理。不用甘特图的公司，我觉得很奇怪。<br><a id="more"></a></p>
<h2 id="什么是甘特图"><a href="#什么是甘特图" class="headerlink" title="什么是甘特图"></a>什么是甘特图</h2><p>什么是甘特图呢？下面这张图就是甘特图。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-31-22-53-21.png" alt=""></p>
<p>这张图是我12月离职做交接时候的甘特图。</p>
<ul>
<li>不同的颜色表示不同的人</li>
<li>每一行表示一个任务</li>
<li>红色竖线表示今天应该完成的任务</li>
<li>任务与任务之间的黑色箭头表示任务之间的依赖关系，必需完成前面的才能完成后面的</li>
<li>带中心黑线的任务表示已经完成的任务</li>
</ul>
<p>通过这一张甘特图，我能一眼看出以下信息：</p>
<ol>
<li>今天谁应该做什么任务</li>
<li>这个任务从什么时候开始，到什么时候结束</li>
<li>一个人在一段时间有哪些任务</li>
<li>应该先做哪些任务再做哪些任务</li>
<li>哪些任务可以同时做</li>
<li>这个任务是否被其他任务依赖，如果是，那么这个任务就不能推迟，必需按时完成或者提前完成，否则会影响后面的任务</li>
<li>每个任务已经完成多少还剩多少</li>
<li>大任务下面有哪些子任务</li>
<li>任务的里程碑是什么时候</li>
</ol>
<h2 id="为什么要用甘特图"><a href="#为什么要用甘特图" class="headerlink" title="为什么要用甘特图"></a>为什么要用甘特图</h2><p>因为为了绘制出甘特图，你必需强迫自己完成以下几件事情：</p>
<ol>
<li>确定每一个任务的开始时间和结束时间</li>
<li>确定任务的依赖关系</li>
<li>分离可以同时运行的任务</li>
<li>确定不同人的任务间的时间关系</li>
</ol>
<p>当你根据以上的规则绘制好第一版甘特图以后，你会发现有些地方是可以继续调整的，但是这种调整，在你没有画图之前是不能发现的。于是你会在调整甘特图的过程中，让项目的规划越来越清晰。</p>
<h2 id="怎么做甘特图"><a href="#怎么做甘特图" class="headerlink" title="怎么做甘特图"></a>怎么做甘特图</h2><p>你可以在纸上做甘特图，也可以用Excel来做。下面这张图是来自网络。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-31-23-20-03.png" alt=""></p>
<p>这是使用Excel做出来的效果，但是做起来稍显麻烦。</p>
<p>Omniplan和MS Project都是非常专业的甘特图制作软件，但是价格非常高。毕竟这是生产力软件，使用这个软件你是可以赚大钱的，自然软件本身就会比较贵。</p>
<p>开源的甘特图软件也有不少，不过不是功能不全就是界面丑陋。这里介绍一个相对比较完整的甘特图制作软件：GanttProject</p>
<p>GanttProject的官方网站为<a href="http://www.ganttproject.biz/" target="_blank" rel="external">http://www.ganttproject.biz/</a>，在这里你可以下载到macOS，Windows或者Linux版本的软件。</p>
<p>GanttProject运行以后的界面如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-31-23-47-11.png" alt=""></p>
<p>在左侧任务面板右键或者按下键盘<code>Command</code> + <code>T</code>就可以添加任务，Windows和Linux对应的快捷键为<code>Ctrl</code> + <code>T</code>。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-31-23-48-11.png" alt=""></p>
<p>创建好了一个任务，它默认的开始时间和结束时间都是今天。在任务上面右键，选择<code>任务属性</code>，可以打开任务属性设置界面，在这里可以设置任务的开始时间和任务时长。但是你不能设置任务结束时间。因为任务结束时间会根据开始时间和任务时长自动计算。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-03-16.png" alt=""></p>
<p>在这个界面，还可以设置任务的颜色，实现不同人不同颜色，或者不同项目不同颜色。也可以在这里更新任务进度。</p>
<p>创建多个任务，如果后面的任务依赖前面的任务，那么在右侧被依赖的任务色条上单击鼠标左键，按住并拖动到依赖它的任务上。依赖它的任务的起始时间自动就会变为被依赖任务的结束时间，如下图所示。此时，后一个任务只能设置任务的时长，不能修改任务的起始时间。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-08-17.png" alt=""></p>
<p>如果依赖关系设置错误，打开依赖任务的任务属性，定位到<code>前置任务</code>选项卡，在这里可以删除被依赖的任务或者修改被依赖任务。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-11-10.png" alt=""></p>
<p>如果你需要移动任务的顺序，鼠标单击选中它，按下键盘上的<code>Alt</code> + <code>方向键上或下</code>即可移动任务。</p>
<p>我认为甘特图有一个非常重要的元素，就是竖直红线，它指向了今天的任务。要打开这跟红线，需要单击菜单栏的<code>编辑</code>-<code>设置</code>，定位到<code>甘特图设定</code>，在<code>将今天显示为红色</code>点选为<code>是</code>，如下图所示。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-20-55.png" alt=""><br>单击确定回到甘特图的界面，可以看到图中出现了一条红色竖线。这条竖线指向了今天应该做的事情。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-23-06.png" alt=""></p>
<p>每天打开甘特图，这根红线都会指向当天。</p>
<p>GanttProject可以把做好的甘特图导出为图片，CSV，HTML或者PDF文件。单击<code>项目</code>-<code>导出</code>，点选<code>Raster图像文件</code>，并单击<code>下一步</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2018-01-01-00-24-34.png" alt=""></p>
<p>设置保存路径和甘特图的日期范围即可导出为PNG文件，以方便分享。</p>
<p>GanttProject还有更多功能，你可以安装以后慢慢研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我非常喜欢使用甘特图来做项目管理。不用甘特图的公司，我觉得很奇怪。&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="https://kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="甘特图" scheme="https://kingname.info/tags/%E7%94%98%E7%89%B9%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins自动部署博客</title>
    <link href="https://kingname.info/2017/12/17/auto-deploy-blog/"/>
    <id>https://kingname.info/2017/12/17/auto-deploy-blog/</id>
    <published>2017-12-17T11:48:10.000Z</published>
    <updated>2017-12-17T13:18:31.142Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章比较简单，适合初学<code>持续集成</code>的读者，本文可以帮助你对基于Jenkins的持续集成有一个比较全局的概念。</p>
<a id="more"></a>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>为了使用HTTPS，我将博客从GitHub Pages迁移到了我的服务器上。由于博客基于Hexo，在迁移之前，我的工作流程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本地写Markdown格式文章-&gt;Hexo生成HTML并推送到GitHub-&gt;GitHub Pages自动使用最新内容</div></pre></td></tr></table></figure>
<p>现在由于Hexo渲染以后的HTML文件需要放到服务器上，那么工作流程变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">本地写Markdown格式文章-&gt;Hexo生成HTML并推送到GitHub-&gt;手动登录服务器</div><div class="line">-&gt;进入放博客文章的文件夹-&gt;执行命令git pull</div></pre></td></tr></table></figure>
<p>增加的两步虽然说操作量不大，但是总显得很麻烦。于是我希望，在我把博客的HTML文件push到GitHub以后，服务器能自动从GitHub上把HTML内容拉下来。由于使用了Nginx，所以只要博客的HTML发生了更新，那么使用浏览器访问<a href="https://kingname.info">https://kingname.info</a>时，新内容自动就会出现。这样一来，对我来说，看起来就像是我刚刚push了网页内容到GitHub，博客就自动更新了。</p>
<p>让服务器从GitHub上面拉代码，这个操作本身很简单。人来操作就一行代码<code>git pull</code>。写个Python脚本也就两行代码。但问题是，服务器怎么知道GitHub发生了更新？</p>
<p>有人说，Kingname，你不是做爬虫吗？你写个爬虫，每一秒检查一下GitHub不就可以了吗？这种办法当然可以。但问题是，我一周就更新一次博客，但这个爬虫为了等这一次更新，一周要访问GitHub高达604800次？更何况我有时候一个月都不更新。</p>
<p>所以显然不能让服务器主动检查GitHub更新，这种“轮询”操作效率太低。那么如果反过来，一旦GitHub有更新，它就通知服务器，然后服务器再去拉代码，这不就简单高效了吗？</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>为了实现这个目的，就需要使用一些持续集成的工具。本文使用的是Jenkins。</p>
<p>Jenkins在<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" target="_blank" rel="external">敏捷开发</a>界可以说是大名鼎鼎了。使用Jenkins搭建一整套<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成</a>环境，可以实现开发者往代码仓库一提交代码，代码自动进行单元测试，覆盖率测试，代码风格检查自动生成报告，自动通知部门同事开始Code Review。当代码被合并入主干以后，服务器自动拉下最新代码，自动编译，自动在几千几万台服务器上部署。在整个过程中，开发者只需要做一件事，那就是<code>git push</code>（当然在实际情况下，后面还会加一些参数）。</p>
<p>本文实现的是博客的自动部署，没有任何测试，也没有Code Review，也没有编译，服务器也只有一台，复杂程度当然远远低于持续集成。不过管中窥豹，来看看这个简单地流程是如何走通的，对初学者也会有帮助。</p>
<p>本文假设你已经在服务器上面搭建好了Jenkins环境。如果你还没有安装Jenkins或者不会安装，那么可以“参考”这篇文章：<a href="https://kingname.info/2016/05/29/raspberryCI-1/">搭建持续集成环境(一)</a>。由于这篇文章是18个月以前写的，系统也是小众的Arch Linux，所以建议你还是在网上搜一下最新的Jenkins安装教程比较好。</p>
<h3 id="设置GitHub"><a href="#设置GitHub" class="headerlink" title="设置GitHub"></a>设置GitHub</h3><p>在GitHub中进入博客所在的Repo，并点击<code>Settings</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-23-18.png" alt=""></p>
<p>在设置页面，单击左侧的<code>Integrations &amp; services</code>，并选择<code>Add service</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-25-25.png" alt=""></p>
<p>从下拉菜单中，选中<code>Jenkins (GitHub plugin)</code>。在新打开的界面，填写Jenkins的信息，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-27-06.png" alt=""></p>
<p>其中<code>Jenkins hook url</code>填写的是我的服务器的Jenkins地址加上<code>/GitHub-webhook/</code>，所以完整的地址为<code>http://xx.xx.xx.xx:8080/GitHub-webhook/</code>。把这里的<code>xx</code>换成实际的IP地址或者域名即可。需要注意的是，网址末尾的斜杠一定不能省略。</p>
<p>填写好信息以后保存，GitHub就配置好了。</p>
<h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><p>Jenkins需要安装<code>GitHub Plugin</code>才能接收到GitHub发来的通知。进入Jenkins的<code>系统管理</code>-<code>管理插件</code>，在<code>可选插件</code>选项卡中，搜索<code>GitHub plugin</code>并安装，安装完成Jenkins会重启。重启以后可以在<code>已安装</code>选项卡下面发现<code>GitHub plugin</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-35-50.png" alt=""></p>
<p>回到Jenkins首页，单击左上角<code>新建</code>按钮，新建一个项目，项目类型为<code>构建一个自由风格的软件项目</code>。任务的配置信息如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-37-57.png" alt=""></p>
<p>其中的<code>项目名称</code>和<code>描述</code>可以随意填写。勾选<code>GitHub project</code>，并把博客对应的GitHub Repo的地址填入。往下拉，看到<code>源码管理</code>，点选<code>Git</code>，依然填写博客对应的Repo地址。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-39-09.png" alt=""></p>
<p>继续往下拉，在<code>构建触发器</code>单击<code>增加构建步骤</code>，在弹出的下拉菜单中选择<code>Execute shell</code>。勾选<code>GitHub hook trigger for GITScm polling</code>。在<code>Execute shell</code>对应的输入框中输入命令，将当前目录下的所有文件和文件夹全部复制到<code>/home/bexercise/kingname.github.io/</code>文件夹下。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-20-43-09.png" alt=""></p>
<p>其中，文件夹<code>/home/bexercise/kingname.GitHub.io/</code>里面的内容如下图所示。这是Hexo生成的HTML文件和资源文件。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-21-06-45.png" alt=""></p>
<p>这里需要解释一下这一条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -r ./* /home/bexercise/kingname.GitHub.io/</div></pre></td></tr></table></figure>
<p>其中的<code>cp -r</code>表示复制文件和文件夹。<code>./</code>表示当前目录。<code>./*</code>表示当前目录下面的所有内容。因此整条命令的意思是把当前目录下的所有内容全部复制到<code>/home/bexercise/kingname.GitHub.io/</code>下，并且如果文件名相同，就会直接覆盖。需要注意的是，<code>kingname.GitHub.io</code>这仅仅是一个普通的文件夹而已，别看它的名字长得像个网址，但其实它只是一个名字比较怪的普通文件夹而已，没有什么特殊的意义。</p>
<p>这个项目在构建的时候，它会自动从GitHub上面对应Repo所有的文件拉取到当前的文件夹下，所以执行了这一条复制命令以后，博客HTML文件自然就被复制到了网站的根目录下。</p>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>由于Jenkins在安装的时候，会自动创建一个名为<code>jenkins</code>的普通账号，这个账号没有管理员权限。jenkins执行命令的时候，它也会使用这个账号。但是由于<code>kingname.GitHub.io</code>这个文件夹是用户<code>bexercise</code>创建的，所以<code>jenkins</code>账号默认是没有权限读写这个文件夹的。现在需要给<code>jenkins</code>账号授予权限。使用<code>bexercise</code>这个账号登录服务器，使用以下命令给<code>jenkins</code>赋予权限，让它可以读写<code>kingname.GitHub.io</code>文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R jenkins:jenkins /home/bexercise/kingname.GitHub.io</div></pre></td></tr></table></figure>
<p>执行完成这一行命令以后，jenkins才可以把其他地方的文件复制到这个文件夹里面。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>没有什么复杂的使用方法，在Hexo中，执行命令<code>hexo d</code>就可以把本地生成好的HTML文件提交到GitHub中。然后打开浏览器，打开博客，发现新的文章已经出现在首页了。</p>
<p>在Jenkins项目的执行历史里面，也可以看到它被自动触发而产生的历史记录。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-17-21-11-50.png" alt=""></p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>由于Jenkins可以运行Shell命令，进行单元测试本质上也是运行一条命令，那这不就可以实现自动进行单元测试了吗？那么如果把Shell命令改成运行一个Python脚本，那不就可以做任何事情了吗？如果Python脚本里面写了发送邮件的代码，那不就实现了你一提交代码，其他人就收到邮件了吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章比较简单，适合初学&lt;code&gt;持续集成&lt;/code&gt;的读者，本文可以帮助你对基于Jenkins的持续集成有一个比较全局的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Jenkins" scheme="https://kingname.info/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://kingname.info/tags/Jenkins/"/>
    
      <category term="CI" scheme="https://kingname.info/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>使用有限状态机原理实现英文分词</title>
    <link href="https://kingname.info/2017/12/10/use-fsm/"/>
    <id>https://kingname.info/2017/12/10/use-fsm/</id>
    <published>2017-12-10T04:12:55.000Z</published>
    <updated>2017-12-10T08:02:50.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>使用Python开发一个英文句子分词程序，把一段英文句子切分为每一个单词。不能导入任何官方的或者第三方的库，也不能使用字符串的split()方法。</p>
<a id="more"></a>
<h2 id="代码是如何一步一步恶化的"><a href="#代码是如何一步一步恶化的" class="headerlink" title="代码是如何一步一步恶化的"></a>代码是如何一步一步恶化的</h2><h3 id="单词与空格"><a href="#单词与空格" class="headerlink" title="单词与空格"></a>单词与空格</h3><p>对于只有单词和空格，不含其他符号的英语句子，可以使用空格来切分单词。于是对于句子<code>I am kingname</code>, 一个字符一个字符的进行遍历。首先遍历到<code>I</code>，发现它是一个字母，于是把它存到一个变量<code>word</code>中，然后遍历到空格，于是把变量<code>word</code>的值添加到变量<code>word_list</code>中，再把<code>word</code>清空。接下来遍历到字母<code>a</code>，又把<code>a</code>放到变量<code>word</code>中。再遍历到<code>m</code>，发现它还是一个字母，于是把字母<code>m</code>拼接到变量<code>word</code>的末尾。此时变量<code>word</code>的值为<code>am</code>。再遍历到第二个空格，于是把<code>word</code>的值添加到<code>word_list</code>中，清空<code>word</code>。</p>
<p>最后，由于第三个单词<code>kingname</code>的末尾没有空格，所以需要手动把它添加到列表<code>word_list</code>中。</p>
<p>完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-03-28.png" alt=""></p>
<h3 id="单词空格与逗号句号"><a href="#单词空格与逗号句号" class="headerlink" title="单词空格与逗号句号"></a>单词空格与逗号句号</h3><p>现在不仅仅只有单词和空格，还有逗号和句号。有这样一个句子：”I am kingname,you should remember me.”如果使用上一小节的程序，那么代码就会出现问题，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-04-07.png" alt=""></p>
<p>其中，”kingname,you”应该是两个单词，但是在这里变成了一个单词。所以现在不仅遇到空格要进行切分，遇到逗号句号还需要进行切分。那么对代码做一些修改，变成如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> [<span class="string">' '</span>, <span class="string">','</span>, <span class="string">'.'</span>]:</div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname,you should remember me.'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>现在运行起来看上去没有问题了，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-06-53.png" alt=""></p>
<p>然而，有些人写英文的时候喜欢在标点符号右侧加一个空格，例如：”I am kingname, you should remember me.”这样小小的一修改，上面的代码又出问题了，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-09-39.png" alt=""></p>
<p>分词出来的结果里面凭空多出来一个空字符串。为了解决这个问题，再加一层判断，只有发现<code>word</code>不为空字符串的时候才把它加入到<code>word_list</code>中，代码继续修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> [<span class="string">' '</span>, <span class="string">','</span>, <span class="string">'.'</span>]:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname, you should remember me.'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>代码看起来又可以正常工作了。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-12-26.png" alt=""></p>
<h3 id="单词空格与各种标点符号"><a href="#单词空格与各种标点符号" class="headerlink" title="单词空格与各种标点符号"></a>单词空格与各种标点符号</h3><p>标点符号可不仅仅只有逗号句号。现在又出现了冒号分号双引号感叹号问号等等杂七杂八的符号。英文句子变为：”I am kingname, you should say: “Kingname Oba” to me, will you?”</p>
<p>使用上面的代码，发现运行起来又出问题了。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-21-15.png" alt=""></p>
<p>为了能覆盖到所有的标点符号，现在修改一下逻辑。原来是“遇到空格/逗号/句号”就把<code>word</code>放到<code>word_list</code>中。现在要改为“如果当前字符不是字母，就把<code>word</code>放到<code>word_list</code>中”。于是代码进一步做修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> constant:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname, you should say: "Kingname Oba" to me, will you?'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>代码修改以后又可以正常工作了，其运行效果如下图所示：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-24-52.png" alt=""></p>
<h3 id="奇奇怪怪的单引号"><a href="#奇奇怪怪的单引号" class="headerlink" title="奇奇怪怪的单引号"></a>奇奇怪怪的单引号</h3><p>如果双引号包含的句子里面还需要用到引号，那么就需要在内部使用单引号。例如有这样一个句子：“I am kingname, you should say: “Kingname Oba, I always remember your motto: ‘kingname is genius’” to me, will you?”</p>
<p>使用前面的代码，运行起来似乎没有问题，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-36-20.png" alt=""></p>
<p>但是，单引号还有其他用途——有人喜欢把两个单词合并成一个单词，例如：</p>
<ul>
<li>“do not” == “don’t”</li>
<li>“is not” == “isn’t”</li>
<li>“I will” == “I’ll”</li>
<li>“I have” == “I’ve”</li>
</ul>
<p>在这种情况下，就应该把单引号连接的两部分看作是一个单词，不应该把它们切开。</p>
<p>如果句子变成：<code>I&#39;m kingname, you should say: &quot;Kingname Oba, I always remember your motto: &#39;kingname&#39;s genius&#39;&quot; to me, won&#39;t you?</code>继续使用上面的代码，就发现返回的单词列表又不对了。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-13-42-16.png" alt=""></p>
<p>要解决这个问题，就需要确定单引号具体是做普通的引号来使用，还是放在缩写里使用。</p>
<p>作为普通单引号使用的时候，如果是前单引号，那么它的左边必定不是字母，如果作为后单引号，那么它的右边必定不是字母。而缩写里面的单引号，它左右两侧必定都是字母。并且需要注意，如果是句子里面第一个符号就是单引号，那么此时它左边没有字符；如果句子里面最后一个符号是单引号，那么它右边没有字符，此时如果使用下标来查找，就需要当心下标越界。</p>
<p>对代码进一步修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(target):</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> constant <span class="keyword">and</span> letter != <span class="string">"'"</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">elif</span> letter == <span class="string">"'"</span>:</div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; index &lt; len(target) - <span class="number">1</span> \</div><div class="line">                    <span class="keyword">and</span> target[index - <span class="number">1</span>] <span class="keyword">in</span> constant \</div><div class="line">                    <span class="keyword">and</span> target[index + <span class="number">1</span>] <span class="keyword">in</span> constant:</div><div class="line">                word += letter</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'''I'm kingname, you should say: "Kingname Oba, </span></div><div class="line">                  I always remember your motto: 'kingname's genius'" to me, won't you?'''</div><div class="line">    result_word_list = split(sentence)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> result_word_list:</div><div class="line">        print(word)</div></pre></td></tr></table></figure>
<p>现在代码又可以成功运行了，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-14-13-43.png" alt=""></p>
<p>但是请细看代码，现在已经混乱到难以阅读难以理解了。如果再增加一个连字符又怎么改？如果单词内部出现了两个单引号怎么改？这种为了增加一个功能，要把很多不相干代码也进行修改的编码方式，相信可以击中很多初学者甚至是不少自称为软件工程师的人。</p>
<h2 id="状态转义图"><a href="#状态转义图" class="headerlink" title="状态转义图"></a>状态转义图</h2><p>根据分词逻辑，遇到各种符号应该怎么处理，画一个分词的状态转移图出来。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/split_fms3.png" alt=""></p>
<p>从这个图上可以看出来，其实程序只需要知道当前是什么状态，以及遇到什么字符需要转移到什么状态就可以了。没有必要知道自己是从哪个状态转移过来的，也没有必要知道和自己不相干的其他状态。</p>
<p>举一个例子：<code>I&#39;m kingname, you should say: &quot;Kingname Oba, I always remember your motto: &#39;kingname&#39;s genius&#39;&quot; to me, won&#39;t you?</code>这个句子中，<code>should</code>这个单词就是处于“单词状态”。它不在单引号内部，它也不是一个缩写。当我们对句子每个字符进行遍历的时候，遍历到“should”的“s”时进入“单词状态”，在单词状态，只需要关心接下来过来的下一个字符是什么，如果是字母，那依然是单词状态，把字母直接拼接上来即可。如果是单引号，那么进入“单引号在单词中状态”。至于“单引号在单词中状态”有什么逻辑，单词状态的代码根本不需要知道。这就像是接力赛，我把棒交给下一个人，我的任务就做完了，下一个人是跑到终点还是爬到终点，都和我没有关系。</p>
<p>这就是有限状态机FSM的原理。</p>
<h2 id="使用状态机"><a href="#使用状态机" class="headerlink" title="使用状态机"></a>使用状态机</h2><p>根据这个原理，使用状态和转移关系来改写代码，就可以让代码的逻辑变得非常清晰。改进以后的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spliter</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line">        self.state = <span class="string">'初始状态'</span></div><div class="line">        self.word = <span class="string">''</span></div><div class="line">        self.word_list = []</div><div class="line">        self.state_dict = &#123;<span class="string">'初始状态'</span>: self.parse_init,</div><div class="line">                           <span class="string">'单词状态'</span>: self.parse_word,</div><div class="line">                           <span class="string">'单引号在单词中状态'</span>: self.parse_contraction&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_init</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.state = <span class="string">'单词状态'</span></div><div class="line">            self.word += letter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_word</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.word += letter</div><div class="line">        <span class="keyword">elif</span> letter == <span class="string">"'"</span>:</div><div class="line">            self.state = <span class="string">'单引号在单词中状态'</span></div><div class="line">            self.word += <span class="string">"'"</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.word_list.append(self.word)</div><div class="line">            self.state = <span class="string">'初始状态'</span></div><div class="line">            self.word = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_contraction</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.word += letter</div><div class="line">            self.state = <span class="string">'单词状态'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.word_list.append(self.word[:<span class="number">-1</span>])</div><div class="line">            self.word = <span class="string">''</span></div><div class="line">            self.state = <span class="string">'初始状态'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self, target)</span>:</span></div><div class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">            self.state_dict[self.state](letter)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.word_list</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    spliter = Spliter()</div><div class="line">    sentence = <span class="string">'''I'm kingname, you should say: "Kingname Oba, </span></div><div class="line">                      I always remember your motto: 'kingname's genius'" to me, won't you?'''</div><div class="line">    print(spliter.split(sentence))</div></pre></td></tr></table></figure></p>
<p>代码运行效果如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-12-10-15-50-27.png" alt=""></p>
<p>需要注意的是，图中的代码只是使用了有限状态机的原理，而并非一个有限状态机。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h2&gt;&lt;p&gt;使用Python开发一个英文句子分词程序，把一段英文句子切分为每一个单词。不能导入任何官方的或者第三方的库，也不能使用字符串的split()方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="FSM" scheme="https://kingname.info/tags/FSM/"/>
    
      <category term="有限状态机" scheme="https://kingname.info/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>TeamFlowy——结合Teambition与Workflowy</title>
    <link href="https://kingname.info/2017/10/03/teamflowy/"/>
    <id>https://kingname.info/2017/10/03/teamflowy/</id>
    <published>2017-10-03T15:29:05.000Z</published>
    <updated>2017-10-27T15:27:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png" alt=""></p>
<p>Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png" alt=""></p>
<p>面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。</p>
<p>当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png" alt=""></p>
<p>但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。</p>
<a id="more"></a>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>TeamFlowy是一个Python脚本，运行以后，它会登录Workflowy账号，读取上面所有的条目。名为[Teambition]的条目是任务开始的标记，这个条目下面的一级条目会作为任务被添加到Teambition中。如果任务下面还有二级条目，这些二级条目会作为子任务被添加到任务中。由于Teambition是按照项目-Stage-任务-子任务的形式组织一个工程（其中Stage对应了Teambition中工程下面的面板，例如：“待处理”，“进行中”，“完成”。）不会存在子任务的子任务，所以Workflowy中[Teambition]这个条目下面最多出现二级缩进。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-28-13.png" alt=""></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="Workflowy"><a href="#Workflowy" class="headerlink" title="Workflowy"></a>Workflowy</h3><p>获取Workflowy上面的条目，需要进行三步操作：</p>
<ol>
<li>登录Workflowy</li>
<li>获取所有条目对应的JSON字符串</li>
<li>提取需要添加到Teambition中的条目</li>
</ol>
<h4 id="登录Workflowy"><a href="#登录Workflowy" class="headerlink" title="登录Workflowy"></a>登录Workflowy</h4><p>打开Chrome监控登录Wokrflowy的过程，可以看到登录Workflowy需要访问的接口为：<code>https://workflowy.com/accounts/login/</code>。使用HTTP <code>POST</code>方式发送请求，提交的数据包括<code>username</code>，<code>password</code>和一个不知道用途的<code>next</code>。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-47-51.png" alt=""></p>
<p>使用Python的第三方网络模块<code>requests</code>向这个模块发送<code>POST</code>请求，提交用户名和密码即可实现登录。其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">login_url = <span class="string">'https://workflowy.com/accounts/login/'</span></div><div class="line">session = requests.Session()</div><div class="line">session.post(login_url,</div><div class="line">             data=&#123;<span class="string">'username'</span>: <span class="string">'12345@qq.com'</span>,</div><div class="line">                   <span class="string">'password'</span>: <span class="string">'8888888'</span>,</div><div class="line">                   <span class="string">'next'</span>: <span class="string">''</span>&#125;)</div></pre></td></tr></table></figure>
<h4 id="获取所有条目"><a href="#获取所有条目" class="headerlink" title="获取所有条目"></a>获取所有条目</h4><p>使用<code>requests</code>的<code>session</code>登录Workflowy以后，Cookies会被自动保存到<code>session</code>这个对象里面。于是使用<code>session</code>继续访问Workfowy就可以以登录后的身份查看自己的各个条目。</p>
<p>通过Chrome可以看到获取所有条目的接口为<code>https://workflowy.com/get_initialization_data?client_version=18</code>，接口返回的数据是一个包含所有条目的超大型JSON字符串，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-55-40.png" alt=""></p>
<p>使用Python的json模块可以解析这个JSON字符串为字典，并获取所有条目，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">outline_url = <span class="string">'https://workflowy.com/get_initialization_data?client_version=18'</span></div><div class="line">outlines_json = session.get(outline_url).text</div><div class="line">outlines_dict = json.loads(outlines_json)</div><div class="line">project_list = outlines_dict.get(<span class="string">'projectTreeData'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'mainProjectTreeInfo'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'rootProjectChildren'</span>, [])</div></pre></td></tr></table></figure>
<h4 id="提取任务与子任务"><a href="#提取任务与子任务" class="headerlink" title="提取任务与子任务"></a>提取任务与子任务</h4><p>所有的条目层层嵌套在列表-字典结构中，其基本的形态如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"ch"</span>: [子条目], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">308496</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"957996b9-67ce-51c7-a796-bfbee44e3d3f"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"AutoEmo"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>nm</code>为这个条目的名字。如果一个条目有子条目，那么<code>ch</code>列表中就会有很多个字典，每个字典的都是这个结构，如果一个条目没有子条目，那么就没有<code>ch</code>这个key。这样一层一层嵌套下去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> &#123;</div><div class="line">    <span class="string">"ch"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"5117e20b-25ba-ba91-59e1-790c0636f78e"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"准备并熟背一段自我介绍，在任何需要自我介绍的场合都有用"</span></div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fb315fc4e6f"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"姓名，来自哪里，什么工作"</span>,</div><div class="line">            <span class="string">"ch"</span>: [</div><div class="line">                &#123;<span class="string">"lm"</span>: <span class="number">5435246</span>, </div><div class="line">                 <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fbadfasdc4e6f"</span>, </div><div class="line">                 <span class="string">"nm"</span>: <span class="string">"工作经验"</span>&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"ea282a1c-94f3-1a44-c5b3-7907792e9e6e"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"自我介绍"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于条目和子条目的结构是一样的，那么就可以使用递归来解析每一个条目。由于需要添加到Teambition的任务，从名为[Teambition]的条目开始，于是可以使用下面这样一个函数来解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">task_dict = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_task</span><span class="params">(sections, task_dict, target_section=False)</span>:</span></div><div class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> sections:</div><div class="line">        name = section[<span class="string">'nm'</span>]</div><div class="line">        <span class="keyword">if</span> target_section:</div><div class="line">            task_dict[name] = [x[<span class="string">'nm'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> section.get(<span class="string">'ch'</span>, [])]</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'[Teambition]'</span>:</div><div class="line">            target_section = <span class="keyword">True</span></div><div class="line">        sub_sections = section.get(<span class="string">'ch'</span>, [])</div><div class="line">        extract_task(sub_sections, task_dict, target_section=target_section)</div></pre></td></tr></table></figure>
<p>下图所示为一段需要添加到Teambition中的条目，运行这段函数以后，得到的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'登录Workflowy'</span>: [], <span class="string">'获取需要添加到Teambition的内容'</span>: [<span class="string">'获取任务'</span>, <span class="string">'获取子任务'</span>], <span class="string">'调试Teambition API'</span>: [], <span class="string">'添加任务到Teambition'</span>: []&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-09-03.png" alt=""></p>
<h2 id="Teambition"><a href="#Teambition" class="headerlink" title="Teambition"></a>Teambition</h2><p>将任务添加到Teambition，需要使用Teambition的Python SDK登录Teambition并调用API添加任务。Teambition的Python SDK在使用<code>OAuth2</code>获取<code>access_token</code>的时候有一个坑，需要特别注意。</p>
<h3 id="登录Teambition"><a href="#登录Teambition" class="headerlink" title="登录Teambition"></a>登录Teambition</h3><h4 id="设置Teambition应用"><a href="#设置Teambition应用" class="headerlink" title="设置Teambition应用"></a>设置Teambition应用</h4><p>Teambition 是使用<code>OAuth2</code>来进行权限验证的，所以需要获取<code>access_token</code>。</p>
<p>首先打开Teambition的<a href="https://developer.teambition.com/dashboard" target="_blank" rel="external">开发者中心</a>并单击<code>新建应用</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-14-38.png" alt=""></p>
<p>应用名称可以随便写。创建好应用以后，可以看到应用的信息，需要记录<code>Client ID</code>和<code>Client Secret</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-18-20.png" alt=""></p>
<p>点击左侧的<code>OAuth2</code>配置，填写回调URL，如下图所示。这里的这个URL其实使用任何一个可以访问的网站的域名都可以，这里以我的博客地址为例。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-20-49.png" alt=""></p>
<h4 id="使用Python获取access-token"><a href="#使用Python获取access-token" class="headerlink" title="使用Python获取access_token"></a>使用Python获取access_token</h4><p>首先在Python中安装Teambition的SDK：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install teambition</div></pre></td></tr></table></figure>
<p>接下来，在Python中获取授权URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> teambition <span class="keyword">import</span> Teambition</div><div class="line"></div><div class="line">tb_client_id = <span class="string">'7bfae080-a8dc-11e7-b543-77a936726657'</span></div><div class="line">tb_client_secret = <span class="string">'9830fc8c-81b3-45ed-b3c0-e039ab8f2d8b'</span></div><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret)</div><div class="line">authorize_url = tb.oauth.get_authorize_url(<span class="string">'https://kingname.info'</span>)</div><div class="line">print(authorize_url)</div></pre></td></tr></table></figure>
<p>代码运行以后，会得到一段形如下面这段URL的授权URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://account.teambition.com/oauth2/authorize?client_id=7bfae080-a8dc-11e7-b543-77a936726657&amp;redirect_uri=https://kingname.info&amp;state=&amp;lang=zh</div></pre></td></tr></table></figure>
<p>在电脑浏览器中<strong>人工</strong>访问这个URL，会出现下面这样的页面。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-31-25.png" alt=""></p>
<p>单击<code>授权并登录</code>，可以看到浏览器上面的网址变为形如：<code>https://kingname.info/?code=Pn7ebs4sZh3NYOz2FvVJQ4uu</code>，此时，需要记录<code>code=</code>后面的这一串字符串<code>Pn7ebs4sZh3NYOz2FvVJQ4uu</code>。</p>
<p>接下来就是Teambition的SDK的坑点了，根据Teambition官方文档的说法，要获取access_token，只需要如下两段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">tb.oauth.fetch_access_token(code)</div><div class="line"><span class="comment"># 上面的代码完成授权，接下来直接使用tb.xxxx就可以操作任务了。</span></div></pre></td></tr></table></figure>
<p>但实际上，上面这一段代码一定会报错。提示<code>grant invaild</code>。要解决这个问题，就必需使用Teambition的HTTP 接口来人工获取access_token。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">fetch_result_dict = session.post(<span class="string">'https://account.teambition.com/oauth2/access_token'</span>,</div><div class="line">                  data=&#123;<span class="string">'client_id'</span>: tb_client_id,</div><div class="line">                        <span class="string">'client_secret'</span>: tb_client_secret,</div><div class="line">                        <span class="string">'code'</span>: code,</div><div class="line">                        <span class="string">'grant_type'</span>: <span class="string">'code'</span>&#125;).json()</div><div class="line">tb_access_token = fetch_result_dict.get(<span class="string">'access_token'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p>此时得到的access_token是一段非常长的字符串。接下来，重新初始化tb变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret,</div><div class="line">                access_token=tb_access_token)</div></pre></td></tr></table></figure>
<p>初始化以后，使用tb这个变量，就可以对工程和任务进行各种操作了。</p>
<h4 id="Teambition的简单使用"><a href="#Teambition的简单使用" class="headerlink" title="Teambition的简单使用"></a>Teambition的简单使用</h4><p>要在某个工程里面创建任务，就需要知道工程的ID。首先在Teambition中手动创建一个工程，在浏览器中打开工程，URL中可以看到工程的ID，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-45-51.png" alt=""></p>
<p>有了工程ID以后，就可以使用下面的代码创建任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(task_name, sub_task_list)</span>:</span></div><div class="line">    tasklist = tb.tasklists.get(project_id=<span class="string">'59d396ee1013d919f3348675'</span>)[<span class="number">0</span>]</div><div class="line">    tasklist_id = tasklist[<span class="string">'_id'</span>]</div><div class="line">    todo_stage_id = tasklist[<span class="string">'stageIds'</span>][<span class="number">0</span>]</div><div class="line">    task_info = tb.tasks.create(task_name, tasklist_id=tasklist_id, stage_id=todo_stage_id)</div><div class="line">    <span class="keyword">if</span> sub_task_list:</div><div class="line">        task_id = task_info[<span class="string">'_id'</span>]</div><div class="line">        <span class="keyword">for</span> sub_task_name <span class="keyword">in</span> sub_task_list:</div><div class="line">            tb.subtasks.create(sub_task_name, task_id=task_id)</div><div class="line">    print(f<span class="string">'task: &#123;task_name&#125; with sub tasks: &#123;sub_task_list&#125; added.'</span>)</div></pre></td></tr></table></figure>
<p>这段代码首先使用<code>tb.tasklists.get()</code>根据工程ID获得任务组的ID和<code>待处理</code>这个面板的ID，接下来调用<code>tb.tasks.create()</code>接口添加任务。从添加任务返回的信息里面拿到任务的ID，再根据任务ID，调用<code>tb.subtasks.create()</code>添加子任务ID。</p>
<h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>上面的代码实现了TeamFlowy的基本逻辑。运行TeamFlowy脚本以后，[Teambition]这个条目下面的任务被成功的添加到了Teambition中，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-55-34.png" alt=""></p>
<p>将代码组合起来并进行完善，让代码更容易使用，完整的代码可以查看<a href="https://github.com/kingname/TeamFlowy" target="_blank" rel="external">https://github.com/kingname/TeamFlowy</a>。完整的代码运行效果如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-17-01-11.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。&lt;/p&gt;
&lt;p&gt;当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Workflowy" scheme="https://kingname.info/tags/Workflowy/"/>
    
      <category term="Teambition" scheme="https://kingname.info/tags/Teambition/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1709</title>
    <link href="https://kingname.info/2017/09/22/tweet-201709/"/>
    <id>https://kingname.info/2017/09/22/tweet-201709/</id>
    <published>2017-09-22T14:34:01.000Z</published>
    <updated>2017-09-22T14:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-09"><a href="#2017-09" class="headerlink" title="2017.09"></a>2017.09</h2><p>在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：<code>Command</code> + <code>Option</code> + <code>C</code></p>
<hr>
<p>以KB，MB，GB方式显示文件大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lh</div></pre></td></tr></table></figure></p>
<hr>
<p>删除超大文本文件的特定行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'10000,50000d'</span> xxx.txt &gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt</div></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<p>切分超大文本文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split -b 2G <span class="_">-d</span> <span class="_">-a</span> 2 deletelines.txt  da  //把超大文件切分为多个文件，每个文件2GB，前缀为da，后缀为2位数字</div></pre></td></tr></table></figure>
<hr>
<p>修改Linux当前用户密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd</div></pre></td></tr></table></figure>
<hr>
<p>使用Python打开一个未知编码的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">"your_file"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</div><div class="line">    file_data = fp.read()</div><div class="line">    result = chardet.detect(file_data)</div><div class="line">    file_content = file_data.decode(encoding=result[<span class="string">'encoding'</span>])</div></pre></td></tr></table></figure></p>
<h2 id="2017-08"><a href="#2017-08" class="headerlink" title="2017.08"></a>2017.08</h2><p>在SSH + Tmux中，如果想复制，按住<code>Alt</code>或者<code>Option</code>键再选择就可以复制了。</p>
<hr>
<p>关闭requests的SSL警告<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">requests.packages.urllib3.disable_warnings()</div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM中，<code>Crtl</code> + <code>V</code> <code>Ctrl</code> + <code>A</code>可以输出特殊符合<code>^A</code>，把A改为可以得到<code>^M</code></p>
<h2 id="2017-07"><a href="#2017-07" class="headerlink" title="2017.07"></a>2017.07</h2><p>在Python中，pymongo的find方法返回的是一个生成器，只有在迭代的时候才会执行里面的具体代码去读MongoDB。但是在Golang的Mgo包中，如果想让Find返回一个迭代器而不是直接把所有结果全部返回，就需要手动指定：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> xInfo <span class="keyword">struct</span> &#123;</div><div class="line">	ID <span class="keyword">int</span> <span class="string">`bson:"mt_poi_id"`</span></div><div class="line">	Count <span class="keyword">int</span> <span class="string">`bson:"count"`</span></div><div class="line">&#125;</div><div class="line">resultIter = m.handler.Find(<span class="literal">nil</span>).Select(bson.M&#123;<span class="string">"_id"</span>: <span class="number">0</span>, <span class="string">"mt_poi_id"</span>: <span class="number">1</span>, <span class="string">"count"</span>: <span class="number">1</span>&#125;).Iter()</div><div class="line"><span class="keyword">var</span> x xInfo</div><div class="line"><span class="keyword">for</span> resultIter.Next(&amp;xInfo) &#123;</div><div class="line">    fmt.Println(xInfo.Id)</div><div class="line">    fmt.Println(xInfo.Count)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2017-06"><a href="#2017-06" class="headerlink" title="2017.06"></a>2017.06</h2><p>在Golang中，使用MySQL的事务：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// paraArray为一个channel，里面是更新所需要的参数</span></div><div class="line">tx, _ := db.Begin()</div><div class="line">    <span class="keyword">for</span> _, para := <span class="keyword">range</span> paraArray&#123;</div><div class="line">        tx.Exec(<span class="string">"update....."</span>, para) </div><div class="line">    &#125;</div><div class="line">    tx.Commit()</div></pre></td></tr></table></figure></p>
<hr>
<p>由于更新MySQL会锁表，因此使用多个goroutine来更新MySQL，效果可能还不如直接在主线程中更新来的高。</p>
<hr>
<p>在Golang中，使用goroutine太多反而会导致性能下降。</p>
<h2 id="2017-05"><a href="#2017-05" class="headerlink" title="2017.05"></a>2017.05</h2><p>在Python中，可以使用<code>&gt;</code>或者<code>&gt;=</code>来判断一个集合是不是另一个集合的子集。只有是子集才会返回<code>True</code><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-05-04-09-58-18.png" alt=""></p>
<h2 id="2017-04"><a href="#2017-04" class="headerlink" title="2017.04"></a>2017.04</h2><p>在MongoDB中，通过_id来更新数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line">conn = pymongo.MongoClient().XX.YY</div><div class="line">conn.update(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'adf84a8fafasf3213'</span>), &#123;<span class="string">'$set'</span>: &#123;<span class="string">'name'</span>: <span class="string">'aaa'</span>&#125;&#125;&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p>在Python 3中，计算两个日期相隔了多少秒：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"></div><div class="line">start = <span class="string">'2017-03-21 17:21:30'</span></div><div class="line">end = <span class="string">'2017-03-21 18:10:13'</span></div><div class="line"></div><div class="line">start_datetime = datetime.datetime.strptime(start, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">end_datetime = datetime.datetime.strptime(end, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"></div><div class="line">total_seconds = (end_datetime - start_datetime).total_seconds()</div></pre></td></tr></table></figure></p>
<hr>
<p>Scrapy中，通过覆写items.py中，每个item的__repr__方法，可以减少打印出来的Log信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXItem</span><span class="params">(Item)</span>:</span></div><div class="line">    name = Field()</div><div class="line">    age = Field()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'======data has been stored.======='</span></div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM粘贴Python代码的时候，缩进会一不小心爆炸。为了避免这个问题，应该先在normal模式输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set paste</div></pre></td></tr></table></figure></p>
<p>回车，再按i，再粘贴。这样Python的缩进就不会乱掉了。</p>
<hr>
<p>Selenium的Debug级的Log有时候打得太多了，为了去掉Selenium的Debug Log又不影响其他部份的Debug Log，可以使用如下命令完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">from</span> selenium.webdriver.remote.remote_connection <span class="keyword">import</span> LOGGER</div><div class="line">LOGGER.setLevel(logging.WARNING)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017-09&quot;&gt;&lt;a href=&quot;#2017-09&quot; class=&quot;headerlink&quot; title=&quot;2017.09&quot;&gt;&lt;/a&gt;2017.09&lt;/h2&gt;&lt;p&gt;在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：&lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;Option&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以KB，MB，GB方式显示文件大小&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ls -lh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;删除超大文本文件的特定行数&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed &lt;span class=&quot;_&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;10000,50000d&#39;&lt;/span&gt; xxx.txt &amp;gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://kingname.info/tags/Golang/"/>
    
      <category term="Linux" scheme="https://kingname.info/tags/Linux/"/>
    
      <category term="Craft" scheme="https://kingname.info/tags/Craft/"/>
    
  </entry>
  
  <entry>
    <title>Tenacity——Exception Retry 从此无比简单</title>
    <link href="https://kingname.info/2017/06/18/easy-retry/"/>
    <id>https://kingname.info/2017/06/18/easy-retry/</id>
    <published>2017-06-17T16:17:47.000Z</published>
    <updated>2017-07-21T13:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://kingname.info/2017/04/17/decorate-for-method/">Python 装饰器装饰类中的方法</a>这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。</p>
<p>在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。</p>
<a id="more"></a>
<p>以爬虫开发为例，由于网页返回的源代码有各种不同的情况，因此捕获异常并重试是很常见的要求。下面这几段代码是我多年以前，在刚开始学习爬虫的时候，由于捕获异常并重试导致代码混乱化过程。</p>
<p>代码一开始的逻辑非常简单，获取网页后台API返回的JSON字符串，转化成字典，提取出里面<code>data</code>的数据，然后传递给<code>save()</code>函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>代码运行一段时间，发现有时候JSON会随机出现解析错误。于是添加捕获异常并重试的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        extract(url)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>后来又发现，有部份的URL会导致递归深度超过最大值。这是因为有一些URL返回的是数据始终是错误的，而有些URL，重试几次又能返回正常的JSON数据，于是限制只重试3次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">            <span class="keyword">if</span> extract(url):</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>后来又发现，不能立刻重试，重试要有时间间隔，并且时间间隔逐次增大……</p>
<p>从上面的例子中可以看到，对于异常的捕获和处理，一不小心就让整个代码变得很难看很难维护。为了解决这个问题，就需要通过装饰器来完成处理异常并重试的功能。</p>
<p>Python 有一个第三方库，叫做<a href="http://tenacity.readthedocs.io/en/latest/" target="_blank" rel="external">Tenacity</a>，它实现了一种优雅的重试功能。</p>
<p>以上面爬虫最初的无限重试版本为例，如果想实现遇到异常就重试。只需要添加两行代码，爬虫的主体函数完全不需要做修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry</div><div class="line"></div><div class="line"><span class="meta">@retry</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在要限制重试次数为3次，代码总行数不需要新增一行就能实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</div><div class="line"></div><div class="line"><span class="meta">@retry(stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在想每5秒钟重试一次，代码行数也不需要增加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_fixed</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_fixed(5))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>甚至重试的时间间隔想指数级递增，代码行数也不需要增加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_exponential</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_exponential(multiplier=1, max=10)) # 重试时间间隔满足：2^n * multiplier, n为重试次数，但最多间隔10秒</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure></p>
<p>重试不仅可以限制次数和间隔时间，还可以针对特定的异常进行重试。在爬虫主体中，其实有三个地方可能出现异常: </p>
<ul>
<li>requests获取网页出错</li>
<li>解析JSON出错</li>
<li>info_dict字典里面没有<code>data</code>这个key</li>
</ul>
<p>如果只需要在JSON解析错误时重试，由于异常类型为<code>json.decoder.JSONDecodeError</code>，所以就可以通过参数来进行限制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>当然，这些特性都可以进行组合，例如只对<code>JSONDecodeError</code> 进行重试，每次间隔5秒，重试三次，那就写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type, wait_fixed, stop_after_attempt</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>自始至终，爬虫主体的代码完全不需要做任何修改。</p>
<p>Tenacity是我见过的，最 Pythonic ，最优雅的第三方库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://kingname.info/2017/04/17/decorate-for-method/&quot;&gt;Python 装饰器装饰类中的方法&lt;/a&gt;这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Exception" scheme="https://kingname.info/tags/Exception/"/>
    
      <category term="Tenacity" scheme="https://kingname.info/tags/Tenacity/"/>
    
  </entry>
  
  <entry>
    <title>记住变量类型的三种方式</title>
    <link href="https://kingname.info/2017/06/11/type-hints-in-python3/"/>
    <id>https://kingname.info/2017/06/11/type-hints-in-python3/</id>
    <published>2017-06-11T07:25:03.000Z</published>
    <updated>2017-06-11T08:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。</p>
<a id="more"></a>
<p>假设有一个变量<code>is_request_finished</code>，从名字上来看，这个变量的值应该为<code>True</code>或者<code>False</code>，在写代码的时候，最初也确实是这样定义的。但是可能由于某些原因，在某一次赋值的时候，<code>is_request_finished = &#39;True&#39;</code>。此时，如果代码的单元测试不够完善，那么<code>if is_request_finished</code>在 <code>is_request_finished = True</code> 和 <code>is_request_finished = &#39;True&#39;</code>的时候都成立，问题被隐藏了。但是当<code>is_request_finished = &#39;False&#39;</code>的时候，由于<code>&#39;False&#39;</code>作为一个非空字符串，就会使得<code>if is_request_finished</code> 依然成立，从而使程序的行为发现异常。</p>
<p>单个变量的类型异常也许还容易发现，但是如果变量是放在字典或者列表里面，那就比较麻烦了。假设需要保存一段个人信息，于是创建了下面这样一个列表套字典的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">person_list = [&#123;</div><div class="line">        &apos;name&apos;: &apos;kingname&apos;,</div><div class="line">        &apos;age&apos;: 23,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;xxx&apos;,</div><div class="line">                    &apos;work&apos;: &apos;engineer&apos;,</div><div class="line">                    &apos;salary&apos;: 100000</div><div class="line">            &#125;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">        &apos;name&apos;: &apos;xiaoming&apos;,</div><div class="line">        &apos;age&apos;: 65,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;yyy&apos;,</div><div class="line">                    &apos;work&apos;: &apos;pm&apos;,</div><div class="line">                    &apos;salary&apos;: 0.5</div><div class="line">            &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>这种方式开发起来非常的快速而方便，但是其他人甚至是开发者自己在一段时间以后读代码，都会有一种想抽死自己的冲动。因为根本不知道这个变量里面保存的是什么东西。</p>
<p>针对以上问题，常见的解决办法有三种。</p>
<h2 id="Type-Hints-与-Variable-Annotations"><a href="#Type-Hints-与-Variable-Annotations" class="headerlink" title="Type Hints 与 Variable Annotations"></a>Type Hints 与 Variable Annotations</h2><p>在<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="external">PEP 484</a>中，引入了Type Hints，在<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">PEP 526</a>中引入了Variable Annotations。它使得Python 3.6及以后的Python 代码拥有了“声明”变量类型的能力。这里的“声明”之所以会打引号，是因为这个声明是给IDE和人看的。这个声明对 Python 的解释器无效。</p>
<h3 id="Type-Hints"><a href="#Type-Hints" class="headerlink" title="Type Hints"></a>Type Hints</h3><p>PyCharm现在已经可以比较好地支持Type Hints了。例如下面这一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url)</span>:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>模拟一段上传文件的函数，上传成功以后返回True。接收一个参数<code>url</code>。在正常情况下，这个<code>url</code>应该是一个字符串。于是，使用Type Hints，代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url: str)</span> -&gt; bool:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如果直接运行，其运行效果如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-23-11.png" alt=""></p>
<p>现在假设传递一个不是字符串的变量给<code>upload</code>函数，此时PyCharm就会提示类型有问题，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-24-35.png" alt=""><br>但提示归提示，强行运行也是没有问题的。这就说明Type Hints主要是给IDE和人用的，解释器并不会关心类型正不正确。</p>
<p>如果修改这个函数的返回值，让它不返回<code>True</code> 或者<code>False</code>，PyCharm 也会发出警告：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-27-49.png" alt=""></p>
<p>Type Hints的官方文档，可以参阅：<a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="external">typing — Support for type hints</a></p>
<h3 id="Variable-Annotations"><a href="#Variable-Annotations" class="headerlink" title="Variable Annotations"></a>Variable Annotations</h3><p>对于Variable Annotations，如下图所示，虽然目前PyCharm还不能很好地提示变量类型不对，但是人在读代码的时候，还是会起到一定的帮助。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-32-23.png" alt=""></p>
<p>除了这种写法外，Variable Annotations还支持把类型写在注释中，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-35-15.png" alt=""></p>
<p>虽然PyCharm不能起到很好的提示作用，但是可以使用一个第三方库<code>mypy</code>来对代码做静态检查，其运行效果如下图所示，可以发现赋值的类型与声明的类型不一致(expression has type “str”, variable has type “bool”, 表达式的类型为“str”，变量的类型是“bool”)。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-41-12.png" alt=""></p>
<p>关于Variable Annotations的更多用法，可以参阅：<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">Syntax for Variable Annotations</a><br>关于Mypy，可以参阅它的官方文档：<a href="http://mypy.readthedocs.io/en/stable/index.html" target="_blank" rel="external">Mypy documentation</a></p>
<h2 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h2><p>在docstring来标注变量的类型，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-48-18.png" alt=""><br>这种写法可以用来提示一个函数，或者一个类它里面的各个变量的情况。但是详细程度需要看开发者有没有耐心把这个注释写清楚。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>这种方法来自与Java Bean的思想，它主要用来解决列表套字典，字典套字典，字典套列表，列表套列表这种深层的嵌套关系。关于这个方法，请参阅另一篇文章：<a href="http://kingname.info/2016/06/19/bean-in-python/">可爱的豆子——使用Beans思想让Python代码更易维护</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 装饰器装饰类中的方法</title>
    <link href="https://kingname.info/2017/04/17/decorate-for-method/"/>
    <id>https://kingname.info/2017/04/17/decorate-for-method/</id>
    <published>2017-04-17T12:44:31.000Z</published>
    <updated>2017-04-17T13:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前在中文网上能搜索到的绝大部分关于装饰器的教程，都在讲如何装饰一个普通的函数。本文介绍如何使用Python的装饰器装饰一个类的方法，同时在装饰器函数中调用类里面的其他方法。本文以捕获一个方法的异常为例来进行说明。</p>
<a id="more"></a>
<p>有一个类Test, 它的结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure>
<p>在类中有一个方法<code>read_value()</code>，这个方法在多个地方被调用。由于某些原因，方法<code>read_value</code>有可能随机抛出Exception导致程序崩溃。所以需要对整个方法做<code>try ... except</code>处理。最丑陋的做法如下面的代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            print(<span class="string">'here I will do something.'</span>)</div><div class="line">            <span class="comment"># do something.</span></div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            print(f<span class="string">'exception &#123;e&#125; raised, parse exception.'</span>)</div><div class="line">            <span class="comment"># do other thing.</span></div><div class="line">            self.revive()</div></pre></td></tr></table></figure>
<p>这样写虽然可以解决问题，但是代码不Pythonic。</p>
<p>使用装饰器来解决这个问题，装饰器函数应该写在类里面还是类外面呢？答案是，写在类外面。那么既然写在类外面，如何调用这个类的其他方法呢？</p>
<p>首先写出一个最常见的处理异常的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_exception</span><span class="params">(origin_func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            u = origin_func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> u</div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            <span class="keyword">return</span> <span class="string">'an Exception raised.'</span></div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line"><span class="meta">    @catch_exception</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure>
<p>这种写法，确实可以捕获到<code>origin_func()</code>的异常，但是如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，这又应该怎么办？答案是给wrapper增加一个参数：self.</p>
<p>代码变为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_exception</span><span class="params">(origin_func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            u = origin_func(self, *args, **kwargs)</div><div class="line">            <span class="keyword">return</span> u</div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            self.revive() <span class="comment">#不用顾虑，直接调用原来的类的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="string">'an Exception raised.'</span></div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line"><span class="meta">    @catch_exception</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure></p>
<p>只需要修改装饰器<strong>定义</strong>的部分，使用装饰器的地方完全不需要做修改。</p>
<p>下图为正常运行时的运行结果：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-04-17-21-19-25.png" alt="正常运行"></p>
<p>下图为发生异常以后捕获并处理异常：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-04-17-21-20-59.png" alt="发生异常"></p>
<p>通过添加一个self参数，类外面的装饰器就可以直接使用类里面的各种方法，也可以直接使用类的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前在中文网上能搜索到的绝大部分关于装饰器的教程，都在讲如何装饰一个普通的函数。本文介绍如何使用Python的装饰器装饰一个类的方法，同时在装饰器函数中调用类里面的其他方法。本文以捕获一个方法的异常为例来进行说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Decorate" scheme="https://kingname.info/tags/Decorate/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1701</title>
    <link href="https://kingname.info/2017/02/05/tweet/"/>
    <id>https://kingname.info/2017/02/05/tweet/</id>
    <published>2017-02-05T15:56:31.000Z</published>
    <updated>2017-02-05T15:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-02"><a href="#2017-02" class="headerlink" title="2017.02"></a>2017.02</h2><p>To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, <em>always</em> remember that the <code>route()</code> decorator is the outermost.</p>
<a id="more"></a>
<h2 id="2017-01"><a href="#2017-01" class="headerlink" title="2017.01"></a>2017.01</h2><p>HTML的<code>&lt;select&gt;&lt;/select&gt;</code>标签可以实现下拉选择框。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span> <span class="attr">selected</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>viewer<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>guest<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>运行效果如下：</p>
<p><select class="form-control"><br>    <option value="admin" selected>admin</option><br>    <option value="admin">viewer</option><br>    <option value="admin">guest</option><br></select></p>
<hr>
<p>通过二进制的位操作，可以简化很多问题的分析。</p>
<p>例如现在有四个角色，分别为：读者，作者，编辑和管理员。有四个不同的权限使用四位的二进制数表示：</p>
<ul>
<li>阅读权限：0001</li>
<li>写入权限：0010</li>
<li>修改权限：0100</li>
<li>删除权限：1000</li>
</ul>
<p>每个角色的权限如下：</p>
<ul>
<li>读者只能读，所以权限是0001</li>
<li>作者能读也能写，所以是0011</li>
<li>编辑能读能写能修改，所以是0111</li>
<li>管理员能读能写能修改能删除，所以是1111</li>
</ul>
<p>要判断一个角色有哪些权限，人眼可以直接看对应的位置上面是0还是1，是0就是没有权限，是1就是有权限。在程序里面可以通过和对应权限的四位二进制数取位与操作。例如，0111编辑是否有写权限？因为0111 &amp; 0010 = 0010 所以有写权限。只要角色的四位二进制数和权限的四位二进制数取位与，得到的结果还是权限的四位二进制数，那么就有这个权限。</p>
<hr>
<p>正常情况下人有十根手指，所以一共可以计数1023个，但是一般在计数到第4个数的时候你就会挨打。明白二进制的自然知道我说的是什么意思。不明白二进制的，请看下面的动图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/count.gif" alt="手指使用二进制计数"></p>
<hr>
<p>Markdown在写作方面有非常好的优势，可以让写作的人不用关心格式，从而专注于要写的内容。但是Markdown不能进行缩进，这导致在一些大纲类的文本信息的显示上不太友好。<a href="https://workflowy.com/invite/4b7e29eb.lnx" target="_blank" rel="external">Workflowy</a>的出现可以解决这个问题。Workflowy只支持文本，界面极其简洁：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-28-16-59-48.png" alt=""><br>通过它来创建一个大纲，有助于理清思路。</p>
<hr>
<p>在HTML的<code>&lt;form&gt;&lt;/form&gt;</code>表单中，有一个属性叫做<code>action</code>,它的值是空或者是一个URL的相对路径或绝对路径。如果为空，表单将会被提交到现在这个页面的URL；如果不为空，表单将会被提交到action的值对应的页面来处理。</p>
<p>理解这一点，那些喜欢在Flask中，把GET和POST写到一个Route，同时又要为GET带参数的人，需要特别注意。因为当你POST的时候，如果action不为空，参数可能会被丢失。</p>
<hr>
<p>如果你想在局域网中共享一个文件，你可以通过Python 3快速完成：</p>
<ol>
<li>打开终端或者CMD</li>
<li><code>cd</code> 进入你需要分享的文件所在的文件夹</li>
<li>输入<code>python3 -m http.server</code>回车</li>
<li>在另一台电脑上打开浏览器，输入上一台电脑的<code>ip地址:8000</code>例如：<code>192.168.2.13:8000</code></li>
<li>下载文件</li>
</ol>
<hr>
<p>在Python中，使用<code>yield</code>实现生成器。生成器的性质是只有在被迭代的时候才运行其内部的代码。这样可以大大降低内存的占用。除此之外，<code>yield</code>还可以接收参数供生成器内部使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(top)</span>:</span></div><div class="line">       index = <span class="number">0</span></div><div class="line">       <span class="keyword">while</span> index &lt;= top:</div><div class="line">              value_from_out = <span class="keyword">yield</span> index ** <span class="number">2</span></div><div class="line">              print(<span class="string">'来自外面的值为：&#123;&#125;'</span>.format(value_from_out))</div><div class="line">              index += <span class="number">1</span></div><div class="line"></div><div class="line">power_2 = generator(<span class="number">10</span>)</div><div class="line">print(next(power_2))</div><div class="line">print(next(power_2))</div><div class="line">print(power_2.send(<span class="string">"next(power_2) 相当于power_2.send(None)"</span>))</div><div class="line">print(next(power_2))</div><div class="line">print(power_2.send(<span class="string">'代码在函数和这里来回跳。'</span>))</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">来自外面的值为：None</div><div class="line">1</div><div class="line">来自外面的值为：next(power_2) 相当于power_2.send(None)</div><div class="line">4</div><div class="line">来自外面的值为：None</div><div class="line">9</div><div class="line">来自外面的值为：代码在函数和这里来回跳。</div><div class="line">16</div></pre></td></tr></table></figure></p>
<p>以上的运行方式，和协程非常的相似。</p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="external">逆波兰式</a>通过栈来实现对表达式的运算。例如：</p>
<blockquote>
<p>中缀表达式: 5 + ((1 + 2) <em> 4) − 3<br>逆波兰式：5 1 2 + 4 </em> + 3 −</p>
</blockquote>
<hr>
<p>使用<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95" target="_blank" rel="external">调度场算法</a>可以将中缀表达式转换为逆波兰式。调度场算法是通过栈来实现的。操作数直接输出，符号需要判断优先级来判断应该直接压栈还是直接输出或者应该先将栈顶元素输出再压栈。</p>
<blockquote>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/170122.png" alt="调度场算法示意图"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017-02&quot;&gt;&lt;a href=&quot;#2017-02&quot; class=&quot;headerlink&quot; title=&quot;2017.02&quot;&gt;&lt;/a&gt;2017.02&lt;/h2&gt;&lt;p&gt;To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, &lt;em&gt;always&lt;/em&gt; remember that the &lt;code&gt;route()&lt;/code&gt; decorator is the outermost.&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Craft" scheme="https://kingname.info/tags/Craft/"/>
    
  </entry>
  
  <entry>
    <title>30秒找到藏在家里的手机</title>
    <link href="https://kingname.info/2017/01/07/findmyphone/"/>
    <id>https://kingname.info/2017/01/07/findmyphone/</id>
    <published>2017-01-07T06:02:02.000Z</published>
    <updated>2017-01-07T07:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们都有这样的生活体验</p>
<blockquote>
<p>我清清楚楚的记得半个小时前还用手机打了电话，怎么现在手机找不到了？这半个小时我一直在房间里，难道手机还会长翅膀飞走了吗？</p>
</blockquote>
<p>如果你有两个手机而且你的手机没有静音，那可以用另一个手机给不见的手机打一个电话。可是如果你的手机静音了呢？有人说可以等到晚上打电话，看家里哪里在发光。那么如果你的手机不仅静音，还屏幕朝下呢？</p>
<p>看了这篇文章以后，只要你的手机在家里，只要手机开机，只要手机可以上网，那么你就可以在30秒以内找到它，不论它是否静音。</p>
<a id="more"></a>
<p>根本原理还是让手机播放音乐，我们通过音乐来找到手机。但是在放音乐之前，需要让手机自动解除静音，并将音量调到最大声。</p>
<p>和<a href="http://kingname.info/2016/11/07/autoalarmclock/">《如果我提前起床，闹钟你就别响》</a>一样，这一次的任务依然是借助Python语言+ Flask框架 + 安卓上面的自动化程序：Automate来完成。不过，这一次我会把这个工具提供给大家一起使用。</p>
<h2 id="四个网址"><a href="#四个网址" class="headerlink" title="四个网址"></a>四个网址</h2><p>本文将会涉及到四个网址：</p>
<ul>
<li>注册你的账号&gt;<a href="http://automatic.kingname.info:8888/账号/register" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/register</a></li>
<li>获取当前状态&gt;<a href="http://automatic.kingname.info:8888/kingname" target="_blank" rel="external">http://automatic.kingname.info:8888/账号</a></li>
<li>让手机在30秒以后放音乐&gt;<a href="http://automatic.kingname.info:8888/kingname/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a></li>
<li>停止寻找手机&gt;<a href="http://automatic.kingname.info:8888/kingname/cancel" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/cancel</a></li>
</ul>
<h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>为了让每个人都能使用这个服务，我开放了账号注册的功能。注册只需要提供用户名即可，不需要密码，不需要邮箱，不需要手机号。注册账号只需要访问<a href="http://automatic.kingname.info:8888/账号/register" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/register</a> 其中，账号只能使用大小写字母或者数字或者下划线。如果你的账号可以使用，你将会看到如下画面：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-40-02.png" alt=""><br>就是这么简单。你的账号已经注册成功了，接下来就可以使用服务了。</p>
<p>当然，如果你的账号不巧被别人注册过了，你将会看到如下的提示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-41-25.png" alt=""><br>这个时候你需要换一个账号注册。</p>
<h3 id="获得状态"><a href="#获得状态" class="headerlink" title="获得状态"></a>获得状态</h3><p>注册完成以后，访问<a href="http://automatic.kingname.info:8888/账号" target="_blank" rel="external">http://automatic.kingname.info:8888/账号</a>, 你可以看到当前的状态，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-27-38.png" alt=""><br>这句话表示，现在不需要让手机自己叫起来。这个网址是给手机上面的Automate使用的，一般情况下不需要手动输入。</p>
<h3 id="呼叫手机"><a href="#呼叫手机" class="headerlink" title="呼叫手机"></a>呼叫手机</h3><p>突然，你发现你的手机不见了。这个时候，赶紧访问<a href="http://automatic.kingname.info:8888/账号/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a>, 如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-50-03.png" alt=""><br>当你访问了这个页面以后，在30秒内，你的手机就会欢快的播放音乐了。各位需要把这个网址保存为书签，方便以后直接使用。</p>
<h3 id="停止呼叫"><a href="#停止呼叫" class="headerlink" title="停止呼叫"></a>停止呼叫</h3><p>当你找到了手机，你就需要这个网址：<a href="http://automatic.kingname.info:8888/账号/cancel" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/cancel</a> 这个网址一般情况下是给Automate使用的，大家不需要手动输入。</p>
<h2 id="Automate"><a href="#Automate" class="headerlink" title="Automate"></a>Automate</h2><p>现在再来看看安卓上面的Automate应该如何配置流程。我已经将文件放在了：<a href="https://github.com/kingname/Automatic/blob/master/BackEnd/automate/Find%20my%20phone.flo" target="_blank" rel="external">Github</a>上面。点击Download按钮即可下载，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-04-56.png" alt=""></p>
<p>下载完成以后，将这个文件放在手机中，打开手机上的Automate，点击右上角的三个竖着的点，选择<code>Import</code>，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-08-49.png" alt=""></p>
<p>再点击<code>SD card</code>,如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-08-24.png" alt=""></p>
<p>选中刚刚下载的文件，即可导入成功。导入完成以后，打开这个flow, 点击右上角铅笔的图标，可以打开整个流程图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-16-49.png" alt=""><br>你需要修改的，只有我画红框的三个方块。</p>
<p>对于这两个HTTP Request，你只需要在<code>REQUEST URL</code>中，把网址里面的账号修改成你自己的账号。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-19-27.png" alt=""></p>
<p>对于Sound Play这个方块，因为我手机上面的音乐不一定在你手机上也有同样的，所以一定要修改音乐：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-20-50.png" alt=""><br>点<code>SOUND URI</code>，选择你一个你喜欢的音乐。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Flow设置完成，点击右上角✓保存，然后点击<code>Start</code>启动这个Flow。在电脑或者手机浏览器中访问：<a href="http://automatic.kingname.info:8888/账号/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a> 坐等30秒，听一下你的手机相应你的呼唤吧。然后再试一试把手机调成静音，看看它是不是依然可以大声的叫出来~</p>
<p>本文设计到的网页源代码，请访问：<a href="https://github.com/kingname/Automatic" target="_blank" rel="external">https://github.com/kingname/Automatic</a>获取。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都有这样的生活体验&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我清清楚楚的记得半个小时前还用手机打了电话，怎么现在手机找不到了？这半个小时我一直在房间里，难道手机还会长翅膀飞走了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有两个手机而且你的手机没有静音，那可以用另一个手机给不见的手机打一个电话。可是如果你的手机静音了呢？有人说可以等到晚上打电话，看家里哪里在发光。那么如果你的手机不仅静音，还屏幕朝下呢？&lt;/p&gt;
&lt;p&gt;看了这篇文章以后，只要你的手机在家里，只要手机开机，只要手机可以上网，那么你就可以在30秒以内找到它，不论它是否静音。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Workflow" scheme="https://kingname.info/tags/Workflow/"/>
    
      <category term="Automatic" scheme="https://kingname.info/tags/Automatic/"/>
    
  </entry>
  
  <entry>
    <title>用图像识别来自动确认网页加载成功</title>
    <link href="https://kingname.info/2016/12/04/how-to-know-webpage-loaded/"/>
    <id>https://kingname.info/2016/12/04/how-to-know-webpage-loaded/</id>
    <published>2016-12-04T10:10:33.000Z</published>
    <updated>2016-12-04T13:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在对安卓手机设计自动化测试用例的时候，判断一个测试场景是否可以自动化的依据在于其是否需要人的参与。对于wifi能否自动打开关闭，短信能否自动收发这样的场景，不需要人参与就可以通过程序来判断，因此对Wifi与短信这样的测试，可以通过程序来实现自动化测试。但是另外还有一些测试场景，需要人的眼睛来看，这种场景要实现自动化就比较困难。<br><a id="more"></a></p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>使用安卓的浏览器访问一个网站，如何判断网站已经加载成功？目标网站确实已经收到了请求，也返回了HTML数据，手机也收到了网站返回的数据，但是不知道什么原因，在某些时候，浏览器上面却什么都没有显示，而浏览器输出的Log却完全看不出异样。对于这样的场景，为了减少人力开销，如何让测试程序自动发现网页没有加载成功，并通知开发者？</p>
<p>这个需求可以使用计算机图像识别来实现自动化。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>由于这个需求只需要判断网页是否加载成功，因此并不需要非常高深的图像识别的理论。对一个网页来说，所谓的加载成功就是指它里面的内容能够正常地在浏览器中显示出来。因此，可以设计一个特别的网页，网页要足够简单，但是又要足够特别，从而方便图像识别。</p>
<p>这篇文章将会使用一个纯绿色的网页来进行测试。网页加载完成以后，手机屏幕上绝大多数的区域是绿色的。这个时候，截取屏幕，并使用程序来识别这张截图。如果发现截图中有大面积的绿色区域，那就证明网页已经加载完成了。</p>
<h2 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h2><h3 id="纯绿色的网页"><a href="#纯绿色的网页" class="headerlink" title="纯绿色的网页"></a>纯绿色的网页</h3><p>创建一个“greenpage.html”，它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Green Page&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body bgcolor=&quot;green&quot;&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>网站加载成功以后，页面是全绿色的，如下图所示。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-18-49-20.png" alt=""></p>
<p>在局域网中搭建一个Web Server，并让局域网的设备可以链接。打开终端，进入到这个html文件所在的文件夹，并通过Python 3在局域网中搭建一个简单地WebServer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/Project/IdentifyWebpage</div><div class="line">python -m http.server</div></pre></td></tr></table></figure></p>
<p>使用手机访问“电脑IP:8000/greenpage.html”，效果如下图所示。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-19-01-42.png" alt=""></p>
<h3 id="识别绿色截图"><a href="#识别绿色截图" class="headerlink" title="识别绿色截图"></a>识别绿色截图</h3><p>这个Demo使用Pillow图像处理库来做图像颜色的识别，通过pip安装Pillow：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pillow</div></pre></td></tr></table></figure></p>
<p>安装完成以后，在Python程序中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div></pre></td></tr></table></figure></p>
<p>导入它图像模块。</p>
<p>程序使用Image模块载入截图，并从截图中读取某一点颜色RGB值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img = Image.open(&apos;snapshot.png&apos;)</div><div class="line">color = img.getpixel((700, 800))</div><div class="line">print(color)</div></pre></td></tr></table></figure></p>
<p>代码中的（700, 800）是截图中的某一点的座标。第一个参数为横座标，第二个参数为纵座标。截图左上角为(0, 0)，越往下，纵座标越大；越往右，横座标越大。</p>
<p>为了谨慎起见，在截图中取9个点，分别获取他们的RGB值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">points = [(200, 300), (455, 678), (333, 1200),</div><div class="line">          (300, 500), (888, 678), (900, 800),</div><div class="line">          (400, 600), (245, 365), (799, 777)]</div><div class="line">img = Image.open(&apos;snapshot.png&apos;)</div><div class="line">for point in self.points:</div><div class="line">    color = img.getpixel(point)</div><div class="line">    print(color)</div></pre></td></tr></table></figure></p>
<p>运行以后的结果如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-19-44-55.png" alt=""><br>从图中可以看到，9个点的RGB值全部是(0, 128, 0)，这个值正是绿色的RGB值。到这里，可以认为这个图片大部分的地方确实是绿色的。如果你觉得9个点还是不够全面，那你可以使用代码生成几百个点来计算。</p>
<h3 id="获取屏幕截图"><a href="#获取屏幕截图" class="headerlink" title="获取屏幕截图"></a>获取屏幕截图</h3><p>adb（Android Debug Bridge）是安卓的调试工具，可以通过adb的命令来控制手机。要对手机截图，只需要使用下面两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell /system/bin/screencap -p /sdcard/screenshot.png</div><div class="line">adb pull /sdcard/screenshot.png ~/Project/IndenfyWebpage/screenshot.png</div></pre></td></tr></table></figure></p>
<p>第一条命令生成截图，并将截图保存到手机内置存储中。虽然这里写的是“sdcard”，但是对于现在没有SD卡的手机，这条命令依然可以使用。</p>
<p>第二条命令将手机内置存储中的截图文件取出来，并保存到电脑中。如果你的电脑为Windows系统，可以将第二条命令修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/screenshot.png D:/Project/IndenfyWebpage/screenshot.png</div></pre></td></tr></table></figure></p>
<p>保存到D盘下面。注意这里使用的是从右上到左下的斜杠（/）。</p>
<p>完整的程序请访问-&gt; <a href="https://github.com/kingname/Automatic" target="_blank" rel="external">https://github.com/kingname/Automatic</a></p>
<h2 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h2><p>虽然这个Demo只是针对网页来进行测试。但是这个方法除了网页还可以验证很多其他的测试场景。例如验证视频能否正常播放，做一个特殊的视频，视频中是几个不同的纯色画面不停的切换。每一个画面停留一定的时间，程序定时获取截图并分析此时是否为纯色画面，且纯色画面是否在更换。</p>
<p>理论上讲，任何需要在屏幕上显示信息的测试案例，都可以使用这个方法来实现自动化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对安卓手机设计自动化测试用例的时候，判断一个测试场景是否可以自动化的依据在于其是否需要人的参与。对于wifi能否自动打开关闭，短信能否自动收发这样的场景，不需要人参与就可以通过程序来判断，因此对Wifi与短信这样的测试，可以通过程序来实现自动化测试。但是另外还有一些测试场景，需要人的眼睛来看，这种场景要实现自动化就比较困难。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="PIL" scheme="https://kingname.info/tags/PIL/"/>
    
      <category term="Android" scheme="https://kingname.info/tags/Android/"/>
    
      <category term="自动化测试" scheme="https://kingname.info/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如果我提前起床，闹钟你就别响</title>
    <link href="https://kingname.info/2016/11/07/autoalarmclock/"/>
    <id>https://kingname.info/2016/11/07/autoalarmclock/</id>
    <published>2016-11-07T14:56:21.000Z</published>
    <updated>2016-12-04T12:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>闹钟已经成了我们生活中必不可少的东西。如果全球每个国家的当地时间明天早上，所有的闹钟突然都不响了，不知道会发生什么样的混乱。</p>
<p>然而我们要讨论另外一种情况，闹钟每天定时响起来，真的是最好的情况吗？你有过醒来以后等闹钟的经历吗？如果你有时候在闹钟响之前就起来了，那么你会不会希望闹钟能知道你已经起来了？如果你提前醒了，那么闹钟就不响，只有你一直睡着的时候，闹钟才会按时响起来。<br><a id="more"></a></p>
<p>这个项目基于 Andorid 上面的自动化 workflow 程序 Automate 和 Python 制作。总代码量非常小。</p>
<p>做这个东西目的，是因为我现在早上有时候会在 7 点起床写东西，然后再去上班。但有时候可能会直接睡到 7 点 45 ，让闹钟把我闹醒。提前起床可能会忘记关闹钟，但是我不希望在我早上写作的时候被闹钟打扰。</p>
<p>如果我早上提前起床使用电脑，那么 Automate 可以得到信息，并关闭闹钟。如果 Automate 发现我 7 点 45 都还没有碰电脑，就会把我闹醒。整个过程，我不需要和闹钟有任何的交互。</p>
<p>这就是AutoAlarmClock这个项目存在的意义。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>AutoAlarmClock分为三个部分，安卓手机上的Automate，VPS上面的Web Server和Mac OS上面的一行命令。</p>
<p>每天早上7点40，手机上的Automate会访问一个URL A：<a href="http://autoemo.kingname.info:745/alarm_clock" target="_blank" rel="external">http://autoemo.kingname.info:745/alarm_clock</a>，只要没有得到返回信息“No”，无论是网络问题，还是因为服务器返回的是其他信息，都会设定一个闹钟，在7点45分响起来。只有访问URL以后，服务器返回“No”，那么就不设闹钟。</p>
<p>对于电脑来说，每天早上7点30分，如果电脑是开着的，说明我正在工作。这个时候电脑就会自动访问一个URL B：<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>.只有这个URL被访问过，之前给Automate访问的URL A才会返回“No”。</p>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>Web Server是手机和电脑之间的桥梁。它是使用Python的Flask框架写成的。代码已经放在了Github上：<a href="https://github.com/kingname/Automatic.git" target="_blank" rel="external">AutoAlarmClock</a>. 包括空行总共只有32行代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'please visit my blog at http://kingname.info'</span></div><div class="line"></div><div class="line"><span class="meta">@app.route("/alarm_clock")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">alarm_clock</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'alarmclock.txt'</span>):</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'alarmclock.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">            date_in_txt = f.read()</div><div class="line">            today = str(date.today())</div><div class="line">            <span class="keyword">if</span> date_in_txt == today:</div><div class="line">                <span class="keyword">return</span> <span class="string">'No'</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Yes'</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/set_alarm')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_alarm</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'alarmclock.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">        f.write(str(date.today()))</div><div class="line">    <span class="keyword">return</span> <span class="string">'OK'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">745</span>)</div></pre></td></tr></table></figure>
<p>由于这个Web Server每天只访问两次，所以没有必要使用数据库或者做线程安全的设置。数据只需要使用一个文本文件作为中转即可。一旦<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>这个链接被访问，就会在当前目录创建一个alarmclock.txt文件，里面存放的是今天的日期。当<a href="http://autoemo.kingname.info:745/alarm_clock" target="_blank" rel="external">http://autoemo.kingname.info:745/alarm_clock</a>被访问的时候，它会去检查alarmclock.txt，如果这个文件不存在，或者里面的日期不是今天的日期，那么它就会返回“Yes”。只有当alarmclock.txt存在，并且里面的内容为今天的日期，它才会返回“No”。</p>
<h3 id="电脑端"><a href="#电脑端" class="headerlink" title="电脑端"></a>电脑端</h3><p>电脑只需要访问<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>.由于Mac Book Pro只休眠，不关机，无法使用开机启动的方法来触发这个URL的访问。所以我使用了Crontab这个定时任务。因为在电脑休眠的时候，Crontab的定时任务是不会执行的，只有我在电脑上工作的时候，电脑开着才会访问这个URL，并让它生成记录今天日期的文本文件。</p>
<p>通过下面的命令设定Crontab定时任务，编辑器我选择的是VIM：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">env EDITOR=vim crontab -e</div></pre></td></tr></table></figure>
<p>定时任务设定为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 07 * * * curl -G http://autoemo.kingname.info:745/set_alarm</div></pre></td></tr></table></figure></p>
<p>表示每天的7点30分使用curl访问后面的链接。</p>
<p>Crontab在Linux下面也可以正常使用。</p>
<p>如果你的电脑为Windows，因为Windows电脑一般在晚上睡觉时会关机，所以访问URL的工作可以设定开机启动来完成。</p>
<p>首先创建一个EnableAlarmClock.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">requests.get(&apos;http://autoemo.kingname.info:745/set_alarm&apos;)</div></pre></td></tr></table></figure></p>
<p>这个文件用到了Python的requests库，如果你没有的话，请使用pip安装。</p>
<p>再创建一个EnableAlarmClock.bat文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python EnableAlarmClock.py</div></pre></td></tr></table></figure></p>
<p>打开Windows的 <strong>任务计划</strong> ，触发器选择“当前用户登录时”，操作选择“启动程序”，并填写EnableAlarmClock.bat的路径，如下图所示：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/task.png" alt=""></p>
<p>这样，每次开机登录桌面的时候，程序自动就会访问设定闹钟的页面了。</p>
<h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>Automate是安卓上面的一个强大的自动化工具，类似于IFTTT和iOS上面的Workflow。</p>
<p>在Automate中创建一个Flow，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161108-074321.png" alt=""><br>其中涉及到了”Time await”, “HTTP request”, “Expression true?”, “Alarm add”这几个组件。</p>
<ul>
<li><p>“Time await”的设置如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224111.png" alt=""></p>
</li>
<li><p>“HTTP request”的设置为下面两张图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224136.png" alt=""><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224142.png" alt=""></p>
</li>
<li><p>“Alarm add”的设置为下图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224155.png" alt=""><br>这里由于没有设置“REPEAT WEEKDAYS”这一项，所以闹钟都是一次性的，关了以后，第二天需要再根据实际情况来让Automate来决定是否需要创建。</p>
</li>
</ul>
<p>设置并启动这个Flow以后，每天早上的闹钟就可以根据你是否在电脑前面工作而决定要不要闹响了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闹钟已经成了我们生活中必不可少的东西。如果全球每个国家的当地时间明天早上，所有的闹钟突然都不响了，不知道会发生什么样的混乱。&lt;/p&gt;
&lt;p&gt;然而我们要讨论另外一种情况，闹钟每天定时响起来，真的是最好的情况吗？你有过醒来以后等闹钟的经历吗？如果你有时候在闹钟响之前就起来了，那么你会不会希望闹钟能知道你已经起来了？如果你提前醒了，那么闹钟就不响，只有你一直睡着的时候，闹钟才会按时响起来。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Automate" scheme="https://kingname.info/tags/Automate/"/>
    
      <category term="Workflow" scheme="https://kingname.info/tags/Workflow/"/>
    
  </entry>
  
  <entry>
    <title>alias导致virtualenv异常的分析和解法</title>
    <link href="https://kingname.info/2016/06/27/alias-vs-virtualenv/"/>
    <id>https://kingname.info/2016/06/27/alias-vs-virtualenv/</id>
    <published>2016-06-27T15:40:56.000Z</published>
    <updated>2016-11-30T13:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>virtualenv 可以虚拟出一个独立的Python环境，在这个环境中安装的第三方库不会对系统中的Python产生影响。作为一个系统洁癖，我的系统中的Python环境只安装最主要的第三方库，我在开发Python项目的时候一般使用virtualenv生成的独立环境来安装项目需要的第三方库。但是如果同时使用了zsh的alias 和virtualenv，有可能就会导致virtualenv下面的python不能使用第三方库。</p>
<h2 id="Python的运行方式"><a href="#Python的运行方式" class="headerlink" title="Python的运行方式"></a>Python的运行方式</h2><p>一般我们会使用以下两种方式之一来运行Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python xxx.py</div></pre></td></tr></table></figure>
<p>或者在代码的第一行加上python的路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/local/bin/python</span></div></pre></td></tr></table></figure>
<p>这两种方式，使用的是系统中的Python来解释代码。</p>
<h2 id="问题的复现"><a href="#问题的复现" class="headerlink" title="问题的复现"></a>问题的复现</h2><p>如果电脑上安装了Python2 和Python3， 那么想运行Python3写的代码的时候，我们可以使用以下方法来运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 xxx.py</div></pre></td></tr></table></figure>
<p>但是由于有人不想写数字3， 于是就使用了zsh的alias功能，在<code>~/.zshrc</code>文件中，添加了一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>在这种情况下，使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python xxx.py</div></pre></td></tr></table></figure>
<p>就可以通过Python3来解析代码了。这种方式使用系统中的Python没有问题，但是如果在virtualenv下面可就惨了。</p>
<p>我们创建一个虚拟环境并激活，安装Python的requests库，再启动python并导入requests库, 并其代码流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ virtualenv --python=python3 venv</div><div class="line">$ . venv/bin/activate</div><div class="line">$ pip install requests</div><div class="line">$ python</div><div class="line">&gt;&gt;&gt;import requests</div></pre></td></tr></table></figure>
<p>如果我们设置了上面的alias，那么你一定会得到下面的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ImportError: No module named requests</div></pre></td></tr></table></figure>
<p>于是你打开<code>venv/lib/python3.5/site-packages</code>却发现requests安安静静的躺在里面。于是你百思不得其解，明明pip 是把requests安装在虚拟环境下面的，为什么Python不能正常导入呢？于是你再执行以下代码查看环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">print(sys.path)</div></pre></td></tr></table></figure>
<p>你看到的可能是下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[&apos;&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python35.zip&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/plat-darwin&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/lib-dynload&apos;,</div><div class="line">&apos;/usr/local/lib/python3.5/site-packages&apos;]</div></pre></td></tr></table></figure>
<p>全部是系统下面Python的路径，和你的virtualenv 没有一点点的关系。</p>
<p>然后你退出Python，在虚拟环境下面打印PATH，你却发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo $PATH</div><div class="line">/Users/kingname/jikexueyuan/class_spider_basic/program/mongodb/venv/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</div></pre></td></tr></table></figure>
<p>你的virtualenv环境好好的躺在你的环境变量的最前面。于是你快要疯掉了，到底是什么鬼，怎么会发生如此灵异的事件？系统不应该是首先找环境变量第一个位置下面的Python吗？怎么会跳过虚拟环境，去打开了系统中的Python呢？应该直接打开虚拟环境下面的Python才对啊！</p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>问题的根源就在你的alias上面。</p>
<p>zsh 的alias的优先级是非常高的，它会首先替换为等号后面的内容，然后再执行。那么即使在虚拟环境下，在终端输入<code>python</code>并回车以后，实际执行的代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>你使用了绝对路径打开了系统中的Python3。</p>
<p>而由于你没有对pip 设定alias, 因此你使用pip 安装requests的时候，它调用的是虚拟环境下面的pip,所以requests会正确安装在虚拟环境下面。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决办法有两个:</p>
<ol>
<li>在<code>~/.zshrc</code>中删除下面的代码，并重启终端：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<ol>
<li>将<code>~/.zshrc</code>中的：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=python3</div></pre></td></tr></table></figure>
<p>本文首发地址： <a href="http://kingname.info/2016/06/27/alias-vs-virtualenv/">http://kingname.info/2016/06/27/alias-vs-virtualenv/</a>转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;virtualenv 可以虚拟出一个独立的Python环境，在这个环境中安装的第三方库不会对系统中的Python产生影响。作为一个系统洁癖，我的系统中的Python环境只安装最主要的第三方库，我在开发Python项目的时候一般使用virtualenv生成的独立环境来安装项目
    
    </summary>
    
      <category term="OS X" scheme="https://kingname.info/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="https://kingname.info/tags/OS-X/"/>
    
      <category term="ZSH" scheme="https://kingname.info/tags/ZSH/"/>
    
      <category term="alias" scheme="https://kingname.info/tags/alias/"/>
    
      <category term="virtualenv" scheme="https://kingname.info/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>可爱的豆子——使用Beans思想让Python代码更易维护</title>
    <link href="https://kingname.info/2016/06/19/bean-in-python/"/>
    <id>https://kingname.info/2016/06/19/bean-in-python/</id>
    <published>2016-06-19T13:43:33.000Z</published>
    <updated>2016-11-30T13:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经是一个对Java非常反感的人，因为Java的语法非常啰嗦。而用惯了动态类型的Python再使用静态类型的Java就会觉得多出了很多的工作量。</p>
<p>因为工作的关系，我开始使用Java来做项目。在这个过程中，我发现Java在某些方面确实和Python不一样。</p>
<p>有一句话说的好：</p>
<blockquote>
<p>语言决定了世界观。</p>
</blockquote>
<p>当我Java用的越来越多的时候，我渐渐发现我不是那么讨厌它了。</p>
<p>今天我要讲的，是我从Java里面学到的，一个被称为JavaBeans的东西。</p>
<blockquote>
<p>In computing based on the Java Platform, JavaBeans are classes that encapsulate many objects into a single object (the bean). They are serializable, have a zero-argument constructor, and allow access to properties using getter and setter methods. </p>
</blockquote>
<p>一句话概括起来： <strong>当一些信息需要使用类似于字典套字典套列表这种很深的结构来储存的时候，请改用类来储存。</strong></p>
<p>在Python里面，我以前会写这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">person_list = [&#123;</div><div class="line">        <span class="string">'name'</span>: <span class="string">'kingname'</span>,</div><div class="line">        <span class="string">'age'</span>: <span class="number">23</span>,</div><div class="line">        <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">        <span class="string">'detail'</span>: &#123;</div><div class="line">                    <span class="string">'address'</span>: <span class="string">'xxx'</span>,</div><div class="line">                    <span class="string">'work'</span>: <span class="string">'engineer'</span>,</div><div class="line">                    <span class="string">'salary'</span>: <span class="number">100000</span></div><div class="line">            &#125;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">        <span class="string">'name'</span>: <span class="string">'xiaoming'</span>,</div><div class="line">        <span class="string">'age'</span>: <span class="number">65</span>,</div><div class="line">        <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">        <span class="string">'detail'</span>: &#123;</div><div class="line">                    <span class="string">'address'</span>: <span class="string">'yyy'</span>,</div><div class="line">                    <span class="string">'work'</span>: <span class="string">'pm'</span>,</div><div class="line">                    <span class="string">'salary'</span>: <span class="number">0.5</span></div><div class="line">            &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>由于Python动态类型的特点，字典里面的value经常是包含了各种类型，有时候，字典里面包含了字典，里面的字典里面还有列表，这个内部字典里面的列表里面又包含了字典……</p>
<p>当我刚刚开始写Java代码的时候，也会保留了这个坏习惯，于是我定义的一个变量类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt;&gt; info = .....</div></pre></td></tr></table></figure>
<p>并且由于Java是静态类型语言，有时候Map里面的Value类型还不一致，需要使用Object来代替，等要使用的时候再做类型转换。</p>
<p>对于这样的写法，真可谓是写代码一时爽，调试代码火葬场。我过几天读自己的代码，自己都不知道这个字典里面有哪些内容，也不知道它们有哪些类型，必须到定义的地方去看。</p>
<p>我的Mentor看了我的Java代码以后，让我去用一下JavaBeans，于是我的世界瞬间就简洁多了。后来我将JavaBeans的思想用到Python中，果然Python代码也变得好看多了。</p>
<p>使用上面person_list这个复杂的结构为例，我用JavaBeans的思想，在Python里面重构它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">''</span>, age=<span class="number">0</span>, sex=<span class="string">''</span>, detail=None)</span>:</span></div><div class="line">        self._name = name</div><div class="line">        self._age = age</div><div class="line">        self._sex = sex</div><div class="line">        self._detail = detail</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line">    </div><div class="line"><span class="meta">    @name.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, new_name)</span>:</span></div><div class="line">        self._name = new_name</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._age</div><div class="line">    </div><div class="line"><span class="meta">    @age.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, new_age)</span>:</span></div><div class="line">        self._age = new_age</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sex</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._sex</div><div class="line">    </div><div class="line"><span class="meta">    @sex.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sex</span><span class="params">(self, new_sex)</span>:</span></div><div class="line">        self._sex = new_sex</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._detail</div><div class="line">    </div><div class="line"><span class="meta">    @detail.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self, new_detail)</span>:</span></div><div class="line">        self._detail = new_detail</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detail</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address=<span class="string">''</span>, work=<span class="string">''</span>, salary=<span class="number">0</span>)</span>:</span></div><div class="line">        self._address = address</div><div class="line">        self._work = work</div><div class="line">        self._salary = salary</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">address</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._address</div><div class="line">    </div><div class="line"><span class="meta">    @address.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">address</span><span class="params">(self, new_address)</span>:</span></div><div class="line">        self._address = new_address</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._work</div><div class="line">    </div><div class="line"><span class="meta">    @work.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self, new_work)</span>:</span></div><div class="line">        self._work = new_work</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._salary</div><div class="line">    </div><div class="line"><span class="meta">    @salary.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self, new_salary)</span>:</span></div><div class="line">        self._salary = new_salary</div></pre></td></tr></table></figure>
<p>从这里可以看到，我把字典变成了类。于是，当我想保存我自己的信息和小明的时候，我就可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">detail_kingname = Detail(address=<span class="string">'xxx'</span>, work=<span class="string">'engineer'</span>, salary=<span class="number">10000</span>),</div><div class="line">kingname = Person(name=<span class="string">'kingname'</span>, age=<span class="number">23</span>, sex=<span class="string">'male'</span>, detail=detail_kingname)</div><div class="line"></div><div class="line">detail_xiaoming = Detail(address=<span class="string">'yyy'</span>, work=<span class="string">'pm'</span>, salary=<span class="number">0.5</span>),</div><div class="line">xiaoming = Person(name=<span class="string">'xiaoming'</span>, age=<span class="number">65</span>, sex=<span class="string">'male'</span>, detail=detail_xiaoming)</div><div class="line"></div><div class="line">person_list = [kingname, xiaoming]</div></pre></td></tr></table></figure>
<p>这样写，虽然说代码量确实翻了不止一倍，但是当我们后期维护的时候或者遇到问题来调试代码，我们就能发现这样写的好处。</p>
<p>举一个很简单的例子，在写了代码一年以后，我已经对这段代码没有多少印象了，现在我得到了变量<code>person_list</code>, 我想查看每个人的工资。首先，由于<code>Person</code>和<code>Detail</code>这两个类是已经定义好的，分别放在<code>Person.py</code>和<code>Detail.py</code>两个文件中，于是我点开它们，就知道，原来工资是保存在<code>Detail</code>这个类中的，关键词是<code>salary</code>, 而<code>Detail</code>又是保存在<code>Person</code>中的，关键词是<code>detail</code>。</p>
<p>所以要查看每个人的工资，我可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> person <span class="keyword">in</span> person_list:</div><div class="line">    detail = person.detail</div><div class="line">    salary = detail.salary</div><div class="line">    print(salary)</div></pre></td></tr></table></figure>
<p>但是如果我使用的是最上面字典的那种方式，那么情况就没有这么简单了。因为我不知道工资是在这个字典的什么地方。于是我首先要找到<code>person_list</code>是在哪里初始化的，然后看它里面有什么。在这个例子中，我是一次性把整个列表字典初始化完成的，直接找到列表初始化的地方就知道，原来这个<code>person_list</code>下面有很多个字典，字典有一个key 叫<code>detail</code>,这个<code>detail</code>的value本身又是一个字典，它下面的key<code>salary</code>保存了工资的信息。这似乎还比较方便。但是如果字典里面的信息不是一次性初始化完成的呢？万一<code>detail</code>这一个key是后面再加的呢？于是又要去找<code>detail</code>初始化的地方……</p>
<p>第二个好处，使用Beans的时候，每个关键字是定义好的，<code>salary</code>就只能叫做<code>salary</code>，如果写成了<code>salarv</code>, 集成开发环境会立刻告诉你，<code>Detail</code>没有<code>salarv</code>这个属性。但是如果使用字典的方式，我在给字典赋值的时候，一不小心:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detail[<span class="string">'salarv'</span>] = <span class="number">0.5</span></div></pre></td></tr></table></figure>
<p>由于这里的<code>salarv</code>是字符串，所以集成开发环境是不会报错的，只有等你运行的时候,尝试读取<code>detail[&#39;salary&#39;]</code>里面的值，Python会告诉你:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;xxx.py&quot;, line 1, in &lt;module&gt;</div><div class="line">KeyError: &apos;salary&apos;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将JavaBeans的思想用在Python中，避免字典套字典这种深层嵌套的情况，对于一些需要反复使用的字典，使用类来表示。这样做，别人读代码的时候会更加的容易，自己开发的时候，也会避免出现问题。</p>
<p>本文首发于：<a href="http://kingname.info/2016/06/19/bean-in-python/">http://kingname.info/2016/06/19/bean-in-python/</a> 转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经是一个对Java非常反感的人，因为Java的语法非常啰嗦。而用惯了动态类型的Python再使用静态类型的Java就会觉得多出了很多的工作量。&lt;/p&gt;
&lt;p&gt;因为工作的关系，我开始使用Java来做项目。在这个过程中，我发现Java在某些方面确实和Python不一样。&lt;/
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Java" scheme="https://kingname.info/tags/Java/"/>
    
      <category term="经验" scheme="https://kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>MarkdownPicPicker - Markdown 图片上传助手</title>
    <link href="https://kingname.info/2016/06/04/markdownPicPicker/"/>
    <id>https://kingname.info/2016/06/04/markdownPicPicker/</id>
    <published>2016-06-04T08:40:06.000Z</published>
    <updated>2016-11-30T13:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>MarkdownPicPicker 是基于Python3 的Markdown写作辅助工具， 作者是我。它能将剪贴板中的图片上传到网络图床中，并将markdown格式的图片链接(![](&lt;图片地址&gt;))复制到剪贴板中。</p>
<p>项目地址：<a href="https://github.com/kingname/MarkdownPicPicker" target="_blank" rel="external">https://github.com/kingname/MarkdownPicPicker</a></p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>第0.2版有以下功能：</p>
<ol>
<li>使用七牛云作为图床。</li>
<li>将图片保存在本地</li>
<li>图片上传成功后将Markdown格式的图片地址保存到剪贴板中</li>
<li>全局监听键盘(默认不开启)</li>
<li>独立配置文件</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件保存在<code>config.ini</code>文件中，其意义分别如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="section">[basic]</span></div><div class="line"><span class="attr">run_method</span> = bat # 设定程序的运行方式，bat为使用bat文件触发，global_listen为全局键盘监听方式</div><div class="line"><span class="attr">picture_folder</span> = pic #设定程序的运行方式，bat为使用bat文件触发，pyHook为全局键盘监听方式</div><div class="line"><span class="attr">picture_suffix</span> = png #截图的保存格式，可以选择bmp或者png</div><div class="line"><span class="comment"># now support qiniu only</span></div><div class="line"><span class="attr">picture_bed</span> = qiniu</div><div class="line"><span class="section"></span></div><div class="line">[global_listen]</div><div class="line"><span class="attr">short_key_one</span> = Lwin #快捷键第一个按键</div><div class="line"><span class="attr">short_key_two</span> = C #快捷键第二个按键</div><div class="line"><span class="section"></span></div><div class="line">[qiniu]</div><div class="line"><span class="comment">#七牛云的相关配置</span></div><div class="line"><span class="attr">access_key</span> = Q6sS422O05AwYD5aVqM3FqCcCpF36tqvyQ75Zvzw</div><div class="line"><span class="attr">secret_key</span> = <span class="number">6</span>QtAqqTxoSxZP-<span class="number">2</span>uoXROehxPLX2CCmoOaB2aLObM</div><div class="line"><span class="attr">container_name</span> = picturebed  #七牛云的图片储存位置</div><div class="line"><span class="attr">url</span> = http://<span class="number">7</span>sbpmp.com1.z0.glb.clouddn.com/&#123;&#125; #七牛云分配的默认域名</div></pre></td></tr></table></figure></p>
<p>其中<code>access_key</code> 和 <code>secret_key</code> 可以在七牛云的控制面板中看到，如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/20160605083025.png" alt=""><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-20-22-43.png" alt=""> </p>
<p><code>container_name</code> 为下图所示内容：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-20-24-40.png" alt=""> </p>
<p><code>short_key_one</code> 和 <code>short_key_two</code> 为快捷键的两个按键，默认为左侧windows徽标键(<code>Lwin</code>) 和 字母 <code>C</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将程序配置好以后运行，创建一个批处理文件markdownpicpicker.bat, 其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">cmd /k &quot;G:\github\MarkdownPicPicker\venv\Scripts\activate &amp; cd /d G:\github\MarkdownPicPicker &amp; python MarkdownPicPicker.py &amp; deactivate &amp; exit&quot;</div></pre></td></tr></table></figure></p>
<p>路径请根据实际情况修改。</p>
<p>由于我使用了virtualenv, 所以需要在批处理中进入virtualenv的环境才能正常运行程序。对于将requirements.txt里面包含的库直接安装在全局的情况，bat 可以简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">cmd /k &quot;cd /d &lt;MarkdownPicPicker.py脚本所在文件夹路径&gt; &amp; python MarkdownPicPicker.py &amp; exit&quot;</div></pre></td></tr></table></figure>
<p>不论哪种方式，均不要在任何相关的路径上出现中文，否则会导致不可预知的问题。</p>
<p>然后右键选择批处理，发送到桌面快捷方式。接着右键快捷方式，属性，在“快捷键” 这一栏按下字母Q，它将自动填充为 <code>Ctrl + Alt + Q</code>, 确定。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-05-00-45-03.png" alt=""> </p>
<p>只需要首先使用QQ截图或者其他截图工具将图片保存到剪贴板中，然后按下设定好的快捷键即可。Markdown格式的图片链接就已经保存到剪贴板中了。在需要使用的地方直接粘贴。</p>
<p>不过这样设定的快捷键，按下以后会有大概一秒钟的延迟。推荐大家使用AutoHotKey来触发这个bat文件。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="Pillow-bug修正"><a href="#Pillow-bug修正" class="headerlink" title="Pillow bug修正"></a>Pillow bug修正</h3><p>本程序使用了Pillow库中的 <code>ImageGrab.grabclipboard()</code> 方法来获取剪贴板中的数据，但是由于这个方法有一个bug, 导致可能会爆以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unsupported BMP bitfields layout</div></pre></td></tr></table></figure></p>
<p>这个问题从Pillow 2.8.0开始，一直到3.2.0都没有被官方解决。目前有一个间接的解决办法。<br>请打开Python安装目录下的\Lib\site-packages\PIL\BmpImagePlugin.py文件，将以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if file_info[&apos;bits&apos;] in SUPPORTED:</div><div class="line">    if file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgba_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgba_mask&apos;])]</div><div class="line">        self.mode = &quot;RGBA&quot; if raw_mode in (&quot;BGRA&quot;,) else self.mode</div><div class="line">    elif file_info[&apos;bits&apos;] in (24, 16) and file_info[&apos;rgb_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgb_mask&apos;])]</div><div class="line">    else:</div><div class="line">        raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div><div class="line">else:</div><div class="line">    raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if file_info[&apos;bits&apos;] in SUPPORTED:</div><div class="line">    if file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgba_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgba_mask&apos;])]</div><div class="line">        self.mode = &quot;RGBA&quot; if raw_mode in (&quot;BGRA&quot;,) else self.mode</div><div class="line">    elif file_info[&apos;bits&apos;] in (24, 16) and file_info[&apos;rgb_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgb_mask&apos;])]</div><div class="line">    &apos;&apos;&apos;新增内容开始&apos;&apos;&apos;</div><div class="line">    elif file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgb_mask&apos;] == (0xff0000, 0xff00, 0xff):</div><div class="line">        pass</div><div class="line">    &apos;&apos;&apos;新增内容结束&apos;&apos;&apos;</div><div class="line">    else:</div><div class="line">        raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div><div class="line">else:</div><div class="line">    raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div></pre></td></tr></table></figure></p>
<p>就能解决本问题。</p>
<h3 id="全局键盘监听"><a href="#全局键盘监听" class="headerlink" title="全局键盘监听"></a>全局键盘监听</h3><p>本程序还有一个功能是全局监听键盘，通过特殊的快捷键组合就可以直接触发读取图片上传图片的操作。但是由于这个功能使用到了pyHook这个库。但是这个库在设计上存在缺陷，如果当前窗体的标题包含Unicode字符时，会导致Python崩溃。因此这个功能默认不启动。</p>
<h3 id="获取键盘按键"><a href="#获取键盘按键" class="headerlink" title="获取键盘按键"></a>获取键盘按键</h3><p>如果不清楚某个键盘按键对应的字符串是什么样子的，可以运行QueryKey.py这个文件，运行以后按下某个键，控制台上就会显示相应的信息。其中<code>Key</code>就是可以设置到<code>SHORT_KEY_ONE</code>和<code>SHORT_KEY_TWO</code>的内容。如图为按下键盘左Shift键以后显示的信息。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-23-14-30.png" alt=""> </p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>支持更多的截图方式</li>
<li>支持更多的图床</li>
<li>窗口隐藏</li>
<li>解决pyHook的问题</li>
<li>适配Linux 和 Mac OS</li>
</ul>
<p><strong>本文首发地址-&gt; <a href="http://kingname.info/2016/06/04/markdownPicPicker/">http://kingname.info/2016/06/04/markdownPicPicker/</a> 转载请注明出处</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;MarkdownPicPicker 是基于Python3 的Markdown写作辅助工具， 作者是我。它能将剪贴板中的图片上
    
    </summary>
    
      <category term="Markdown" scheme="https://kingname.info/categories/Markdown/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Markdown" scheme="https://kingname.info/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>搭建持续集成环境(一)</title>
    <link href="https://kingname.info/2016/05/29/raspberryCI-1/"/>
    <id>https://kingname.info/2016/05/29/raspberryCI-1/</id>
    <published>2016-05-29T06:04:49.000Z</published>
    <updated>2016-11-30T13:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开题说明"><a href="#开题说明" class="headerlink" title="开题说明"></a>开题说明</h2><p>软件开发的过程是一个从简单到复杂的过程。我们在开发的时候，会首先写出具有核心的功能的原型，满足基本的需求。但是这个原型使用非常的麻烦，有无数的配置，数据的格式也需要严格的规定，稍微一个不合法的输入输出就有可能导致程序的崩溃。</p>
<p>接下来，在这个基本的原型上，我们逐渐进行完善，逐渐提高了程序的鲁棒性，用户体验逐渐的提高。新的需求出现了，于是又添加新的功能来满足新的需求。</p>
<p>在这样一个逐渐搭建（迭代）起来的过程中，我们要进行不间断的测试来保证修改没有破坏代码的已有功能，也要防止引入新的bug.如果是团队开发，要保持代码风格的一致。如果多个人同时开发，又要防止代码修改的地方出现冲突。一个版本的代码开发完成了，测试也没有问题了，同时部署到几百台服务器上，完成新功能的上线。</p>
<p>这样一个流程，如果手动来完成是相当痛苦的。于是，就需要持续集成来帮助我们完成这些琐碎的工作。开发者开发好了程序，本地测试没有问题了。使用Git提交到代码仓库，然后触发一系列的检查流程，如果出问题就给提交者发邮件提示问题，如果一切正常就开始代码审核(code review)，审核完成，合并代码。合并完成以后，会自动做好部署前面的集成测试，然后等待下一次部署周期到达以后自动将代码部署到各个服务器。</p>
<p>持续集成这个系列的文章，就是要完成以上各个环节的搭建工作，从而让开发者把精力放在开发上，而不是一些无谓的体力劳动上。</p>
<p>我会使用树莓派2 来搭建持续集成的环境，树莓派的系统为ArchLinux.</p>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Jenkins是一个用Java编写的开源的持续集成工具。它是持续集成的核心部分，扮演了一个总管的角色，统筹联系各个部分。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -S jenkins</div></pre></td></tr></table></figure>
<p>由于jenkins是Java写的，所以这个时候如果你的系统中没有Java的运行环境，他就会让你选择安装jre7-openjdk 或者是jre8-openjdk, 我选择的是安装jre8-openjdk. 这个时候我没有意识到，隐患已经埋下来了。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在ArchLinux中，什么东西都喜欢使用systemd来启动，所以执行以下命令来启动Jenkins：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start jenkins.service</div></pre></td></tr></table></figure></p>
<p>理论上这样就能使用了。但是当我在浏览器打开<code>http://192.168.2.107:8090</code>的时候却发现网页无法打开。于是检查它的log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">journalctl -u jenkins</div></pre></td></tr></table></figure></p>
<p>发现原来报错了。如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/openjdkerror.png" alt=""></p>
<p>难道说Java环境有问题？于是我是用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>来检查Java环境，果然, 连查看Java 的版本都报错了，如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/javaversion.png" alt=""></p>
<h3 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h3><p>对于这种情况，看起来不能使用openJDK了，于是去安装Oracle的JDK。</p>
<p>首先要卸载openJdk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -Rdd jre8-openjdk</div></pre></td></tr></table></figure>
<p>这里使用<code>-Rdd</code> 而不是<code>-R</code>就是为了忽略依赖性。如果直接使用<code>-R</code>的话，会报错，无法卸载。</p>
<p>如何判断卸载是否完成呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<p>提示找不到Java的时候，就说明卸载完成了。如果此时依然会爆出上面的core dumpd的错误, 就说明openJDK没有卸载干净。输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -Rdd jre</div></pre></td></tr></table></figure></p>
<p>然后按键盘上面的Tab键，让自动完成功能来探测到底是哪个部分还没有卸载。</p>
<p>完全卸载干净openJDK以后，就可以安装Oracle的JDK了。</p>
<p>由于Oracle的JDK不能直接使用pacman来安装，所以需要使用AUR。树莓派的CPU是ARM架构，所以使用使用<a href="https://aur.archlinux.org/packages/jdk-arm/" target="_blank" rel="external">arm版的JDK</a>。如果有朋友是在X86的电脑上面安装的话，可以使用<a href="https://aur.archlinux.org/packages/jdk" target="_blank" rel="external">x86版的JDK</a>。</p>
<p>对于安装AUR的文件，首先从左侧<a href="https://aur.archlinux.org/cgit/aur.git/snapshot/jdk-arm.tar.gz" target="_blank" rel="external">Download snapshot</a>下载pkg文件，然后使用以下命令来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xvf jdk-arm.tar.gz</div><div class="line">cd jdk-arm</div><div class="line">makepkg -sri</div></pre></td></tr></table></figure>
<p>然后就等待下载安装文件然后完成安装。如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/aurinstall.png" alt=""></p>
<p>完成以后，我们再执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>就可以正常看到Java的版本信息了。</p>
<h3 id="再启动"><a href="#再启动" class="headerlink" title="再启动"></a>再启动</h3><p>再一次启动Jenkins:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start jenkins.service</div></pre></td></tr></table></figure></p>
<p>也可以正常启动了。（输入命令以后等待1分钟左右，让服务完全启动起来。）如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/jenkins.png" alt=""></p>
<p>根据它的提示读取密码，并填写到网页上，于是Jenkins就算是安装成功了。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>插件是Jenkins的精华，在第一次进入的时候，Jenkins就会让你选择插件。这里我选择<br><code>Select plugins to install</code>.<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/plugin.png" alt=""></p>
<p>它默认已经勾选了一些插件，我增加了以下的插件：</p>
<ul>
<li>Source Code Management 下面的Github plugin</li>
<li>Notifications and Publishing下面的 SSH plugin</li>
<li>Pipelines and Continuous Delivery 下面的 Parameterized Trigger plugin</li>
</ul>
<p>选择好以后点击 install就可以等待它安装了。如果发现漏选了或者多选了也没有关系，因为之后还可以手动管理这些插件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇讲到了如何在树莓派上面搭建Jenkins并安装插件。下一篇将会讲到Jenkins Job的创建和配置和使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开题说明&quot;&gt;&lt;a href=&quot;#开题说明&quot; class=&quot;headerlink&quot; title=&quot;开题说明&quot;&gt;&lt;/a&gt;开题说明&lt;/h2&gt;&lt;p&gt;软件开发的过程是一个从简单到复杂的过程。我们在开发的时候，会首先写出具有核心的功能的原型，满足基本的需求。但是这个原型使用非
    
    </summary>
    
      <category term="持续集成" scheme="https://kingname.info/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Jenkins" scheme="https://kingname.info/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="https://kingname.info/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>使用Python保存截图</title>
    <link href="https://kingname.info/2016/05/19/screenshot/"/>
    <id>https://kingname.info/2016/05/19/screenshot/</id>
    <published>2016-05-19T14:47:29.000Z</published>
    <updated>2016-11-30T13:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在<a href="http://jikexueyuan.com" target="_blank" rel="external">极客学院</a>讲授《使用Python编写远程控制程序》的课程中，涉及到查看被控制电脑屏幕截图的功能。</p>
<p>如果使用PIL，这个需求只需要三行代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</div><div class="line">pic = ImageGrab.grab()</div><div class="line">pic.save(<span class="string">'1.jpg'</span>)</div></pre></td></tr></table></figure></p>
<p>但是考虑到被控端应该尽量的精简，对其他模块尽量少的依赖，这样才能比较方便的部署，因此我考虑能否有一种方法，不依赖PIL来实现截图的功能。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于被控端使用了win32api, 因此有一个方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32api.keybd_event</div></pre></td></tr></table></figure></p>
<p>这个方法可以模拟键盘的按键动作。因此，解决方法就比较的明显了：</p>
<ol>
<li>模拟键盘上面的“Print Screen” 键按下</li>
<li>从剪贴板中读取出截图</li>
<li>将截图保存到本地 </li>
</ol>
<p>第一步非常的简单，实用win32api 和 win32con，两行代码就能实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import win32api</div><div class="line">import win32con</div><div class="line">win32api.keybd_event(win32con.VK_SNAPSHOT, 0)</div></pre></td></tr></table></figure></p>
<p>其中win32con这个库里面包含了很多定义好的和Windows相关的常量，而VK_SNAPSHOT就是Print Screen键的键位码。后面的数字0表示截取整个屏幕。如果改成数字1，表示截取当前窗口。</p>
<p>那么现在问题来了，在不实用PIL的情况下，如何将剪贴板你们的图片保存到本地？</p>
<p>win32api有一个模块 win32clipboard 是负责剪贴板相关的操作。它有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32clipboard.GetClipboardData(formats)</div></pre></td></tr></table></figure></p>
<p>这个方法可以从剪贴板里面读取数据。但是需要指定数据的格式。从<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff729168\(v=vs.85\" target="_blank" rel="external">这里</a>.aspx)可以查看到更多的标准剪贴板格式(<em>Standard Clipboard Formats</em>).</p>
<p>一开始我使用的formats是<strong>CF_BITMAP</strong>，程序返回的是一串整数，怀疑应该是一个内存地址。这也和这个format的描述：</p>
<blockquote>
<p>A handle to a bitmap (<strong>HBITMAP</strong>).</p>
</blockquote>
<p>是一致的，它是一个handle。</p>
<p>我也尝试过CF_TIFF, 不过程序直接报错了，可见我使用Print Screen截图以后，剪贴板里面的图片格式并不是TIFF。</p>
<p>经过查阅其他资料，我最后确定使用了CF_DIB。</p>
<blockquote>
<p>A memory object containing a BITMAPINFO structure followed by the bitmap bits.</p>
</blockquote>
<p>这个描述说明，CF_DIB返回的是一个内存对象，包含了BIT格式图片的信息。经过测试使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32clipboard.GetClipboardData(win32con.CF_DIB)</div></pre></td></tr></table></figure></p>
<p>以后，可以得到一个很大的字符串。显然这个字符串就是图片的内容了。但是当我把这个字符串写入到bmp格式的文件后，却发现图片无法打开。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在StackOverflow上，我遇到了一个非常好的老先生： <a href="http://stackoverflow.com/users/355230/martineau" target="_blank" rel="external">Mr. martineau</a>他为了解答了问题，并给我提供了解决办法。以下内容翻译自martineau先生的回答，原文请戳-&gt;<a href="http://stackoverflow.com/a/35885108/3922976" target="_blank" rel="external">http://stackoverflow.com/a/35885108/3922976</a></p>
<blockquote>
<p>你的方法的主要问题在于，你写入文件的字符串缺少了.bmp 文件头，这个文件头是<code>BITMAPFILEHEADER</code>结构。</p>
<p>为了创建这个文件头，使用<code>GetClipboardData()</code>返回的字符串必须要进行解码(<em>decoded</em>)。对于<code>CF_DIB</code>格式来说，返回的字符串的前面一部分就是<code>BOTMAPINFOHEADER</code>。</p>
<p>对于各种各样有不同种类压缩的<code>DIB</code>来说，这种文件头结构是非常的普遍的。不过幸好对截图来说，只需要简单的无压缩的RGBA像素。</p>
<p>由于<code>BOTMAPFILEHEADER</code>被放在了bf0ffBits的区域里，所以事情就变得很容易了。而其他的情况，例如大尺度的颜色表跟在<code>BITMAPINFOHEADER</code> 和像素数组的开头。</p>
<p>（这一段我看不太懂，还请如果有能正确解释这段话的朋友指正。原文是：</p>
<blockquote>
<p>That fact makes things much easier because otherwise determining the value to put in the bfOffBits field of the BITMAPFILEHEADER would be complicated by the fact that in most other cases there’s also a variably-sized color table following the BITMAPINFOHEADER and the start of the pixel array.）</p>
</blockquote>
<p>下面的代码是一个简单的例子（仅仅针对这个需求）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">import ctypes</div><div class="line">from ctypes.wintypes import *</div><div class="line">import win32clipboard</div><div class="line">from win32con import *</div><div class="line">import sys</div><div class="line"></div><div class="line">class BITMAPFILEHEADER(ctypes.Structure):</div><div class="line">    _pack_ = 1  # structure field byte alignment</div><div class="line">    _fields_ = [</div><div class="line">        (&apos;bfType&apos;, WORD),  # file type (&quot;BM&quot;)</div><div class="line">        (&apos;bfSize&apos;, DWORD),  # file size in bytes</div><div class="line">        (&apos;bfReserved1&apos;, WORD),  # must be zero</div><div class="line">        (&apos;bfReserved2&apos;, WORD),  # must be zero</div><div class="line">        (&apos;bfOffBits&apos;, DWORD),  # byte offset to the pixel array</div><div class="line">    ]</div><div class="line">SIZEOF_BITMAPFILEHEADER = ctypes.sizeof(BITMAPFILEHEADER)</div><div class="line"></div><div class="line">class BITMAPINFOHEADER(ctypes.Structure):</div><div class="line">    _pack_ = 1  # structure field byte alignment</div><div class="line">    _fields_ = [</div><div class="line">        (&apos;biSize&apos;, DWORD),</div><div class="line">        (&apos;biWidth&apos;, LONG),</div><div class="line">        (&apos;biHeight&apos;, LONG),</div><div class="line">        (&apos;biPLanes&apos;, WORD),</div><div class="line">        (&apos;biBitCount&apos;, WORD),</div><div class="line">        (&apos;biCompression&apos;, DWORD),</div><div class="line">        (&apos;biSizeImage&apos;, DWORD),</div><div class="line">        (&apos;biXPelsPerMeter&apos;, LONG),</div><div class="line">        (&apos;biYPelsPerMeter&apos;, LONG),</div><div class="line">        (&apos;biClrUsed&apos;, DWORD),</div><div class="line">        (&apos;biClrImportant&apos;, DWORD)</div><div class="line">    ]</div><div class="line">SIZEOF_BITMAPINFOHEADER = ctypes.sizeof(BITMAPINFOHEADER)</div><div class="line"></div><div class="line">win32clipboard.OpenClipboard()</div><div class="line">try:</div><div class="line">    if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_DIB):</div><div class="line">        data = win32clipboard.GetClipboardData(win32clipboard.CF_DIB)</div><div class="line">    else:</div><div class="line">        print(&apos;clipboard does not contain an image in DIB format&apos;)</div><div class="line">        sys.exit(1)</div><div class="line">finally:</div><div class="line">    win32clipboard.CloseClipboard()</div><div class="line"></div><div class="line">bmih = BITMAPINFOHEADER()</div><div class="line">ctypes.memmove(ctypes.pointer(bmih), data, SIZEOF_BITMAPINFOHEADER)</div><div class="line"></div><div class="line">if bmih.biCompression != BI_BITFIELDS:  # RGBA?</div><div class="line">    print(&apos;insupported compression type &#123;&#125;&apos;.format(bmih.biCompression))</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line">bmfh = BITMAPFILEHEADER()</div><div class="line">ctypes.memset(ctypes.pointer(bmfh), 0, SIZEOF_BITMAPFILEHEADER)  # zero structure</div><div class="line">bmfh.bfType = ord(&apos;B&apos;) | (ord(&apos;M&apos;) &lt;&lt; 8)</div><div class="line">bmfh.bfSize = SIZEOF_BITMAPFILEHEADER + len(data)  # file size</div><div class="line">SIZEOF_COLORTABLE = 0</div><div class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</div><div class="line"></div><div class="line">bmp_filename = &apos;clipboard.bmp&apos;</div><div class="line">with open(bmp_filename, &apos;wb&apos;) as bmp_file:</div><div class="line">    bmp_file.write(bmfh)</div><div class="line">    bmp_file.write(data)</div><div class="line"></div><div class="line">print(&apos;file &quot;&#123;&#125;&quot; created from clipboard image&apos;.format(bmp_filename))</div></pre></td></tr></table></figure></p>
</blockquote>
<p>经过测试，这一段代码成功的实现了读取剪贴板的图片并保存到本地。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这段代码使用ctypes库来实现指针的功能，从而在内存中操作数据。这里定义了两个结构体，<code>BITMAPFILEHEADER</code> 和<code>BITMAPINFOHEADER</code>，于是，使用sizeof获取到了他们的大小。那么使用指针，从使用<code>GetClipboardData()</code>获取到的数据的头部开始移动，分别移动这两个结构体的大小，也就获取到了这两个结构体在内存中的数据。</p>
<p>代码中使用了<code>memmove</code>和<code>memset</code>两个内存操作的方法。从ctypes的官方文档上，我们可以看到这两个方法有如下的定义：</p>
<blockquote>
<p><code>ctypes.memmove(dst, src, count)</code></p>
<p>Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers.</p>
<p><code>ctypes.memset(dst, c, count)</code></p>
<p>Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address, or a ctypes instance.</p>
</blockquote>
<p>所以可以看出，代码里面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bmih = BITMAPINFOHEADER()</div><div class="line">ctypes.memmove(ctypes.pointer(bmih), data, SIZEOF_BITMAPINFOHEADER)</div></pre></td></tr></table></figure></p>
<p>从内存中拷贝出来了<code>BITMAPINFOHEADER</code>这么大的一块的数据，并保存到了<code>bmih</code>这个变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bmfh = BITMAPFILEHEADER()</div><div class="line">ctypes.memset(ctypes.pointer(bmfh), 0,     SIZEOF_BITMAPFILEHEADER)</div></pre></td></tr></table></figure></p>
<p>这一段在内存中开辟出了<code>BITMAPFILEHEADER</code>这么大一块区域，并全部填充为0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bmfh.bfType = ord(&apos;B&apos;) | (ord(&apos;M&apos;) &lt;&lt; 8)</div></pre></td></tr></table></figure></p>
<p>这一行代码使用了位操作。首先<code>ord(&#39;B&#39;)</code>的值为66，换成二进制就是<code>1000010</code>；<code>ord(&#39;M&#39;)</code>的值为77，换成二进制就是<code>1001101</code>，然后向左移动8位，得到<code>100110100000000</code>，这个值再与<code>1000010</code>取位或，得到<code>100110101000010</code>。</p>
<p>最后，使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</div></pre></td></tr></table></figure></p>
<p>拼装出头部的大小。然后以二进制方式，首先写文件头, 再写剪贴板获取到的字符串到本地的<code>.bmp</code>文件中，完成图片的生成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python一些轮子确实非常好的提高了开发效率，例如PIL，三行代码实现了我的需求。Python在快速开发方面确实非常的方便，但是涉及到底层的一些操作的时候，还是不得不使用C语言的一些接口来进行内存的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://jikexueyuan.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极客学院&lt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Win32Api" scheme="https://kingname.info/tags/Win32Api/"/>
    
  </entry>
  
  <entry>
    <title>对Java与设计模式态度的转变</title>
    <link href="https://kingname.info/2015/12/02/opinionchange/"/>
    <id>https://kingname.info/2015/12/02/opinionchange/</id>
    <published>2015-12-01T16:03:08.000Z</published>
    <updated>2016-11-30T13:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直自诩自己是Java一生黑。也从来不屑于设计模式这种东西，因为我一直认为，设计模式是为了解决Java的一些缺陷才存在的。对于Python来说，设计模式并不重要。不过最近在做一个新功能开发的时候对Java的态度有了一些改变。<more></more></p>
<p>事情的起因是在一个大概有十万行代码的框架中重构他的写Log方式。这个框架原来的Log模块是原作者自己写的，通过打开关闭文件来写Log。现在需要更换成Python的logging模块。对于一个设计相当糟糕的系统来说，要重构是很麻烦的事情。</p>
<p>在原来的Log方式中，文件的句柄通过参数的形式到处传，常常十多个文件句柄同时打开，还会互相影响，相当的混乱。最后由于需要一个地方来将所有模块的Log统一起来，还给系统的入口再加了一个入口，新的入口使用subprocess来执行</p>
<pre><code>`python xxxx`
</code></pre><p>调用原来的系统模块，并将控制台的输出重定向到文件。</p>
<p>重构的过程相当的痛苦，花了我几乎整个Sprint的时间，细节我会在后续的文章中讲到。今天我要讲的是单例模式让我对设计模式看法的一些改变。</p>
<p>对Python来说，是可以将一个类的实例通过参数的形式直接传递的，所以看起来似乎Python并不需要单例模式。对于新写的代码来说，这当然没有什么问题。但是对已有的代码添加新的功能的时候，这个方法就不太适用了。</p>
<p>如果原来一个方法，它的参数已经有七八个了，这个时候你在加一个参数上去，并不确定会产生什么样的影响。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def foo(a, b, c):</div><div class="line">		do()</div><div class="line">		some()</div><div class="line">		thing()</div></pre></td></tr></table></figure>
<p>如果想加一个新的参数，但是又不影响其他的已经在调用这个方法的地方，当然可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> def foo(a, b, c, d=None):</div><div class="line">do()</div><div class="line">some()</div><div class="line">thing()</div></pre></td></tr></table></figure>
<p>如果代码量不大，当然没有问题，但是如果代码量大起来了，这样就会出问题。</p>
<p>例如，现在有一个实例instanceA 在module1 中初始化了，而module3如果想使用instanceA，就必须想办法让instanceA 传递到module3去。但是原本module3和module1并没有什么关系，现在因为需要这个instanceA, 怎么办呢？这个时候发现instanceA 被传递到了module2, 然后又从module2传递到了module4, 最后在module4里面终于找到了一个地方，可以强行把instanceA和module3联系在一起。这样一来，这几个module他们被强制耦合在了一起。</p>
<p>对于程序来说，耦合程度应该越低越好，所以这样的做法，非常不妥。</p>
<p>于是，这个时候单例模式就出现了。</p>
<p>对于module3来说，如果他想要instanceA, 他完全可以再重新new一个，由于是单例模式，于是新的instance 和instanceA是完全一样的。这样就并没有增加多余的耦合关系。</p>
<p>另外，在极客学院录课的时候，最近有涉及到程序集之间通信。这个时候偶然发现设计模式里面的观察者模式可以对我的设计起到相当大的帮助。</p>
<p>就像以前某人说的，你要讨厌一个东西，你必须要比喜欢这个东西的人更了解它。而我以前讨厌Java仅仅是因为Java看起来太罗嗦，太多冗余代码。而我不屑于设计模式，更是因为它是从Java来的。</p>
<p>现在看起来，态度真的应该改变一下了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直自诩自己是Java一生黑。也从来不屑于设计模式这种东西，因为我一直认为，设计模式是为了解决Java的一些缺陷才存在的。对于Python来说，设计模式并不重要。不过最近在做一个新功能开发的时候对Java的态度有了一些改变。&lt;more&gt;&lt;/more&gt;&lt;/p&gt;
&lt;p&gt;事情的
    
    </summary>
    
      <category term="态度" scheme="https://kingname.info/categories/%E6%80%81%E5%BA%A6/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Java" scheme="https://kingname.info/tags/Java/"/>
    
      <category term="设计模式" scheme="https://kingname.info/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
