<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2021-02-18T14:42:43.371Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小问题大隐患：如何正确设置 Python 项目的入口文件？</title>
    <link href="https://www.kingname.info/2021/02/18/entry-file/"/>
    <id>https://www.kingname.info/2021/02/18/entry-file/</id>
    <published>2021-02-18T14:41:10.000Z</published>
    <updated>2021-02-18T14:42:43.371Z</updated>
    
    <content type="html"><![CDATA[<p>今天在公众号粉丝群里面，有一位同学提到了 Python 找不到模块的问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-20-42-01.png" alt></p><p>问题涉及到的代码结构和代码截图如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG" alt></p><p>这个问题的解决方法非常简单，就是把<code>start.py</code>文件从<code>bin</code>文件夹移出来就好了。</p><p>但如果对这个问题进一步分析，可以看到更多问题。</p><a id="more"></a><p>在我以前的文章：<a href="https://mp.weixin.qq.com/s/lTisktaIiC0QZMWzEgFWzw" target="_blank" rel="noopener">为什么Python代码能运行但是PyCharm给我画红线？</a>中，我讲到了工作区（Workdir）对代码的影响。PyCharm、VSCode 识别的工作区，可能并不等于你直接在终端窗口运行<code>.py</code>文件时候的工作区。</p><p>今天这个问题本质上也是工作区导致的问题。 这个同学的项目根目录是<code>MY_API</code>，所以他使用的编辑器VSCode 就会默认把<code>MY_API</code>当做工作区。所以，当他在<code>start.py</code>文件中写上<code>from lib.interface import server</code>时，VScode 并不会给他标记红色波浪线。因为从 VSCode 的视角看，<code>lib</code>文件夹确实就是在工作区下面的。</p><p>但是，当他在 VSCode 里面运行这个<code>start.py</code>文件时，Python 是从<code>bin</code>文件夹下面运行的。此时，Python 会把<code>bin</code>文件夹当做工作区。在工作区里面就只有这一个<code>start.py</code>文件，所以当然找不到<code>lib</code>文件夹。</p><p>如果仅仅从技术上来说，你非要导入 <code>bin</code> 文件夹的父文件夹下面的其他模块，也并不困难，我在<a href="https://mp.weixin.qq.com/s/cNKr1uhDy47pOVjFznoBwA" target="_blank" rel="noopener">一日一技：导入父文件夹中的模块并读取当前文件夹内的资源</a>一文中讲到了具体的做法。</p><p>但问题在于，你不应该这样做。<strong>你不应该把项目的入口文件，放到项目内部很深的文件夹中。</strong></p><p>所谓入口文件，就是要首先经过它，才能到达其他的文件。当你拿到一个 Python 项目，你只需要首先从入口文件开始阅读代码，根据入口文件调用的模块，一路看下去，你就能读到它的所有实现逻辑。</p><p>但如果大家经常逛 Github，就会发现，有些人可能是被其他垃圾语言污染了思想，他的 Python 项目，根目录有五六个文件夹和七八个<code>.py</code>文件。你拿到这个项目的时候，你甚至不知道，当你想运行这个代码的时候，<code>python3 xxx.py</code>应该运行哪个文件。你多方打听，或者看了半天文档，才知道，哦，原来入口文件在<code>com/xx/yy/zz/script/run.py</code>。</p><p>当你打开这个<code>run.py</code>文件，你发现它的顶部，文件导入的代码写的是<code>from ../../../../aaa import bbb</code>。</p><p>简直是神经病写法。我知道有些垃圾语言流行这样写。但现在你用的是 Python，学聪明一点，别那样写。</p><p>对于一个 Python 项目来说，入口文件应该始终在最外层。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-21-12-59.png" alt></p><p>当你要启动这个项目的时候，直接在最外层<code>python3 main.py</code>，就能把它启动起来。在<code>main.py</code>里面，你可以导入其他模块，然后调用其他模块里面的类或者函数。</p><p>这样做的好处是什么？这样做，你是在项目的根目录启动的这个项目，所以你的工作区就是项目的根目录。那么你在任何一个<code>.py</code>文件里面都可以很容易地基于工作区导入任意其他文件。例如，你现在在<code>models/mongo-util/mongob_helper.py</code>文件中，你想导入<code>utils/abc.py</code>中的<code>time_format()</code>函数，那么，你只需要这样写就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.abc <span class="keyword">import</span> time_format</span><br></pre></td></tr></table></figure><p>你根本不可能出现需要导入父文件夹中的某个模块的情况。</p><p>只有工具脚本，才需要单独使用一个文件夹来存放，然后调用父文件夹中的其他文件。例如，我现在有一个工具脚本，它每天晚上0点会读写 MongoDB，清理无效数据，那么此时，我可以在根目录单独创建一个<code>script</code>或<code>tools</code>或者<code>bin</code>文件夹，然后把工具脚本放进去，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-21-22-43.png" alt></p><p>在这个工具脚本里面，你可能会调用<code>models/mongo-util/mongob_helper.py</code>文件中的某个函数。这种情况下，你调用父文件夹中的内容是可以接受的。但这毕竟只是工具脚本。</p><p>可能还有同学要问，那如果我的项目是一个 Python 的包，它本身没有入口文件怎么办呢？这个时候，你可以把这个包的<code>__init__.py</code>当做它的入口文件。大家可以参考我在 <a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="noopener">GitHub - kingname/GeneralNewsExtractor: 新闻网页正文通用抽取器 Beta 版.</a>的代码组织结构。在项目根目录留下一个<code>example.py</code>文件，用来演示如何调用这个包。而这个包本身的代码，是在一个叫做<code>gne</code>的文件夹中的。这个<code>gne</code>文件夹是一个包，它的入口文件在<code>__init__.py</code>中。</p><p>各位，当你写代码的时候，你先想一想，如果别人拿到了你的代码，想要梳理一下这个项目的逻辑，在不询问你的情况下，怎么让他知道应该从哪个文件开始读？应该按什么顺序读？他能不能轻易地看到数据在你的代码中是怎么运转的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在公众号粉丝群里面，有一位同学提到了 Python 找不到模块的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-20-42-01.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;问题涉及到的代码结构和代码截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个问题的解决方法非常简单，就是把&lt;code&gt;start.py&lt;/code&gt;文件从&lt;code&gt;bin&lt;/code&gt;文件夹移出来就好了。&lt;/p&gt;
&lt;p&gt;但如果对这个问题进一步分析，可以看到更多问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 服务器中创建假桌面运行模拟浏览器有头模式</title>
    <link href="https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/"/>
    <id>https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/</id>
    <published>2021-02-16T06:27:49.000Z</published>
    <updated>2021-02-18T14:42:46.422Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用 Selenium 或者 Puppeteer 的同学都知道，他们启动的 Chrome 浏览器分为有头模式和无头模式。在自己电脑上操作时，如果是有头模式，会弹出一个 Chrome 浏览器窗口，然后你能看到这个浏览器里面在自动操作。而无头模式则不会弹出任何窗口，只有进程。</p><p><a href="https://mp.weixin.qq.com/s/yS8juVNb2kyb15H9wwm8sg" target="_blank" rel="noopener">别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征</a>这篇文章中，我们介绍了一个探测模拟浏览器特征的网站。通过他我们可以发现，在不做任何设置的情况下，Selenium 或者 Puppeteer 启动的浏览器有几十个特征能够被目标网站识别为爬虫。并且，无头模式的特征比有头模式的特征多得多。</p><a id="more"></a><p>也就是说，即使你不使用任何隐藏特征的技术，仅仅使用有头模式，你都会安全很多。如果网站不是非常严格的反爬虫，很多情况下，使用无头模式更容易被发现，但使用有头模式，更难被发现。</p><p>下图为<strong>有头模式</strong>，不使用任何隐藏特征的技术访问检测网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-11-26-20-09-46.png" alt></p><p>下图为<strong>无头模式</strong>，不使用任何隐藏特征的技术访问检测网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/headless_screenshot.png" alt="万里河山一片红"></p><p>所以，一般情况下，你应该多使用有头模式。</p><p>但问题在于，当我们要在 Linux 服务器上面使用 Selenium 或者 Puppeteer 运行爬虫的时候，就会发现有头模式始终会报错。这是因为，有头模式需要系统提供图形界面支持，才能绘制浏览器窗口，但是 Linux 服务器一般来说是没有图形界面的，所以有头模式一定会失败。</p><p>在这种情况下，为了能够使用模拟浏览器的有头模式，我们需要搞一个假的图形界面出来，从而欺骗浏览器，让它的有头模式能够正常使用。</p><p>为了达到这个目的，我们可以使用一个叫做 <code>Xvfb</code>的东西。这个东西在<a href="https://en.wikipedia.org/wiki/Xvfb" target="_blank" rel="noopener">维基百科上面的介绍</a>如下：</p><blockquote><p>Xvfb or X virtual framebuffer is a display server implementing the X11 display server protocol. In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output.</p></blockquote><p>Xvfb 在一个没有图像设备的机器上实现了 X11显示服务的协议。它实现了其他图形界面都有的各种接口，但并没有真正的图形界面。所以当一个程序在 Xvfb 中调用图形界面相关的操作时，这些操作都会在虚拟内存里面运行，只不过你什么都看不到而已。</p><p>使用 Xvfb，我们就可以欺骗 Selenium 或者 Puppeteer，让它以为自己运行在一个有图形界面的系统里面，这样一来就能够正常使用有头模式了。</p><p>要安装 Xvfb 非常简单，在 Ubuntu 中，只需要执行下面两行命令就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><p>现在，我们来写一段非常简单的 Selenium 操作 Chrome 的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'https://bot.sannysoft.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.save_screenshot(<span class="string">'screenshot.png'</span>)</span><br><span class="line">driver.close()</span><br><span class="line">print(<span class="string">'运行完成'</span>)</span><br></pre></td></tr></table></figure><p>如果直接在服务器上运行，效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-11-46-39.png" alt></p><p>因为没有图形界面，所以程序必定报错。</p><p>现在，我们只需要在运行这段代码的命令前面加上<code>xvfb-run</code>，再来看看运行效果：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-11-50-40.png" alt></p><p>代码成功运行，没有报错。现在我们从服务器上把这个生成的<code>screenshot.png</code>文件拉下来，打开以后可以看到内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/xvfb-screenshot.png" alt></p><p>可以看到，虽然窗口比较小，但确实是有头模式下面的检测结果。当然，我们也可以调整一下窗口大小，增加参数：<code>xvfb-run python3 test.py -s -screen 0 1920x1080x16</code>就能假装在一个分辨率为1920x1280的显示器上运行程序了。然后修改 Selenium 的代码，设置浏览器窗口的大小：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-12-02-45.png" alt></p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/xvfb-screenshot-2.png" alt></p><p>本文演示使用的是 Python操作 Selenium，你也可以试一试使用 Puppeteer，只需要把启动命令改为<code>xvfb-run node index.js</code>就可以了。</p><p>有了本文以后，再结合我之前的两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/Bge-_yiatSq4CQq7fRvjdQ" target="_blank" rel="noopener">最完美方案！模拟浏览器如何正确隐藏特征</a></li><li><a href="https://mp.weixin.qq.com/s/XOXb_XvsHqgv0MUICahjJw" target="_blank" rel="noopener">Chome 88如何正确隐藏 webdriver？</a></li></ul><p>相信你的模拟浏览器能够绕过更多的网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用 Selenium 或者 Puppeteer 的同学都知道，他们启动的 Chrome 浏览器分为有头模式和无头模式。在自己电脑上操作时，如果是有头模式，会弹出一个 Chrome 浏览器窗口，然后你能看到这个浏览器里面在自动操作。而无头模式则不会弹出任何窗口，只有进程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yS8juVNb2kyb15H9wwm8sg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征&lt;/a&gt;这篇文章中，我们介绍了一个探测模拟浏览器特征的网站。通过他我们可以发现，在不做任何设置的情况下，Selenium 或者 Puppeteer 启动的浏览器有几十个特征能够被目标网站识别为爬虫。并且，无头模式的特征比有头模式的特征多得多。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="Xvfb" scheme="https://www.kingname.info/tags/Xvfb/"/>
    
  </entry>
  
  <entry>
    <title>奇技淫巧：在 ssh 里面把服务器的文本复制到本地电脑</title>
    <link href="https://www.kingname.info/2020/10/02/copy-from-ssh/"/>
    <id>https://www.kingname.info/2020/10/02/copy-from-ssh/</id>
    <published>2020-10-02T03:18:58.000Z</published>
    <updated>2020-10-02T03:27:41.293Z</updated>
    
    <content type="html"><![CDATA[<p>使用 macOS 的同学，应该熟悉一个命令<code>pbcopy</code>，它可以在命令行中把一段内容写入到剪贴板，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"kingname"</span> | pbcopy</span><br></pre></td></tr></table></figure><p>就能把字符串<code>kingname</code>复制到剪贴板里面。我们也可以使用这个方法把一个文件中的内容写入到剪贴板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat xxx.txt | pbcopy</span><br></pre></td></tr></table></figure><p>这样我们就不需要把文件打开再手动复制的。</p><p>有时候，我要把服务器上面的日志复制下来。原来都是进入服务器以后，用 vim 打开日志文件，用鼠标选中再复制。且不说服务器是 Linux，没有<code>pbcopy</code>这个命令，即使有这个命令，服务器上又怎么能访问本地的剪贴板呢？</p><a id="more"></a><p>在网上一搜，竟然还真有办法。<a href="https://www.laruence.com/2020/05/21/5880.html" target="_blank" rel="noopener">使用OSC52实现iTerm2远程pbcopy - 风雪之隅</a>这篇文章借助 iterms 的一个功能和几个特殊的字符，通过 php 实现了这个功能。我们来把它改写成 Python 版本。</p><p>首先打开 iterms 的设置，把方框框住的这一项勾上：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-29-25.png" alt></p><p>然后，在 iterms 里面，通过 ssh 连上服务器。</p><p>然后，我们来写一段 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\033]52;c;'</span> + base64.b64encode(<span class="string">'青南'</span>.encode()).decode() + <span class="string">'\007'</span>)</span><br></pre></td></tr></table></figure><p>然后在服务器上运行这段代码，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-40-11.png" alt></p><p>什么都没有打印出来？但不要担心，现在，你随便找一个可以打字的输入框，按下键盘上面的<code>Command +V</code>键。你会发现，<code>青南</code>两个字竟然被粘贴出来了！</p><p>有了这个机制，我们就来人工写一个<code>pbcopy.py</code>，接收管道的输入：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-22-08-35.png" alt="在公众号后台回复 pbcopy 获得代码文本"></p><p>其中，<code>#! /usr/bin/python3</code>是远程服务器上面 Python 的地址。你可以通过命令<code>which python3</code>找到这个地址。</p><p>保存完成以后，给他添加可执行权限：<code>chmod +x pbcopy.py</code>。</p><p>现在，我们试一试把远程的多行文本复制到本地的剪贴板中：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-51-22.png" alt></p><p>我这里复制的就是这个代码自身。大家也可以使用其他文件来测试。复制完成以后，我们随便找个地方粘贴，发现复制成功！</p><p>现在，我们使用软连接，把这个可执行文件变得更像命令一些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/ubuntu/pbcopy.py /usr/bin/pbcopy</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-53-54.png" alt></p><p>完美满足要求。</p><p>需要注意的是，这个程序会把管道输入的所有内容全部接收完成以后才会复制，所以，如果你输入的文本内容太大，可能会撑爆内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 macOS 的同学，应该熟悉一个命令&lt;code&gt;pbcopy&lt;/code&gt;，它可以在命令行中把一段内容写入到剪贴板，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;kingname&quot;&lt;/span&gt; | pbcopy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就能把字符串&lt;code&gt;kingname&lt;/code&gt;复制到剪贴板里面。我们也可以使用这个方法把一个文件中的内容写入到剪贴板：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat xxx.txt | pbcopy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就不需要把文件打开再手动复制的。&lt;/p&gt;
&lt;p&gt;有时候，我要把服务器上面的日志复制下来。原来都是进入服务器以后，用 vim 打开日志文件，用鼠标选中再复制。且不说服务器是 Linux，没有&lt;code&gt;pbcopy&lt;/code&gt;这个命令，即使有这个命令，服务器上又怎么能访问本地的剪贴板呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>手把手教学，如何解决 git 冲突？</title>
    <link href="https://www.kingname.info/2020/09/13/how-to-reslove-conflict/"/>
    <id>https://www.kingname.info/2020/09/13/how-to-reslove-conflict/</id>
    <published>2020-09-13T14:52:37.000Z</published>
    <updated>2020-09-13T16:21:07.111Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是现在使用最广泛的源代码管理程序。一个合格的程序员必须要熟练掌握 Git。在使用 Git 的时候，最让人头疼的问题是什么？肯定是解冲突了。如果两个人修改了同一个文件的相同位置，那么当一个人提交代码并合并到主分支以后，第二个人尝试合并时就会触发冲突。大多数情况下，Git 自己知道如何把两份代码合并起来。但有时候当 Git 不知道应该怎么合并，就会提示你需要手动解决冲突。</p><p>我以前学习 Git 的时候，由于没有人跟我一起提交代码，所以我为了模拟两人提交的情况，会把代码 clone 到两个文件夹里面，然后把相同的位置分别做不同的修改，再分别提交。过程非常繁琐。</p><a id="more"></a><p>最近因为评上了微软 MVP 的关系，会主动关注一下微软的在线课程，结果发现微软悄无声息地出了一整套的 Github 课程。而这其中，有一套交互式的课程手把手指导如何解决 Git 的冲突：<a href="https://docs.microsoft.com/zh-cn/learn/modules/resolve-merge-conflicts-github/?WT.mc_id=DT-MVP-5003916" target="_blank" rel="noopener">在 GitHub 上使用合并冲突解决来解决竞争提交</a>，由于 Github 是基于 Git 的，所以只要稍作设置，这个课程就能变成通用的 Git 操作指导教程。</p><p>一开始我以为这个课程只有 MVP 能看，后来发现，课程不仅完全免费，而且不需要注册，所有人都能随时学习。只要你有一个 Github 账号就能参加。大家点击公众号下方的<code>阅读原文</code>就可以打开这个课程页面。</p><p>打开课程以后，页面如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-09-57.png" alt></p><p>点击其中的“开始”按钮，就可以开始学习。课程一共有5个单元，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-11-49.png" alt></p><p>其中，第1，2单元是知识性介绍，大家可以看一下。今天我们重点说一下第3单元《练习-管理合并冲突》。这一单元，会基于 Github Lab(Github 学习实验室)来一步一步手把手指导。我们点击<code>在 Github 上启动学习实验室</code>按钮。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-15-22.png" alt></p><p>此时，浏览器会新开一个选项卡，如下图所示。点击<code>Start free course</code>，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-17-27.png" alt></p><p>此时，会让你登录 Github，并授权 Github Lab 创建一个练习源，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/author.png" alt></p><p>大家可以创建公共源，也可以创建私有源。如果是创建私有源的话，之后每次从远程推拉代码时，会让你输入 Github 账号密码。需要注意的是<code>Additional Options</code>这一项一定要选择<code>Use the command line</code>，这样我们才能学习通用的 Git 操作。另外两项都是 Github 专用的操作。对我们帮助不大。</p><p>授权完成以后，你的 Github 上会自动创建一个源，并且有很多的冲突，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-43-54.png" alt></p><p>回到刚才的课程页面，可以看到下面出现了几个课程阶段，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-45-09.png" alt></p><p>我们点击第一课的<code>Start</code>按钮，开始第一课。浏览器弹出了新的页面（实际上就是 Github 的 PR 页面），在这里，我们可以根据它的提示和说明进行操作。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-24-14.png" alt></p><p>大家不要担心全是英文看不懂，真正需要你进行的操作，都是灰色背景的代码片段，这些代码是很容易看懂的。</p><p>根据提示，首先 clone 代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kingname/merge-conflicts.git</span><br><span class="line"><span class="built_in">cd</span> merge-conflicts</span><br></pre></td></tr></table></figure><p>接下来，切换到<code>update-config</code>分支，然后拉取远程最新代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout update-config</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>然后，我们把远程的<code>master</code>分支代码合并到<code>update-config</code>分支中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>发现了冲突，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-50-47.png" alt></p><p>它已经提示了<code>_config.yml</code>文件有冲突。所以我们可以直接打开<code>_config.yml</code>文件。你可以使用自己喜欢的编辑器打开。我这里使用 Vim。打开以后的代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-54-22.png" alt></p><p>注意，这里的实际代码可能跟教程不一样。教程里面说冲突内容是被<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; update-config</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</code>包起来的，但实际上代码里面的冲突内容是被<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</code>包起来的。</p><p>大家可以看到，在<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>与<code>=======</code>中间的内容，与<code>=======</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</code>中间的内容，他们的字段名是一样的，但是值不一样，所以 Git 不知道应该以哪个为准，需要我们人工决断。</p><p>假设我想以上面这一段为准（在实际开发过程中，可能上下要各取一部分合并），如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-55-47.png" alt></p><p>保存修改，根据它的提示，执行以下代码进行提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"merge master into update-config"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>提交成功以后，网页上会立刻给出反馈：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-58-22.png" alt></p><p>我们继续往下看，根据它的提示，首先切换回<code>master</code>分支，然后拉取最新代码，然后把<code>update-config</code>分支的内容合并进入master：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git merge update-config</span><br></pre></td></tr></table></figure><p>合并成功，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-16-42.png" alt></p><p>最后把本地已经合并的代码使用<code>git push</code>推到远程即可。</p><p>第二个问题更复杂一些，这次有两个冲突文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-23-44.png" alt></p><p>并且冲突的内容有好几个，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-25-19.png" alt></p><p>但解决方法还是一样的，人来决定要保留哪些内容，把不要的地方删掉：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-26-28.png" alt></p><p>保存修改，然后检查第二个文件。第二个文件也解决以后，根据页面上的提示输入代码，合并提交就可以了。</p><p>前两个问题，是别人创建了冲突，需要我们来改。第三个问题，是我们自己导致了冲突，我们自己来解决。方法跟之前是一样的，就不多说了。</p><p>最后这一步，让你完善这个源里面的内容。因为这个模拟冲突的源本质上是一个在线简历页面，你可以把里面的内容改成你自己的。当然，这是选做题，可做可不做。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-45-20.png" alt></p><p>所有任务都做完了，是不是很有成就感：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-44-40.png" alt></p><p>最后还能解锁成就：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-47-37.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的学习过程，我总结了一个解决冲突的常规流程：</p><ol><li><strong>前提条件：不能在 master 分支上修改任何文件。master 分支的变更只能通过 git pull 和 git merge 获得。在 master 分支下面，不能手动修改任何文件。</strong></li><li>我们自己有一个分支用来修改代码，例如我的分支叫做<code>dev</code>分支。我把代码修改完成了，现在不知道有没有冲突。</li><li>在 dev 分支里面，执行命令<code>git merge origin/master</code>，把远程的<code>master</code>分支合并到当前<code>dev</code>分支中。如果没有任何报错，那么直接转到第5步。</li><li>如果有冲突，根据提示，把冲突解决，保存文件。然后执行命令<code>git add xxx</code>把你修改的文件添加到缓存区。然后执行命令<code>git commit -m &quot;xxx&quot;</code>添加 commit 信息。</li><li>执行如下命令，切换到 master 分支：<code>git checkout master</code>。</li><li>执行命令<code>git pull</code>确保当前 master 分支是最新代码。</li><li>把<code>dev</code>分支的代码合并回 master 分支：<code>git merge dev</code>。</li><li>提交代码：<code>git push</code>。</li></ol><p>只要所有开发者都遵守这个规则，那么解决冲突是一件非常容易的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是现在使用最广泛的源代码管理程序。一个合格的程序员必须要熟练掌握 Git。在使用 Git 的时候，最让人头疼的问题是什么？肯定是解冲突了。如果两个人修改了同一个文件的相同位置，那么当一个人提交代码并合并到主分支以后，第二个人尝试合并时就会触发冲突。大多数情况下，Git 自己知道如何把两份代码合并起来。但有时候当 Git 不知道应该怎么合并，就会提示你需要手动解决冲突。&lt;/p&gt;
&lt;p&gt;我以前学习 Git 的时候，由于没有人跟我一起提交代码，所以我为了模拟两人提交的情况，会把代码 clone 到两个文件夹里面，然后把相同的位置分别做不同的修改，再分别提交。过程非常繁琐。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.kingname.info/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.kingname.info/tags/Git/"/>
    
      <category term="Github" scheme="https://www.kingname.info/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>现场打脸：如何使用Selenium批量上传文件？</title>
    <link href="https://www.kingname.info/2020/09/09/upload-multiple-file-by-selenium/"/>
    <id>https://www.kingname.info/2020/09/09/upload-multiple-file-by-selenium/</id>
    <published>2020-09-09T04:19:16.000Z</published>
    <updated>2020-09-09T04:59:08.824Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Selenium里面，当我们获得一个 element 对象的时候，如果它是一个输入框，那么我们可以使用<code>.send_keys()</code>方法，模拟键盘按键，发送特定的字符串到输入框中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_box = driver.find_element_by_xpath(<span class="string">'//input[@class="xxx"]'</span>)</span><br><span class="line">input_box.send_keys(<span class="string">'账号 xxx'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>但如果要说<code>.send_keys()</code>可以上传文件，你可能会非常吃惊吧。今天有个读者在问我的时候，我也非常吃惊，觉得这怎么可能：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-01-03.png" alt></p><p>结果我到 Selenium 的文档里面一看，发现<code>send_keys()</code>竟然真的可以上传文件: <a href="https://selenium-python.readthedocs.io/faq.html?highlight=send_keys#how-to-upload-files-into-file-inputs" target="_blank" rel="noopener">8.5. How to upload files into file inputs ?</a></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-02-31.png" alt></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-04-31.png" alt></p><p>为了验证这个说法，我们使用 Flask 手写一个支持上传功能的简陋网站。网站代码如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-21-09.png" alt></p><p>网站运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-08-09.png" alt></p><p>点击“选择文件”按钮，在弹出的对话框里面选中一个文件，然后点击“Upload”按钮，就会把文件上传到代码里面的<code>uploads</code>文件夹中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-22-49.png" alt></p><p>现在我们在 Selenium 里面进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'http://127.0.0.1:5000'</span>)</span><br><span class="line">file_input = driver.find_element_by_xpath(<span class="string">'//input[@type="file"]'</span>)</span><br><span class="line">file_input.send_keys(<span class="string">'/Users/kingname/test_send_keys/target/x.txt'</span>)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">'//input[@type="submit"]'</span>)</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure><p>经过测试，发现确实可以正常上传文件。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-25-27.png" alt></p><p>这样一来，既然 <code>.send_keys()</code>能够正常工作，那么就可以反向推测出，浏览器上传文件的原理，选择文件的对话框实际上提供给浏览器的仅仅是一个文件路径。当我们点击了上传按钮以后，浏览器会根据这个路径去读硬盘，找到这个文件然后上传。由于文件路径本质上就是一个字符串，所以用<code>.send_keys()</code>本质上就是直接替代了选择文件对话框生成的文件路径，直接把这个路径上传给了文件输入表单。</p><p>那么如何一次性上传多个文件呢？</p><p>只要网站支持同时上传多个文件，那么我们可以把多个文件的路径拼接到一个长字符串中，路径与路径之间使用换行符<code>\n</code>来进行分割。</p><p>假设在文件夹<code>/Users/kingname/test_send_keys/target</code>里面有多个文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-26-14.png" alt></p><p>我们需要一次性全部上传。那么，可以使用换行符把每一个文件的路径拼接起来：</p><p>代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line">folder = <span class="string">'/Users/kingname/test_send_keys/target'</span></span><br><span class="line">file_name_list = os.listdir(folder)</span><br><span class="line">path_list = [os.path.join(folder, x) <span class="keyword">for</span> x <span class="keyword">in</span> file_name_list]</span><br><span class="line">path_split_by_newline = <span class="string">'\n'</span>.join(path_list)</span><br><span class="line"></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'http://127.0.0.1:5000'</span>)</span><br><span class="line">file_input = driver.find_element_by_xpath(<span class="string">'//input[@type="file"]'</span>)</span><br><span class="line">file_input.send_keys(path_split_by_newline)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">'//input[@type="submit"]'</span>)</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-30-18.png" alt></p><p>成功上传多个文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Selenium里面，当我们获得一个 element 对象的时候，如果它是一个输入框，那么我们可以使用&lt;code&gt;.send_keys()&lt;/code&gt;方法，模拟键盘按键，发送特定的字符串到输入框中，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input_box = driver.find_element_by_xpath(&lt;span class=&quot;string&quot;&gt;&#39;//input[@class=&quot;xxx&quot;]&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input_box.send_keys(&lt;span class=&quot;string&quot;&gt;&#39;账号 xxx&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：实现有过期时间的LRU缓存</title>
    <link href="https://www.kingname.info/2020/03/23/lru-with-expire-time/"/>
    <id>https://www.kingname.info/2020/03/23/lru-with-expire-time/</id>
    <published>2020-03-23T15:46:52.000Z</published>
    <updated>2020-03-23T15:47:20.191Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://mp.weixin.qq.com/s/F7D9MjGypRj5J1EZVvPv0Q" target="_blank" rel="noopener">一日一技：实现函数调用结果的 LRU 缓存</a>一文中，我们提到Python自带的LRU缓存<code>lru_cache</code>。通过这个装饰器可以非常轻松地实现缓存。</p><a id="more"></a><p>现在我们考虑下面这个应用场景：MongoDB中有100对id-用户名的对应关系，我从Redis中持续不断读取id，如果id能在MongoDB中找到对应关系，那么就把对应的用户名打印出来。如果找不到对应关系，那么就把这个id丢弃。</p><p>为了防止频繁读取MongoDB，我在程序开始的时候直接读取这一百对对应关系，并存为字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">client = redis.Redis()</span><br><span class="line">handler = pymongo.MongoClient().weibo.id_name_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_id_name_map</span><span class="params">()</span>:</span></span><br><span class="line">    id_name = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> handler.find():</span><br><span class="line">        id_name[row[<span class="string">'id'</span>]] = row[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> id_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id_name_map = read_id_name_map()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client.blpop(<span class="string">'weibo_id'</span>)</span><br><span class="line">    user_id = data[<span class="number">1</span>].decode()</span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">in</span> id_name_map:</span><br><span class="line">        print(id_name_map[user_id])</span><br></pre></td></tr></table></figure><p>大家可以思考一下，上面这段代码有没有什么问题。然后继续看后面。</p><p>如果我现在需要再增加100个id-用户名的对应关系怎么办？</p><p>由于这个程序运行以后就一直阻塞式地读取Redis，不会停止，所以整个过程只会读取一次MongoDB。后面即使我向MongoDB中添加了新的对应关系，只要程序不重启，就无法读取到新的对应关系。</p><p>肯定有同学想到，在while循环里面增加一个计时器，每x分钟就重新调用一下read_id_name_map()函数，更新对应关系。</p><p>不过今天我们要讲的是另一个更有创意的办法，使用<code>lru_cache</code>来实现。</p><p>对于这个例子来说，lru_cache的<code>maxsize</code>参数只需要设置为1，因为只需要存放1份对应关系即可。那么我们如何做到，比如每10分钟更新一次呢？我们知道，在使用lru_cache时，如果调用同一个函数，并且传入的参数相同，那么从第二次开始就会使用缓存。现在我们如何让时间在每10分钟内相同呢？</p><p>我们来看现在的时间戳：1578399211.30042</p><p>它除以600，值是<code>1578399211.30042 // 600 = 2630665.0</code>。然后我让这个时间戳加5分钟，也就是增加300秒，变成<code>1578399511.30042</code>。这个新的时间戳再除以600，发现结果还是<code>2630665.0</code>。但如果原来的时间戳增加超过10分钟，例如增加了601秒，我们再来看看效果<code>(1578399211.30042 + 601) // 600 = 2630666.0</code>，此时的结果也发生了变化。</p><p>利用这个特点，修改一下我们的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line">client = redis.Redis()</span><br><span class="line">handler = pymongo.MongoClient().weibo.id_name_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_id_name_map</span><span class="params">(_)</span>:</span></span><br><span class="line">    id_name = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> handler.find():</span><br><span class="line">        id_name[row[<span class="string">'id'</span>]] = row[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> id_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client.blpop(<span class="string">'weibo_id'</span>)</span><br><span class="line">    id_name_map = read_id_name_map(time.time() // <span class="number">600</span>)</span><br><span class="line">    user_id = data[<span class="number">1</span>].decode()</span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">in</span> id_name_map:</span><br><span class="line">        print(id_name_map[user_id])</span><br></pre></td></tr></table></figure><p>现在，我们直接在while循环内部调用<code>read_id_name_map</code>，如果两次调用的时间间隔小于600秒，那么<code>time.time() // 600</code>的值是相同的，第二次直接使用缓存，也就不会查询MongoDB了。当时间超过10分钟后，时间戳除以600的值增加了，于是缓存没有命中，进入查询MongoDB的过程，更新id_name_map。实现了有过期时间的LRU缓存。</p><p>补充：可能有同学注意到定义<code>read_id_name_map</code>函数的时候，参数我写的是下划线。这是Python 编码规范中建议的一种写法。当一个变量不会被使用，但又需要保留时，就可以用下划线表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/F7D9MjGypRj5J1EZVvPv0Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：实现函数调用结果的 LRU 缓存&lt;/a&gt;一文中，我们提到Python自带的LRU缓存&lt;code&gt;lru_cache&lt;/code&gt;。通过这个装饰器可以非常轻松地实现缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="LRU" scheme="https://www.kingname.info/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>拒绝想当然，不看文档导致GNE 的隐秘 bug</title>
    <link href="https://www.kingname.info/2020/03/23/bug-for-gne/"/>
    <id>https://www.kingname.info/2020/03/23/bug-for-gne/</id>
    <published>2020-03-23T15:45:55.000Z</published>
    <updated>2020-03-23T15:46:27.498Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="noopener">GNE</a>上线4天，已经有很多朋友通过它来编写自己的新闻类网页通用爬虫。</p><a id="more"></a><p>今天有一个用户来跟我反馈，GNE 0.1.4版本在提取澎湃新闻时，只能提取一小部分的内容。</p><p>一开始我以为是提取算法有问题，Debug 了半天，最后才发现，是新闻正文在预处理的时候，就被提前<code>删除</code>了！</p><p>为了解释这个问题，我们用一小段 HTML 代码来还原当时的场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>阅读过 GNE 源代码的朋友都知道，GNE 会在预处理阶段尽可能移除没什么用的 HTML 标签。例如上面这段代码中的两行<code>&lt;p class=&quot;con&quot; /&gt;</code>都属于会干扰提取结果，且对提取没有任何帮助的标签。</p><p>于是我们使用 lxml 库的方法来移除它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"></span><br><span class="line">selector = fromstring(h)</span><br><span class="line">useless_list = selector.xpath(<span class="string">'//p[@class="con"]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> useless <span class="keyword">in</span> useless_list:</span><br><span class="line">    useless.getparent().remove(useless)</span><br></pre></td></tr></table></figure><p>根据想当然的理论：</p><ol><li>找到<code>&lt;p class=&quot;con&quot; /&gt;</code>标签</li><li>找到它的父标签</li><li>从父标签里面把这两个无效标签移除掉</li></ol><p>整个过程看起来没有问题，并且预期移除以后的 HTML 应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>但实际上，现实情况与想当然的情况自然不一样。真正的输出结果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-04-16-12-49.png" alt></p><p><code>&lt;div class=&quot;txt&quot;&gt;</code>这个标签下面的<code>text()</code>有三行，分别为<code>第一行</code>、<code>第二行</code>、<code>第三行</code>。但是使用上面的代码移除时，<code>第二行</code>与<code>第三行</code>都一并被删除了。</p><p>这是因为，这就是<code>ElementTree.remove</code>这个方法的行为。它不仅会移除这个节点，还会移除这个节点父节点的 text()中，位于这个节点后面的所有内容。</p><p>所以，正常的做法应该是直接调用要被移除这个节点的<code>.drop_tag()</code>方法。我们修改一下上面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"><span class="keyword">from</span> html <span class="keyword">import</span> unescape</span><br><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">selector = fromstring(h)</span><br><span class="line">useless_list = selector.xpath(<span class="string">'//p[@class="con"]'</span>)</span><br><span class="line"><span class="keyword">for</span> useless <span class="keyword">in</span> useless_list:</span><br><span class="line">    useless.drop_tag()</span><br><span class="line"></span><br><span class="line">print(unescape(etree.tostring(selector).decode()))</span><br></pre></td></tr></table></figure><p>运行效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-04-16-14-38.png" alt></p><p>成功达到了我们想要的目的。</p><p>GNE 已经更新了版本，修复了这个 bug。使用 GNE 的同学请升级到0.1.5以上版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade gne</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kingname/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GNE&lt;/a&gt;上线4天，已经有很多朋友通过它来编写自己的新闻类网页通用爬虫。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：应该传入对象还是在用的时候再初始化？</title>
    <link href="https://www.kingname.info/2020/03/23/pass-or-create/"/>
    <id>https://www.kingname.info/2020/03/23/pass-or-create/</id>
    <published>2020-03-23T15:45:05.000Z</published>
    <updated>2020-03-23T15:45:32.539Z</updated>
    
    <content type="html"><![CDATA[<p>在写 Python 代码的时候，大家可能会在不知不觉中使用一些设计范式。我们来看两个例子。</p><a id="more"></a><p>假设有一个类<code>People</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>现在我们有另一个类<code>ClassRoom</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.student = People(<span class="string">'小明'</span>, <span class="number">17</span>, <span class="string">'男'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.student.study()</span><br></pre></td></tr></table></figure><p>我们在<code>ClassRoom</code>的构造函数中，初始化了一个 student 对象，然后在<code>start_class</code>方法中，调用了这个对象的<code>study</code>方法。</p><p>这个过程看起来似乎没有什么问题，相信很多读者也是这样写代码的。</p><p>现在，我们再增加两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.consumer = People(<span class="string">'张三'</span>, <span class="number">30</span>, <span class="string">'男'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_launch</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.consumer.eat()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballroom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.dancer = People(<span class="string">'小红'</span>, <span class="number">20</span>, <span class="string">'女'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dancer.dance()</span><br></pre></td></tr></table></figure><p>新增加的两个类<code>Restaurant</code>和<code>Ballroom</code>的构造函数里面都通过<code>People</code>类初始化了对象。然后在调用这个对象的方法。</p><p>这样写看起来没有问题，能正常工作，代码也不丑。</p><p>现在，<code>People</code>类需要修改一下它的构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex, address)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>在初始化<code>People</code>类时，需要传入一个<code>address</code>参数。现在怎么办？</p><p>于是<code>ClassRoom</code>、<code>Restaurant</code>、<code>Ballroom</code>这三个类的构造函数都要随之做修改，全都得加上这个<code>address</code>参数。</p><p>这就叫做<code>牵一发而动全身</code>。</p><p>很多人为了避免做这样的修改，会把新增加的这个参数<code>address</code>改成默认参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex, address=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>这样看起来，另外三个类的代码就不需要做任何修改了。</p><blockquote><p>这就是为什么你们公司的代码里面，很多函数会带上大量奇奇怪怪的默认参数的原因。</p></blockquote><p>在编程范式中，有一个术语叫做<code>依赖注入</code>，就是为了解决这个问题的。</p><p>而且做起来简单到你觉得这是在逗你，把<code>People</code>初始化以后的对象传到其他类的构造函数中即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballroom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, dancer)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.dancer = dancer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dancer.dance()</span><br><span class="line"></span><br><span class="line">dancer = People(<span class="string">'小红'</span>, <span class="number">20</span>, <span class="string">'女'</span>)</span><br><span class="line">ballroom = Ballroom(<span class="string">'xxx'</span>, dancer)</span><br><span class="line">ballroom.open()</span><br></pre></td></tr></table></figure><p>虽然叫做编程范式，但也不是说应该始终使用依赖注入。例如你的代码会层层调用，难道从第一层把对象一层一层传到最里面去？所以应该根据实际情况来进行选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 Python 代码的时候，大家可能会在不知不觉中使用一些设计范式。我们来看两个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用二分法排查正则表达式的异常</title>
    <link href="https://www.kingname.info/2020/03/23/binary-search-for-regex/"/>
    <id>https://www.kingname.info/2020/03/23/binary-search-for-regex/</id>
    <published>2020-03-23T15:44:11.000Z</published>
    <updated>2020-03-23T15:44:40.471Z</updated>
    
    <content type="html"><![CDATA[<p>现在我有10亿条微博正文，并从同事手上拿到了15000条需要过滤的垃圾信息正则表达式，只要微博正文符合任何一条正则表达式，就删除这条微博。</p><a id="more"></a><p>正则表达式的格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">^你成功领取</span><br><span class="line">|^感谢您的积</span><br><span class="line">|^在第\d+次抽奖.</span><br><span class="line">|^只有帮主才</span><br><span class="line">|^目标有相应</span><br><span class="line">|^宝宝<span class="comment">#G.</span></span><br><span class="line">|^提交失败，</span><br><span class="line">|^您已领取过</span><br><span class="line">|^破军争夺战</span><br><span class="line">|^首席大弟子</span><br><span class="line">|数第\d+个丫鬟</span><br><span class="line">|你的店铺</span><br><span class="line">|恭喜.*?投中了</span><br><span class="line">|&lt;web</span><br><span class="line">|你将该物品拆解成</span><br><span class="line">|^你身上没有</span><br><span class="line">|欢迎参加微博抽奖</span><br><span class="line">|蔡徐坤</span><br><span class="line">|王一博</span><br><span class="line">|朱一龙</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>存放在一个名为<code>trash.txt</code>的文本文件中，每个正则表达式一行。</p><p>一般情况下，我只需要使用如下几行代码就能实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'trash.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line">    pattern = re.compile(<span class="string">''</span>.join(lines))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weibo <span class="keyword">in</span> weibo_list:</span><br><span class="line">    <span class="keyword">if</span> pattern.search(weibo):</span><br><span class="line">        print(<span class="string">'垃圾信息，过滤！'</span>)</span><br></pre></td></tr></table></figure><p>但是当我的代码运行到<code>re.compile</code>这一行时，报错了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-12-56-46.png" alt></p><p>并且，即使你在 Google 上面搜索：<code>re.error: multiple repeat at position</code>，截至2019年12月30日，你能找到的都是对这个报错的讨论，但没有一个讨论能解决本文描述的问题。</p><p>那我们自食其力，来试着解决一下这个问题。它报错报的是<code>position 167</code>，那么我们来看看第167个字符有什么问题。在 PyCharm 中，可以在右下角查看你选中了多少个字符，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-12-59-22.png" alt></p><p>从截图中可以看到，第167个字符所在的这一行正则表达式为：<code>|张三丰.*?张翠山.*?张无忌</code>，但是我完全看不出这一行正则表达式有什么问题。</p><p>由于报错了，那么肯定至少有一行正则表达式有问题，我们假设有问题的正则表达式有且只有一行。现在我们有15000行正则表达式，如何找出有问题的这一行呢？</p><p>这个时候，我们就可以使用二分查找来解决这个问题，$log_{2}15000=13.8$，我们最多查找14次就能找到有问题的这一行正则表达式。</p><p>由于正则表达式一共有15000行，我们就先看0-7500行在编译时是否会报错，如果报错，在看<code>0-3750</code>行是否报错，如果不报错，在看<code>3750-7500</code>行是否报错……如此分割下去，直到找到报错的这一行正则表达式。</p><p>二分查找的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'trash.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_compile_success</span><span class="params">(regex)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        re.compile(regex)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(regex_list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(regex_list) == <span class="number">1</span>:</span><br><span class="line">        print(regex_list[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = len(regex_list) // <span class="number">2</span></span><br><span class="line">    part_1 = <span class="string">''</span>.join(regex_list[: mid])</span><br><span class="line">    part_2 = <span class="string">''</span>.join(regex_list[mid: ])</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_compile_success(part_1):</span><br><span class="line">        search(regex_list[: mid])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_compile_success(part_2):</span><br><span class="line">        search(regex_list[mid:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search(lines)</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-13-20-24.png" alt></p><p>原来出问题的地方在：<code>.*??</code>，这里多写了一个问号。把这一行改成<code>|赵大.*?包</code>以后，编译成功通过。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>如果要把出问题的这一行所在的行号打印出来，应该如何修改代码？</li><li>如果有问题的正则表达式不止一行，应该如何修改代码，从而打印所有有问题的正则表达式？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我有10亿条微博正文，并从同事手上拿到了15000条需要过滤的垃圾信息正则表达式，只要微博正文符合任何一条正则表达式，就删除这条微博。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>你经常看到却经常忽视的__init__.py有什么用？</title>
    <link href="https://www.kingname.info/2020/03/23/init-in-python/"/>
    <id>https://www.kingname.info/2020/03/23/init-in-python/</id>
    <published>2020-03-23T15:40:46.000Z</published>
    <updated>2020-03-23T15:41:11.370Z</updated>
    
    <content type="html"><![CDATA[<p>Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做<code>__init__.py</code>的文件。下图为著名的第三方库<code>requests</code>的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png" alt></p><p>那么<code>__init__.py</code>有什么用呢？本文介绍它的两个用途。</p><a id="more"></a><h2 id="精简导入路径"><a href="#精简导入路径" class="headerlink" title="精简导入路径"></a>精简导入路径</h2><p>假设我们有两个文件<code>main.py</code>与<code>writer.py</code>，他们所在的文件结构如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-48-36.png" alt></p><p><code>main.py</code>在<code>DocParser</code>文件夹下面；<code>writer.py</code>在<code>DocParser/microsoft/docx/</code>文件夹下面。<code>writer.py</code>文件中有一个函数<code>write</code>。其内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-48.png" alt></p><p>现在我想在<code>main.py</code>文件夹调用这个函数，那么我有3种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.word.docx.writer <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line">write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-50-32.png" alt></p><p>或者这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.word.docx <span class="keyword">import</span> writer</span><br><span class="line"></span><br><span class="line">writer.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-51-21.png" alt></p><p>或者这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> microsoft.word.docx.writer</span><br><span class="line"></span><br><span class="line">microsoft.word.docx.writer.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-02.png" alt></p><p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在<code>microsoft</code>文件夹下面创建一个<code>__init__.py</code>文件，并在里面填写如下内容：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt></p><p>此时，在 <code>main.py</code>，我们导入<code>write</code>函数，就像是从<code>microsoft.py</code> 文件中导入一样。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt></p><p>注意上面我说的是就像从<code>microsoft.py 文件</code>中导入一样，这里是用的<code>文件</code>而不是<code>文件夹</code>。</p><p>这是因为，当一个文件夹里面有<code>__init__.py</code>以后，这个文件夹就会被 Python 作为一个<code>包(package)</code>来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到<code>__init__.py</code>中。这样以来，包外面再想导入这些内容时，就可以用<code>from 包名 import 函数名</code>来导入了。</p><h2 id="无视工作区的相对引用"><a href="#无视工作区的相对引用" class="headerlink" title="无视工作区的相对引用"></a>无视工作区的相对引用</h2><p>为什么会有<code>包</code>这个东西呢？这是因为，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的部分提供给其他模块调用。</p><p>由于调用包的其他模块所在的绝对路径是千变万化的，所以在包的内部调用自身其他文件中的函数、常量、类，就应该使用相对路径，而是绝对路径。</p><p>例如，现在我在<code>microsoft</code>文件夹下面再创建一个<code>parse.py</code>文件，它需要导入<code>microsoft/word/docx/writer.py</code>中的<code>write</code>函数，那么代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .word.docx.writer <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_doc</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'现在在 parse.py 中调用 write 函数'</span>)</span><br><span class="line">    write()</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-08-34.png" alt></p><p>可以看到，此时<code>from .word.docx.writer</code>中的<code>.</code>表示当前包，所以<code>.word.docx.writer</code>表示当前包下面的word 文件夹下面的 docx 文件夹下面的 writer.py 文件。</p><p>然后我们修改<code>__init__.py</code>，把<code>parse_doc</code>函数导入进去，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-25.png" alt></p><p>最后，在<code>main.py</code>中调用这个<code>parse_doc</code>函数，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-59.png" alt></p><p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。</p><p>并且，上面<code>parse.py</code>中导入<code>write</code>函数的代码还可以进一步简化，由于<code>write</code>函数已经被导入到了<code>__init__.py</code>中，所以我们可以直接从<code>.</code>里面导入<code>write</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> write</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-13-05.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当一个文件夹里面包含<code>__init__.py</code>时，这个文件夹会被 Python 认为是一个<code>包(package)</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到<code>__init__.py</code>中再在其他文件中导入，可以精简代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做&lt;code&gt;__init__.py&lt;/code&gt;的文件。下图为著名的第三方库&lt;code&gt;requests&lt;/code&gt;的源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;__init__.py&lt;/code&gt;有什么用呢？本文介绍它的两个用途。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Python 中的 import 与 from import</title>
    <link href="https://www.kingname.info/2020/03/23/know-import/"/>
    <id>https://www.kingname.info/2020/03/23/know-import/</id>
    <published>2020-03-23T15:40:01.000Z</published>
    <updated>2020-03-23T15:40:29.703Z</updated>
    
    <content type="html"><![CDATA[<p>对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用<code>import xxx</code>？什么时候用<code>from xxx import yyy</code>？什么时候用<code>from xxx.yyy import zzz</code>？什么时候用<code>from xxx import *</code>？</p><p>这篇文章，我们来彻底搞懂这个问题。</p><a id="more"></a><h2 id="系统自带的模块"><a href="#系统自带的模块" class="headerlink" title="系统自带的模块"></a>系统自带的模块</h2><p>以正则表达式模块为例，我们经常这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">target = <span class="string">'abc1234xyz'</span></span><br><span class="line">re.search(<span class="string">'(\d+)'</span>, target)</span><br></pre></td></tr></table></figure><p>但有时候，你可能会看到某些人这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> search</span><br><span class="line">target = <span class="string">'abc1234xyz'</span></span><br><span class="line">search(<span class="string">'(\d+)'</span>, target)</span><br></pre></td></tr></table></figure><p>那么这两种导入方式有什么区别呢？</p><p>我们分别使用<code>type</code>函数来看看他们的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(re)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">module</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">re</span> <span class="title">import</span> <span class="title">search</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(search)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-30-59.png" alt></p><p>可以看到，直接使用<code>import re</code>导入的<code>re</code>它是一个<code>module</code>类，也就是模块。我们把它成为<code>正则表达式模块</code>。而当我们<code>from re import search</code>时，这个<code>search</code>是一个<code>function</code>类，我们称呼它为<code>search 函数</code>。</p><p>一个模块里面可以包含多个函数。</p><p>如果在你的代码里面，你已经确定只使用<code>search</code>函数，不会再使用正则表达式里面的其他函数了，那么你使用两种方法都可以，没什么区别。</p><p>但是，如果你要使用正则表达式下面的多个函数，或者是一些常量，那么用第一种方案会更加简洁清晰。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">re.search(<span class="string">'c(.*?)x'</span>, flags=re.S)</span><br><span class="line">re.sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=re.I)</span><br></pre></td></tr></table></figure><p>在这个例子中，你分别使用了<code>re.search</code>，<code>re.sub</code>，<code>re.S</code>和<code>re.I</code>。后两者是常量，用于忽略换行符和大小写。</p><p>但是，如果你使用<code>from re import search, sub, S, I</code>来写代码，那么代码就会变成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">search(<span class="string">'c(.*?)x'</span>, flags=S)</span><br><span class="line">sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=I)</span><br></pre></td></tr></table></figure><p>看起来虽然简洁了，但是，一旦你的代码行数多了以后，你很容易忘记<code>S</code>和<code>I</code>这两个变量是什么东西。而且我们自己定义的函数，也很有可能取名为<code>sub</code>或者<code>search</code>，从而覆盖正则表达式模块下面的这两个同名函数。这就会导致很多难以觉察的潜在 bug。</p><p>再举一个例子。Python 的 <code>datetime</code>模块，我们可以直接<code>import datetime</code>，此时我们导入的是一个<code>datetime</code>模块，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-43-21.png" alt></p><p>但是如果你写为<code>from datetime import datetime</code>，那么你导入的<code>datetime</code>是一个<code>type</code>类：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-45-07.png" alt></p><p>因为这种方式导入的<code>datetime</code>，它就是Python 中的一种类型，用于表示包含日期和时间的数据。</p><p>这两种导入方式导入的<code>datetime</code>，虽然名字一样，但是他们的意义完全不一样，请大家观察下面两种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">one_hour_ago = now - datetime.timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">now = datetime.now()</span><br><span class="line">one_hour_ago = now - timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第二种写法看似简单，但实则改动起来却更为麻烦。例如我还需要增加一个变量<code>today</code>用于记录今日的日期。</p><p>对于第一段代码，我们只需要增加一行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">today = datetime.date.today()</span><br></pre></td></tr></table></figure><p>但对于第二行来说，我们需要首先修改导入部分的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, date</span><br></pre></td></tr></table></figure><p>然后才能改代码：<code>today = date.today()</code></p><p>这样一来你就要修改两个地方，反倒增加了负担。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>在使用某些第三方库的代码里面，我们会看到类似这样的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"></span><br><span class="line">selector = fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是我们还可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">selector = html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是，下面这种写法会导致报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line">selector = lxml.html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>那么这里的<code>lxml.html</code>又是什么东西呢？</p><p>这种情况多常见于一些特别大型的第三方库中，这种库能处理多种类型的数据。例如<code>lxml</code>它既能处理<code>xml</code>的数据，又能处理<code>html</code>的数据，于是这种库会划分子模块，<code>lxml.html</code>模块专门负责<code>html</code>相关的数据。</p><h2 id="自己来实现多种导入方法"><a href="#自己来实现多种导入方法" class="headerlink" title="自己来实现多种导入方法"></a>自己来实现多种导入方法</h2><p>我们现在自己来写代码，实现这多种导入方法。</p><p>我们创建一个文件夹<code>DocParser</code>，在里面分别创建两个文件<code>main.py</code>和<code>util.py</code>，他们的内容如下：</p><p><code>util.py</code>文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'write 函数被调用！'</span>)</span><br></pre></td></tr></table></figure><p><code>main.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util</span><br><span class="line"></span><br><span class="line">util.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-06-29.png" alt></p><p>现在我们把<code>main.py</code>的导入方式修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line">write()</span><br></pre></td></tr></table></figure><p>依然正常运行，如下图所示</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-07-21.png" alt></p><blockquote><p>当两个文件在同一个文件夹下面，并且该文件夹里面没有<strong>init</strong>.py 文件时，两种导入方式等价。</p></blockquote><p>现在，我们来创建一个文件夹<code>microsoft</code>，里面再添加一个文件<code>parse.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'我是 microsoft 文件夹下面的 parse.py 中的 read函数'</span>)</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-11-17.png" alt></p><p>此时我们在 <code>main.py</code>中对它进行调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">parse.read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-12-17.png" alt></p><p>我们也可以用另一种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.parse <span class="keyword">import</span> read</span><br><span class="line"></span><br><span class="line">read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-13-17.png" alt></p><p>但是，你不能直接导入<code>microsoft</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-15-35.png" alt></p><blockquote><p>你只能导入一个模块或者导入一个函数或者类，你不能导入一个文件夹</p></blockquote><p>无论你使用的是<code>import xxx</code>还是<code>from xxx.yyy.zzz.www import qqq</code>，你导入进来的东西，要不就是一个模块(对应到.py 文件的文件名)，或者是某个.py 文件中的函数名、类名、变量名。</p><p>无论是<code>import xxx</code>还是<code>from xxx import yyy</code>，你导入进来的都不能是一个文件夹的名字。</p><p>可能有这样一种情况，就是某个函数名与文件的名字相同，例如：</p><p>在 <code>microsoft</code>文件夹里面有一个<code>microsoft.py</code>文件，这个文件里面有一个函数叫做<code>microsoft</code>，那么你的代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> microsoft`</span><br><span class="line">microsoft.microsoft()</span><br></pre></td></tr></table></figure><p>但请注意分辨，这里你导入的还是模块，只不过<code>microsoft.py</code>文件名与它所在的文件夹名恰好相同而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是使用<code>import</code>还是<code>from import</code>，第一个要求是代码能够正常运行，其次，根据代码维护性，团队编码风格来确定选择哪一种方案。</p><p>如果我们只会使用到某个模块下面的一个函数（或者常量、类）并且名字不会产生混淆，可识别性高，那么<code>from 模块名 import 函数名</code>这没有什么问题。</p><p>如果我们会用到一个模块下面的多个函数，或者是我们将要使用的函数名、常量名、类名可能会让人产生混淆（例如 re.S、re.I），那么这种情况下，<code>import 模块名</code>然后再 <code>模块名.xxx</code>来调用会让代码更加清晰，更好维护。</p><p>但无论什么情况下，都禁止使用<code>from xxx import *</code>这种写法，它会给你带来无穷无尽的噩梦。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>在明天的文章中，我们来讲讲还有一种写法<code>from . import xxx</code>，以及当文件夹中存在<code>__init__.py</code>时，导入方式又有什么变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用&lt;code&gt;import xxx&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import yyy&lt;/code&gt;？什么时候用&lt;code&gt;from xxx.yyy import zzz&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import *&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;这篇文章，我们来彻底搞懂这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：推特时间的格式化方案</title>
    <link href="https://www.kingname.info/2020/03/23/twitter-time-format/"/>
    <id>https://www.kingname.info/2020/03/23/twitter-time-format/</id>
    <published>2020-03-23T15:39:12.000Z</published>
    <updated>2020-03-23T15:39:39.967Z</updated>
    
    <content type="html"><![CDATA[<p>在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"Tue Dec 24 10:51:15 +0000 2019"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我想把它转换为<code>2019-12-24 18:51:15</code>的形式，应该如何操作呢？</p><a id="more"></a><p>可能有同学会按照下面这个逻辑来处理：</p><ol><li>首先，使用空格把这个时间字符串切分开变成<code>[&#39;Tue&#39;, &#39;Dec&#39;, &#39;24&#39;, &#39;10:51:15&#39;, &#39;+0000&#39;, &#39;2019&#39;]</code></li><li>第0项是星期，不需要，直接丢弃</li><li>第1项是月份，通过一个英文月份简称到月份数字的字典，把<code>Dec</code>映射为<code>12</code></li><li>第2项是日期，不做修改</li><li>第3项是时分秒，不做修改</li><li>第4项是时区，说明这个时间是采用的0时区，比北京时间晚8小时</li><li>第5项是年份，不做修改</li><li>把修改过的第1项、第2项、第3项、第5项调整顺序，拼接成一个符合要求的时间：<code>2019-12-24 10:51:15</code>。把使用<code>datetime.datetime.strptime</code>转成<code>datetime.datetime</code>对象。</li><li>把这个<code>datetime.datetime</code>对象加上<code>datetime.timedelta(hours=8)</code></li><li>使用<code>strftime</code>方法再把<code>datetime.datetime</code>对象转回字符串</li></ol><p>整个过程看起来非常麻烦。</p><p>实际上，我们有更简单的办法来处理。<code>Tue Dec 24 10:51:15 +0000 2019</code>对应的时间格式为<code>%a %b %d %H:%M:%S %z %Y</code>；对于一个<code>datetime.datetime</code>对象，我们可以调用它的<code>astimezone</code>方法把时区移除，移除以后就会变成当地时间。</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = <span class="string">'Wed Dec 25 09:09:25 +0000 2019'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj = datetime.datetime.strptime(dt, <span class="string">'%a %b %d %H:%M:%S %z %Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj.astimezone(tz=<span class="literal">None</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="string">'2019-12-25 17:09:25'</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-25-21-38-09.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;created_at&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Tue Dec 24 10:51:15 +0000 2019&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我想把它转换为&lt;code&gt;2019-12-24 18:51:15&lt;/code&gt;的形式，应该如何操作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>逆向操作，把被压平的字典还原成嵌套字典</title>
    <link href="https://www.kingname.info/2020/03/23/reverse-flat/"/>
    <id>https://www.kingname.info/2020/03/23/reverse-flat/</id>
    <published>2020-03-23T15:38:04.000Z</published>
    <updated>2020-03-23T15:38:33.913Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;mid=2648977876&amp;idx=1&amp;sn=76c6f8d0a8dabaefe3aa3f666893c991&amp;chksm=f2506c34c527e522478a1c0e07d52075d05c2436bd326662746c1fd854ee922244dcae23b1dd&amp;token=821834861&amp;lang=zh_CN#rd" target="_blank" rel="noopener">使用 yield 压平嵌套字典有多简单？</a>这篇文章中，我们讲到，要把一个多层嵌套的字典压平，可以使用<code>yield</code>关键字来实现。</p><p>今天，我们倒过来，把一个已经被压平的字典还原成嵌套字典。</p><a id="more"></a><p>目标字典为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'a_b_h'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'a_b_i'</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">'a_c_j'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'a_d'</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">'a_c_k'</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="string">'a_e'</span>:<span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要把它还原为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"a"</span>: &#123;</span><br><span class="line">    <span class="string">"b"</span>: &#123;</span><br><span class="line">      <span class="string">"h"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"i"</span>: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"c"</span>: &#123;</span><br><span class="line">      <span class="string">"j"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">"k"</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"d"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"e"</span>: <span class="number">6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现这个需求，我们分成两个主要的步骤。</p><h2 id="还原每一个嵌套字典"><a href="#还原每一个嵌套字典" class="headerlink" title="还原每一个嵌套字典"></a>还原每一个嵌套字典</h2><p>对于<code>{&#39;a_b_h&#39;:1}</code>，它实际上被还原以后应该是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'a'</span>: &#123;<span class="string">'b'</span>: &#123;<span class="string">'h'</span>: <span class="number">1</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>现在，写一个函数<code>unpack</code>，这个函数的作用是传入两个参数<code>[&#39;a&#39;, &#39;b&#39;, &#39;h&#39;]</code>和<code>1</code>输出<code>{&#39;a&#39;: {&#39;b&#39;: {&#39;h&#39;: 1}}}</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpack</span><span class="params">(key, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(key) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;key[<span class="number">0</span>]: value&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prefix = key.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;prefix: unpack(key, value)&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>unpack</code>函数的第一个参数是一个列表，形如：<code>[&#39;a&#39;, &#39;b&#39;, &#39;h&#39;]</code>。运行效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-20-29-10.png" alt></p><p>这个函数使用递归，把第一个参数列表一项一项拿出来，作为字典的 key，并把剩下的项作为子字典的 key。当列表只剩一个值的时候，说明已经到了最里面了，把这个值作为最里面字典的 key，第二个参数作为 value。</p><p>接下来，我们实现第二个函数<code>deflat</code>，它把目标字典分成<code>key, value</code>对，并把 key 转换为列表以后传给<code>unpack</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deflat</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</span><br><span class="line">        <span class="keyword">yield</span> unpack(key.split(<span class="string">'_'</span>), value)</span><br></pre></td></tr></table></figure><p>在 <code>deflat</code>函数中，我们传入目标字典。目标字典的每一对 <code>key, value</code>被取出来，传入<code>unpack</code>函数构造每一个小的嵌套字典。</p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-20-43-03.png" alt></p><h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>有了每一个嵌套字典以后，我们要做的就是把他们合并起来。</p><p>假设我们有两个字典：dst 和 src，把 src 的内容合并到 dst 字典中，有如下几种情况。</p><h3 id="dst中没有-src-的-key"><a href="#dst中没有-src-的-key" class="headerlink" title="dst中没有 src 的 key"></a>dst中没有 src 的 key</h3><p>假设<code>dst = {&#39;a&#39;: 1}</code>，<code>src = {&#39;b&#39;: 1}</code>，那么合并以后，<code>dst</code>变成<code>{&#39;a&#39;: 1, &#39;b&#39;: 1}</code>。</p><p>对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dst:</span><br><span class="line">            dst[key] = value</span><br></pre></td></tr></table></figure><h3 id="dst-中有-src-的-key且值都是字典"><a href="#dst-中有-src-的-key且值都是字典" class="headerlink" title="dst 中有 src 的 key且值都是字典"></a>dst 中有 src 的 key且值都是字典</h3><p>假设<code>dst = {&#39;a&#39;: {&#39;b&#39;: 1}}</code>， <code>src = {&#39;a&#39;: {&#39;c&#39;: 1}}</code>，那么由于<code>dst</code>与<code>src</code>都有<code>&#39;a&#39;</code>这个 key，所以问题转换为合并<code>{&#39;b&#39;: 1}</code>和<code>{&#39;c&#39;: 1}</code>，变成第一种情况。</p><p>对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> dst:</span><br><span class="line">            merge(dst[key], value)</span><br></pre></td></tr></table></figure><h3 id="dst-中有-src-的-key-且值相同"><a href="#dst-中有-src-的-key-且值相同" class="headerlink" title="dst 中有 src 的 key 且值相同"></a>dst 中有 src 的 key 且值相同</h3><p>在本题中，这种情况不存在，因为这会导致目标字典有相同的 key。但是字典是不能重复的。</p><h3 id="dst中有-src-的-key-且值的类型不同"><a href="#dst中有-src-的-key-且值的类型不同" class="headerlink" title="dst中有 src 的 key 且值的类型不同"></a>dst中有 src 的 key 且值的类型不同</h3><p>这种情况下说明目标字典有问题，无法合并。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">'a_b_c'</span>: <span class="number">1</span></span><br><span class="line"> <span class="string">'a'</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种字典不存在嵌套写法，因为<code>{&#39;a&#39;: 3}</code>与<code>{&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 1}}}</code>只能互相覆盖，不能合并。</p><h3 id="完整写法"><a href="#完整写法" class="headerlink" title="完整写法"></a>完整写法</h3><p><code>merge</code>函数的完整写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dst:</span><br><span class="line">            dst[key] = value</span><br><span class="line">        <span class="keyword">elif</span> isinstance(dst[key], dict) <span class="keyword">and</span> isinstance(value, dict):</span><br><span class="line">            merge(dst[key], value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'数据格式有误，不能转换为嵌套字典'</span>)</span><br></pre></td></tr></table></figure><h2 id="解答问题"><a href="#解答问题" class="headerlink" title="解答问题"></a>解答问题</h2><p>最后我们来解答这个问题，把三个函数结合起来。运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-21-00-23.png" alt></p><p>当传入不能被转换的目标字典时，也会正常报错</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-21-01-43.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;amp;mid=2648977876&amp;amp;idx=1&amp;amp;sn=76c6f8d0a8dabaefe3aa3f666893c991&amp;amp;chksm=f2506c34c527e522478a1c0e07d52075d05c2436bd326662746c1fd854ee922244dcae23b1dd&amp;amp;token=821834861&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用 yield 压平嵌套字典有多简单？&lt;/a&gt;这篇文章中，我们讲到，要把一个多层嵌套的字典压平，可以使用&lt;code&gt;yield&lt;/code&gt;关键字来实现。&lt;/p&gt;
&lt;p&gt;今天，我们倒过来，把一个已经被压平的字典还原成嵌套字典。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>剖析灵魂，为什么aiohttp默认的写法那么慢？</title>
    <link href="https://www.kingname.info/2020/03/23/why-default-aiohttp-slow/"/>
    <id>https://www.kingname.info/2020/03/23/why-default-aiohttp-slow/</id>
    <published>2020-03-23T15:36:58.000Z</published>
    <updated>2020-03-23T15:37:41.416Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们提到了aiohttp官方文档中的默认写法速度与requests单线程请求没有什么区别，需要通过使用<code>asyncio.wait</code>来加速aiohttp的请求。今天我们来探讨一下这背后的原因。</p><a id="more"></a><p>我们使用一个可以通过URL设定返回延迟的网站来进行测试，网址为：<code>http://httpbin.org/delay/5</code>。当<code>delay</code>后面的数字为5时，表示请求这个网址以后，要等5秒才会收到返回；当<code>delay</code>后面的数字为3时，表示请求这个网址以后，要等3秒才会收到返回。大家可以在浏览器上面输入这个网址测试看看。</p><p>现在我们写一段简单的aiohttp代码来进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/3'</span>)</span><br><span class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/5'</span>)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">f'总共耗时：<span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.6或以下需要注释掉上面一行，并为下面两行解除注释</span></span><br><span class="line"><span class="comment">#loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="comment">#loop.run_until_complete(main())</span></span><br></pre></td></tr></table></figure><p>注意，如果你的Python 版本大于等于3.7，那么你可以直接使用<code>asyncio.run</code>来运行一个协程，而不需要像昨天那样先创建一个事件循环再运行。</p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-28-34.png" alt></p><p>可以看到，运行时间大于8秒钟，也就是说，这段代码，是先请求第一个3秒的网址，等它运行完成以后，再请求第二个5秒的网址，他们根本就没有并行！</p><p>按照我们之前的认识，协程在网络 IO 等待的时候，可以交出控制权，当 aiohttp 请求第一个3秒网址，等待返回的时候，应该就可以立刻请求第二个5秒的网址。在等待5秒网址返回的过程中，又去检查第一个3秒请求是否结束了。直到3秒请求已经返回了结果，再等待5秒的请求。</p><p>那为什么上面这段代码，并没有按这段逻辑来走？</p><p>这是因为，协程虽然可以充分利用网络 IO 的等待时间，但它并不会自动这么做。而是需要你把它加入到调度器里面。</p><p>能被 <code>await</code>的对象有3种：协程、Task对象、future 对象。</p><p>当你<code>await 协程</code>对象时，它并没有被加入到调度器中，所以它依然是串行执行的。</p><p>但 Task 对象会被自动加入到调度器中，所以 Task 对象能够并发执行。</p><p>要创建一个 Task 对象非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asyncio.create_task(协程) <span class="comment">#python 3.7或以上版本的写法</span></span><br><span class="line">asyncio.ensure_future(协程)  <span class="comment"># python 3.6或以下的写法</span></span><br></pre></td></tr></table></figure><p>所以我们来稍稍修改一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        start = time.time()</span><br><span class="line">        task1 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/3'</span>))</span><br><span class="line">        task2 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/5'</span>))</span><br><span class="line">        <span class="keyword">await</span> task1</span><br><span class="line">        <span class="keyword">await</span> task2</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">f'总共耗时：<span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-37-55.png" alt></p><p>可以看到，现在请求两个网址的时间加到一起，只比5秒多一点，说明确实已经实现了并发请求的效果。至于这多出来的一点点时间，是因为协程之间切换控制权导致的。</p><p>那么为什么我们把很多协程放进一个 列表里面，然后把列表放进 <code>asyncio.wait</code>里面，也能实现并行呢？这是因为，<code>asyncio.wait</code>帮我们做了创建 Task 的任务。这一点我们可以在Python 的<a href="https://docs.python.org/3/library/asyncio-task.html#waiting-primitives" target="_blank" rel="noopener">官方文档</a>中看到原话：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-43-35.png" alt></p><p>同理，当你把协程传入<code>asyncio.gather</code>时，这些协程也会被当做Task 来调度：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-45-34.png" alt></p><p>回到我们昨天的问题，我们不用<code>asyncio.wait</code>也不用<code>asyncio.Queue</code>让爬虫并发起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, page)</span>:</span></span><br><span class="line">    url = template.format(page=page)</span><br><span class="line">    resp = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">            task = asyncio.create_task(get(session, page))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">            <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/new-fast.2019-12-19 12_56_10.gif" alt></p><p>但你需要注意一点，创建 Task 与<code>await Task</code>是分开执行的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks = []</span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    task = asyncio.create_task(get(session, page))</span><br><span class="line">    tasks.append(task)</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    <span class="keyword">await</span> task</span><br></pre></td></tr></table></figure><p>你不能写成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    task = asyncio.create_task(get(session, page))</span><br><span class="line">    <span class="keyword">await</span> task</span><br></pre></td></tr></table></figure><p>这是因为，创建Task 的时候会自动把它加入到调度队列里面，然后<code>await Task</code>的时候执行调度。上面这样写，会导致每一个 Task 被分批调度，一个 Task 在等待网络 IO 的时候，没有办法切换到第二个 Task，所以最终又会降级成串行请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，我们提到了aiohttp官方文档中的默认写法速度与requests单线程请求没有什么区别，需要通过使用&lt;code&gt;asyncio.wait&lt;/code&gt;来加速aiohttp的请求。今天我们来探讨一下这背后的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="aiohttp" scheme="https://www.kingname.info/tags/aiohttp/"/>
    
  </entry>
  
  <entry>
    <title>为 aiohttp 爬虫注入灵魂</title>
    <link href="https://www.kingname.info/2020/03/23/insert-sprit/"/>
    <id>https://www.kingname.info/2020/03/23/insert-sprit/</id>
    <published>2020-03-23T15:35:14.000Z</published>
    <updated>2020-03-23T15:36:17.499Z</updated>
    
    <content type="html"><![CDATA[<p>听说过异步爬虫的同学，应该或多或少听说过<code>aiohttp</code>这个库。它通过 Python 自带的<code>async/await</code>实现了异步爬虫。</p><p>使用 aiohttp，我们可以通过 requests 的api写出并发量匹敌 Scrapy 的爬虫。</p><a id="more"></a><p>我们在 aiohttp 的官方文档上面，可以看到它给出了一个代码示例，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-18-21-55-56.png" alt></p><p>我们现在稍稍修改一下，来看看这样写爬虫，运行效率如何。</p><p>修改以后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, page)</span>:</span></span><br><span class="line">    url = template.format(page=page)</span><br><span class="line">    resp = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">await</span> get(session, page)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><p>这段代码访问我的爬虫练习站100次，获取100页的内容。</p><p>大家可以通过下面这个视频看看它的运行效率：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/slow.2019-12-18 22_51_37.gif" alt></p><p>可以说，目前这个运行速度，跟 requests 写的单线程爬虫几乎没有区别，代码还多了那么多。</p><p>那么，应该如何正确释放 aiohttp 的超能力呢？</p><p>我们现在把代码做一下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            page = queue.get_nowait()</span><br><span class="line">        <span class="keyword">except</span> asyncio.QueueEmpty:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        url = template.format(page=page)</span><br><span class="line">        resp = <span class="keyword">await</span> session.get(url)</span><br><span class="line">        print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        queue = asyncio.Queue()</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">            queue.put_nowait(page)</span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            task = get(session, queue)</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><p>在修改以后的代码里面，我让这个爬虫爬1000页的内容，我们来看看下面这个视频。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/fast.2019-12-18 22_49_49.gif" alt></p><p>可以看到，目前这个速度已经可以跟 Scrapy 比一比了。并且大家需要知道，这个爬虫只有1个进程1个线程，它是通过异步的方式达到这个速度的。</p><p>那么，修改以后的代码，为什么速度能快那么多呢？</p><p>关键的代码，就在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tasks = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    task = get(session, queue)</span><br><span class="line">    tasks.append(task)</span><br><span class="line"><span class="keyword">await</span> asyncio.wait(tasks)</span><br></pre></td></tr></table></figure><p>在慢速版本里面，我们只有1个协程在运行。而在现在这个快速版本里面，我们创建了100个协程，并把它提交给<code>asyncio.wait</code>来统一调度。<code>asyncio.wait</code>会在所有协程全部结束的时候才返回。</p><p>我们把1000个 URL 放在<code>asyncio.Queue</code>生成的一个异步队列里面，每一个协程都通过 while True 不停从这个异步队列里面取 URL 并进行访问，直到异步队列为空，退出。</p><p>当程序运行时，Python 会自动调度这100个协程，当一个协程在等待网络 IO 返回时，切换到第二个协程并发起请求，在这个协程等待返回时，继续切换到第三个协程并发起请求……。程序充分利用了网络 IO 的等待时间，从而大大提高了运行速度。</p><p>最后，感谢实习生小河给出的这种加速方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听说过异步爬虫的同学，应该或多或少听说过&lt;code&gt;aiohttp&lt;/code&gt;这个库。它通过 Python 自带的&lt;code&gt;async/await&lt;/code&gt;实现了异步爬虫。&lt;/p&gt;
&lt;p&gt;使用 aiohttp，我们可以通过 requests 的api写出并发量匹敌 Scrapy 的爬虫。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="aiohttp" scheme="https://www.kingname.info/tags/aiohttp/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Python读写Kafka？</title>
    <link href="https://www.kingname.info/2020/03/23/operate-kafka-by-python/"/>
    <id>https://www.kingname.info/2020/03/23/operate-kafka-by-python/</id>
    <published>2020-03-23T15:34:07.000Z</published>
    <updated>2020-03-23T15:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<p>关于Kafka的第三篇文章，我们来讲讲如何使用Python读写Kafka。这一篇文章里面，我们要使用的一个第三方库叫做<code>kafka-python</code>。大家可以使用<code>pip</code>或者<code>pipenv</code>安装它。下面两种安装方案，任选其一即可。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install kafka-python</span><br><span class="line">pipenv install kafka-python</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-07-03.png" alt></p><p>这篇文章，我们将会使用最短的代码来实现一个读、写Kafka的示例。</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>由于生产者和消费者都需要连接Kafka，所以我单独写了一个配置文件<code>config.py</code>用来保存连接Kafka所需要的各个参数，而不是直接把这些参数Hard Code写在代码里面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.py</span></span><br><span class="line">SERVER = <span class="string">'123.45.32.11:1234'</span></span><br><span class="line">USERNAME = <span class="string">'kingname'</span></span><br><span class="line">PASSWORD = <span class="string">'kingnameisgod'</span></span><br><span class="line">TOPIC = <span class="string">'howtousekafka'</span></span><br></pre></td></tr></table></figure><p>本文演示所用的Kafka由我司平台组的同事搭建，需要账号密码才能连接，所以我在配置文件中加上了<code>USERNAME</code>和<code>PASSWORD</code>两项。你使用的Kafka如果没有账号和密码，那么你只需要<code>SERVER</code>和<code>TOPIC</code>即可。</p><h2 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h2><p>代码简单到甚至不需要解释。首先使用<code>KafkaProducer</code>类连接 Kafka，获得一个生产者对象，然后往里面写数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=config.SERVER,</span><br><span class="line">                         value_serializer=<span class="keyword">lambda</span> m: json.dumps(m).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    data = &#123;<span class="string">'num'</span>: i, <span class="string">'ts'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</span><br><span class="line">    producer.send(config.TOPIC, data)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>参数<code>bootstrap_servers</code>用于指定 Kafka 的服务器连接地址。</p><p>参数<code>value_serializer</code>用来指定序列化的方式。这里我使用 json 来序列化数据，从而实现我向 Kafka 传入一个字典，Kafka 自动把它转成 JSON 字符串的效果。</p><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-40-18.png" alt></p><p>注意，上图中，我多写了4个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">security_protocol=<span class="string">"SASL_PLAINTEXT"</span></span><br><span class="line">sasl_mechanism=<span class="string">"PLAIN"</span></span><br><span class="line">sasl_plain_username=config.USERNAME</span><br><span class="line">sasl_plain_password=config.PASSWORD</span><br></pre></td></tr></table></figure><p>这四个参数是因为我这里需要通过密码连接 Kafka 而加上的，如果你的 Kafka 没有账号密码，就不需要这四个参数。</p><h2 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h2><p>Kafka 消费者也需要连接 Kafka，首先使用<code>KafkaConsumer</code>类初始化一个消费者对象，然后循环读取数据。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer = KafkaConsumer(config.TOPIC,</span><br><span class="line">                         bootstrap_servers=config.SERVER,</span><br><span class="line">                         group_id=<span class="string">'test'</span>,</span><br><span class="line">                         auto_offset_reset=<span class="string">'earliest'</span>)</span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</span><br><span class="line">    print(msg.value)</span><br></pre></td></tr></table></figure><p>KafkaConsumer 的第一个参数用于指定 Topic。你可以把这个 Topic 理解成 Redis 的 Key。</p><p>bootstrap_servers用于指定 Kafka 服务器连接地址。</p><p>group_id这个参数后面的字符串可以任意填写。如果两个程序的<code>Topic</code>与<code>group_id</code>相同，那么他们读取的数据不会重复，两个程序的<code>Topic</code>相同，但是<code>group_id</code>不同，那么他们各自消费全部数据，互不影响。</p><p>auto_offset_rest 这个参数有两个值，<code>earliest</code>和<code>latest</code>，如果省略这个参数，那么默认就是<code>latest</code>。这个参数会单独介绍。这里先略过。</p><p>连接好 Kafka 以后，直接对消费者对象使用 for 循环迭代，就能持续不断获取里面的数据了。</p><h2 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h2><p>运行两个消费者程序和一个生产者程序，效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-44-26.png" alt></p><p>我们可以看到，两个消费者程序读取数据不重复，不遗漏。</p><p>当所有数据都消费完成以后，如果你把两个消费者程序关闭，再运行其中一个，你会发现已经没有数据会被打印出来了。</p><p>但如果你修改一下 group_id，程序又能正常从头开始消费了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-48-55.png" alt></p><h2 id="很多人都会搞混的几个地方"><a href="#很多人都会搞混的几个地方" class="headerlink" title="很多人都会搞混的几个地方"></a>很多人都会搞混的几个地方</h2><h3 id="earliest-与-latest"><a href="#earliest-与-latest" class="headerlink" title="earliest 与 latest"></a>earliest 与 latest</h3><p>在我们创建消费者对象的时候，有一个参数叫做<code>auto_offset_reset=&#39;earliest&#39;</code>。有人看到<code>earliest</code>与<code>latest</code>，想当然地认为设置为<code>earliest</code>，就是从 Topic 的头往后读，设置为<code>latest</code>就是忽略之前的数据，从程序运行以后，新来的数据开始读。</p><p>这种看法是不正确的。</p><p><code>auto_offset_reset</code>这个参数，只有在一个<code>group</code>第一次运行的时候才有作用，从第二次运行开始，这个参数就失效了。</p><p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test2</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。</p><p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test3</code>。<code>auto_offset_reset</code>设置为 <code>latest</code>。那么当你的消费者运行的时候，Kafka 不会给你返回任何数据，消费者看起来就像卡住了一样，但是 Kafka 会直接强制把前100条数据的状态设置为已经被你消费的状态。所以当前你的 offset 就直接是99了。直到生产者插入了一条新的数据，此时消费者才能读取到。这条新的数据对应的 offset 就变成了100。</p><p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test4</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。等消费到第50条数据时，你把消费者程序关了，把<code>auto_offset_reset</code>设置为<code>latest</code>，再重新运行。此时消费者依然会接着从第51条数据开始读取。不会跳过剩下的50条数据。</p><p>所以，auto_offset_reset的作用，是在你的 group 第一次运行，还没有 offset 的时候，给你设定初始的 offset。而一旦你这个 group 已经有 offset 了，那么auto_offset_reset这个参数就不会再起作用了。</p><h3 id="partition-是如何分配的？"><a href="#partition-是如何分配的？" class="headerlink" title="partition 是如何分配的？"></a>partition 是如何分配的？</h3><p>对于同一个 Topic 的同一个 Group：</p><p>假设你的 Topic 有10个  Partition，一开始你只启动了1个消费者。那么这个消费者会轮换着从这10个Partition 中读取数据。</p><p>当你启动第二个消费者时，Kafka 会从第一个消费者手上抢走5个Partition，分给第二个消费者。于是两个消费者各自读5个 Partition。互不影响。</p><p>当第三个消费者又出现时，Kafka 从第一个消费者手上再抢走1个 Partition，从第二个消费者手上抢走2个 Partition 给第三个消费者。于是，消费者1有4个 Partition，消费者2有3个 Partition，消费者3有3个 Partiton，互不影响。</p><p>当你有10个消费者一起消费时，每个消费者读取一个 Partition，互不影响。</p><p>当第11个消费者出现时，它由于分配不到 Partition，所以它什么都读不到。</p><p>所以在上一篇文章中，我说，在同一个 Topic，同一个 Group 中，你有多少个 Partiton，就能起多少个进程同时消费。</p><h3 id="Kafka-是不是完全不重复不遗漏？"><a href="#Kafka-是不是完全不重复不遗漏？" class="headerlink" title="Kafka 是不是完全不重复不遗漏？"></a>Kafka 是不是完全不重复不遗漏？</h3><p>在极端情况下，Kafka 会重复，也会遗漏，但是这种极端情况并不常见。如果你的 Kafka 频繁漏数据，或者总是出现重复数据，那么肯定是你环境没有搭建正确，或者代码有问题。</p><h3 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h3><p>再次提醒：专业的人做专业的事情，不要轻易自建Kafka 集群。让专门的同事复制搭建和维护，你只管使用。这才是最高效省事的做法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Kafka的第三篇文章，我们来讲讲如何使用Python读写Kafka。这一篇文章里面，我们要使用的一个第三方库叫做&lt;code&gt;kafka-python&lt;/code&gt;。大家可以使用&lt;code&gt;pip&lt;/code&gt;或者&lt;code&gt;pipenv&lt;/code&gt;安装它。下面两种安装方案，任选其一即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="https://www.kingname.info/categories/Kafka/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 里面的信息是如何被消费的？</title>
    <link href="https://www.kingname.info/2020/03/23/how-kafka-consume/"/>
    <id>https://www.kingname.info/2020/03/23/how-kafka-consume/</id>
    <published>2020-03-23T15:32:45.000Z</published>
    <updated>2020-03-23T15:36:36.199Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就可以m’ys’q作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就何读取就可以可了。</p><blockquote><p>请谨记：使用 Kafka 很容易，但对 Kafka 集群进行搭建、维护与调优很麻烦。Kafka 集群需要有专人来维护，不要以为你能轻易胜任这个工作。</p></blockquote><a id="more"></a><p>本文，以及接下来的几篇针对 Kafka 的文章，我们面向的对象都是爬虫工程师或者仅仅需要使用 Kafka 的读者。关于 Kafka 更深入的底层细节与核心原理，不在我们的讨论范围中。为了解释方便，文章中对 Kafka 的一些术语会使用一些不太准确但能表明意思的类比。如果你需要在面试中解释这些术语，还请阅读Kafka 的官方文档。</p><p>今天我们要讨论的一个话题是，Kafka 是如何做到，对单个程序的多个进程而言，能持续消费，断点续传和并行消费；对多个程序而言又互不影响，各自独立。</p><p>一个 Kafka 可以有多个不同的队列，我们把这个队列叫做<code>Topic</code>，假设其中一个队列如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-14-00.png" alt></p><p>信息从右边进去，从左边出来。如果这是Redis 的列表，那么它弹出一条信息以后，队列会变成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-15-28.png" alt></p><p>最左边的<code>信息1</code>不见了。所以即使程序在消费了<code>信息1</code>后立刻关闭，再重新打开，程序也会接着从<code>信息2</code>开始消费，不会把<code>信息1</code>重复消费两次。</p><p>但我如果有两个程序呢？程序1读取每一条数据，再转存到数据库。程序2读取每一条数据，再检查是否有关键词。这种情况下，<code>信息1</code>应该能被程序1消费，也能被程序2消费。但上面这种方案显然是不行的。当程序1消费了<code>信息1</code>，程序2就再也拿不到它了。</p><p>所以，在 Kafka 里面，信息会停留在队列里面，但对每一个程序来说，有一个单独的记号，来记录当前消费到了哪一条数据，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-23-41.png" alt></p><p>当程序1要读取 Kafka 里面下一条数据时，Kafka 先把当前位置的标记向右移动一位，把新的这个值返回出来。标记移动与返回这两个操作合在一起算是一个原子操作，不会出现重复读取的问题。</p><p>程序1与程序2使用的是不同的标记，所以各自的标记指向哪个值，是互不影响的。</p><p>当增加一个程序3的时候，只需要再加一个标记即可。新的这个标记也不受前两个标记的影响。</p><p>这就实现了在多个不同的程序读取  Kafka 时，各自互不影响。</p><p>现在如果你觉得程序1消费太慢了，把程序1同时运行了3次，那么由于标记和移位是原子操作，即使你看起来程序是同时去读取 Kafka，但在内部 Kafka 也会对他们进行“排队”，从而使得他们返回的结果不重复，不遗漏。</p><p>如果你在网上看 Kafka 的教程，你会发现他们提到了一个叫做 <code>Offset</code> 的东西，实际上就是本文所说的各个程序里面指向当前数据的<code>标记</code>。</p><p>你还会看到一个关键词叫做<code>Group</code>，实际上对应到本文的<code>程序1</code>，<code>程序2</code>和<code>程序3</code>。</p><p>对同一个队列，如果多个程序使用不同的<code>Group</code>消费，那么他们读取的数据就互不干扰。</p><p>对同一个队列，相同 Group 的多个进程在消费数据时，看起来就像是在对 Redis 进行 lpop 操作一样。</p><p>最后，你在网上关于 Kafka 的文章里面，一定会看到一个词叫做<code>Paritition</code>或者中文<code>分片</code>。而且你会发现你无法理解这个东西。</p><p>没关系，忘记它吧。你只需要知道，一个 Topic 有多少个 Partition，那么你最多能启动多少个进程读取同一个 Group。——如果一个Topic有3个Partition，那么你只能最多开3个进程同时读相同的 Group。 Topic如果有5个Partition，那么你只能最多开5个进程读同一个 Group。</p><p>下一篇文章，我们用 Python 来读写一下 Kafka。只需要几行代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就可以m’ys’q作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就何读取就可以可了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请谨记：使用 Kafka 很容易，但对 Kafka 集群进行搭建、维护与调优很麻烦。Kafka 集群需要有专人来维护，不要以为你能轻易胜任这个工作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kafka" scheme="https://www.kingname.info/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>GNE v0.1 正式发布： 4 行代码开发新闻网站通用爬虫</title>
    <link href="https://www.kingname.info/2020/01/01/gne-release/"/>
    <id>https://www.kingname.info/2020/01/01/gne-release/</id>
    <published>2020-01-01T11:07:33.000Z</published>
    <updated>2020-03-23T15:34:45.069Z</updated>
    
    <content type="html"><![CDATA[<p>GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。</p><a id="more"></a><p>使用方式非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</span><br><span class="line"></span><br><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">html = <span class="string">'网站源代码'</span></span><br><span class="line">result = extractor.extract(html)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>GNE 的输入是<code>经过 js 渲染以后的</code> HTML 代码，所以 GNE 可以配合Selenium 或者 Pyppeteer 使用。</p><p>下图是 GNE 配合 Selenium 实现的一个 Demo：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-51-47.png" alt></p><p>对应的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'https://www.toutiao.com/a6766986211736158727/'</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">result = extractor.extract(driver.page_source)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>下图是 GNE 配合 Pyppeteer 实现的 Demo：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-07-14.png" alt></p><p>对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(executablePath=<span class="string">'/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://news.163.com/20/0101/17/F1QS286R000187R2.html'</span>)</span><br><span class="line">    extractor = GeneralNewsExtractor()</span><br><span class="line">    result = extractor.extract(<span class="keyword">await</span> page.content())</span><br><span class="line">    print(result)</span><br><span class="line">    input(<span class="string">'检查完成以后回到这里按下任意键'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h2 id="如何安装-GNE"><a href="#如何安装-GNE" class="headerlink" title="如何安装 GNE"></a>如何安装 GNE</h2><p>现在你可以直接使用 pip 安装 GNE 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gne</span><br></pre></td></tr></table></figure><p>如果访问pypi 官方源太慢，你也可以使用网易源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gne -i https://mirrors.163.com/pypi/simple/</span><br></pre></td></tr></table></figure><p>安装过程如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-34-36.png" alt></p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><h3 id="获取正文源代码"><a href="#获取正文源代码" class="headerlink" title="获取正文源代码"></a>获取正文源代码</h3><p>在<code>extract()</code>方法只传入网页源代码，不添加任何额外参数时，GNE 返回如下字段：</p><ul><li>title：新闻标题</li><li>publish_time：新闻发布时间</li><li>author：新闻作者</li><li>content：新闻正文</li><li>images: 正文中的图片（相对路径或者绝对路径）</li></ul><p>可能有些朋友希望获取新闻正文所在标签的源代码，此时可以给<code>extract()</code>方法传入<code>with_body_html</code>参数，设置为 True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">extractor.extract(html, with_body_html=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>返回数据中将会增加一个字段<code>body_html</code>，它的值就是正文对应的 HTML 源代码。</p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-16-25.png" alt></p><h3 id="总是返回图片的绝对路径"><a href="#总是返回图片的绝对路径" class="headerlink" title="总是返回图片的绝对路径"></a>总是返回图片的绝对路径</h3><p>默认情况下，如果新闻中的图片使用的是相对路径，那么 GNE 返回的<code>images</code>字段对应的值也是图片相对路径的列表。</p><p>如果你想始终让 GNE 返回绝对路径，那么你可以给<code>extract()</code>方法增加<code>host</code>参数，这个参数的值是图片的域名，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">extractor.extract(html, host=<span class="string">'https://www.kingname.info'</span>)</span><br></pre></td></tr></table></figure><p>这样，如果新闻中的图片是<code>/images/pic.png</code>，那么 GNE 返回时会自动把它变为<code>https://www.kingname.info/images/pic.png</code>。</p><h3 id="指定新闻标题所在的-XPath"><a href="#指定新闻标题所在的-XPath" class="headerlink" title="指定新闻标题所在的 XPath"></a>指定新闻标题所在的 XPath</h3><p>GNE 预定义了一组 XPath 和正则表达式用于提取新闻的标题。但某些特殊的新闻网站可能无法提取标题，此时，你可以给<code>extract()</code>方法指定<code>title_xpath</code>参数，用于提取新闻标题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">extractor.extract(html, title_xpath=<span class="string">'//title/text()'</span>)</span><br></pre></td></tr></table></figure><h3 id="提前移除噪声标签"><a href="#提前移除噪声标签" class="headerlink" title="提前移除噪声标签"></a>提前移除噪声标签</h3><p>某些新闻下面可能会存在长篇大论的评论，这些评论看起来比新闻正文“更像”正文，为了防止他们干扰新闻的提取，可以通过给<code>extract()</code>方法传入<code>noise_node_list</code>参数，提前把这些噪声节点移除。<code>noise_node_list</code>的值是一个列表，里面是一个或多个 XPath：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extractor = GeneralNewsExtractor()</span><br><span class="line">extractor.extract(html, noise_node_list=[<span class="string">'//div[@class="comment-list"]'</span>, <span class="string">'//*[@style="display:none"]'</span>])</span><br></pre></td></tr></table></figure><h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>API 中的参数 <code>title_xpath</code>、 <code>host</code>、 <code>noise_node_list</code>、 <code>with_body_html</code>除了直接写到 <code>extract()</code> 方法中外，还可以通过一个配置文件来设置。</p><p>请在项目的根目录创建一个文件 <code>.gne</code>，配置文件可以用 YAML 格式，也可以使用 JSON 格式。</p><ul><li>YAML 格式配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line">   <span class="attr">xpath:</span> <span class="string">//title/text()</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">https://www.xxx.com</span></span><br><span class="line"><span class="attr">noise_node_list:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">//div[@class=\"comment-list\"]</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">//*[@style=\"display:none\"]</span></span><br><span class="line"><span class="attr">with_body_html:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>JSON 格式配置文件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"title"</span>: &#123;</span><br><span class="line">       <span class="attr">"xpath"</span>: <span class="string">"//title/text()"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"host"</span>: <span class="string">"https://www.xxx.com"</span>,</span><br><span class="line">   <span class="attr">"noise_node_list"</span>: [<span class="string">"//div[@class=\"comment-list\"]"</span>,</span><br><span class="line">                       <span class="string">"//*[@style=\"display:none\"]"</span>],</span><br><span class="line">   <span class="attr">"with_body_html"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种写法是完全等价的。</p><p>配置文件与 <code>extract()</code> 方法的参数一样，并不是所有字段都需要提供。你可以组合填写你需要的字段。</p><p>如果一个参数，既在 <code>extract()</code> 方法中，又在 <code>.gne</code> 配置文件中，但值不一样，那么 <code>extract()</code> 方法中的这个参数的优先级更高。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="GeneralNewsExtractor-以下简称GNE-是爬虫吗？"><a href="#GeneralNewsExtractor-以下简称GNE-是爬虫吗？" class="headerlink" title="GeneralNewsExtractor(以下简称GNE)是爬虫吗？"></a>GeneralNewsExtractor(以下简称GNE)是爬虫吗？</h3><p>GNE不是爬虫，它的项目名称General News Extractor表示通用新闻抽取器。它的输入是HTML，输出是一个包含新闻标题，新闻正文，作者，发布时间的字典。你需要自行设法获取目标网页的HTML。</p><p>GNE 现在不会，将来也不会提供请求网页的功能。</p><h3 id="GNE支持翻页吗？"><a href="#GNE支持翻页吗？" class="headerlink" title="GNE支持翻页吗？"></a>GNE支持翻页吗？</h3><p>GNE不支持翻页。因为GNE不会提供网页请求的功能，所以你需要自行获取每一页的HTML，并分别传递给GNE。</p><h3 id="GNE支持哪些版本的Python？"><a href="#GNE支持哪些版本的Python？" class="headerlink" title="GNE支持哪些版本的Python？"></a>GNE支持哪些版本的Python？</h3><p>不小于Python 3.6.0</p><h3 id="我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？"><a href="#我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？" class="headerlink" title="我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？"></a>我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？</h3><p>GNE是基于HTML来提取正文的，所以传入的HTML一定要是经过JavaScript渲染以后的HTML。而requests和Scrapy获取的只是JavaScript渲染之前的源代码，所以无法正确提取。</p><p>另外，有一些网页，例如今日头条，它的新闻正文实际上是以JSON格式直接写在网页源代码的，当页面在浏览器上面打开的时候，JavaScript把源代码里面的正文解析为HTML。这种情况下，你在Chrome上面就看不到Ajax请求。</p><p>所以建议你使用Puppeteer/Pyppeteer/Selenium之类的工具获取经过渲染的HTML再传入GNE。</p><h3 id="GNE-支持非新闻类网站吗（例如博客、论坛……）"><a href="#GNE-支持非新闻类网站吗（例如博客、论坛……）" class="headerlink" title="GNE 支持非新闻类网站吗（例如博客、论坛……）"></a>GNE 支持非新闻类网站吗（例如博客、论坛……）</h3><p>不支持。</p><h2 id="关于-GNE"><a href="#关于-GNE" class="headerlink" title="关于 GNE"></a>关于 GNE</h2><p>GNE 官方文档：<a href="https://generalnewsextractor.readthedocs.io/" target="_blank" rel="noopener">https://generalnewsextractor.readthedocs.io/</a></p><p>GNE 的项目源代码在：<a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="noopener">https://github.com/kingname/GeneralNewsExtractor</a>。</p><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>如果您觉得GNE对您的日常开发或公司有帮助，请加作者微信 mxqiuchen（或扫描下方二维码） 并注明”GNE”，作者会将你拉入群。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_3729_2.JPG" alt></p><p>验证消息：<code>GNE</code></p><p>我的公众号：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么每一个爬虫工程师都应该学习 Kafka</title>
    <link href="https://www.kingname.info/2019/12/14/use-kakfa-in-spider/"/>
    <id>https://www.kingname.info/2019/12/14/use-kakfa-in-spider/</id>
    <published>2019-12-14T00:36:02.000Z</published>
    <updated>2019-12-14T00:38:53.112Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。</p><a id="more"></a><h2 id="一个简单的需求"><a href="#一个简单的需求" class="headerlink" title="一个简单的需求"></a>一个简单的需求</h2><p>假设我们需要写一个微博爬虫，老板给的需求如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-35-25.png" alt></p><p>开发爬虫对你来说非常简单，于是三下五除二你就把爬虫开发好了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-39-18.png" alt></p><p>接下来开始做报警功能，逻辑也非常简单：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-52-50.png" alt></p><p>再来看看统计关键词的功能，这个功能背后有一个网页，会实时显示抓取数据量的变化情况，可以显示每分钟、每小时的某个关键词的抓取量。</p><p>这个功能对你来说也挺简单，于是你实现了如下逻辑：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-16-03.png" alt></p><p>最后一个需求，对微博数据进行情感分析。情感分析的模块有别的部门同事开发，你要做的就是每个小时拉取一批数据，发送到接口，获取返回，然后存入后端需要的数据库：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-12-52.png" alt></p><p>任务完成，于是你高兴地回家睡觉了。</p><h2 id="困难接踵而至"><a href="#困难接踵而至" class="headerlink" title="困难接踵而至"></a>困难接踵而至</h2><h3 id="爬虫变慢了"><a href="#爬虫变慢了" class="headerlink" title="爬虫变慢了"></a>爬虫变慢了</h3><p>随着老板逐渐增加新的关键词，你发现每一次完整抓取的时间越来越长，一开始是2分钟抓取一轮，后来变成10分钟一轮，然后变成30分钟一轮，接下来变成1小时才能抓取一轮。随着延迟越来越高，你的报警越来越不准确，微博都发出来一小时了，你的报警还没有发出来，因为那一条微博还没有来得及入库。</p><p>你的爬虫技术非常好，能绕过所有反爬虫机制，你有无限个代理 IP，于是你轻轻松松就把爬虫提高到了每秒一百万并发。现在只需要1分钟你就能完成全部数据的抓取。这下没问题了吧。</p><p>可是报警还是没有发出来。这是怎么回事？</p><h3 id="数据库撑不住了"><a href="#数据库撑不住了" class="headerlink" title="数据库撑不住了"></a>数据库撑不住了</h3><p>经过排查，你发现了问题。数据抓取量上来了，但是 MongoDB 却无法同时接收那么多的数据写入。数据写入速度远远小于爬取数据，大量的数据堆积在内存中。于是你的服务器爆炸了。</p><p>你紧急搭建了100个数据库并编号0-99，对于抓取到的微博，先把每一条微博的 ID对100求余数，然后把数据存入余数对应的 MongoDB 中。每一台 MongoDB 的压力下降到了原来的1%。数据终于可以即时存进数据库里面了。</p><p>可是报警还是没有发出来，不仅如此，现在实时抓取量统计功能也不能用了，还有什么问题？</p><h3 id="查询来不及了"><a href="#查询来不及了" class="headerlink" title="查询来不及了"></a>查询来不及了</h3><p>现在报警程序要遍历100个数据库最近5分钟里面的每一条数据，确认是否有需要报警的内容。但是这个遍历过程就远远超过5分钟。</p><h3 id="时间错开了"><a href="#时间错开了" class="headerlink" title="时间错开了"></a>时间错开了</h3><p>由于微博的综合搜索功能不是按照时间排序的，那么就会出现这样一种情况，早上10:01发的微博，你在12:02的时候才抓到。</p><p>不论你是在报警的时候筛选数据，还是筛选数据推送给 NLP 分析接口，如果你是以微博的发布时间来搜索，那么这一条都会被你直接漏掉——当你在10:05的时候检索10:00-10:05这5分钟发表的微博，由于这一条微博没有抓到，你自然搜索不到。</p><p>当你12:05开始检索12:00-12:05的数据时，你搜索的是发布时间为12:00-12:05的数据，于是10:01这条数据虽然是在12:02抓到的，但你也无法筛选出来。</p><p>那么是不是可以用抓取时间来搜索呢？例如10:05开始检索在10:00-10:05抓取到的数据，无论它的发布时间是多少，都检索出来。</p><p>这样做确实可以保证不漏掉数据，但这样做的代价是你必需保存、检索非常非常多的数据。例如每次抓取，只要发布时间是最近10小时的，都要保存下来。于是报警程序在检索数据时，就需要检索这5分钟入库的，实际上发布时间在10小时内的全部数据。</p><p>什么，你说每次保存之前检查一下这条微博是否已经存在，如果存在就不保存？别忘了批量写入时间都不够了，你还准备分一些时间去查询？</p><h3 id="脏数据来了"><a href="#脏数据来了" class="headerlink" title="脏数据来了"></a>脏数据来了</h3><p>老板突然来跟你说，关键词“篮球”里面有大量的关于 蔡徐坤的内容，所以要你把所有包含蔡徐坤的数据全部删掉。</p><p>那么，这个过滤逻辑放在哪里？放在爬虫的 pipelines.py 里面吗？那你要重新部署所有爬虫。今天是过滤蔡徐坤，明天是过滤范层层，后天是过滤王一博，每天增加关键词，你每天都得重新部署爬虫？</p><p>那你把关键词放在 Redis 或者 MongoDB 里面，每次插入数据前，读取所有关键词，看微博里面不包含再存。</p><p>还是那个问题，插入时间本来就不够了，你还要查数据库？</p><p>好，关键词过滤不放在爬虫里面了。你写了一个脚本，每分钟检查一次MongoDB新增的数据，如果发现包含 不需要的关键词，就把他删除。</p><p>现在问题来了，删除数据的程序每分钟检查一次，报警程序每5分钟检查一次。中间必定存在某些数据，还没有来得及删除，报警程序就报警了，老板收到报警来看数据，而你的删除程序又在这时把这个脏数据删了。</p><p>这下好了，天天报假警，狼来了的故事重演了。</p><h2 id="5个问题1个救星"><a href="#5个问题1个救星" class="headerlink" title="5个问题1个救星"></a>5个问题1个救星</h2><p>如果你在爬虫开发的过程中遇到过上面的诸多问题，那么，你就应该试一试使用 Kafka。一次性解决上面的所有问题。</p><p>把 Kafka 加入到你的爬虫流程中，那么你的爬虫架构变成了下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-34-55.png" alt></p><p>这看起来似乎和数据直接写进 MongoDB 里面，然后各个程序读取 MongoDB 没什么区别啊？那 Kafka 能解决什么问题？</p><p>我们来看看，在这个爬虫架构里面，我们将会用到的 Kafka 的特性：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-39-28.png" alt></p><p>与其说 Kafka 在这个爬虫架构中像 MongoDB，不如说更像 Redis 的列表。</p><p>现在来简化一下我们的模型，如果现在爬虫只有一个需求，就是搜索，然后报警。那么我们可以这样设计：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-46-23.png" alt></p><p>爬虫爬下来的数据，直接塞进 Redis 的列表右侧。报警程序从 Redis 列表左侧一条一条读取。读取一条检视一条，如果包含报警关键词，就报警。然后读取下一条。</p><p>这样做有什么好处？</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-50-27.png" alt></p><p>因为报警程序直接从 Redis 里面一条一条读取，不存在按时间搜索数据的过程，所以不会有数据延迟的问题。由于 Redis 是单线程数据库，所以可以同时启动很多个报警程序。由于 lpop 读取一条就删除一条，如果报警程序因为某种原因崩溃了，再把它启动起来即可，它会接着工作，不会重复报警。</p><p>但使用 Redis 列表的优势也是劣势：列表中的信息只能消费1次，被弹出了就没有了。</p><p>所以如果既需要报警，还需要把数据存入 MongoDB 备份，那么只有一个办法，就是报警程序检查完数据以后，把数据存入 MongoDB。</p><blockquote><p>可我只是一个哨兵，为什么要让我做后勤兵的工作？</p></blockquote><p>一个报警程序，让它做报警的事情就好了，它不应该做储存数据的事情。</p><p>而使用 Kafka，它有 Redis 列表的这些好处，但又没有 Redis 列表的弊端！</p><p>我们完全可以分别实现4个程序，不同程序之间消费数据的快慢互不影响。但同一个程序，无论是关闭再打开，还是同时运行多次，都不会重复消费。</p><h3 id="程序1：报警"><a href="#程序1：报警" class="headerlink" title="程序1：报警"></a>程序1：报警</h3><p>从 Kafka 中一条一条读取数据，做报警相关的工作。程序1可以同时启动多个。关了再重新打开也不会重复消费。</p><h3 id="程序2：储存原始数据"><a href="#程序2：储存原始数据" class="headerlink" title="程序2：储存原始数据"></a>程序2：储存原始数据</h3><p>这个程序从 Kafka 中一条一条读取数据，每凑够1000条就批量写入到 MongoDB 中。这个程序不要求实时储存数据，有延迟也没关系。 存入MongoDB中也只是原始数据存档。一般情况下不会再从 MongoDB 里面读取出来。</p><h3 id="程序3：统计"><a href="#程序3：统计" class="headerlink" title="程序3：统计"></a>程序3：统计</h3><p>从 Kafka 中读取数据，记录关键词、发布时间。按小时和分钟分别对每个关键词的微博计数。最后把计数结果保存下来。</p><h3 id="程序4：情感分析"><a href="#程序4：情感分析" class="headerlink" title="程序4：情感分析"></a>程序4：情感分析</h3><p>从 Kafka 中读取每一条数据，凑够一批发送给 NLP 分析接口。拿到结果存入后端数据库中。</p><h3 id="如果要清洗数据怎么办"><a href="#如果要清洗数据怎么办" class="headerlink" title="如果要清洗数据怎么办"></a>如果要清洗数据怎么办</h3><p>4个需求都解决了，那么如果还是需要你首先移除脏数据，再分析怎么办呢？实际上非常简单，你加一个 Kafka（Topic） 就好了！</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-11-27.png" alt></p><h2 id="大批量通用爬虫"><a href="#大批量通用爬虫" class="headerlink" title="大批量通用爬虫"></a>大批量通用爬虫</h2><p>除了上面的微博例子以外，我们再来看看在开发通用爬虫的时候，如何应用 Kafka。</p><p>在任何时候，无论是 XPath 提取数据还是解析网站返回的 JSON，都不是爬虫开发的主要工作。爬虫开发的主要工作一直是爬虫的调度和反爬虫的开发。</p><p>我们现在写 Scrapy 的时候，处理反爬虫的逻辑和提取数据的逻辑都是写在一个爬虫项目中的，那么在开发的时候实际上很难实现多人协作。</p><p>现在我们把网站内容的爬虫和数据提取分开，实现下面这样一个爬虫架构：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-22-51.png" alt></p><p>爬虫开发技术好的同学，负责实现绕过反爬虫，获取网站的内容，无论是 HTML 源代码还是接口返回的JSON。拿到以后，直接塞进 Kafka。</p><p>爬虫技术相对一般的同学、实习生，需要做的只是从 Kafka 里面获取数据，不需要关心这个数据是来自于 Scrapy 还是 Selenium。他们要做的只是把这些HTML 或者JSON 按照产品要求解析成格式化的数据，然后塞进 Kafka，供后续数据分析的同学继续读取并使用。</p><p>如此一来，一个数据小组的工作就分开了，每个人做各自负责的事情，约定好格式，同步开发，互不影响。</p><h2 id="为什么是-Kafka-而不是其他"><a href="#为什么是-Kafka-而不是其他" class="headerlink" title="为什么是 Kafka 而不是其他"></a>为什么是 Kafka 而不是其他</h2><p>上面描述的功能，实际上有不少 MQ 都能实现。但为什么是 Kafka 而不是其他呢？因为Kafka 集群的性能非常高，在垃圾电脑上搭建的集群能抗住每秒10万并发的数据写入量。而如果选择性能好一些的服务器，每秒100万的数据写入也能轻松应对。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章通过两个例子介绍了 Kafka 在爬虫开发中的作用。作为一个爬虫工程师，作为我的读者。请一定要掌握 Kafka。</p><p>下一篇文章，我们来讲讲如何使用 Kafka。比你在网上看到的教程会更简单，更容易懂。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt></p><p>关注本公众号，回复“爬虫与Kafka”获取本文对应的思维导图原图。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中实现函数重载</title>
    <link href="https://www.kingname.info/2019/12/11/singledispatch/"/>
    <id>https://www.kingname.info/2019/12/11/singledispatch/</id>
    <published>2019-12-11T15:01:25.000Z</published>
    <updated>2019-12-11T15:01:58.828Z</updated>
    
    <content type="html"><![CDATA[<p>假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</span><br><span class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</span><br></pre></td></tr></table></figure><p>你想在代码里面兼容这两种写法，于是你可能会这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(address, str):</span><br><span class="line">        ip, port = address.split(<span class="string">':'</span>)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(address, tuple):</span><br><span class="line">        ip, port = address</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'地址格式不正确'</span>)</span><br></pre></td></tr></table></figure><p>这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 <code>if-elif-elif-...-else</code>。代码看起来就非常不美观。</p><p>学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。</p><p>在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 <code>if-else</code>外，我们还可以使用<code>functools</code>模块里面的<code>singledispatch</code>装饰器实现函数重载。</p><a id="more"></a><p>我们来写一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></span><br><span class="line">    print(<span class="string">f' 传输参数类型为：<span class="subst">&#123;type(address)&#125;</span>，不是有效类型'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@connect.register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: str)</span>:</span></span><br><span class="line">    ip, port = address.split(<span class="string">':'</span>)</span><br><span class="line">    print(<span class="string">f'参数为字符串，IP是：<span class="subst">&#123;ip&#125;</span>, 端口是：<span class="subst">&#123;port&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@connect.register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: tuple)</span>:</span></span><br><span class="line">    ip, port = address</span><br><span class="line">    print(<span class="string">f'参数为元组，IP是：<span class="subst">&#123;ip&#125;</span>, 端口是：<span class="subst">&#123;port&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</span><br><span class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</span><br><span class="line">connect(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>我们运行一下这段代码，大家看看根据参数的不同，有什么样的不同效果：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-11-21-55-13.png" alt></p><p>可以看到，我们调用的函数，始终都是<code>connect</code>，但是由于传入参数的类型不同，它运行的结果也不一样。</p><p>我们使用<code>singledispatch</code>装饰一个函数，那么这个函数就是我们将会调用的函数。</p><p>这个函数在传入参数不同时的具体实现，通过下面注册的函数来实现。注册的时候使用<code>@我们定义的函数名.register</code>来注册。被注册的函数名叫什么无关紧要，所以这里我都直接使用下划线代替。</p><p>被注册的函数的第一个参数，通过类型标注来确定它应该使用什么类型。当我们调用我们定义的函数是，如果参数类型符合某个被注册的函数，那么就会执行这个被注册的函数。如果参数类型不满足任何一个被注册的函数，那么就会执行我们的原函数。</p><p>使用类型标注来指定参数类型是从 Python 3.7才引入的新特性。在 Python 3.6或之前的版本，我们需要通过<code>@我们定义的函数名.register(类型)</code>来指定类型，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></span><br><span class="line">    print(<span class="string">f' 传输参数类型为：<span class="subst">&#123;type(address)&#125;</span>，不是有效类型'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@connect.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></span><br><span class="line">    ip, port = address.split(<span class="string">':'</span>)</span><br><span class="line">    print(<span class="string">f'参数为字符串，IP是：<span class="subst">&#123;ip&#125;</span>, 端口是：<span class="subst">&#123;port&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@connect.register(tuple)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></span><br><span class="line">    ip, port = address</span><br><span class="line">    print(<span class="string">f'参数为元组，IP是：<span class="subst">&#123;ip&#125;</span>, 端口是：<span class="subst">&#123;port&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>同时，还有一个需要注意的点，就是只有第一个参数的不同类型会被重载。后面的参数的类型变化会被自动忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;connect(&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18:8080&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connect((&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你想在代码里面兼容这两种写法，于是你可能会这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(address)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isinstance(address, str):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ip, port = address.split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; isinstance(address, tuple):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ip, port = address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;地址格式不正确&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 &lt;code&gt;if-elif-elif-...-else&lt;/code&gt;。代码看起来就非常不美观。&lt;/p&gt;
&lt;p&gt;学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。&lt;/p&gt;
&lt;p&gt;在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 &lt;code&gt;if-else&lt;/code&gt;外，我们还可以使用&lt;code&gt;functools&lt;/code&gt;模块里面的&lt;code&gt;singledispatch&lt;/code&gt;装饰器实现函数重载。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
</feed>
