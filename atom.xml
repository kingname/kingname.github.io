<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2021-06-19T08:51:46.804Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么爬虫工程师应该有一些基本的后端常识？</title>
    <link href="https://www.kingname.info/2021/06/19/crawler-should-know-backend/"/>
    <id>https://www.kingname.info/2021/06/19/crawler-should-know-backend/</id>
    <published>2021-06-19T08:50:43.000Z</published>
    <updated>2021-06-19T08:51:46.804Z</updated>
    
    <content type="html"><![CDATA[<p>今天在粉丝交流群里面，有个同学说他发现了<code>Requests</code>的一个 bug，并修复了它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png" alt></p><p>聊天记录中对应的图片为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png" alt></p><p>看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。</p><a id="more"></a><p>要解释这个问题，我们需要首先明白一个问题，那就是 JSON 字符串的两种显示形式和<code>json.dumps</code>的<code>ensure_ascii</code>参数。</p><p>假设我们在 Python 里面有一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>当我们想把它转成 JSON 字符串的时候，我们可能会这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">info_str = json.dumps(info)</span><br><span class="line">print(info_str)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，中文变成了 Unicode 码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-33-18.png" alt></p><p>我们也可以增加一个参数<code>ensure_ascii=False</code>，让中文正常显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_str = json.dumps(info, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-34-30.png" alt></p><p>这位同学认为，由于<code>{&quot;name&quot;: &quot;\u9752\u5357&quot;, &quot;age&quot;: 20}</code>和<code>{&quot;name&quot;: &quot;青南&quot;, &quot;age&quot;: 20}</code>从字符串角度看，显然不相等。而 Requests 在 POST 发送数据的时候，默认是没有这个参数，而对<code>json.dumps</code>来说，省略这个参数等价于<code>ensure_ascii=True</code>：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-37-27.png" alt></p><p>所以实际上<code>Requests</code>在 POST 含有中文的数据时，会把中文转成 Unicode 码发给服务器，于是服务器根本就拿不到原始的中文信息了。所以就会导致报错。</p><p>但实际上，并不是这样的。我常常跟群里的同学说，做爬虫的同学，应该要有一些基本的后端常识，才不至于被这种现象误导。为了说明为什么上面这个同学的理解是错误的，为什么这不是 Requests 的 bug，我们自己来写一个含有 POST 的服务，来看看我们POST 两种情况的数据有没有区别。为了证明这个特性与网络框架无关，我这里分别使用Flask、Fastapi 、Gin 来进行演示。</p><p>首先，我们来看看Requests 测试代码。这里用3种方式发送了 JSON 格式的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line">body = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'青南'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'http://127.0.0.1:5000/test_json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 json=的方式发送</span></span><br><span class="line">resp = requests.post(url, json=body).json() </span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文转成 Unicode，跟第一种方式等价</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body)).json()</span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文保留</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body, ensure_ascii=<span class="literal">False</span>).encode()).json()</span><br><span class="line">print(resp)</span><br></pre></td></tr></table></figure><p>这段测试代码使用3种方式发送 POST 请求，其中，第一种方法就是 Requests 自带的<code>json=</code>参数，参数值是一个字典。Requests 会自动把它转成 JSON 字符串。后两种方式，是我们手动提前把字典转成 JSON 字符串，然后使用<code>data=</code>参数发送给服务器。这两种方式需要在 Headers 里面指明<code>&#39;Content-Type&#39;: &#39;application/json&#39;</code>，服务器才知道发上来的是 JSON 字符串。</p><p>我们再来看看 Flask 写的后端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test_json', methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    body = request.json </span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body[<span class="string">"name"</span>]=&#125;</span>, <span class="subst">&#123;body[<span class="string">"age"</span>]=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-51-17.png" alt></p><p>可以看到，无论使用哪种 POST 方式，后端都能接收到正确的信息。</p><p>我们再来看 Fastapi 版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int </span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post('/test_json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">(body: Body)</span>:</span></span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body.name=&#125;</span>, <span class="subst">&#123;body.age=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，三种 POST 发送的数据，都能被后端正确识别：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-53-52.png" alt></p><p>我们再来看看 Gin 版本的后端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age  <span class="keyword">int16</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"running"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.POST(<span class="string">"/test_json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        json := Body&#123;&#125;</span><br><span class="line">        c.BindJSON(&amp;json)</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age)</span><br><span class="line">        fmt.Println(<span class="string">"&gt;&gt;&gt;"</span>, msg)</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下，三种请求方式的数据完全相同：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-56-23.png" alt></p><p>从这里可以知道，无论我们 POST 提交的 JSON 字符串中，中文是以 Unicode 码的形式存在还是直接以汉字的形式存在，后端服务都可以正确解析。</p><p>为什么我说中文在 JSON 字符串里面以哪种形式显示并不重要呢？这是因为，对 JSON 字符串来说，编程语言把它重新转换为对象的过程（叫做<code>反序列化</code>），本身就可以正确处理他们。我们来看下图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-16-05-25.png" alt></p><p><code>ensure_ascii</code>参数的作用，仅仅控制的是 JSON 的显示样式，当<code>ensure_ascii</code>为<code>True</code>的时候，确保 JSON 字符串里面只有 ASCII 字符，所以不在 ASCII 128个字符内的字符，都会被转换。而当<code>ensure_ascii</code>为<code>False</code>的时候，这些非 ASCII 字符依然以原样显示。这就像是一个人化妆和不化妆一样，本质并不会改变。现代化的编程语言在对他们进行反序列化的时候，两种形式都能正确识别。</p><p>所以，如果你是用现代化的 Web 框架来写后端，那么这两种 JSON 形式应该是没有任何区别的。Request 默认的<code>json=</code>参数，相当于<code>ensure_ascii=True</code>，任何现代化的 Web 框架都能正确识别 POST 提交上来的内容。</p><p>当然，如果你使用的是 C 语言、汇编或者其他语言来裸写后端接口，那确实可能有所差别。可智商正常的人，谁会这样做？</p><p>综上所述，这位同学遇到的问题，并不是 Requests 的 bug，而是他的后端接口本身有问题。可能那个后端使用了某种弱智 Web 框架，它接收到的被 POST 发上来的信息，没有经过反序列化，就是一段 JSON 字符串，而那个后端程序员使用正则表达式从 JSON 字符串里面提取数据，所以当发现 JSON 字符串里面没有中文的时候，就报错了。</p><p>除了这个 POST 发送 JSON 的问题，以前我有个下属，在使用 Scrapy 发送 POST 信息的时候，由于不会写POST 的代码，突发奇想，把 POST 发送的字段拼接到 URL 上，然后用 GET 方式请求，发现也能获取数据，类似于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">url = <span class="string">'http://www.xxx.com/api/yyy'</span></span><br><span class="line">requests.post(url, json=body).text</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">'http://www.xxx.com/api/yyy?name=青南&amp;age=20'</span>).text</span><br></pre></td></tr></table></figure><p>于是，这个同学得出一个结论，他认为这是一个普遍的规律，所有 POST 的请求都可以这样转到 GET 请求。</p><p>但显然，这个结论也是不正确的。这只能说明，这个网站的后端程序员，让这个接口能同时兼容两种提交数据的方式，这是需要后端程序员额外写代码来实现的。在默认情况下，GET 和 POST 是两种完全不同的请求方式，也不能这样转换。</p><p>如果这位同学会一些简单的后端，那么他立刻就可以写一个后端程序来验证自己的猜想。</p><p>再来一个例子，有一些网站，他们在 URL 中可能会包含另外一个 URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https://abc.com/def/xyz?id=123&amp;db=admin</span><br></pre></td></tr></table></figure><p>如果你没有基本的后端知识，那么你可能看不出上面的网址有什么问题。但是如果你有一些基本的后端常识，那么你可能会问一个问题：网址中的<code>&amp;db=admin</code>，是属于<code>https://kingname.info/get_info</code>的一个参数，跟<code>url=</code>平级；还是属于<code>https://abc.com/def/xyz?id=123&amp;db=admin</code>的参数？你会疑惑，后端也会疑惑，所以这就是为什么我们这个时候需要 urlencode 的原因，毕竟下面两种写法，是完全不一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123%26db%3Dadmin</span><br><span class="line"></span><br><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123&amp;db=admin</span><br></pre></td></tr></table></figure><p>最后，以我的爬虫书序言中的一句话来作为总结：</p><blockquote><p>爬虫是一门杂学，如果你只会爬虫，那么你是学不好爬虫的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在粉丝交流群里面，有个同学说他发现了&lt;code&gt;Requests&lt;/code&gt;的一个 bug，并修复了它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;聊天记录中对应的图片为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="https://www.kingname.info/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
      <category term="编程思想" scheme="https://www.kingname.info/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Scrapy 如何正确 Post 发送 JSON 数据</title>
    <link href="https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/"/>
    <id>https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/</id>
    <published>2021-05-20T13:08:20.000Z</published>
    <updated>2021-05-20T13:11:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如<code>JSON</code>/<code>form-data</code>/<code>x-www-form-urlencoded</code>等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png" alt></p><a id="more"></a><p>虽然同样都是 POST 方式，但是有些网站只能使用特定的格式才能正常返回数据。我们来看一个例子，现在向网址：<code>http://exercise.kingname.info/ajax_1_postbackend</code> POST 提交一个 JSON 字符串：<code>{“name”:”xx”,”age”:24}</code>可以正常得到返回：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-33-58.png" alt></p><p>但如果提交的数据格式不是 JSON，而是<code>form-data</code>，那么就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-35-50.png" alt></p><p>这也就是为什么在使用 requests 的时候，post 方法的第二个参数有<code>data=</code>和<code>json=</code>的区别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-37-58.png" alt></p><p>在使用 Scrapy 的时候，很多人都知道怎么提交 GET 请求，但却不太清楚怎么提交 POST 请求。如果你在网上搜索，那么，你会看到有两种回答：</p><p>第一种回答，会建议你使用<code>scrapy.FormRequest</code>。但这个方法提交的数据是<code>form-data</code>格式，如果网站需要接收 JSON 格式的数据，那么提交就会失败。</p><p>第二种回答，会建议你使用<code>scrapy.Request(url, method=&#39;POST&#39;, body=json.dumps(xxx))</code>。这种方式确实可以成功提交 JSON 数据，但写起来比较麻烦。</p><p>但如果你看过 Scrapy 的官方文档<a href="https://doc.scrapy.org/en/latest/topics/request-response.html#jsonrequest" target="_blank" rel="noopener">Requests and Responses</a>，你就会知道，实际上 Scrapy 原本就提供了一个专门用来POST 提交 JSON 数据的方式——<code>JsonRequest</code>。它的位置在<code>scrapy.http.JsonRequest</code>。并且使用起来跟 <code>scrapy.Request</code>一样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy.http import JsonRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExampleSpider(scrapy.Spider):</span><br><span class="line">    name = &apos;example&apos;</span><br><span class="line">    allowed_domains = [&apos;xxx.com&apos;]</span><br><span class="line">    # start_urls = [&apos;http://xxx.com/&apos;]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        body = &#123;</span><br><span class="line">            &apos;name&apos;: &apos;kingname&apos;,</span><br><span class="line">            &apos;age&apos;: 28</span><br><span class="line">        &#125;</span><br><span class="line">        url = &apos;http://exercise.kingname.info/ajax_1_postbackend&apos;</span><br><span class="line">        yield JsonRequest(url, data=body, callback=self.parse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def parse(self, response, *args, **kwargs):</span><br><span class="line">        print(response.body.decode())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-48-43.png" alt></p><p><code>JsonRequest</code>本来就是<code>scrapy.Request</code>的一个子类，所以所有能在<code>scrapy.Request</code>使用的参数，都可以直接在<code>JsonRequest</code>中使用。同时，它额外支持两个参数，分别是<code>data</code>和<code>dumps_kwargs</code>。其中<code>data</code>参数的值就是一个可以被<code>json.dumps</code>序列化的对象，例如字典或者列表。而<code>dumps_kwargs</code>里面的参数，就是 <code>json.dumps</code>支持的那些参数，例如<code>ensure_ascii=False</code>、<code>sort_keys=True</code>等等。</p><p>大家遇到问题多看官方文档，少在网上搜索些杂七杂八装逼货的烂博客。官方文档是你最好的朋友。</p><hr><p><strong>未闻 Code</strong> 技术交流群开放啦！群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请添加我的微信“mekingname”，备注“粉丝群”（谢绝广告党，非诚勿扰！）~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如&lt;code&gt;JSON&lt;/code&gt;/&lt;code&gt;form-data&lt;/code&gt;/&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：你真的知道如何设置环境变量？</title>
    <link href="https://www.kingname.info/2021/05/14/do-you-know-env/"/>
    <id>https://www.kingname.info/2021/05/14/do-you-know-env/</id>
    <published>2021-05-14T14:36:58.000Z</published>
    <updated>2021-05-14T14:37:40.147Z</updated>
    
    <content type="html"><![CDATA[<p>很多人都知道环境变量，很多人也在使用环境变量。但是很多人一说到在 Linux、macOS 中使用环境变量，第一个想到的就是<code>export XXX=yyy</code>这种形式的环境变量。但实际上，在 Linux 和 macOS 中，定义环境变量有三种方式，他们的效果和作用范围是不相同的。</p><a id="more"></a><p>以 macOS 为例，来说明这三种环境变量有什么不同。我们通过下面这个 Python 程序来验证设置结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">name = os.getenv(<span class="string">'WHO_AM_I'</span>, <span class="string">'找不到环境变量'</span>)</span><br><span class="line">print(<span class="string">'环境变量 WHO_AM_I 的值是：'</span>, name)</span><br></pre></td></tr></table></figure><h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>如果你使用 ZSH，那么你就会知道，ZSH 有一个配置文件<code>~/.zshrc</code>，打开以后，它的内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-19-58.png" alt></p><p>在这里添加一行代码：<code>export WHO_AM_I=kingname</code>，就能设置一个全局的环境变量。这个环境变量会始终生效。即使你现在把电脑关了再打开，或者任意新开一个终端窗口，这个环境变量始终是有效的。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-23-27.png" alt></p><p>如果你电脑上没有 ZSH 的话，你也可以修改系统默认的<code>~/.bashrc</code>文件</p><h2 id="仅对当前窗口有效的环境变量"><a href="#仅对当前窗口有效的环境变量" class="headerlink" title="仅对当前窗口有效的环境变量"></a>仅对当前窗口有效的环境变量</h2><p>除了修改配置文件外，你也可以直接执行命令来设置环境变量，这也是最众所周知的方式。我们先把<code>~/.zshrc</code>里面的环境变量删了，来测试一下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-27-26.png" alt></p><p>可以看到，当我们执行<code>export WHO_AM_I=kingname</code>时，这个环境变量只对<strong>当前终端窗口</strong>有用。你重新开一个新的终端窗口，或者关闭当前窗口再打开，它都会失效。</p><h2 id="仅对当前命令有效的环境变量"><a href="#仅对当前命令有效的环境变量" class="headerlink" title="仅对当前命令有效的环境变量"></a>仅对当前命令有效的环境变量</h2><p>除此之外，我们还可以设置让环境变量只对当前命令有效，就是把定义环境变量的代码直接放在执行的命令之前。并且不加 <code>export</code>。例如，我们要执行命令<code>python3 test.py</code>，那么我们就这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHO_AM_I=kingname python3 test.py</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-30-36.png" alt></p><p>可以看到，只有在命令前面带上了定义语句的这一行才能正确获得环境变量。</p><p>这种方式特别在使用 Crontab 的时候有用。如果你经常使用 Crontab，那么你一定知道，Crontab 里面是不会认你的全局环境变量的。无论你是在<code>.zshrc</code>文件还是<code>.bashrc</code>中定义的环境变量，当你通过 Crontab 来执行的时候，程序都读不到环境变量。这个时候，就可以通过这种方式让程序运行的时候现场定义环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 12 * * * <span class="built_in">cd</span> /job/xxx &amp;&amp; WHO_AM_I=kingname python3 ./test.py</span><br></pre></td></tr></table></figure><p>这样一来，程序始终能够正确获得环境变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人都知道环境变量，很多人也在使用环境变量。但是很多人一说到在 Linux、macOS 中使用环境变量，第一个想到的就是&lt;code&gt;export XXX=yyy&lt;/code&gt;这种形式的环境变量。但实际上，在 Linux 和 macOS 中，定义环境变量有三种方式，他们的效果和作用范围是不相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.kingname.info/categories/Linux/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="环境变量" scheme="https://www.kingname.info/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要轻易使用 Chrome 复制的 XPath？</title>
    <link href="https://www.kingname.info/2021/05/14/do-not-copy-xpath/"/>
    <id>https://www.kingname.info/2021/05/14/do-not-copy-xpath/</id>
    <published>2021-05-14T14:34:58.000Z</published>
    <updated>2021-05-14T14:36:01.077Z</updated>
    
    <content type="html"><![CDATA[<p>有一些同学在写爬虫的时候，喜欢在Chrome 开发者工具里面直接复制 XPath，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-46-58.png" alt></p><p>他们觉得这样复制出来的 XPath 虽然长了点，但是工作一切正常，所以频繁使用。</p><p>但我希望大家不要过于依赖这个功能。因为它给出的结果仅作参考，有时候并不能让你提取出数据。我们来看一个例子。</p><a id="more"></a><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-55-52.png" alt></p><p>这是一个非常简单的HTML 页面，页面中有一个表格，表格有一列叫做<code>电话</code>。我现在想把这里面的5个电话提取出来。如果直接使用 Chrome 的复制 XPath 的功能，我们可以得到下面这个 XPath：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div/table/tbody/tr[<span class="number">3</span>]/td[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这实际上对应了<code>刘小三</code>这一行的电话字段。那么，我们去掉<code>tr</code>后面的数字，似乎就能覆盖到所有行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div/table/tbody/tr/td[<span class="number">4</span>]/text()</span><br></pre></td></tr></table></figure><p>在 XPath Helper 上面运行看看效果，确实提取出了所有的电话号码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-56-16.png" alt></p><p>但如果你使用 requests 来爬这个网页，然后使用 XPath 提取电话号码，你就会发现什么都提取不到，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-01-42.png" alt></p><p>你可能会想，这应该是异步加载导致的问题。表格里面的数据是通过 Ajax 后台加载的，不在网页源代码里面。</p><p>那么我们打印看看网页的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-02-47.png" alt></p><p>大家可以看到，数据就在网页源代码里面，那为什么我们在Chrome 上面通过 XPath  Helper 就能提取数据，而用 requests 就无法提取数据？</p><p>实际上，如果大家仔细观察从 Chrome 中复制出来的 XPath，就会发现它里面有一个<code>tbody</code>节点。但是我们的网页源代码是没有这个节点的。</p><p>这就要说到 Chrome 开发者工具里面显示的 HTML 代码，跟网页真正的源代码之间的区别了。很多人分不清楚这两者的区别，所以导致写出的 XPath 匹配不到数据。</p><p>当我们说到<code>网页源代码</code>的时候，我们指的是在网页上右键，选择“显示网页源代码”按钮所查看到的 HTML 代码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-07-17.png" alt></p><p>这个查看源代码的页面长成下图所示的这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-08-33.png" alt></p><p>注意地址栏，是以<code>view-source:</code>开头的。这才是网页真真正正的源代码。</p><p>而Chrome 的开发者工具里面的<code>Element</code>标签所显示的源代码，长成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-09-48.png" alt></p><p>这两个地方的HTML代码<strong>可能是</strong>不一样的，而且在现代化的网站中，这两个地方的 HTML<strong>大概率是不一样的</strong>。当我们使用 requests 或者 Scrapy 时，拿到的是第一种情况的源代码，这才是网页真正的源代码。而在开发者工具里面的 HTML 代码，是经过 Chrome 浏览器修饰甚至大幅度增删后的 HTML 代码。当网站有异步加载时，JavaScript 可以轻易在这里增加、删除非常多的内容。即使网站没有异步加载，如果网站原始的 HTML 代码编写不够规范，或者存在一些错漏，那么 Chrome 浏览器会自动纠错和调整。</p><p>以本文的例子来说，在 HTML 的官方规范里面，表格的正文确实应该包在<code>&lt;tbody&gt;&lt;/tbody&gt;</code>标签里面。但现在大多数情况下，前端开发者都会省略这个标签，所以真正的源代码里面是没有这个标签的。而 Chrome 会自动识别到这种情况，然后自动加上这个标签，所以在开发者工具里面看到的 HTML 代码是有这个标签的。</p><p>当你写爬虫的时候，不仅仅是 Chrome 开发者工具里面复制的 XPath 仅作参考，甚至这个开发者工具里面显示的 HTML 代码也是仅作参考。你应该首先检查你需要的数据是不是在真正的源代码里面，然后再来确定是写 XPath 还是抓接口。如果是写 XPath，那么更应该以这个真正的源代码为准，而不是开发者工具里面的 HTML 代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些同学在写爬虫的时候，喜欢在Chrome 开发者工具里面直接复制 XPath，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-46-58.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;他们觉得这样复制出来的 XPath 虽然长了点，但是工作一切正常，所以频繁使用。&lt;/p&gt;
&lt;p&gt;但我希望大家不要过于依赖这个功能。因为它给出的结果仅作参考，有时候并不能让你提取出数据。我们来看一个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="XPath" scheme="https://www.kingname.info/tags/XPath/"/>
    
      <category term="Chrome" scheme="https://www.kingname.info/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>前天才讲的知识点，不听讲的人今天就跑来问</title>
    <link href="https://www.kingname.info/2021/04/05/thread-event/"/>
    <id>https://www.kingname.info/2021/04/05/thread-event/</id>
    <published>2021-04-05T15:02:11.000Z</published>
    <updated>2021-05-14T15:06:58.514Z</updated>
    
    <content type="html"><![CDATA[<p> 今天在读者交流群里面，有同学提到这样一个问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-34.png" alt></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-51.png" alt></p><p>这个同学想实现，在代码第35行，如果进入了 <code>if</code> 判断，那么就退出第40-43行对应的 ac 函数。</p><p>能问出这个问题，说明这个同学显然没有认真看我的微信公众号。就在几天前我才发了一篇文章：<a href="https://mp.weixin.qq.com/s/po6wGCF_Ww8xDJKgEywZ0g" target="_blank" rel="noopener">一日一技：Python多线程的事件监控</a>。使用这篇文章里面讲到的方法，就可以轻易实现他的需求。</p><p>在那篇文章中，我们讲到了<code>threading.Event</code>，这个东西不仅可以在线程之间使用，也可以在主线程和子线程之间使用。</p><a id="more"></a><p>这个同学的代码不够清晰，我们稍稍修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, endtime)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'ac 函数将会在：'</span>, endtime, <span class="string">'停止'</span>)</span><br><span class="line">        self.endtime = endtime</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            now = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">if</span> now &gt; self.endtime:</span><br><span class="line">                print(<span class="string">'结束主线程'</span>)</span><br><span class="line">                <span class="comment"># <span class="doctag">TODO:</span> 这里需要做点什么事情</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ac</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'主线程正在运行，现在时间'</span>, datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">60</span>)</span><br><span class="line">    monitor = Monitor(stop_time)</span><br><span class="line">    monitor.start()</span><br><span class="line">    ac()</span><br></pre></td></tr></table></figure><p>如果你直接运行上面这段代码，你会发现程序每5秒钟会通过<code>ac</code>函数打印一条字符串，但永远不会停止。现在，我们在 需要在<code>#TODO</code>的位置怎么写代码，才能让程序停止呢？这个时候，我们把<code>threading.Event</code>引入进来。在外面生成并传给子线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, endtime, event)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.endtime = endtime</span><br><span class="line">        print(<span class="string">'ac 函数将会在：'</span>, endtime, <span class="string">'停止'</span>)</span><br><span class="line">        self.event = event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            now = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">if</span> now &gt; self.endtime:</span><br><span class="line">                print(<span class="string">'结束主线程'</span>)</span><br><span class="line">                self.event.set()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ac</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        print(<span class="string">'主线程正在运行，现在时间'</span>, datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">60</span>)</span><br><span class="line">    monitor = Monitor(stop_time, event)</span><br><span class="line">    monitor.start()</span><br><span class="line">    ac(event)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-59-47.png" alt></p><p>当子线程检测到满足结束条件的时候，调用<code>event.set()</code>。主线程里面，<code>ac</code>函数使用一个循环不停检测<code>event.is_set()</code>。一开始<code>event.is_set()</code>始终返回 <code>False</code>，直到<code>event.set()</code>以后，就返回 True。这样一来，<code>ac</code>函数就像是收到了通知，于是可以结束函数的运行了。</p><p>如果大家有任何编程上的问题，可以进入未闻 Code 读者交流微信群提问。目前交流群一群、二群已经慢了，三群正在等待更多同学的加入。加我微信号<code>mekingname</code>，备注<code>粉丝群</code>就可以进入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 今天在读者交流群里面，有同学提到这样一个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-34.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-51.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个同学想实现，在代码第35行，如果进入了 &lt;code&gt;if&lt;/code&gt; 判断，那么就退出第40-43行对应的 ac 函数。&lt;/p&gt;
&lt;p&gt;能问出这个问题，说明这个同学显然没有认真看我的微信公众号。就在几天前我才发了一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/po6wGCF_Ww8xDJKgEywZ0g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：Python多线程的事件监控&lt;/a&gt;。使用这篇文章里面讲到的方法，就可以轻易实现他的需求。&lt;/p&gt;
&lt;p&gt;在那篇文章中，我们讲到了&lt;code&gt;threading.Event&lt;/code&gt;，这个东西不仅可以在线程之间使用，也可以在主线程和子线程之间使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.kingname.info/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开发经验：已经有对象储存，为什么我们还要开发一个图片接口？</title>
    <link href="https://www.kingname.info/2021/04/05/why-wrap-oos/"/>
    <id>https://www.kingname.info/2021/04/05/why-wrap-oos/</id>
    <published>2021-04-05T15:02:11.000Z</published>
    <updated>2021-05-14T15:03:31.304Z</updated>
    
    <content type="html"><![CDATA[<p>现在阿里云，腾讯云等等云服务商都已经提供对象储存服务，我们可以使用对象储存来存放文件或者图片。通过云服务商提供的 SDK，一行代码就可以把文件或者图片上传到对象储存，并获得文件的地址。</p><p>我的博客图片就使用腾讯云的对象储存作为图床，所以如果你查看图片的地址，会发现他们的网址是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG</span><br></pre></td></tr></table></figure><p>其中的<code>https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/</code>就是我的对象储存的域名。</p><p>然而，在公司的项目中，虽然我们也是用云服务商提供的对象储存来存放图片，但是我们会额外开发一个图片服务接口。所以，公司项目网站的图片，使用的地址类似于：<code>https://img.kingname.info/xxx.png</code>。当你访问这个地址的时候，这个图片服务会从域名拿到图片的名字<code>xxx.png</code>，然后访问对象储存拿到这张图片，最后再把这种图片以数据流的形式返回给你。</p><p>你可能会觉得，这不是多此一举吗？为什么不能让用户直接访问对象储存获得图片呢？单独做一个图片接口不仅增加了开发时间，而且还需要服务器单独再发一次请求到对象储存拿数据，白白增加了访问延迟，怎么看都是得不偿失啊。</p><p>这是因为，工程上的问题，有时候不仅仅是一个行与不行的问题。它需要考虑很多额外的因素。</p><a id="more"></a><h2 id="迁移的成本"><a href="#迁移的成本" class="headerlink" title="迁移的成本"></a>迁移的成本</h2><p>首先要考虑的一个问题是未来是否会更换云服务商。现在我用腾讯云的对象储存，我有一张图片的地址是<code>https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG</code>，未来我要换到七牛云去了。图片文件我可以写个 Python 脚本，一键同步到新的对象储存里面去。但是我的图片地址应该怎么改？</p><p>对于新闻类网站或者 App 来说，新闻里面的图片一般都跟正文一起，以 HTML 代码的形式存放到数据库中了。如果我要迁移对象储存，岂不是要扫描一次数据库，把所有图片地址的前半截批量更新为新的地址？对整个数据库进行这样的更新是非常危险的，很容易导致数据损坏或者服务长时间停机。</p><p>但如果我们在对象储存上层有一个自己的图片服务，那么只需要更新图片服务内部的访问原始图片的逻辑就可以了。已有的新闻原始数据不需要做任何改动就能直接使用。</p><h2 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h2><p>如果使用对像储存，那么所有拿到图片地址的人都能够访问这张图片。假设我们有一篇新闻因为某种原因被删除了，用户已经不能访问这篇新闻了。但是之前拿到了这篇新闻图片的人，还可以通过对象储存对应的图片地址访问这张图片。这可能会被别有用心的人拿来利用，通过发送一篇不和谐的文章配上不和谐的图片，然后举报文章，发现文章被删除以后，再举报图片没有删除。</p><p>那可不可以删除新闻的同时把对应的原始图片也删除了呢？其实也不行。因为新闻一般是假删除。也就是在数据库中设置一个标注，让网站不再显示这篇新闻。例如一篇有版权争议的文章，收到原作者投诉以后，我们需要先把这篇文章撤下，然后商务会跟原作者沟通，获得授权以后再把文章重新打开。可是对象储存没有这样临时冻结图片的功能，删了就真的没有了。</p><p>但如果我们在对象储存上层加一个图片服务。用户访问图片的时候，我们先检查这张图片对应的新闻是否能够访问，如果能够访问，再去对象储存拉取图片返回给用户。这样就能降低被有心人利用的风险。</p><h2 id="功能扩展性"><a href="#功能扩展性" class="headerlink" title="功能扩展性"></a>功能扩展性</h2><p>对象储存提供文件存取功能外，还会提供一些简单的文件处理功能。但有时候我们需要一些自定义的功能，此时不得不再包装一层图片服务。</p><p>例如我们想在图片上加水印。对象储存提供的水印服务功能是在图片上传的时候直接修改原始图片文件，一旦添加就再也不能修改了。如果后面我想修改水印的内容，那么只能让新的图片使用新的水印，老的图片还是老的水印。</p><p>而如果我们有一个图片服务，那么可以在对象储存中直接存放原始图片。而图片服务拿到图片原文件以后，动态添加水印，再返回给调用者。这样一来，当我们要修改水印内容的时候，只需要修改图片服务接口就可以同步更新所有历史图片。</p><p>又比如，大家都知道最近因为棉花的事情，很多综艺节目突然出现了大面积的马赛克。因为有些赞助商的标志不能播放了。这可累死了这些节目的后期剪辑人员。新闻图片其实也会面临这种问题。但我们网站上有几千万篇新闻，显然我们不可能有人力去筛选每一篇新闻的图片。这个时候，我们只需要在图片服务中加上图片识别的功能，发现图片含有这些公司的商标，自动给图片加上高斯模糊。轻松解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一句话说得好，在计算机领域，没有什么问题是不能通过增加若干个中间层搞定的。在一些可能发生变故的地方，提前设置一些中间层，那么一开始可能仅仅只是简单的数据转发。但等到后面要对功能进行增强的时候，这些中间层往往能起到意想不到的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在阿里云，腾讯云等等云服务商都已经提供对象储存服务，我们可以使用对象储存来存放文件或者图片。通过云服务商提供的 SDK，一行代码就可以把文件或者图片上传到对象储存，并获得文件的地址。&lt;/p&gt;
&lt;p&gt;我的博客图片就使用腾讯云的对象储存作为图床，所以如果你查看图片的地址，会发现他们的网址是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的&lt;code&gt;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/&lt;/code&gt;就是我的对象储存的域名。&lt;/p&gt;
&lt;p&gt;然而，在公司的项目中，虽然我们也是用云服务商提供的对象储存来存放图片，但是我们会额外开发一个图片服务接口。所以，公司项目网站的图片，使用的地址类似于：&lt;code&gt;https://img.kingname.info/xxx.png&lt;/code&gt;。当你访问这个地址的时候，这个图片服务会从域名拿到图片的名字&lt;code&gt;xxx.png&lt;/code&gt;，然后访问对象储存拿到这张图片，最后再把这种图片以数据流的形式返回给你。&lt;/p&gt;
&lt;p&gt;你可能会觉得，这不是多此一举吗？为什么不能让用户直接访问对象储存获得图片呢？单独做一个图片接口不仅增加了开发时间，而且还需要服务器单独再发一次请求到对象储存拿数据，白白增加了访问延迟，怎么看都是得不偿失啊。&lt;/p&gt;
&lt;p&gt;这是因为，工程上的问题，有时候不仅仅是一个行与不行的问题。它需要考虑很多额外的因素。&lt;/p&gt;
    
    </summary>
    
      <category term="开发经验" scheme="https://www.kingname.info/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="开发经验" scheme="https://www.kingname.info/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：一根短横线在Golang 和 Python 中的妙用。</title>
    <link href="https://www.kingname.info/2021/03/22/use/"/>
    <id>https://www.kingname.info/2021/03/22/use/</id>
    <published>2021-03-22T14:59:33.000Z</published>
    <updated>2021-05-14T15:01:08.844Z</updated>
    
    <content type="html"><![CDATA[<p>一根不起眼的短横线，在 Golang 和 Python 中，都能够让你不输出某些不想要的字符。</p><a id="more"></a><h2 id="不输出日期时间前面的0"><a href="#不输出日期时间前面的0" class="headerlink" title="不输出日期时间前面的0"></a>不输出日期时间前面的0</h2><p>我们在使用 Python 输出时间日期的时候，一般格式是这样的：<code>YYYY-mm-dd  :MM:SS</code>，例如：<code>2021-03-22 09:10:12</code>。可以看到<code>03</code>和<code>09</code>前面都有一个0。这样做的好处，是可以让日期时间保持相同的长度，于是就可以通过字符串的方式比较大小。</p><p>但有时候，因为某些原因，你可能确实不想补0，你就想输出<code>2021-3-22 9:10:12</code>这种格式的时间。</p><p>但我们知道，在 Python 里面把日期时间格式化输出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt_str = now.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure><p>在这个格式化符号里面，可以看到我们本身就使用的是一个字符，月份就是<code>%m</code>，难道还有另外一个符号用来表示不补0的日期？</p><p>实际上，不补0并不需要另外一个符号来表示，我们只需要在<code>%</code>和<code>m</code>之间加上一根短横线就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt_str = now.strftime(<span class="string">'%Y-%-m-%-d %-H:%-M:%-S'</span>)</span><br><span class="line">print(dt_str)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-21-06-08.png" alt></p><h2 id="Golang-结构体与-JSON-的互相转换"><a href="#Golang-结构体与-JSON-的互相转换" class="headerlink" title="Golang 结构体与 JSON 的互相转换"></a>Golang 结构体与 JSON 的互相转换</h2><p>在使用 Golang 的时候，我们有时候需要在结构体和 JSON 字符串之间互相转换。在转换的工程中，可能会发现有些字段是多余的。我们不想让 JSON中的某些字段转到结构体里面，或者不想让结构体里面的某些字段转到 JSON 中去。</p><p>对于从 JSON 转到结构体，要忽略字段非常简单，例如有如下一个 JSON 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"kingname"</span>, <span class="string">"salary"</span>: <span class="number">999999999</span>, <span class="string">"address"</span>: <span class="string">"上海"</span>, <span class="string">"handsome"</span>: true&#125;</span><br></pre></td></tr></table></figure><p>在转成结构体的时候，我不想要<code>handsome</code>这个字段，于是可以这样写代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Salary  <span class="keyword">int64</span>  <span class="string">`json:"salary"`</span></span><br><span class="line">Address <span class="keyword">string</span> <span class="string">`json:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonstr := <span class="string">`&#123;"name": "kingname", "salary": 999999999, "address": "上海", "handsome": true&#125;`</span></span><br><span class="line"><span class="keyword">var</span> info Info</span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(jsonstr), &amp;info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-44-56.png" alt></p><p>但问题是，如果现在给你一个结构体，但是转成 JSON 的时候不想要其中一个字段，应该怎么操作？可能有人会以为，在定义结果体的时候，不要加上<code>json:&quot;xxx&quot;</code>就可以了。但实际执行的效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-49-42.png" alt></p><p>Golang 会直接使用这个字段在结构体中的名字来转成 JSON。</p><p>如果不想要这个字段，实际上有一个非常简单的办法，就是在定义结构体的时候，加上<code>json:&quot;-&quot;</code>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Salary   <span class="keyword">int64</span>  <span class="string">`json:"salary"`</span></span><br><span class="line">Address  <span class="keyword">string</span> <span class="string">`json:"address"`</span></span><br><span class="line">Handsome <span class="keyword">bool</span>   <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-52-43.png" alt></p><p>通过指定这个横线，就能忽略这个字段了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一根不起眼的短横线，在 Golang 和 Python 中，都能够让你不输出某些不想要的字符。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：可视化分析 Redis Key 资源占用情况</title>
    <link href="https://www.kingname.info/2021/02/26/redis-dashboard/"/>
    <id>https://www.kingname.info/2021/02/26/redis-dashboard/</id>
    <published>2021-02-26T14:13:24.000Z</published>
    <updated>2021-05-14T14:36:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 在日常的开发中，会积累大量的 Key，占用不少内存空间。有时候，我们想知道当前 Redis 里面有多少个 Key，是哪个 Key 占用了最大的内存。</p><p>但是，我们知道，由于 Redis 是单线程数据库，所以在线上环境是绝对禁止使用<code>keys *</code>这种命令的，因为它会花费很长时间扫描所有的 Key，在这个过程中，Redis 会卡死，无法处理其他的读写操作。</p><p>那么，我们应该怎么知道当前有多少个 Key 呢？有同学说可以使用<code>scan</code>命令。但这个命令一方面是需要写程序来迭代，另一方面是它给出的结果可能是不准确的。</p><a id="more"></a><p>也有同学会说，可以使用<code>info keyspace</code>命令，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-48-27.png" alt></p><p>确实可以看到有多少个 Key。不过另一个问题是，怎么知道哪个 Key 占用的内存空间最大？</p><p>还有时候，Redis 里面可能有几万十几万个 Key，里面有些 Key 是可以删掉的。但是由于我们不能使用<code>keys</code>命令查看当前有哪些 Key，所以不知道这些可以删掉的 Key 竟然还在。</p><p>实际上，这些问题，我们使用一个叫做<a href="https://github.com/xueqiu/rdr" target="_blank" rel="noopener">RDR</a>的工具，都可以解决。在 RDR 的 Github 上，可以找到对应系统的可执行文件。我们以 Linux 版本为例来进行说明。Linux 版本的可执行文件地址为：<code>https://github.com/xueqiu/rdr/releases/download/v0.0.1/rdr-linux</code>，下载以后，赋予可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://github.com/xueqiu/rdr/releases/download/v0.0.1/rdr-linux</span><br><span class="line">chmod +x rdr-linux</span><br></pre></td></tr></table></figure><p>接下来，我们需要找到 <code>dump.rdb</code>文件。</p><p>Redis 默认开启了<code>RDB</code>方式的持久化储存。满足一定条件时，Redis 会把内存中的数据存放到硬盘中，防止由于突然断电导致数据丢失。默认情况下，RDB 文件在<code>/var/lib/redis/dump.rdb</code>，这个文件只有 root 用户可以读取。</p><p>如果你现在不是 root 用户，那么你可以把它复制出来，修改成当前用户，我的 Linux 系统当前用户名叫做 kingname，所在的用户组也叫 kingname，所以可以执行如下 shell 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo cp /var/lib/redis/dump.rdb ./</span><br><span class="line">sudo chown kingname:kinganme dump.rdb</span><br></pre></td></tr></table></figure><p>修改了用户以后，现在我们让 RDR 来读取这个RDB 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rdr-linux show -p 8766 dump.rdb</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-57-12.png" alt></p><p>现在，打开浏览器，打开<code>http://IP:8766</code>，就可以看到当前 Redis 的各个 Key 的统计信息：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-58-22.png" alt></p><p>不仅可以看到Redis 有哪些 Key，还能看到每个 Key 里面有多少元素，大小是多少。</p><p>而且由于是分析的 RDB 文件，所以也完全不需要担心对线上数据造成任何影响。</p><p>有了这个工具以后，要找出占用空间最大的 Key，就非常简单了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 在日常的开发中，会积累大量的 Key，占用不少内存空间。有时候，我们想知道当前 Redis 里面有多少个 Key，是哪个 Key 占用了最大的内存。&lt;/p&gt;
&lt;p&gt;但是，我们知道，由于 Redis 是单线程数据库，所以在线上环境是绝对禁止使用&lt;code&gt;keys *&lt;/code&gt;这种命令的，因为它会花费很长时间扫描所有的 Key，在这个过程中，Redis 会卡死，无法处理其他的读写操作。&lt;/p&gt;
&lt;p&gt;那么，我们应该怎么知道当前有多少个 Key 呢？有同学说可以使用&lt;code&gt;scan&lt;/code&gt;命令。但这个命令一方面是需要写程序来迭代，另一方面是它给出的结果可能是不准确的。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://www.kingname.info/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>小问题大隐患：如何正确设置 Python 项目的入口文件？</title>
    <link href="https://www.kingname.info/2021/02/18/entry-file/"/>
    <id>https://www.kingname.info/2021/02/18/entry-file/</id>
    <published>2021-02-18T14:41:10.000Z</published>
    <updated>2021-02-18T14:42:43.371Z</updated>
    
    <content type="html"><![CDATA[<p>今天在公众号粉丝群里面，有一位同学提到了 Python 找不到模块的问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-20-42-01.png" alt></p><p>问题涉及到的代码结构和代码截图如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG" alt></p><p>这个问题的解决方法非常简单，就是把<code>start.py</code>文件从<code>bin</code>文件夹移出来就好了。</p><p>但如果对这个问题进一步分析，可以看到更多问题。</p><a id="more"></a><p>在我以前的文章：<a href="https://mp.weixin.qq.com/s/lTisktaIiC0QZMWzEgFWzw" target="_blank" rel="noopener">为什么Python代码能运行但是PyCharm给我画红线？</a>中，我讲到了工作区（Workdir）对代码的影响。PyCharm、VSCode 识别的工作区，可能并不等于你直接在终端窗口运行<code>.py</code>文件时候的工作区。</p><p>今天这个问题本质上也是工作区导致的问题。 这个同学的项目根目录是<code>MY_API</code>，所以他使用的编辑器VSCode 就会默认把<code>MY_API</code>当做工作区。所以，当他在<code>start.py</code>文件中写上<code>from lib.interface import server</code>时，VScode 并不会给他标记红色波浪线。因为从 VSCode 的视角看，<code>lib</code>文件夹确实就是在工作区下面的。</p><p>但是，当他在 VSCode 里面运行这个<code>start.py</code>文件时，Python 是从<code>bin</code>文件夹下面运行的。此时，Python 会把<code>bin</code>文件夹当做工作区。在工作区里面就只有这一个<code>start.py</code>文件，所以当然找不到<code>lib</code>文件夹。</p><p>如果仅仅从技术上来说，你非要导入 <code>bin</code> 文件夹的父文件夹下面的其他模块，也并不困难，我在<a href="https://mp.weixin.qq.com/s/cNKr1uhDy47pOVjFznoBwA" target="_blank" rel="noopener">一日一技：导入父文件夹中的模块并读取当前文件夹内的资源</a>一文中讲到了具体的做法。</p><p>但问题在于，你不应该这样做。<strong>你不应该把项目的入口文件，放到项目内部很深的文件夹中。</strong></p><p>所谓入口文件，就是要首先经过它，才能到达其他的文件。当你拿到一个 Python 项目，你只需要首先从入口文件开始阅读代码，根据入口文件调用的模块，一路看下去，你就能读到它的所有实现逻辑。</p><p>但如果大家经常逛 Github，就会发现，有些人可能是被其他垃圾语言污染了思想，他的 Python 项目，根目录有五六个文件夹和七八个<code>.py</code>文件。你拿到这个项目的时候，你甚至不知道，当你想运行这个代码的时候，<code>python3 xxx.py</code>应该运行哪个文件。你多方打听，或者看了半天文档，才知道，哦，原来入口文件在<code>com/xx/yy/zz/script/run.py</code>。</p><p>当你打开这个<code>run.py</code>文件，你发现它的顶部，文件导入的代码写的是<code>from ../../../../aaa import bbb</code>。</p><p>简直是神经病写法。我知道有些垃圾语言流行这样写。但现在你用的是 Python，学聪明一点，别那样写。</p><p>对于一个 Python 项目来说，入口文件应该始终在最外层。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-21-12-59.png" alt></p><p>当你要启动这个项目的时候，直接在最外层<code>python3 main.py</code>，就能把它启动起来。在<code>main.py</code>里面，你可以导入其他模块，然后调用其他模块里面的类或者函数。</p><p>这样做的好处是什么？这样做，你是在项目的根目录启动的这个项目，所以你的工作区就是项目的根目录。那么你在任何一个<code>.py</code>文件里面都可以很容易地基于工作区导入任意其他文件。例如，你现在在<code>models/mongo-util/mongob_helper.py</code>文件中，你想导入<code>utils/abc.py</code>中的<code>time_format()</code>函数，那么，你只需要这样写就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.abc <span class="keyword">import</span> time_format</span><br></pre></td></tr></table></figure><p>你根本不可能出现需要导入父文件夹中的某个模块的情况。</p><p>只有工具脚本，才需要单独使用一个文件夹来存放，然后调用父文件夹中的其他文件。例如，我现在有一个工具脚本，它每天晚上0点会读写 MongoDB，清理无效数据，那么此时，我可以在根目录单独创建一个<code>script</code>或<code>tools</code>或者<code>bin</code>文件夹，然后把工具脚本放进去，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-21-22-43.png" alt></p><p>在这个工具脚本里面，你可能会调用<code>models/mongo-util/mongob_helper.py</code>文件中的某个函数。这种情况下，你调用父文件夹中的内容是可以接受的。但这毕竟只是工具脚本。</p><p>可能还有同学要问，那如果我的项目是一个 Python 的包，它本身没有入口文件怎么办呢？这个时候，你可以把这个包的<code>__init__.py</code>当做它的入口文件。大家可以参考我在 <a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="noopener">GitHub - kingname/GeneralNewsExtractor: 新闻网页正文通用抽取器 Beta 版.</a>的代码组织结构。在项目根目录留下一个<code>example.py</code>文件，用来演示如何调用这个包。而这个包本身的代码，是在一个叫做<code>gne</code>的文件夹中的。这个<code>gne</code>文件夹是一个包，它的入口文件在<code>__init__.py</code>中。</p><p>各位，当你写代码的时候，你先想一想，如果别人拿到了你的代码，想要梳理一下这个项目的逻辑，在不询问你的情况下，怎么让他知道应该从哪个文件开始读？应该按什么顺序读？他能不能轻易地看到数据在你的代码中是怎么运转的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在公众号粉丝群里面，有一位同学提到了 Python 找不到模块的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-18-20-42-01.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;问题涉及到的代码结构和代码截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个问题的解决方法非常简单，就是把&lt;code&gt;start.py&lt;/code&gt;文件从&lt;code&gt;bin&lt;/code&gt;文件夹移出来就好了。&lt;/p&gt;
&lt;p&gt;但如果对这个问题进一步分析，可以看到更多问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 服务器中创建假桌面运行模拟浏览器有头模式</title>
    <link href="https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/"/>
    <id>https://www.kingname.info/2021/02/16/use-selenium-head-in-linux/</id>
    <published>2021-02-16T06:27:49.000Z</published>
    <updated>2021-02-18T14:42:46.422Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用 Selenium 或者 Puppeteer 的同学都知道，他们启动的 Chrome 浏览器分为有头模式和无头模式。在自己电脑上操作时，如果是有头模式，会弹出一个 Chrome 浏览器窗口，然后你能看到这个浏览器里面在自动操作。而无头模式则不会弹出任何窗口，只有进程。</p><p><a href="https://mp.weixin.qq.com/s/yS8juVNb2kyb15H9wwm8sg" target="_blank" rel="noopener">别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征</a>这篇文章中，我们介绍了一个探测模拟浏览器特征的网站。通过他我们可以发现，在不做任何设置的情况下，Selenium 或者 Puppeteer 启动的浏览器有几十个特征能够被目标网站识别为爬虫。并且，无头模式的特征比有头模式的特征多得多。</p><a id="more"></a><p>也就是说，即使你不使用任何隐藏特征的技术，仅仅使用有头模式，你都会安全很多。如果网站不是非常严格的反爬虫，很多情况下，使用无头模式更容易被发现，但使用有头模式，更难被发现。</p><p>下图为<strong>有头模式</strong>，不使用任何隐藏特征的技术访问检测网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-11-26-20-09-46.png" alt></p><p>下图为<strong>无头模式</strong>，不使用任何隐藏特征的技术访问检测网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/headless_screenshot.png" alt="万里河山一片红"></p><p>所以，一般情况下，你应该多使用有头模式。</p><p>但问题在于，当我们要在 Linux 服务器上面使用 Selenium 或者 Puppeteer 运行爬虫的时候，就会发现有头模式始终会报错。这是因为，有头模式需要系统提供图形界面支持，才能绘制浏览器窗口，但是 Linux 服务器一般来说是没有图形界面的，所以有头模式一定会失败。</p><p>在这种情况下，为了能够使用模拟浏览器的有头模式，我们需要搞一个假的图形界面出来，从而欺骗浏览器，让它的有头模式能够正常使用。</p><p>为了达到这个目的，我们可以使用一个叫做 <code>Xvfb</code>的东西。这个东西在<a href="https://en.wikipedia.org/wiki/Xvfb" target="_blank" rel="noopener">维基百科上面的介绍</a>如下：</p><blockquote><p>Xvfb or X virtual framebuffer is a display server implementing the X11 display server protocol. In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output.</p></blockquote><p>Xvfb 在一个没有图像设备的机器上实现了 X11显示服务的协议。它实现了其他图形界面都有的各种接口，但并没有真正的图形界面。所以当一个程序在 Xvfb 中调用图形界面相关的操作时，这些操作都会在虚拟内存里面运行，只不过你什么都看不到而已。</p><p>使用 Xvfb，我们就可以欺骗 Selenium 或者 Puppeteer，让它以为自己运行在一个有图形界面的系统里面，这样一来就能够正常使用有头模式了。</p><p>要安装 Xvfb 非常简单，在 Ubuntu 中，只需要执行下面两行命令就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><p>现在，我们来写一段非常简单的 Selenium 操作 Chrome 的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'https://bot.sannysoft.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.save_screenshot(<span class="string">'screenshot.png'</span>)</span><br><span class="line">driver.close()</span><br><span class="line">print(<span class="string">'运行完成'</span>)</span><br></pre></td></tr></table></figure><p>如果直接在服务器上运行，效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-11-46-39.png" alt></p><p>因为没有图形界面，所以程序必定报错。</p><p>现在，我们只需要在运行这段代码的命令前面加上<code>xvfb-run</code>，再来看看运行效果：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-11-50-40.png" alt></p><p>代码成功运行，没有报错。现在我们从服务器上把这个生成的<code>screenshot.png</code>文件拉下来，打开以后可以看到内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/xvfb-screenshot.png" alt></p><p>可以看到，虽然窗口比较小，但确实是有头模式下面的检测结果。当然，我们也可以调整一下窗口大小，增加参数：<code>xvfb-run python3 test.py -s -screen 0 1920x1080x16</code>就能假装在一个分辨率为1920x1280的显示器上运行程序了。然后修改 Selenium 的代码，设置浏览器窗口的大小：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-16-12-02-45.png" alt></p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/xvfb-screenshot-2.png" alt></p><p>本文演示使用的是 Python操作 Selenium，你也可以试一试使用 Puppeteer，只需要把启动命令改为<code>xvfb-run node index.js</code>就可以了。</p><p>有了本文以后，再结合我之前的两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/Bge-_yiatSq4CQq7fRvjdQ" target="_blank" rel="noopener">最完美方案！模拟浏览器如何正确隐藏特征</a></li><li><a href="https://mp.weixin.qq.com/s/XOXb_XvsHqgv0MUICahjJw" target="_blank" rel="noopener">Chome 88如何正确隐藏 webdriver？</a></li></ul><p>相信你的模拟浏览器能够绕过更多的网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用 Selenium 或者 Puppeteer 的同学都知道，他们启动的 Chrome 浏览器分为有头模式和无头模式。在自己电脑上操作时，如果是有头模式，会弹出一个 Chrome 浏览器窗口，然后你能看到这个浏览器里面在自动操作。而无头模式则不会弹出任何窗口，只有进程。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yS8juVNb2kyb15H9wwm8sg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;别去送死了。Selenium 与 Puppeteer 能被网站探测的几十个特征&lt;/a&gt;这篇文章中，我们介绍了一个探测模拟浏览器特征的网站。通过他我们可以发现，在不做任何设置的情况下，Selenium 或者 Puppeteer 启动的浏览器有几十个特征能够被目标网站识别为爬虫。并且，无头模式的特征比有头模式的特征多得多。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
      <category term="Xvfb" scheme="https://www.kingname.info/tags/Xvfb/"/>
    
  </entry>
  
  <entry>
    <title>奇技淫巧：在 ssh 里面把服务器的文本复制到本地电脑</title>
    <link href="https://www.kingname.info/2020/10/02/copy-from-ssh/"/>
    <id>https://www.kingname.info/2020/10/02/copy-from-ssh/</id>
    <published>2020-10-02T03:18:58.000Z</published>
    <updated>2020-10-02T03:27:41.293Z</updated>
    
    <content type="html"><![CDATA[<p>使用 macOS 的同学，应该熟悉一个命令<code>pbcopy</code>，它可以在命令行中把一段内容写入到剪贴板，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"kingname"</span> | pbcopy</span><br></pre></td></tr></table></figure><p>就能把字符串<code>kingname</code>复制到剪贴板里面。我们也可以使用这个方法把一个文件中的内容写入到剪贴板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat xxx.txt | pbcopy</span><br></pre></td></tr></table></figure><p>这样我们就不需要把文件打开再手动复制的。</p><p>有时候，我要把服务器上面的日志复制下来。原来都是进入服务器以后，用 vim 打开日志文件，用鼠标选中再复制。且不说服务器是 Linux，没有<code>pbcopy</code>这个命令，即使有这个命令，服务器上又怎么能访问本地的剪贴板呢？</p><a id="more"></a><p>在网上一搜，竟然还真有办法。<a href="https://www.laruence.com/2020/05/21/5880.html" target="_blank" rel="noopener">使用OSC52实现iTerm2远程pbcopy - 风雪之隅</a>这篇文章借助 iterms 的一个功能和几个特殊的字符，通过 php 实现了这个功能。我们来把它改写成 Python 版本。</p><p>首先打开 iterms 的设置，把方框框住的这一项勾上：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-29-25.png" alt></p><p>然后，在 iterms 里面，通过 ssh 连上服务器。</p><p>然后，我们来写一段 Python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\033]52;c;'</span> + base64.b64encode(<span class="string">'青南'</span>.encode()).decode() + <span class="string">'\007'</span>)</span><br></pre></td></tr></table></figure><p>然后在服务器上运行这段代码，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-40-11.png" alt></p><p>什么都没有打印出来？但不要担心，现在，你随便找一个可以打字的输入框，按下键盘上面的<code>Command +V</code>键。你会发现，<code>青南</code>两个字竟然被粘贴出来了！</p><p>有了这个机制，我们就来人工写一个<code>pbcopy.py</code>，接收管道的输入：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-22-08-35.png" alt="在公众号后台回复 pbcopy 获得代码文本"></p><p>其中，<code>#! /usr/bin/python3</code>是远程服务器上面 Python 的地址。你可以通过命令<code>which python3</code>找到这个地址。</p><p>保存完成以后，给他添加可执行权限：<code>chmod +x pbcopy.py</code>。</p><p>现在，我们试一试把远程的多行文本复制到本地的剪贴板中：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-51-22.png" alt></p><p>我这里复制的就是这个代码自身。大家也可以使用其他文件来测试。复制完成以后，我们随便找个地方粘贴，发现复制成功！</p><p>现在，我们使用软连接，把这个可执行文件变得更像命令一些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/ubuntu/pbcopy.py /usr/bin/pbcopy</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-10-01-21-53-54.png" alt></p><p>完美满足要求。</p><p>需要注意的是，这个程序会把管道输入的所有内容全部接收完成以后才会复制，所以，如果你输入的文本内容太大，可能会撑爆内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 macOS 的同学，应该熟悉一个命令&lt;code&gt;pbcopy&lt;/code&gt;，它可以在命令行中把一段内容写入到剪贴板，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;kingname&quot;&lt;/span&gt; | pbcopy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就能把字符串&lt;code&gt;kingname&lt;/code&gt;复制到剪贴板里面。我们也可以使用这个方法把一个文件中的内容写入到剪贴板：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat xxx.txt | pbcopy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样我们就不需要把文件打开再手动复制的。&lt;/p&gt;
&lt;p&gt;有时候，我要把服务器上面的日志复制下来。原来都是进入服务器以后，用 vim 打开日志文件，用鼠标选中再复制。且不说服务器是 Linux，没有&lt;code&gt;pbcopy&lt;/code&gt;这个命令，即使有这个命令，服务器上又怎么能访问本地的剪贴板呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>手把手教学，如何解决 git 冲突？</title>
    <link href="https://www.kingname.info/2020/09/13/how-to-reslove-conflict/"/>
    <id>https://www.kingname.info/2020/09/13/how-to-reslove-conflict/</id>
    <published>2020-09-13T14:52:37.000Z</published>
    <updated>2020-09-13T16:21:07.111Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是现在使用最广泛的源代码管理程序。一个合格的程序员必须要熟练掌握 Git。在使用 Git 的时候，最让人头疼的问题是什么？肯定是解冲突了。如果两个人修改了同一个文件的相同位置，那么当一个人提交代码并合并到主分支以后，第二个人尝试合并时就会触发冲突。大多数情况下，Git 自己知道如何把两份代码合并起来。但有时候当 Git 不知道应该怎么合并，就会提示你需要手动解决冲突。</p><p>我以前学习 Git 的时候，由于没有人跟我一起提交代码，所以我为了模拟两人提交的情况，会把代码 clone 到两个文件夹里面，然后把相同的位置分别做不同的修改，再分别提交。过程非常繁琐。</p><a id="more"></a><p>最近因为评上了微软 MVP 的关系，会主动关注一下微软的在线课程，结果发现微软悄无声息地出了一整套的 Github 课程。而这其中，有一套交互式的课程手把手指导如何解决 Git 的冲突：<a href="https://docs.microsoft.com/zh-cn/learn/modules/resolve-merge-conflicts-github/?WT.mc_id=DT-MVP-5003916" target="_blank" rel="noopener">在 GitHub 上使用合并冲突解决来解决竞争提交</a>，由于 Github 是基于 Git 的，所以只要稍作设置，这个课程就能变成通用的 Git 操作指导教程。</p><p>一开始我以为这个课程只有 MVP 能看，后来发现，课程不仅完全免费，而且不需要注册，所有人都能随时学习。只要你有一个 Github 账号就能参加。大家点击公众号下方的<code>阅读原文</code>就可以打开这个课程页面。</p><p>打开课程以后，页面如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-09-57.png" alt></p><p>点击其中的“开始”按钮，就可以开始学习。课程一共有5个单元，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-11-49.png" alt></p><p>其中，第1，2单元是知识性介绍，大家可以看一下。今天我们重点说一下第3单元《练习-管理合并冲突》。这一单元，会基于 Github Lab(Github 学习实验室)来一步一步手把手指导。我们点击<code>在 Github 上启动学习实验室</code>按钮。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-15-22.png" alt></p><p>此时，浏览器会新开一个选项卡，如下图所示。点击<code>Start free course</code>，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-17-27.png" alt></p><p>此时，会让你登录 Github，并授权 Github Lab 创建一个练习源，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/author.png" alt></p><p>大家可以创建公共源，也可以创建私有源。如果是创建私有源的话，之后每次从远程推拉代码时，会让你输入 Github 账号密码。需要注意的是<code>Additional Options</code>这一项一定要选择<code>Use the command line</code>，这样我们才能学习通用的 Git 操作。另外两项都是 Github 专用的操作。对我们帮助不大。</p><p>授权完成以后，你的 Github 上会自动创建一个源，并且有很多的冲突，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-43-54.png" alt></p><p>回到刚才的课程页面，可以看到下面出现了几个课程阶段，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-45-09.png" alt></p><p>我们点击第一课的<code>Start</code>按钮，开始第一课。浏览器弹出了新的页面（实际上就是 Github 的 PR 页面），在这里，我们可以根据它的提示和说明进行操作。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-23-24-14.png" alt></p><p>大家不要担心全是英文看不懂，真正需要你进行的操作，都是灰色背景的代码片段，这些代码是很容易看懂的。</p><p>根据提示，首先 clone 代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kingname/merge-conflicts.git</span><br><span class="line"><span class="built_in">cd</span> merge-conflicts</span><br></pre></td></tr></table></figure><p>接下来，切换到<code>update-config</code>分支，然后拉取远程最新代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout update-config</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>然后，我们把远程的<code>master</code>分支代码合并到<code>update-config</code>分支中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>发现了冲突，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-50-47.png" alt></p><p>它已经提示了<code>_config.yml</code>文件有冲突。所以我们可以直接打开<code>_config.yml</code>文件。你可以使用自己喜欢的编辑器打开。我这里使用 Vim。打开以后的代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-54-22.png" alt></p><p>注意，这里的实际代码可能跟教程不一样。教程里面说冲突内容是被<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; update-config</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</code>包起来的，但实际上代码里面的冲突内容是被<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</code>包起来的。</p><p>大家可以看到，在<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>与<code>=======</code>中间的内容，与<code>=======</code>到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</code>中间的内容，他们的字段名是一样的，但是值不一样，所以 Git 不知道应该以哪个为准，需要我们人工决断。</p><p>假设我想以上面这一段为准（在实际开发过程中，可能上下要各取一部分合并），如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-55-47.png" alt></p><p>保存修改，根据它的提示，执行以下代码进行提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"merge master into update-config"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>提交成功以后，网页上会立刻给出反馈：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-10-58-22.png" alt></p><p>我们继续往下看，根据它的提示，首先切换回<code>master</code>分支，然后拉取最新代码，然后把<code>update-config</code>分支的内容合并进入master：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git merge update-config</span><br></pre></td></tr></table></figure><p>合并成功，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-16-42.png" alt></p><p>最后把本地已经合并的代码使用<code>git push</code>推到远程即可。</p><p>第二个问题更复杂一些，这次有两个冲突文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-23-44.png" alt></p><p>并且冲突的内容有好几个，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-25-19.png" alt></p><p>但解决方法还是一样的，人来决定要保留哪些内容，把不要的地方删掉：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-26-28.png" alt></p><p>保存修改，然后检查第二个文件。第二个文件也解决以后，根据页面上的提示输入代码，合并提交就可以了。</p><p>前两个问题，是别人创建了冲突，需要我们来改。第三个问题，是我们自己导致了冲突，我们自己来解决。方法跟之前是一样的，就不多说了。</p><p>最后这一步，让你完善这个源里面的内容。因为这个模拟冲突的源本质上是一个在线简历页面，你可以把里面的内容改成你自己的。当然，这是选做题，可做可不做。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-45-20.png" alt></p><p>所有任务都做完了，是不是很有成就感：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-44-40.png" alt></p><p>最后还能解锁成就：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-13-11-47-37.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的学习过程，我总结了一个解决冲突的常规流程：</p><ol><li><strong>前提条件：不能在 master 分支上修改任何文件。master 分支的变更只能通过 git pull 和 git merge 获得。在 master 分支下面，不能手动修改任何文件。</strong></li><li>我们自己有一个分支用来修改代码，例如我的分支叫做<code>dev</code>分支。我把代码修改完成了，现在不知道有没有冲突。</li><li>在 dev 分支里面，执行命令<code>git merge origin/master</code>，把远程的<code>master</code>分支合并到当前<code>dev</code>分支中。如果没有任何报错，那么直接转到第5步。</li><li>如果有冲突，根据提示，把冲突解决，保存文件。然后执行命令<code>git add xxx</code>把你修改的文件添加到缓存区。然后执行命令<code>git commit -m &quot;xxx&quot;</code>添加 commit 信息。</li><li>执行如下命令，切换到 master 分支：<code>git checkout master</code>。</li><li>执行命令<code>git pull</code>确保当前 master 分支是最新代码。</li><li>把<code>dev</code>分支的代码合并回 master 分支：<code>git merge dev</code>。</li><li>提交代码：<code>git push</code>。</li></ol><p>只要所有开发者都遵守这个规则，那么解决冲突是一件非常容易的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是现在使用最广泛的源代码管理程序。一个合格的程序员必须要熟练掌握 Git。在使用 Git 的时候，最让人头疼的问题是什么？肯定是解冲突了。如果两个人修改了同一个文件的相同位置，那么当一个人提交代码并合并到主分支以后，第二个人尝试合并时就会触发冲突。大多数情况下，Git 自己知道如何把两份代码合并起来。但有时候当 Git 不知道应该怎么合并，就会提示你需要手动解决冲突。&lt;/p&gt;
&lt;p&gt;我以前学习 Git 的时候，由于没有人跟我一起提交代码，所以我为了模拟两人提交的情况，会把代码 clone 到两个文件夹里面，然后把相同的位置分别做不同的修改，再分别提交。过程非常繁琐。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.kingname.info/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.kingname.info/tags/Git/"/>
    
      <category term="Github" scheme="https://www.kingname.info/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>现场打脸：如何使用Selenium批量上传文件？</title>
    <link href="https://www.kingname.info/2020/09/09/upload-multiple-file-by-selenium/"/>
    <id>https://www.kingname.info/2020/09/09/upload-multiple-file-by-selenium/</id>
    <published>2020-09-09T04:19:16.000Z</published>
    <updated>2020-09-09T04:59:08.824Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Selenium里面，当我们获得一个 element 对象的时候，如果它是一个输入框，那么我们可以使用<code>.send_keys()</code>方法，模拟键盘按键，发送特定的字符串到输入框中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_box = driver.find_element_by_xpath(<span class="string">'//input[@class="xxx"]'</span>)</span><br><span class="line">input_box.send_keys(<span class="string">'账号 xxx'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>但如果要说<code>.send_keys()</code>可以上传文件，你可能会非常吃惊吧。今天有个读者在问我的时候，我也非常吃惊，觉得这怎么可能：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-01-03.png" alt></p><p>结果我到 Selenium 的文档里面一看，发现<code>send_keys()</code>竟然真的可以上传文件: <a href="https://selenium-python.readthedocs.io/faq.html?highlight=send_keys#how-to-upload-files-into-file-inputs" target="_blank" rel="noopener">8.5. How to upload files into file inputs ?</a></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-02-31.png" alt></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-04-31.png" alt></p><p>为了验证这个说法，我们使用 Flask 手写一个支持上传功能的简陋网站。网站代码如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-21-09.png" alt></p><p>网站运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-11-08-09.png" alt></p><p>点击“选择文件”按钮，在弹出的对话框里面选中一个文件，然后点击“Upload”按钮，就会把文件上传到代码里面的<code>uploads</code>文件夹中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-22-49.png" alt></p><p>现在我们在 Selenium 里面进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'http://127.0.0.1:5000'</span>)</span><br><span class="line">file_input = driver.find_element_by_xpath(<span class="string">'//input[@type="file"]'</span>)</span><br><span class="line">file_input.send_keys(<span class="string">'/Users/kingname/test_send_keys/target/x.txt'</span>)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">'//input[@type="submit"]'</span>)</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure><p>经过测试，发现确实可以正常上传文件。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-25-27.png" alt></p><p>这样一来，既然 <code>.send_keys()</code>能够正常工作，那么就可以反向推测出，浏览器上传文件的原理，选择文件的对话框实际上提供给浏览器的仅仅是一个文件路径。当我们点击了上传按钮以后，浏览器会根据这个路径去读硬盘，找到这个文件然后上传。由于文件路径本质上就是一个字符串，所以用<code>.send_keys()</code>本质上就是直接替代了选择文件对话框生成的文件路径，直接把这个路径上传给了文件输入表单。</p><p>那么如何一次性上传多个文件呢？</p><p>只要网站支持同时上传多个文件，那么我们可以把多个文件的路径拼接到一个长字符串中，路径与路径之间使用换行符<code>\n</code>来进行分割。</p><p>假设在文件夹<code>/Users/kingname/test_send_keys/target</code>里面有多个文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-26-14.png" alt></p><p>我们需要一次性全部上传。那么，可以使用换行符把每一个文件的路径拼接起来：</p><p>代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line">folder = <span class="string">'/Users/kingname/test_send_keys/target'</span></span><br><span class="line">file_name_list = os.listdir(folder)</span><br><span class="line">path_list = [os.path.join(folder, x) <span class="keyword">for</span> x <span class="keyword">in</span> file_name_list]</span><br><span class="line">path_split_by_newline = <span class="string">'\n'</span>.join(path_list)</span><br><span class="line"></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</span><br><span class="line">driver.get(<span class="string">'http://127.0.0.1:5000'</span>)</span><br><span class="line">file_input = driver.find_element_by_xpath(<span class="string">'//input[@type="file"]'</span>)</span><br><span class="line">file_input.send_keys(path_split_by_newline)</span><br><span class="line">submit = driver.find_element_by_xpath(<span class="string">'//input[@type="submit"]'</span>)</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-09-09-12-30-18.png" alt></p><p>成功上传多个文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Selenium里面，当我们获得一个 element 对象的时候，如果它是一个输入框，那么我们可以使用&lt;code&gt;.send_keys()&lt;/code&gt;方法，模拟键盘按键，发送特定的字符串到输入框中，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input_box = driver.find_element_by_xpath(&lt;span class=&quot;string&quot;&gt;&#39;//input[@class=&quot;xxx&quot;]&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;input_box.send_keys(&lt;span class=&quot;string&quot;&gt;&#39;账号 xxx&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：实现有过期时间的LRU缓存</title>
    <link href="https://www.kingname.info/2020/03/23/lru-with-expire-time/"/>
    <id>https://www.kingname.info/2020/03/23/lru-with-expire-time/</id>
    <published>2020-03-23T15:46:52.000Z</published>
    <updated>2020-03-23T15:47:20.191Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://mp.weixin.qq.com/s/F7D9MjGypRj5J1EZVvPv0Q" target="_blank" rel="noopener">一日一技：实现函数调用结果的 LRU 缓存</a>一文中，我们提到Python自带的LRU缓存<code>lru_cache</code>。通过这个装饰器可以非常轻松地实现缓存。</p><a id="more"></a><p>现在我们考虑下面这个应用场景：MongoDB中有100对id-用户名的对应关系，我从Redis中持续不断读取id，如果id能在MongoDB中找到对应关系，那么就把对应的用户名打印出来。如果找不到对应关系，那么就把这个id丢弃。</p><p>为了防止频繁读取MongoDB，我在程序开始的时候直接读取这一百对对应关系，并存为字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">client = redis.Redis()</span><br><span class="line">handler = pymongo.MongoClient().weibo.id_name_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_id_name_map</span><span class="params">()</span>:</span></span><br><span class="line">    id_name = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> handler.find():</span><br><span class="line">        id_name[row[<span class="string">'id'</span>]] = row[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> id_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">id_name_map = read_id_name_map()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client.blpop(<span class="string">'weibo_id'</span>)</span><br><span class="line">    user_id = data[<span class="number">1</span>].decode()</span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">in</span> id_name_map:</span><br><span class="line">        print(id_name_map[user_id])</span><br></pre></td></tr></table></figure><p>大家可以思考一下，上面这段代码有没有什么问题。然后继续看后面。</p><p>如果我现在需要再增加100个id-用户名的对应关系怎么办？</p><p>由于这个程序运行以后就一直阻塞式地读取Redis，不会停止，所以整个过程只会读取一次MongoDB。后面即使我向MongoDB中添加了新的对应关系，只要程序不重启，就无法读取到新的对应关系。</p><p>肯定有同学想到，在while循环里面增加一个计时器，每x分钟就重新调用一下read_id_name_map()函数，更新对应关系。</p><p>不过今天我们要讲的是另一个更有创意的办法，使用<code>lru_cache</code>来实现。</p><p>对于这个例子来说，lru_cache的<code>maxsize</code>参数只需要设置为1，因为只需要存放1份对应关系即可。那么我们如何做到，比如每10分钟更新一次呢？我们知道，在使用lru_cache时，如果调用同一个函数，并且传入的参数相同，那么从第二次开始就会使用缓存。现在我们如何让时间在每10分钟内相同呢？</p><p>我们来看现在的时间戳：1578399211.30042</p><p>它除以600，值是<code>1578399211.30042 // 600 = 2630665.0</code>。然后我让这个时间戳加5分钟，也就是增加300秒，变成<code>1578399511.30042</code>。这个新的时间戳再除以600，发现结果还是<code>2630665.0</code>。但如果原来的时间戳增加超过10分钟，例如增加了601秒，我们再来看看效果<code>(1578399211.30042 + 601) // 600 = 2630666.0</code>，此时的结果也发生了变化。</p><p>利用这个特点，修改一下我们的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line">client = redis.Redis()</span><br><span class="line">handler = pymongo.MongoClient().weibo.id_name_map</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_id_name_map</span><span class="params">(_)</span>:</span></span><br><span class="line">    id_name = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> handler.find():</span><br><span class="line">        id_name[row[<span class="string">'id'</span>]] = row[<span class="string">'name'</span>]</span><br><span class="line">    <span class="keyword">return</span> id_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client.blpop(<span class="string">'weibo_id'</span>)</span><br><span class="line">    id_name_map = read_id_name_map(time.time() // <span class="number">600</span>)</span><br><span class="line">    user_id = data[<span class="number">1</span>].decode()</span><br><span class="line">    <span class="keyword">if</span> user_id <span class="keyword">in</span> id_name_map:</span><br><span class="line">        print(id_name_map[user_id])</span><br></pre></td></tr></table></figure><p>现在，我们直接在while循环内部调用<code>read_id_name_map</code>，如果两次调用的时间间隔小于600秒，那么<code>time.time() // 600</code>的值是相同的，第二次直接使用缓存，也就不会查询MongoDB了。当时间超过10分钟后，时间戳除以600的值增加了，于是缓存没有命中，进入查询MongoDB的过程，更新id_name_map。实现了有过期时间的LRU缓存。</p><p>补充：可能有同学注意到定义<code>read_id_name_map</code>函数的时候，参数我写的是下划线。这是Python 编码规范中建议的一种写法。当一个变量不会被使用，但又需要保留时，就可以用下划线表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/F7D9MjGypRj5J1EZVvPv0Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：实现函数调用结果的 LRU 缓存&lt;/a&gt;一文中，我们提到Python自带的LRU缓存&lt;code&gt;lru_cache&lt;/code&gt;。通过这个装饰器可以非常轻松地实现缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="LRU" scheme="https://www.kingname.info/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>拒绝想当然，不看文档导致GNE 的隐秘 bug</title>
    <link href="https://www.kingname.info/2020/03/23/bug-for-gne/"/>
    <id>https://www.kingname.info/2020/03/23/bug-for-gne/</id>
    <published>2020-03-23T15:45:55.000Z</published>
    <updated>2020-03-23T15:46:27.498Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="noopener">GNE</a>上线4天，已经有很多朋友通过它来编写自己的新闻类网页通用爬虫。</p><a id="more"></a><p>今天有一个用户来跟我反馈，GNE 0.1.4版本在提取澎湃新闻时，只能提取一小部分的内容。</p><p>一开始我以为是提取算法有问题，Debug 了半天，最后才发现，是新闻正文在预处理的时候，就被提前<code>删除</code>了！</p><p>为了解释这个问题，我们用一小段 HTML 代码来还原当时的场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>阅读过 GNE 源代码的朋友都知道，GNE 会在预处理阶段尽可能移除没什么用的 HTML 标签。例如上面这段代码中的两行<code>&lt;p class=&quot;con&quot; /&gt;</code>都属于会干扰提取结果，且对提取没有任何帮助的标签。</p><p>于是我们使用 lxml 库的方法来移除它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"></span><br><span class="line">selector = fromstring(h)</span><br><span class="line">useless_list = selector.xpath(<span class="string">'//p[@class="con"]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> useless <span class="keyword">in</span> useless_list:</span><br><span class="line">    useless.getparent().remove(useless)</span><br></pre></td></tr></table></figure><p>根据想当然的理论：</p><ol><li>找到<code>&lt;p class=&quot;con&quot; /&gt;</code>标签</li><li>找到它的父标签</li><li>从父标签里面把这两个无效标签移除掉</li></ol><p>整个过程看起来没有问题，并且预期移除以后的 HTML 应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>但实际上，现实情况与想当然的情况自然不一样。真正的输出结果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-04-16-12-49.png" alt></p><p><code>&lt;div class=&quot;txt&quot;&gt;</code>这个标签下面的<code>text()</code>有三行，分别为<code>第一行</code>、<code>第二行</code>、<code>第三行</code>。但是使用上面的代码移除时，<code>第二行</code>与<code>第三行</code>都一并被删除了。</p><p>这是因为，这就是<code>ElementTree.remove</code>这个方法的行为。它不仅会移除这个节点，还会移除这个节点父节点的 text()中，位于这个节点后面的所有内容。</p><p>所以，正常的做法应该是直接调用要被移除这个节点的<code>.drop_tag()</code>方法。我们修改一下上面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"><span class="keyword">from</span> html <span class="keyword">import</span> unescape</span><br><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">h = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="txt"&gt;</span></span><br><span class="line"><span class="string">        第一行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第二行</span></span><br><span class="line"><span class="string">        &lt;p class="con" /&gt;</span></span><br><span class="line"><span class="string">        第三行</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">selector = fromstring(h)</span><br><span class="line">useless_list = selector.xpath(<span class="string">'//p[@class="con"]'</span>)</span><br><span class="line"><span class="keyword">for</span> useless <span class="keyword">in</span> useless_list:</span><br><span class="line">    useless.drop_tag()</span><br><span class="line"></span><br><span class="line">print(unescape(etree.tostring(selector).decode()))</span><br></pre></td></tr></table></figure><p>运行效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-04-16-14-38.png" alt></p><p>成功达到了我们想要的目的。</p><p>GNE 已经更新了版本，修复了这个 bug。使用 GNE 的同学请升级到0.1.5以上版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade gne</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kingname/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GNE&lt;/a&gt;上线4天，已经有很多朋友通过它来编写自己的新闻类网页通用爬虫。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：应该传入对象还是在用的时候再初始化？</title>
    <link href="https://www.kingname.info/2020/03/23/pass-or-create/"/>
    <id>https://www.kingname.info/2020/03/23/pass-or-create/</id>
    <published>2020-03-23T15:45:05.000Z</published>
    <updated>2020-03-23T15:45:32.539Z</updated>
    
    <content type="html"><![CDATA[<p>在写 Python 代码的时候，大家可能会在不知不觉中使用一些设计范式。我们来看两个例子。</p><a id="more"></a><p>假设有一个类<code>People</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>现在我们有另一个类<code>ClassRoom</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassRoom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.student = People(<span class="string">'小明'</span>, <span class="number">17</span>, <span class="string">'男'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.student.study()</span><br></pre></td></tr></table></figure><p>我们在<code>ClassRoom</code>的构造函数中，初始化了一个 student 对象，然后在<code>start_class</code>方法中，调用了这个对象的<code>study</code>方法。</p><p>这个过程看起来似乎没有什么问题，相信很多读者也是这样写代码的。</p><p>现在，我们再增加两个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.consumer = People(<span class="string">'张三'</span>, <span class="number">30</span>, <span class="string">'男'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_launch</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.consumer.eat()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballroom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.dancer = People(<span class="string">'小红'</span>, <span class="number">20</span>, <span class="string">'女'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dancer.dance()</span><br></pre></td></tr></table></figure><p>新增加的两个类<code>Restaurant</code>和<code>Ballroom</code>的构造函数里面都通过<code>People</code>类初始化了对象。然后在调用这个对象的方法。</p><p>这样写看起来没有问题，能正常工作，代码也不丑。</p><p>现在，<code>People</code>类需要修改一下它的构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex, address)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>在初始化<code>People</code>类时，需要传入一个<code>address</code>参数。现在怎么办？</p><p>于是<code>ClassRoom</code>、<code>Restaurant</code>、<code>Ballroom</code>这三个类的构造函数都要随之做修改，全都得加上这个<code>address</code>参数。</p><p>这就叫做<code>牵一发而动全身</code>。</p><p>很多人为了避免做这样的修改，会把新增加的这个参数<code>address</code>改成默认参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sex, address=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在跳舞'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在学习'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'我在吃东西'</span>)</span><br></pre></td></tr></table></figure><p>这样看起来，另外三个类的代码就不需要做任何修改了。</p><blockquote><p>这就是为什么你们公司的代码里面，很多函数会带上大量奇奇怪怪的默认参数的原因。</p></blockquote><p>在编程范式中，有一个术语叫做<code>依赖注入</code>，就是为了解决这个问题的。</p><p>而且做起来简单到你觉得这是在逗你，把<code>People</code>初始化以后的对象传到其他类的构造函数中即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballroom</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, dancer)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.dancer = dancer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dancer.dance()</span><br><span class="line"></span><br><span class="line">dancer = People(<span class="string">'小红'</span>, <span class="number">20</span>, <span class="string">'女'</span>)</span><br><span class="line">ballroom = Ballroom(<span class="string">'xxx'</span>, dancer)</span><br><span class="line">ballroom.open()</span><br></pre></td></tr></table></figure><p>虽然叫做编程范式，但也不是说应该始终使用依赖注入。例如你的代码会层层调用，难道从第一层把对象一层一层传到最里面去？所以应该根据实际情况来进行选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 Python 代码的时候，大家可能会在不知不觉中使用一些设计范式。我们来看两个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用二分法排查正则表达式的异常</title>
    <link href="https://www.kingname.info/2020/03/23/binary-search-for-regex/"/>
    <id>https://www.kingname.info/2020/03/23/binary-search-for-regex/</id>
    <published>2020-03-23T15:44:11.000Z</published>
    <updated>2020-03-23T15:44:40.471Z</updated>
    
    <content type="html"><![CDATA[<p>现在我有10亿条微博正文，并从同事手上拿到了15000条需要过滤的垃圾信息正则表达式，只要微博正文符合任何一条正则表达式，就删除这条微博。</p><a id="more"></a><p>正则表达式的格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">^你成功领取</span><br><span class="line">|^感谢您的积</span><br><span class="line">|^在第\d+次抽奖.</span><br><span class="line">|^只有帮主才</span><br><span class="line">|^目标有相应</span><br><span class="line">|^宝宝<span class="comment">#G.</span></span><br><span class="line">|^提交失败，</span><br><span class="line">|^您已领取过</span><br><span class="line">|^破军争夺战</span><br><span class="line">|^首席大弟子</span><br><span class="line">|数第\d+个丫鬟</span><br><span class="line">|你的店铺</span><br><span class="line">|恭喜.*?投中了</span><br><span class="line">|&lt;web</span><br><span class="line">|你将该物品拆解成</span><br><span class="line">|^你身上没有</span><br><span class="line">|欢迎参加微博抽奖</span><br><span class="line">|蔡徐坤</span><br><span class="line">|王一博</span><br><span class="line">|朱一龙</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>存放在一个名为<code>trash.txt</code>的文本文件中，每个正则表达式一行。</p><p>一般情况下，我只需要使用如下几行代码就能实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'trash.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line">    pattern = re.compile(<span class="string">''</span>.join(lines))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> weibo <span class="keyword">in</span> weibo_list:</span><br><span class="line">    <span class="keyword">if</span> pattern.search(weibo):</span><br><span class="line">        print(<span class="string">'垃圾信息，过滤！'</span>)</span><br></pre></td></tr></table></figure><p>但是当我的代码运行到<code>re.compile</code>这一行时，报错了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-12-56-46.png" alt></p><p>并且，即使你在 Google 上面搜索：<code>re.error: multiple repeat at position</code>，截至2019年12月30日，你能找到的都是对这个报错的讨论，但没有一个讨论能解决本文描述的问题。</p><p>那我们自食其力，来试着解决一下这个问题。它报错报的是<code>position 167</code>，那么我们来看看第167个字符有什么问题。在 PyCharm 中，可以在右下角查看你选中了多少个字符，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-12-59-22.png" alt></p><p>从截图中可以看到，第167个字符所在的这一行正则表达式为：<code>|张三丰.*?张翠山.*?张无忌</code>，但是我完全看不出这一行正则表达式有什么问题。</p><p>由于报错了，那么肯定至少有一行正则表达式有问题，我们假设有问题的正则表达式有且只有一行。现在我们有15000行正则表达式，如何找出有问题的这一行呢？</p><p>这个时候，我们就可以使用二分查找来解决这个问题，$log_{2}15000=13.8$，我们最多查找14次就能找到有问题的这一行正则表达式。</p><p>由于正则表达式一共有15000行，我们就先看0-7500行在编译时是否会报错，如果报错，在看<code>0-3750</code>行是否报错，如果不报错，在看<code>3750-7500</code>行是否报错……如此分割下去，直到找到报错的这一行正则表达式。</p><p>二分查找的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'trash.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_compile_success</span><span class="params">(regex)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        re.compile(regex)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(regex_list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(regex_list) == <span class="number">1</span>:</span><br><span class="line">        print(regex_list[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = len(regex_list) // <span class="number">2</span></span><br><span class="line">    part_1 = <span class="string">''</span>.join(regex_list[: mid])</span><br><span class="line">    part_2 = <span class="string">''</span>.join(regex_list[mid: ])</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_compile_success(part_1):</span><br><span class="line">        search(regex_list[: mid])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_compile_success(part_2):</span><br><span class="line">        search(regex_list[mid:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search(lines)</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-30-13-20-24.png" alt></p><p>原来出问题的地方在：<code>.*??</code>，这里多写了一个问号。把这一行改成<code>|赵大.*?包</code>以后，编译成功通过。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>如果要把出问题的这一行所在的行号打印出来，应该如何修改代码？</li><li>如果有问题的正则表达式不止一行，应该如何修改代码，从而打印所有有问题的正则表达式？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我有10亿条微博正文，并从同事手上拿到了15000条需要过滤的垃圾信息正则表达式，只要微博正文符合任何一条正则表达式，就删除这条微博。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>你经常看到却经常忽视的__init__.py有什么用？</title>
    <link href="https://www.kingname.info/2020/03/23/init-in-python/"/>
    <id>https://www.kingname.info/2020/03/23/init-in-python/</id>
    <published>2020-03-23T15:40:46.000Z</published>
    <updated>2020-03-23T15:41:11.370Z</updated>
    
    <content type="html"><![CDATA[<p>Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做<code>__init__.py</code>的文件。下图为著名的第三方库<code>requests</code>的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png" alt></p><p>那么<code>__init__.py</code>有什么用呢？本文介绍它的两个用途。</p><a id="more"></a><h2 id="精简导入路径"><a href="#精简导入路径" class="headerlink" title="精简导入路径"></a>精简导入路径</h2><p>假设我们有两个文件<code>main.py</code>与<code>writer.py</code>，他们所在的文件结构如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-48-36.png" alt></p><p><code>main.py</code>在<code>DocParser</code>文件夹下面；<code>writer.py</code>在<code>DocParser/microsoft/docx/</code>文件夹下面。<code>writer.py</code>文件中有一个函数<code>write</code>。其内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-48.png" alt></p><p>现在我想在<code>main.py</code>文件夹调用这个函数，那么我有3种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.word.docx.writer <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line">write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-50-32.png" alt></p><p>或者这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.word.docx <span class="keyword">import</span> writer</span><br><span class="line"></span><br><span class="line">writer.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-51-21.png" alt></p><p>或者这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> microsoft.word.docx.writer</span><br><span class="line"></span><br><span class="line">microsoft.word.docx.writer.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-02.png" alt></p><p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在<code>microsoft</code>文件夹下面创建一个<code>__init__.py</code>文件，并在里面填写如下内容：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt></p><p>此时，在 <code>main.py</code>，我们导入<code>write</code>函数，就像是从<code>microsoft.py</code> 文件中导入一样。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt></p><p>注意上面我说的是就像从<code>microsoft.py 文件</code>中导入一样，这里是用的<code>文件</code>而不是<code>文件夹</code>。</p><p>这是因为，当一个文件夹里面有<code>__init__.py</code>以后，这个文件夹就会被 Python 作为一个<code>包(package)</code>来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到<code>__init__.py</code>中。这样以来，包外面再想导入这些内容时，就可以用<code>from 包名 import 函数名</code>来导入了。</p><h2 id="无视工作区的相对引用"><a href="#无视工作区的相对引用" class="headerlink" title="无视工作区的相对引用"></a>无视工作区的相对引用</h2><p>为什么会有<code>包</code>这个东西呢？这是因为，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的部分提供给其他模块调用。</p><p>由于调用包的其他模块所在的绝对路径是千变万化的，所以在包的内部调用自身其他文件中的函数、常量、类，就应该使用相对路径，而是绝对路径。</p><p>例如，现在我在<code>microsoft</code>文件夹下面再创建一个<code>parse.py</code>文件，它需要导入<code>microsoft/word/docx/writer.py</code>中的<code>write</code>函数，那么代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .word.docx.writer <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_doc</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'现在在 parse.py 中调用 write 函数'</span>)</span><br><span class="line">    write()</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-08-34.png" alt></p><p>可以看到，此时<code>from .word.docx.writer</code>中的<code>.</code>表示当前包，所以<code>.word.docx.writer</code>表示当前包下面的word 文件夹下面的 docx 文件夹下面的 writer.py 文件。</p><p>然后我们修改<code>__init__.py</code>，把<code>parse_doc</code>函数导入进去，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-25.png" alt></p><p>最后，在<code>main.py</code>中调用这个<code>parse_doc</code>函数，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-59.png" alt></p><p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。</p><p>并且，上面<code>parse.py</code>中导入<code>write</code>函数的代码还可以进一步简化，由于<code>write</code>函数已经被导入到了<code>__init__.py</code>中，所以我们可以直接从<code>.</code>里面导入<code>write</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> write</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-13-05.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当一个文件夹里面包含<code>__init__.py</code>时，这个文件夹会被 Python 认为是一个<code>包(package)</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到<code>__init__.py</code>中再在其他文件中导入，可以精简代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做&lt;code&gt;__init__.py&lt;/code&gt;的文件。下图为著名的第三方库&lt;code&gt;requests&lt;/code&gt;的源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;__init__.py&lt;/code&gt;有什么用呢？本文介绍它的两个用途。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Python 中的 import 与 from import</title>
    <link href="https://www.kingname.info/2020/03/23/know-import/"/>
    <id>https://www.kingname.info/2020/03/23/know-import/</id>
    <published>2020-03-23T15:40:01.000Z</published>
    <updated>2020-03-23T15:40:29.703Z</updated>
    
    <content type="html"><![CDATA[<p>对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用<code>import xxx</code>？什么时候用<code>from xxx import yyy</code>？什么时候用<code>from xxx.yyy import zzz</code>？什么时候用<code>from xxx import *</code>？</p><p>这篇文章，我们来彻底搞懂这个问题。</p><a id="more"></a><h2 id="系统自带的模块"><a href="#系统自带的模块" class="headerlink" title="系统自带的模块"></a>系统自带的模块</h2><p>以正则表达式模块为例，我们经常这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">target = <span class="string">'abc1234xyz'</span></span><br><span class="line">re.search(<span class="string">'(\d+)'</span>, target)</span><br></pre></td></tr></table></figure><p>但有时候，你可能会看到某些人这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> search</span><br><span class="line">target = <span class="string">'abc1234xyz'</span></span><br><span class="line">search(<span class="string">'(\d+)'</span>, target)</span><br></pre></td></tr></table></figure><p>那么这两种导入方式有什么区别呢？</p><p>我们分别使用<code>type</code>函数来看看他们的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(re)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">module</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">re</span> <span class="title">import</span> <span class="title">search</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(search)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-30-59.png" alt></p><p>可以看到，直接使用<code>import re</code>导入的<code>re</code>它是一个<code>module</code>类，也就是模块。我们把它成为<code>正则表达式模块</code>。而当我们<code>from re import search</code>时，这个<code>search</code>是一个<code>function</code>类，我们称呼它为<code>search 函数</code>。</p><p>一个模块里面可以包含多个函数。</p><p>如果在你的代码里面，你已经确定只使用<code>search</code>函数，不会再使用正则表达式里面的其他函数了，那么你使用两种方法都可以，没什么区别。</p><p>但是，如果你要使用正则表达式下面的多个函数，或者是一些常量，那么用第一种方案会更加简洁清晰。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">re.search(<span class="string">'c(.*?)x'</span>, flags=re.S)</span><br><span class="line">re.sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=re.I)</span><br></pre></td></tr></table></figure><p>在这个例子中，你分别使用了<code>re.search</code>，<code>re.sub</code>，<code>re.S</code>和<code>re.I</code>。后两者是常量，用于忽略换行符和大小写。</p><p>但是，如果你使用<code>from re import search, sub, S, I</code>来写代码，那么代码就会变成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">search(<span class="string">'c(.*?)x'</span>, flags=S)</span><br><span class="line">sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=I)</span><br></pre></td></tr></table></figure><p>看起来虽然简洁了，但是，一旦你的代码行数多了以后，你很容易忘记<code>S</code>和<code>I</code>这两个变量是什么东西。而且我们自己定义的函数，也很有可能取名为<code>sub</code>或者<code>search</code>，从而覆盖正则表达式模块下面的这两个同名函数。这就会导致很多难以觉察的潜在 bug。</p><p>再举一个例子。Python 的 <code>datetime</code>模块，我们可以直接<code>import datetime</code>，此时我们导入的是一个<code>datetime</code>模块，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-43-21.png" alt></p><p>但是如果你写为<code>from datetime import datetime</code>，那么你导入的<code>datetime</code>是一个<code>type</code>类：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-45-07.png" alt></p><p>因为这种方式导入的<code>datetime</code>，它就是Python 中的一种类型，用于表示包含日期和时间的数据。</p><p>这两种导入方式导入的<code>datetime</code>，虽然名字一样，但是他们的意义完全不一样，请大家观察下面两种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">one_hour_ago = now - datetime.timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">now = datetime.now()</span><br><span class="line">one_hour_ago = now - timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第二种写法看似简单，但实则改动起来却更为麻烦。例如我还需要增加一个变量<code>today</code>用于记录今日的日期。</p><p>对于第一段代码，我们只需要增加一行即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">today = datetime.date.today()</span><br></pre></td></tr></table></figure><p>但对于第二行来说，我们需要首先修改导入部分的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, date</span><br></pre></td></tr></table></figure><p>然后才能改代码：<code>today = date.today()</code></p><p>这样一来你就要修改两个地方，反倒增加了负担。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>在使用某些第三方库的代码里面，我们会看到类似这样的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"></span><br><span class="line">selector = fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是我们还可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">selector = html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是，下面这种写法会导致报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line">selector = lxml.html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>那么这里的<code>lxml.html</code>又是什么东西呢？</p><p>这种情况多常见于一些特别大型的第三方库中，这种库能处理多种类型的数据。例如<code>lxml</code>它既能处理<code>xml</code>的数据，又能处理<code>html</code>的数据，于是这种库会划分子模块，<code>lxml.html</code>模块专门负责<code>html</code>相关的数据。</p><h2 id="自己来实现多种导入方法"><a href="#自己来实现多种导入方法" class="headerlink" title="自己来实现多种导入方法"></a>自己来实现多种导入方法</h2><p>我们现在自己来写代码，实现这多种导入方法。</p><p>我们创建一个文件夹<code>DocParser</code>，在里面分别创建两个文件<code>main.py</code>和<code>util.py</code>，他们的内容如下：</p><p><code>util.py</code>文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'write 函数被调用！'</span>)</span><br></pre></td></tr></table></figure><p><code>main.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util</span><br><span class="line"></span><br><span class="line">util.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-06-29.png" alt></p><p>现在我们把<code>main.py</code>的导入方式修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> write</span><br><span class="line"></span><br><span class="line">write()</span><br></pre></td></tr></table></figure><p>依然正常运行，如下图所示</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-07-21.png" alt></p><blockquote><p>当两个文件在同一个文件夹下面，并且该文件夹里面没有<strong>init</strong>.py 文件时，两种导入方式等价。</p></blockquote><p>现在，我们来创建一个文件夹<code>microsoft</code>，里面再添加一个文件<code>parse.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'我是 microsoft 文件夹下面的 parse.py 中的 read函数'</span>)</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-11-17.png" alt></p><p>此时我们在 <code>main.py</code>中对它进行调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">parse.read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-12-17.png" alt></p><p>我们也可以用另一种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.parse <span class="keyword">import</span> read</span><br><span class="line"></span><br><span class="line">read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-13-17.png" alt></p><p>但是，你不能直接导入<code>microsoft</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-15-35.png" alt></p><blockquote><p>你只能导入一个模块或者导入一个函数或者类，你不能导入一个文件夹</p></blockquote><p>无论你使用的是<code>import xxx</code>还是<code>from xxx.yyy.zzz.www import qqq</code>，你导入进来的东西，要不就是一个模块(对应到.py 文件的文件名)，或者是某个.py 文件中的函数名、类名、变量名。</p><p>无论是<code>import xxx</code>还是<code>from xxx import yyy</code>，你导入进来的都不能是一个文件夹的名字。</p><p>可能有这样一种情况，就是某个函数名与文件的名字相同，例如：</p><p>在 <code>microsoft</code>文件夹里面有一个<code>microsoft.py</code>文件，这个文件里面有一个函数叫做<code>microsoft</code>，那么你的代码可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> microsoft`</span><br><span class="line">microsoft.microsoft()</span><br></pre></td></tr></table></figure><p>但请注意分辨，这里你导入的还是模块，只不过<code>microsoft.py</code>文件名与它所在的文件夹名恰好相同而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是使用<code>import</code>还是<code>from import</code>，第一个要求是代码能够正常运行，其次，根据代码维护性，团队编码风格来确定选择哪一种方案。</p><p>如果我们只会使用到某个模块下面的一个函数（或者常量、类）并且名字不会产生混淆，可识别性高，那么<code>from 模块名 import 函数名</code>这没有什么问题。</p><p>如果我们会用到一个模块下面的多个函数，或者是我们将要使用的函数名、常量名、类名可能会让人产生混淆（例如 re.S、re.I），那么这种情况下，<code>import 模块名</code>然后再 <code>模块名.xxx</code>来调用会让代码更加清晰，更好维护。</p><p>但无论什么情况下，都禁止使用<code>from xxx import *</code>这种写法，它会给你带来无穷无尽的噩梦。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>在明天的文章中，我们来讲讲还有一种写法<code>from . import xxx</code>，以及当文件夹中存在<code>__init__.py</code>时，导入方式又有什么变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用&lt;code&gt;import xxx&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import yyy&lt;/code&gt;？什么时候用&lt;code&gt;from xxx.yyy import zzz&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import *&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;这篇文章，我们来彻底搞懂这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：推特时间的格式化方案</title>
    <link href="https://www.kingname.info/2020/03/23/twitter-time-format/"/>
    <id>https://www.kingname.info/2020/03/23/twitter-time-format/</id>
    <published>2020-03-23T15:39:12.000Z</published>
    <updated>2020-03-23T15:39:39.967Z</updated>
    
    <content type="html"><![CDATA[<p>在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"created_at"</span>: <span class="string">"Tue Dec 24 10:51:15 +0000 2019"</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我想把它转换为<code>2019-12-24 18:51:15</code>的形式，应该如何操作呢？</p><a id="more"></a><p>可能有同学会按照下面这个逻辑来处理：</p><ol><li>首先，使用空格把这个时间字符串切分开变成<code>[&#39;Tue&#39;, &#39;Dec&#39;, &#39;24&#39;, &#39;10:51:15&#39;, &#39;+0000&#39;, &#39;2019&#39;]</code></li><li>第0项是星期，不需要，直接丢弃</li><li>第1项是月份，通过一个英文月份简称到月份数字的字典，把<code>Dec</code>映射为<code>12</code></li><li>第2项是日期，不做修改</li><li>第3项是时分秒，不做修改</li><li>第4项是时区，说明这个时间是采用的0时区，比北京时间晚8小时</li><li>第5项是年份，不做修改</li><li>把修改过的第1项、第2项、第3项、第5项调整顺序，拼接成一个符合要求的时间：<code>2019-12-24 10:51:15</code>。把使用<code>datetime.datetime.strptime</code>转成<code>datetime.datetime</code>对象。</li><li>把这个<code>datetime.datetime</code>对象加上<code>datetime.timedelta(hours=8)</code></li><li>使用<code>strftime</code>方法再把<code>datetime.datetime</code>对象转回字符串</li></ol><p>整个过程看起来非常麻烦。</p><p>实际上，我们有更简单的办法来处理。<code>Tue Dec 24 10:51:15 +0000 2019</code>对应的时间格式为<code>%a %b %d %H:%M:%S %z %Y</code>；对于一个<code>datetime.datetime</code>对象，我们可以调用它的<code>astimezone</code>方法把时区移除，移除以后就会变成当地时间。</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = <span class="string">'Wed Dec 25 09:09:25 +0000 2019'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj = datetime.datetime.strptime(dt, <span class="string">'%a %b %d %H:%M:%S %z %Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj.astimezone(tz=<span class="literal">None</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="string">'2019-12-25 17:09:25'</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-25-21-38-09.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;created_at&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Tue Dec 24 10:51:15 +0000 2019&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我想把它转换为&lt;code&gt;2019-12-24 18:51:15&lt;/code&gt;的形式，应该如何操作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
</feed>
