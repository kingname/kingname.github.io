<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2022-04-04T09:33:49.776Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么我认为爬虫开发的新征途在海外市场？</title>
    <link href="https://www.kingname.info/2022/04/04/new-future-of-crawler/"/>
    <id>https://www.kingname.info/2022/04/04/new-future-of-crawler/</id>
    <published>2022-04-04T09:32:25.000Z</published>
    <updated>2022-04-04T09:33:49.776Z</updated>
    
    <content type="html"><![CDATA[<p>开篇先抛出我的观点：希望各位做爬虫的同学，尽快，尽可能多地做海外的爬虫项目，爬海外的网站。这才是你们新的未来。</p><p>我最近两年时间，已经没有做过任何国内网站的爬虫了，根据这两年爬海外网站的一些经验，谈谈我的发现和想法。</p><a id="more"></a><h2 id="内地的环境不适合做爬虫"><a href="#内地的环境不适合做爬虫" class="headerlink" title="内地的环境不适合做爬虫"></a>内地的环境不适合做爬虫</h2><p>国内的网站在这么多年的爬虫与反爬虫的斗争中，反爬能力越来越强，瑞数、极验和其它第三方专业反爬虫系统，就能挡住很多人了。</p><p>国内值得爬的网站就只有这么几个，大家都在爬，你有1GB的数据，他有1TB的数据，内卷极其严重。很多工作室直接使用群控技术，几万台机器一起爬。普通人很难跟他们竞争。</p><p>国内一些专门做舆情分析的公司，他们甚至可以通过地下渠道直接拿到网站的内部API，数据质量比你通过爬虫爬的数据高多了。</p><p>爬国内的大网站，很容易被请喝茶。轻者拘留，重者在档案里面留下一辈子的污点。</p><h2 id="海外数据的新机遇"><a href="#海外数据的新机遇" class="headerlink" title="海外数据的新机遇"></a>海外数据的新机遇</h2><h3 id="NLP的语料"><a href="#NLP的语料" class="headerlink" title="NLP的语料"></a>NLP的语料</h3><p>NLP最重要的四个元素就是：语料、模型、算法、算力。其中模型和算力可以复用，自然不是问题。但因为没有人抓海外的数据，因此缺少了语料，没有语料，就没有办法训练模型。NLP里面的ABSA、语意理解、文本生成、智能问答也全都做不下去。特别是小众语言——法语、俄语、韩语、西班牙语，几乎就没有国内的公司在做。</p><p>抓数据不难，但难在对数据的标注。现在国内对小众语言的标注，还停留在使用Google翻译把小众语言先翻译成英文，再让人去给英文打标的阶段。</p><p>如果你能尽早收集小语种的语料，然后让懂这个语料的人去打标，那么以后即便你不直接做NLP，光出售小语种的标注数据，你都可以大赚一笔。国内学习小语种的大学生，找工作都很困难。如果你能让他们兼职给你标注数据，不仅提供了就业岗位，而且价格非常低廉，属于是双赢。</p><p>语料抓取的壁垒不是爬虫技术，而是数据量和数据多样性。数据量达到一定规模以后，壁垒自然就能形成。别人的爬虫再先进，只要它短期收集不了那么多的数据，那么它就没有办法超过你。</p><p>总之，越早开始收集海外语料，越早能形成自己的壁垒。</p><h3 id="游戏出海"><a href="#游戏出海" class="headerlink" title="游戏出海"></a>游戏出海</h3><p>众所周知，游戏在内地已经没有未来了，各大游戏厂商在接下来的几年会把游戏出海作为最重要的目标。目前已经有几家公司的游戏在东南亚大杀四方，在欧美市场也一路血洗当地的产品。想必大家都知道我说的是哪几个游戏。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220404152553.png" alt></p><p>但可以确定的是，目前国内做舆情分析的公司，还没有谁能够把海外舆情（特指非英语国家）分析做好。如果你有丰富的海外舆情抓取经验，那么当这些公司招聘的时候，你就有很高的竞争力。</p><h3 id="尽职调查"><a href="#尽职调查" class="headerlink" title="尽职调查"></a>尽职调查</h3><p>除了游戏外，基于数据的尽职调查也是一个方向。投资人在确定是否要投资某个创业公司前，都会做尽职调查（DD）。其中基于数据的尽职调查（DDD）就是其中的重要一环。例如一个电商初创公司告诉投资人，他每个月的销售额有几百亿，然后你用爬虫爬一下他的商城，根据每个商品的销量和评论，反推出他的月销售额只有几百元，那么你就能知道这个电商公司在骗投资人了。</p><p>又比如某个直播网站，对投资人宣称自己的日活月活非常高，然后你用爬虫监控一下热门主播的评论数，礼物数，设计一个公式计算出它的真实日活月活，两边一对比你就知道他们有没有骗人了。</p><h2 id="海外网站是新的蓝海"><a href="#海外网站是新的蓝海" class="headerlink" title="海外网站是新的蓝海"></a>海外网站是新的蓝海</h2><p>只要你把视野放开，稍微研究一下我国台湾、香港的网站，以及英法意德，巴西韩国，俄罗斯东南亚的网站，你就会发现：</p><ol><li>大部分网站几乎没有反爬虫机制</li><li>语料极其丰富</li><li>小部分网站有极难的反爬虫系统（Akamai），但是可以通过曲折绕过的方式拿到数据</li><li>国内几乎没有竞争对手，你爬得越多，你积累的原始资本就越大</li></ol><p>如果你是个人开发者，你几乎不用担心有什么风险。因为不会有人来找你喝茶。</p><h2 id="怎么跟外国的公司竞争？"><a href="#怎么跟外国的公司竞争？" class="headerlink" title="怎么跟外国的公司竞争？"></a>怎么跟外国的公司竞争？</h2><p>有人可能会问，难道美国、欧洲自己没有做爬虫、做舆情的公司吗？他们肯定也做了很多年了，为什么国内的公司要找你，而不去找这些欧美本土的公司？</p><p>我认为，就凭这五个字：<code>你是自己人</code>。</p><p>如果你是一家中国的公司，专注分析海外舆情。即便你的业务能力跟一家欧美公司差不多甚至稍微低一些（当然低太多可不行），国内的大公司在选择合作伙伴的时候，一定会优先考虑你，而不是欧美当地的公司。</p><p>无论从人性上，还是从法律合规上，选择自己人都会安心很多。从人性上，中国人会选择跟中国人合作。大家都在互联网圈子，你这个公司怎么样，你这个老板怎么样，稍稍打听一下就知道了。只要知道你确实有实力，为什么不找你？</p><p>从业务上，两边公司沟通都用中文，有什么问题线上聊一下或者出个差，早上出发中午就能到，沟通起来很方便。</p><h2 id="大公司应该怎么做爬虫？"><a href="#大公司应该怎么做爬虫？" class="headerlink" title="大公司应该怎么做爬虫？"></a>大公司应该怎么做爬虫？</h2><p>我提到如果你是个人开发者或者小公司，那么你几乎不用担心任何风险。尽管爬就是了。</p><p>但如果你是国内的大公司，那么还是有一些注意事项的。因为大公司会担心像GDPR这样的信息保护法，也会担心如果爬虫被发现了会影响自己的国际声誉。但这些其实都不是什么大问题，都有办法绕过去的。</p><p>具体做法跟本文的关系不大，我就先不讲了。如果大家对爬虫出海有兴趣的话，请留言告诉我，我可以再分享一些具体的实践经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开篇先抛出我的观点：希望各位做爬虫的同学，尽快，尽可能多地做海外的爬虫项目，爬海外的网站。这才是你们新的未来。&lt;/p&gt;
&lt;p&gt;我最近两年时间，已经没有做过任何国内网站的爬虫了，根据这两年爬海外网站的一些经验，谈谈我的发现和想法。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：为什么网站知道我的爬虫使用了代理？</title>
    <link href="https://www.kingname.info/2022/03/20/proxy-is-not-everything/"/>
    <id>https://www.kingname.info/2022/03/20/proxy-is-not-everything/</id>
    <published>2022-03-20T15:34:55.000Z</published>
    <updated>2022-03-20T15:37:56.964Z</updated>
    
    <content type="html"><![CDATA[<p>在公众号粉丝群里面，经常有同学问：为什么自己的爬虫明明设置了代理，但一访问网站就能被发现。我总结了几种常见的情况。</p><p>实际上，网站要识别你是否使用了代理，并不一定非要什么高深的反爬虫机制，也不需要使用AI识别用户行为。下面这几种情况，要识别代理简直是易如反掌。</p><a id="more"></a><h2 id="你根本没有使用代理"><a href="#你根本没有使用代理" class="headerlink" title="你根本没有使用代理"></a>你根本没有使用代理</h2><p>有一些初学者在使用Requests请求网站的时候，是这样写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>).text</span><br><span class="line"></span><br><span class="line">print(<span class="string">'不使用代理：'</span>, resp)</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>: <span class="string">'http://IP:port'</span>&#125;).text</span><br><span class="line">print(<span class="string">'使用代理：'</span>, resp)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220320141719.png" alt></p><p>为什么使用了代理以后，IP没有变呢？这是很多刚刚使用Requests的同学常常犯的错误。因为你根本没有给https网站使用代理，你的代理只会对http网站生效。要对https网站生效，需要给它指定代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>: <span class="string">'http://IP:port'</span>, <span class="string">'https'</span>: <span class="string">'http://IP:port'</span>&#125;).text</span><br></pre></td></tr></table></figure><blockquote><p>P.S.: 注意看上面的代码，给https网址设置代理的时候，key是<code>https</code>，但值依然是<code>http://</code>开头。对一些代理供应商来说，如果你把这里设置成了<code>https://</code>开头，就会报错。不过这个原理跟本文无关，就暂时不讲了。如果大家有兴趣的话，我再写一篇文章来讲。</p></blockquote><h2 id="你的代理IP是服务器IP"><a href="#你的代理IP是服务器IP" class="headerlink" title="你的代理IP是服务器IP"></a>你的代理IP是服务器IP</h2><p>有很多代理供应商，他们批量采购云服务器来搭建代理服务。例如国内的供应商会采购阿里云、腾讯云、华为云的服务器来搭建代理。海外的供应商会采购AWS或者Google云服务器。</p><p>如果你在云服务器上跑过不加代理的爬虫，你会发现，有时候一个爬虫，不加代理，在自己电脑上跑一点问题都没有，但是在云服务器上一跑就会被识别。这是因为云服务器的IP地址范围跟家用宽带是不一样的。</p><p>像AWS和Google云，他们的云服务器IP范围是公开的，只要网站提前把来自这个范围的所有请求全部禁掉，那么从AWS、Google云服务器上面发起的请求直接就会被当做爬虫请求。因此搭建在上面的代理服务自然就不会生效了。</p><p>国内的云服务供应商的服务器IP地址是否公布过我不太清楚，但他们的IP范围肯定是跟家用IP不一样的。网址遇到来自这些可疑IP范围的请求时，虽然不一定完全封禁，但是弹一个验证码出来测一测，还是可以挡住很多爬虫。</p><p>遇到这种情况，爬虫只有设法采购一些使用家用宽带搭建代理服务的供应商，才能解决问题。但这种代理价格肯定会翻好几倍。</p><h2 id="你的代理IP不是高匿代理"><a href="#你的代理IP不是高匿代理" class="headerlink" title="你的代理IP不是高匿代理"></a>你的代理IP不是高匿代理</h2><p>代理IP有三种常见的类型，透明代理，匿名代理和高匿代理。</p><p>使用透明代理的时候，网站可以同时看到代理IP和你的真实IP。用了等于白用。</p><p>使用匿名代理的时候，网站看不到你的真实IP，但是在请求里面有一个特征，可以告诉网站，你正在使用代理访问。</p><p>而只有真正的高匿代理，才能把你的爬虫请求隐藏起来。</p><p>有一些同学可能会从网上搜索免费的代理IP来使用。但这里面很多代理并不是高匿代理。肯定会被发现。</p><h2 id="服务器供应商的IP池被污染"><a href="#服务器供应商的IP池被污染" class="headerlink" title="服务器供应商的IP池被污染"></a>服务器供应商的IP池被污染</h2><p>有些人的爬虫写得非常垃圾，自以为有代理就无所畏惧，爬虫请求漏掉百出，网站即使不检查IP频率，也可以从其它特征知道这是爬虫请求，于是网站就会连带着这个代理IP一起封掉。而偏偏这种垃圾爬虫的请求速度又极快。哪怕代理供应商的IP池中有几百万个IP，也会很快被这些垃圾爬虫全部害死。</p><p>国内头部网站每天都会被数以千万计的爬虫请求访问，而主流的代理供应商就那么几家。如果很多垃圾爬虫都选中了同一家供应商，而他们的代理池更新又不及时。那么你使用了这家供应商的代理IP，自然一来就会被发现。</p><h2 id="代理不支持HTTP-2"><a href="#代理不支持HTTP-2" class="headerlink" title="代理不支持HTTP/2"></a>代理不支持HTTP/2</h2><p>有一些网站需要使用HTTP/2请求。在Python里面，已经有不少HTTP客户端库支持发起HTTP/2的请求了，例如<code>httpx</code>。但是，现在很少有代理供应商能提供支持HTTP/2的代理，因为它搭建起来比较麻烦。于是，当你使用了支持HTTP/2的客户端，通过一个HTTP/1.1的代理IP访问一个HTTP/2的网站的时候，网站并不能正常返回内容。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网站要检测爬虫有非常多的方法，要检测一个请求是不是使用了代理来发起，也有很多种方法。而且这些方法并不需要什么高深的技术，一个初级工程师都能写出来。</p><p>那些自以为给爬虫加了代理就可随便爬网站的人，你们不仅害了自己，还害了别的爬虫。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在公众号粉丝群里面，经常有同学问：为什么自己的爬虫明明设置了代理，但一访问网站就能被发现。我总结了几种常见的情况。&lt;/p&gt;
&lt;p&gt;实际上，网站要识别你是否使用了代理，并不一定非要什么高深的反爬虫机制，也不需要使用AI识别用户行为。下面这几种情况，要识别代理简直是易如反掌。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="代理" scheme="https://www.kingname.info/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用装饰器简化大量if判断（二）</title>
    <link href="https://www.kingname.info/2022/03/20/decrease-if-2/"/>
    <id>https://www.kingname.info/2022/03/20/decrease-if-2/</id>
    <published>2022-03-20T15:34:39.000Z</published>
    <updated>2022-03-20T15:39:31.630Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章：<a href="https://mp.weixin.qq.com/s/eGji_6PBkf-vK2SQPB0WTQ" target="_blank" rel="noopener">一日一技：使用装饰器简化大量 if…elif…代码</a>发布以后，有很多同学说想看后续，如何在装饰器中表示大于小于。甚至有同学每周来催一次稿：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_0672.jpg" alt></p><p>于是，今天我们就来看看大于小于应该怎么来判断。为了实现我们今天的目标，有两个前置知识需要掌握，一个是Python自带的<code>operator</code>模块，另一个是偏函数。</p><a id="more"></a><h2 id="2-gt-1还有另一种写法？"><a href="#2-gt-1还有另一种写法？" class="headerlink" title="2 &gt; 1还有另一种写法？"></a>2 &gt; 1还有另一种写法？</h2><p>当我们要表达<code>大于</code>这个意思的时候，你想到的肯定是大于符号<code>&gt;</code>。所以<code>2大于1</code>，肯定写作<code>2 &gt; 1</code>。这看起来是很正常的事情。现在，如果我让你不准使用大于符号<code>&gt;</code>，怎么表示大于？</p><p>实际上，在Python里面，除了<code>&gt;</code>外，还有一种写法，就是使用自带的<code>operator</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">operator.gt(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中的<code>.gt(参数1, 参数2)</code>就表示<code>参数1 &gt; 参数2</code>。如果成立，返回<code>True</code>，否则返回<code>False</code>。</p><p>类似的还有：</p><ul><li>大于等于：operator.ge</li><li>小于：operator.lt</li><li>小于等于：operator.le</li><li>不等于：operator.ne</li><li>等于：operator.eq</li></ul><p>因此，下面两个写法是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt;= b:</span><br><span class="line">    print(<span class="string">'成功'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> operator.le(a, b):</span><br><span class="line">    print(<span class="string">'成功'</span>)</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>我在很久以前的公众号文章里面已经介绍过偏函数了：<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g" target="_blank" rel="noopener">偏函数：在Python中设定默认参数的另一种办法</a>。因此本文就不再讲它的基础用法了，大家点击链接去看那篇文章就可以掌握。</p><p>为什么我们需要偏函数呢？这是因为我们今天要做的事情，它需要给函数先传一半的参数，另一半的参数要在未来才能传入。例如，循环等待用户输入数字，如果其中一次输入的数字大于等于5，就打印<code>你好世界</code>。</p><p>如果不知道偏函数，你可能是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入数字：'</span>))</span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">'你好世界'</span>)</span><br></pre></td></tr></table></figure><p>有了偏函数以后，你的写法是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">ge_5 = partial(operator.le, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入数字：'</span>))</span><br><span class="line">    <span class="keyword">if</span> ge_5(num):</span><br><span class="line">        print(<span class="string">'你好世界'</span>)</span><br></pre></td></tr></table></figure><p>特别注意，这里我在偏函数中传入的第一个参数是<code>operator.le</code>：小于。因为<code>operator.xx</code>表示第一个参数对第二个参数的比较，所以<code>x &gt;= 5</code> 就相当于5 &lt;= x 也就是<code>operator.le(5, x)</code>。</p><h2 id="在装饰器中实现大小比较"><a href="#在装饰器中实现大小比较" class="headerlink" title="在装饰器中实现大小比较"></a>在装饰器中实现大小比较</h2><p>前置知识掌握以后，我们就能看如何在装饰器里面实现大小比较。在第一篇文章中，我们只实现了参数等于，它的原理是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(value)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> registry:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                    <span class="string">f'registered for <span class="subst">&#123;value!r&#125;</span>'</span></span><br><span class="line">                )</span><br><span class="line">            registry[value] = func</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p><code>register</code>只接收了一个位置参数<code>value</code>。但实际上，我们还可以通过修改这段注册的代码，实现如下的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(3, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级大于3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(3, op='le')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_le3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级小于等于3'</span>)</span><br></pre></td></tr></table></figure><p>有同学问，有没有可能实现这样的写法呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, le=3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级为2'</span>)</span><br></pre></td></tr></table></figure><p>我觉得这样写是没有什么必要的。因为<code>register()</code>里面，多个参数之间的关系是<code>且</code>。那么只有两种情况，要么，就等于这个数，例如<code>@get_discount.register(2, le=3)</code>，既要等于2，又要小于等于3，那显然就等于2。不需要写这个<code>le=3</code>。要么，就不存在结果，例如<code>@get_discount.register(2, gt=3)</code>，既要等于2，又要大于3，显然下面被装饰的函数永远不会执行。因为找不到这个数。</p><p>因此，我们的装饰器函数就可以做如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_dispatch</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    registry_eq = &#123;&#125;</span><br><span class="line">    registry_other = &#123;&#125;</span><br><span class="line">    key_op_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(arg0, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> arg0 <span class="keyword">in</span> registry_eq:</span><br><span class="line">            delegate = registry_eq[arg0]</span><br><span class="line">            <span class="keyword">return</span> delegate(arg0, *args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> key, op <span class="keyword">in</span> key_op_map.items():</span><br><span class="line">                <span class="keyword">if</span> op(arg0):</span><br><span class="line">                    delegate = registry_other[key]</span><br><span class="line">                    <span class="keyword">return</span> delegate(arg0, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(arg0, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(value, op=<span class="string">'eq'</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'eq'</span>:</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> value <span class="keyword">in</span> registry_eq:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(</span><br><span class="line">                        <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                        <span class="string">f'registered for <span class="subst">&#123;value!r&#125;</span>'</span></span><br><span class="line">                    )</span><br><span class="line">                registry_eq[value] = func</span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">return</span> wrap</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'gt'</span>:</span><br><span class="line">                op_func = functools.partial(operator.lt, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'ge'</span>:</span><br><span class="line">                op_func = functools.partial(operator.le, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'lt'</span>:</span><br><span class="line">                op_func = functools.partial(operator.gt, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'le'</span>:</span><br><span class="line">                op_func = functools.partial(operator.ge, value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'op 参数只能是：gt/ge/lt/le之一'</span>)</span><br><span class="line">            key = <span class="string">f'<span class="subst">&#123;op&#125;</span>_<span class="subst">&#123;value&#125;</span>'</span></span><br><span class="line">            key_op_map[key] = op_func</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> registry_other:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(</span><br><span class="line">                        <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                        <span class="string">f'registered for <span class="subst">&#123;key!r&#125;</span>'</span></span><br><span class="line">                    )</span><br><span class="line">                registry_other[key] = func</span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">return</span> wrap</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    wrapper.register = register</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>它的使用方法还是跟以前一样，先定义默认的函数逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value_dispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_discount</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'等级错误'</span></span><br></pre></td></tr></table></figure><p>如果定义相等的逻辑，写法跟以前完全一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_1</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="string">"大量计算代码"</span></span><br><span class="line">    discount = <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>如果要定义不等于逻辑，就在<code>.register()</code>中添加一个参数<code>op</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220315203458.png" alt></p><p>由于我们定义了大于2时，始终返回1，所以可以看到<code>get_discount(6)</code>和<code>get_discount(10)</code>返回的都是1.</p><p>由于我们只定义了等于1和大于2的逻辑，所以当传入的参数为2时，就返回<code>等级错误</code>.</p><p>到这里，本文要讲的内容就结束了。但最后还是要考大家3个问题：</p><h3 id="如果不使用偏函数和operator模块，你会怎么做"><a href="#如果不使用偏函数和operator模块，你会怎么做" class="headerlink" title="如果不使用偏函数和operator模块，你会怎么做"></a>如果不使用偏函数和operator模块，你会怎么做</h3><p>你可以试一试在不实用偏函数和<code>operator</code>的情况下，实现这个需求。</p><h3 id="如果定义的条件有重叠怎么办？"><a href="#如果定义的条件有重叠怎么办？" class="headerlink" title="如果定义的条件有重叠怎么办？"></a>如果定义的条件有重叠怎么办？</h3><p>例如对于下面的两个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(10, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>当level的值是20的时候，同时满足两个条件，应该运行哪一个呢？</p><h3 id="如何定义区间？"><a href="#如何定义区间？" class="headerlink" title="如何定义区间？"></a>如何定义区间？</h3><p>怎么实现这样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(ge=2, lt=5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_between2_5</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级2&lt;=level&lt;5'</span>)</span><br><span class="line">    discount = <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>如果区间存在全包含、部分包含应该运行哪个函数？例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(ge=2, lt=00)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(ge=20, lt=50)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(ge=80, lt=200)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>请大家把你对这两个问题的答案回答在评论区里面。提示（想清楚什么是真需求，什么是伪需求，再考虑怎么解决）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/eGji_6PBkf-vK2SQPB0WTQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：使用装饰器简化大量 if…elif…代码&lt;/a&gt;发布以后，有很多同学说想看后续，如何在装饰器中表示大于小于。甚至有同学每周来催一次稿：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_0672.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;于是，今天我们就来看看大于小于应该怎么来判断。为了实现我们今天的目标，有两个前置知识需要掌握，一个是Python自带的&lt;code&gt;operator&lt;/code&gt;模块，另一个是偏函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何准备简历和面试（未闻Code直播录像）</title>
    <link href="https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/"/>
    <id>https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/</id>
    <published>2022-03-09T09:26:09.000Z</published>
    <updated>2022-03-09T09:27:02.721Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1t3411B7XW&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1t3411B7XW&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="面试" scheme="https://www.kingname.info/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="面试" scheme="https://www.kingname.info/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>不走弯路的Docker入门</title>
    <link href="https://www.kingname.info/2022/03/09/intro-to-docker/"/>
    <id>https://www.kingname.info/2022/03/09/intro-to-docker/</id>
    <published>2022-03-09T09:24:02.000Z</published>
    <updated>2022-03-09T09:25:33.107Z</updated>
    
    <content type="html"><![CDATA[<p>保证你看完这个视频，就能使用 Docker。</p><iframe src="//player.bilibili.com/player.html?bvid=BV1Tg41157j4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保证你看完这个视频，就能使用 Docker。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1Tg41157j4&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder
      
    
    </summary>
    
      <category term="Docker" scheme="https://www.kingname.info/categories/Docker/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="Docker" scheme="https://www.kingname.info/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GneList 来了！抓取列表页-极-其-简-单！</title>
    <link href="https://www.kingname.info/2022/03/09/this-is-gnelist/"/>
    <id>https://www.kingname.info/2022/03/09/this-is-gnelist/</id>
    <published>2022-03-09T08:56:05.000Z</published>
    <updated>2022-03-09T09:06:54.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/GeneralNewsExtractor/GeneralNewsExtractor" target="_blank" rel="noopener">Gne</a>发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。</p><a id="more"></a><h2 id="GneList-是什么"><a href="#GneList-是什么" class="headerlink" title="GneList 是什么"></a>GneList 是什么</h2><p>GneList是一个浏览器插件，专门用来生成列表页的 XPath。使用这个 XPath，你可以快速获取到列表页中的每一个条目。</p><h2 id="GneList-怎么用？"><a href="#GneList-怎么用？" class="headerlink" title="GneList 怎么用？"></a>GneList 怎么用？</h2><iframe src="//player.bilibili.com/player.html?bvid=BV1Nb4y1s7Lc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe><p>GneList 的使用非常简单，几乎不需要说明。</p><ol><li>打开带有列表的页面</li><li>点击插件</li><li>输入名字，点击<code>开始抓取</code></li><li>鼠标点击列表的前两项，GneList 会自动选中所有项</li><li>点击<code>提交</code>按钮</li><li>去数据库查看 XPath</li></ol><h2 id="怎么安装-GneList"><a href="#怎么安装-GneList" class="headerlink" title="怎么安装 GneList?"></a>怎么安装 GneList?</h2><p>GneList 由两个部分组成：插件端与后端。</p><p>插件端的下载地址：<a href="https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip</a></p><p>后端的代码：<a href="https://github.com/GeneralNewsExtractor/GneListBackend" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneListBackend</a> ，并且后端依赖 MongoDB。</p><h3 id="安装后端"><a href="#安装后端" class="headerlink" title="安装后端"></a>安装后端</h3><p>首先确保你有一个可以连接的 MongoDB，我们假设它的 URI 是：<code>mongodb://localhost</code>。从 Github上面 clone 后端的代码：<code>https://github.com/GeneralNewsExtractor/GneListBackend.git</code>。</p><p>进入后端代码的根目录中的 config 文件夹中，你会发现一个<code>local.yml</code>文件。打开它，第一行填写 MongoDB 的 URI 地址，第二行是数据库名，第三行是集合名。插件生成的 XPath 会保存在这里供你的下游调用。</p><p>改好配置文件以后，回到后端的根目录，分别执行如下命令(你需要先安装 Pipenv)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipenv install</span><br><span class="line">pipenv shell</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">local</span> <span class="comment"># 你自己创建的 yml文件的名字</span></span><br><span class="line">uvicorn main:app --port 8800 --host 0.0.0.0  <span class="comment"># 使用8800端口</span></span><br></pre></td></tr></table></figure><p>命令执行完成后，如果你使用浏览器访问<code>http://127.0.0.1:8800</code>，应该会看到下图的内容，说明后端搭建成功。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-40-38.png" alt></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>GneList 插件支持所有基于 Chromium 内核的浏览器，包括但不限于 Chrome/Chromium/Edge。</p><p>从上面的地址下载<code>GneList.zip</code>后，把它解压到任何一个文件夹中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-45-08.png" alt></p><p>然后打开你的浏览器的插件管理页面，启动<code>开发人员模式</code>，例如下图是我在 Edge 中开启开发人员模式的方法。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-47-02.png" alt></p><p>然后点击右上角的<code>加载解压缩的扩展</code>，选中<code>GneList</code>文件夹。完成。</p><p>现在，刷新已有的列表页，或者重新开一个新的列表页，然后点击插件，试用一下吧。</p><h3 id="管理配置页面"><a href="#管理配置页面" class="headerlink" title="管理配置页面"></a>管理配置页面</h3><p>在插件上右键，选择<code>扩展选项</code>。Chrome 上面，名字可能是叫做<code>选项</code>或者英文<code>Options</code>。可以打开如下图所示的页面：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-51-06.png" alt></p><p>如果你没有启动后端，或者后端地址不是<code>http://127.0.0.1:8800</code>（例如你把后端部署在服务器上，需要使用 IP 或者域名来访问，或者端口不是8800），那么这个页面应该如上图所示。</p><p>你可以把输入框中的地址改为<code>后端地址/rule</code>，例如<code>http://123.56.78.99:8888/rule</code>。然后点击<code>提交</code>按钮。接下来刷新页面，你就可以看到如下图所示的内容：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-54-35.png" alt></p><p>这个页面显示了你已经添加的所有网站的XPath，你可以对他们进行修改或者删除。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>为什么插件生成的 XPath 这么奇怪？</p></blockquote><p>因为这些 XPath 是从 CssSelector 转成的 XPath，我用了一个第三方的 JavaScript 包。那个包转出来的就是这么奇怪。但不影响它的功能。我后面会更换更好的包，让 XPath 变得更好看。</p><blockquote><p>我的爬虫怎么使用这些 XPath？</p></blockquote><p>还记得一开始配置的 MongoDB 吗？让你的爬虫去里面读取就可以了。</p><blockquote><p>为什么我启动插件以后，点网页上面的元素第一次没有反应？</p></blockquote><p>第一次点击的时候，如果发现没有生成红框框，就多点一下。看到红框框了再点第二个元素。</p><h2 id="GneList-的原理是什么？"><a href="#GneList-的原理是什么？" class="headerlink" title="GneList 的原理是什么？"></a>GneList 的原理是什么？</h2><p>接下来的几篇文章，我会介绍 GneList 的原理。如果你等不及的话，也可以到 Github上查看<a href="https://github.com/GeneralNewsExtractor/GneList" target="_blank" rel="noopener">源代码</a>。GneList 与 Gne 一样，他们是站在其他优秀开源项目的肩膀上做出来的，尤其是受到 <a href="https://github.com/martinsbalodis/web-scraper-chrome-extension" target="_blank" rel="noopener">web-scraper-chrome-extension</a>的启发。因此，GneList也是完全开源的，允许非商业使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gne&lt;/a&gt;发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。&lt;/p&gt;
    
    </summary>
    
      <category term="Gne" scheme="https://www.kingname.info/categories/Gne/"/>
    
    
      <category term="Gne" scheme="https://www.kingname.info/tags/Gne/"/>
    
      <category term="GneList" scheme="https://www.kingname.info/tags/GneList/"/>
    
  </entry>
  
  <entry>
    <title>使用 LogSeq 阅读 PDF体验极好</title>
    <link href="https://www.kingname.info/2022/03/09/read-pdf-by-logseq/"/>
    <id>https://www.kingname.info/2022/03/09/read-pdf-by-logseq/</id>
    <published>2022-03-09T07:10:49.000Z</published>
    <updated>2022-03-09T09:28:56.104Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1iL411N7sq&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1iL411N7sq&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="LogSeq" scheme="https://www.kingname.info/categories/LogSeq/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="LogSeq" scheme="https://www.kingname.info/tags/LogSeq/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI的小兄弟，开发命令行工具更给力</title>
    <link href="https://www.kingname.info/2022/03/06/typer/"/>
    <id>https://www.kingname.info/2022/03/06/typer/</id>
    <published>2022-03-06T15:16:46.000Z</published>
    <updated>2022-03-06T15:27:53.637Z</updated>
    
    <content type="html"><![CDATA[<p>关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。</p><p>FastAPI的开发组织叫做<code>tiangolo</code>，他家除了FastAPI外，还有另一个项目也非常好用，叫做<code>typer</code>。</p><p>三年前，我写过一篇文章<a href="https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ" target="_blank" rel="noopener">一日一技：快速实现Python 命令行参数</a>介绍另一个命令行工具fire. 而<code>typer</code>做得比fire还要好。</p><a id="more"></a><p>首先使用pip来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer</span><br></pre></td></tr></table></figure><h2 id="函数参数等于命令行参数"><a href="#函数参数等于命令行参数" class="headerlink" title="函数参数等于命令行参数"></a>函数参数等于命令行参数</h2><p>我们首先来看看typer怎么使用。创建一个<code>example_1.py</code>文件，写入如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(name: str, salary: int)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span>月薪<span class="subst">&#123;salary&#125;</span>元'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    typer.run(main)</span><br></pre></td></tr></table></figure><p>直接运行，Python会报错：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182532.png" alt></p><p>使用参数<code>--help</code>可以查看这个脚本的命令行参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182619.png" alt></p><p>于是我们根据这里的提示，输入正确的参数，从而正常运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182659.png" alt></p><h2 id="子命令与自动补全更好用"><a href="#子命令与自动补全更好用" class="headerlink" title="子命令与自动补全更好用"></a>子命令与自动补全更好用</h2><p>假设我们有一个神经网络的程序，其中的入口函数代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>显然，这个程序可以用来训练数据，也可以用来预测数据，所以有两种不同的命令，每一种命令有不同的参数。</p><p>这种情况下，使用typer非常方便，只需要加两个装饰器就可以了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183543.png" alt></p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183621.png" alt></p><p>输入具体的子命令，还可以查看每个子命令的参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183725.png" alt></p><p>因此，我可以使用两个不同的子命令来运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185959.png" alt></p><p>你以为这样就完了？我们再安装它的一个辅助工具<code>typer-cli</code>，还可以做更多事情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer-cli</span><br><span class="line">typer --install-completion</span><br></pre></td></tr></table></figure><p>有了这个东西，我们运行程序可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer example_2.py run 子命令 参数1 参数2 --可选参数1 可选参数1的值</span><br></pre></td></tr></table></figure><p>例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184434.png" alt></p><p>并且，typer可以帮我们可以实现自动补全：</p><p>输入<code>typer example_2.py run</code> 然后按下<code>Tab</code>键，自动告诉你可以输入哪些子命令，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184218.png" alt></p><p>除此之外，如果你的命令行程序只有一个命令，那么你甚至只需要写一个函数，连typer都不需要导入，就可以使用typer来运行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184837.png" alt></p><h2 id="自动生成文档也简单"><a href="#自动生成文档也简单" class="headerlink" title="自动生成文档也简单"></a>自动生成文档也简单</h2><p>我们知道，FastAPI自动生成接口文档的功能非常好用。typer作为它的兄弟，也继承了这个高级功能。我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line">app = typer.Typer(help=<span class="string">"人脸检测模型"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer main.py utils docs --name <span class="string">"python3 main.py"</span> --output readme.md</span><br></pre></td></tr></table></figure><p>自动在当前文件夹生成一个<code>readme.md</code>文件。我们使用任何能够渲染Markdown的软件打开这个文档，可以看到文档内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185537.png" alt></p><p>这样一来，我们不需要额外花心思去维护文档，只需要在修改完代码、增删新的命令或者参数以后，运行这个命令，就可以把文档自动更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。&lt;/p&gt;
&lt;p&gt;FastAPI的开发组织叫做&lt;code&gt;tiangolo&lt;/code&gt;，他家除了FastAPI外，还有另一个项目也非常好用，叫做&lt;code&gt;typer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;三年前，我写过一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：快速实现Python 命令行参数&lt;/a&gt;介绍另一个命令行工具fire. 而&lt;code&gt;typer&lt;/code&gt;做得比fire还要好。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="FastAPI" scheme="https://www.kingname.info/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>舍近求远，为什么 Golang 要这样读取本地的 package？</title>
    <link href="https://www.kingname.info/2022/03/06/gomod/"/>
    <id>https://www.kingname.info/2022/03/06/gomod/</id>
    <published>2022-03-06T15:16:38.000Z</published>
    <updated>2022-03-06T15:28:07.028Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 <code>pip</code> 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 <code>go get</code> 进行安装。</p><p>有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。</p><a id="more"></a><p>例如我们看这个项目：<a href="https://github.com/kingname/handsome" target="_blank" rel="noopener">https://github.com/kingname/handsome</a> ，它的入口文件是<code>main.go</code>。我们打开这个文件，会看到里面<code>import</code>语句中，从 Github导入自身的<code>util</code>包：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193156.png" alt></p><p>可问题是，这个 <code>util</code>文件夹就在<code>main.go</code>旁边啊：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193259.png" alt></p><p>如果是在 Python 里面，入口文件<code>main.py</code>旁边有一个<code>util</code>文件夹，这个文件夹里面有一个<code>util.py</code>的文件，那么我们直接写<code>from util.util import xxx</code>就可以导入<code>util.py</code>文件中的函数了。为什么 Golang 里面要从 Github 导入？那如果我更新了<code>util/util.go</code>文件里面的内容，但是我没有把这次修改上传到 Github 中，当我运行<code>go run main.go</code>的时候，运行的是老代码还是新代码？用的是我本地的版本还是 Github 上面的版本？</p><p>这个问题的关键，就在<code>go.mod</code>这个文件中。打开请看这个文件的第一行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120194356.png" alt></p><p>可以看到，这个项目是使用 <code>go mod</code> 进行管理的，并且指定这个模块的名字，就叫做<code>github.com/kingname/handsome</code>。</p><p>所以，当我们执行命令<code>go run main.go</code>的时候，Golang 的编译器知道自己就是<code>github.com/kingname/handsome</code>，那么<code>main.go</code>里面导入<code>github.com/kingname/handsome/util</code>，实际上就是本项目自身根目录的 <code>util</code>文件夹中的包，它不会发起网络请求，不会从 Github 上面重新下载。每次运行的时候，使用的总是项目<code>util/util.go</code>中的内容。</p><p>但是，如果你现在在另外一个项目里面导入<code>github.com/kingname/handsome/util</code>，Golang 从<code>go.mod</code>中知道当前运行的项目跟即将导入的这个包不在同一个项目中，于是它就会去 Github 上面拉代码下来运行。</p><p>这个规则，可以在 Golang 的官方文档<strong>Module paths</strong>这一节找到：<a href="https://go.dev/ref/mod#introduction" target="_blank" rel="noopener">Go Modules Reference - The Go Programming Language</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 &lt;code&gt;pip&lt;/code&gt; 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 &lt;code&gt;go get&lt;/code&gt; 进行安装。&lt;/p&gt;
&lt;p&gt;有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</title>
    <link href="https://www.kingname.info/2022/03/06/gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/gzip-boom/</id>
    <published>2022-03-06T15:16:09.000Z</published>
    <updated>2022-03-06T15:26:02.606Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。</p><p>看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。</p><a id="more"></a><blockquote><p>本文有一个前提：你已经知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。</p></blockquote><p>很多人的爬虫是使用Requests来写的，如果你阅读过Requests的文档，那么你可能在文档中的<a href="https://2.python-requests.org/en/master/user/quickstart/#binary-response-content" target="_blank" rel="noopener">Binary Response Content</a>这一小节，看到这样一句话：</p><blockquote><p>The gzip and deflate transfer-encodings are automatically decoded for you.<br>（Request）会自动为你把gzip和deflate转码后的数据进行解码</p></blockquote><p>网站服务器可能会使用<code>gzip</code>压缩一些大资源，这些资源在网络上传输的时候，是压缩后的二进制格式。客户端收到返回以后，如果发现返回的Headers里面有一个字段叫做<code>Content-Encoding</code>，其中的值包含<code>gzip</code>，那么客户端就会先使用<code>gzip</code>对数据进行解压，解压完成以后再把它呈现到客户端上面。浏览器自动就会做这个事情，用户是感知不到这个事情发生的。而<code>requests</code>、<code>Scrapy</code>这种网络请求库或者爬虫框架，也会帮你做这个事情，因此你不需要手动对网站返回的数据解压缩。</p><p>这个功能原本是一个方便开发者的功能，但我们可以利用这个功能来做报复爬虫的事情。</p><p>我们首先写一个客户端，来测试一下返回<code>gzip</code>压缩数据的方法。</p><p>我首先在硬盘上创建一个文本文件<code>text.txt</code>，里面有两行内容，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124194721.png" alt></p><p>然后，我是用<code>gzip</code>命令把它压缩成一个<code>.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat text.txt | gzip &gt; data.gz</span><br></pre></td></tr></table></figure><p>接下来，我们使用FastAPI写一个HTTP服务器<code>server.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>然后使用命令<code>uvicorn server:app</code>启动这个服务。</p><p>接下来，我们使用requests来请求这个接口，会发现返回的数据是乱码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195107.png" alt></p><p>返回的数据是乱码，这是因为服务器没有告诉客户端，这个数据是<code>gzip</code>压缩的，因此客户端只有原样展示。由于压缩后的数据是二进制内容，强行转成字符串就会变成乱码。</p><p>现在，我们稍微修改一下<code>server.py</code>的代码，通过Headers告诉客户端，这个数据是经过<code>gzip</code>压缩的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    resp.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'gzip'</span>  <span class="comment"># 说明这是gzip压缩的数据</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>修改以后，重新启动服务器，再次使用requests请求，发现已经可以正常显示数据了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195422.png" alt></p><p>这个功能已经展示完了，那么我们怎么利用它呢？这就不得不提到压缩文件的原理了。</p><p>文件之所以能压缩，是因为里面有大量重复的元素，这些元素可以通过一种更简单的方式来表示。压缩的算法有很多种，其中最常见的一种方式，我们用一个例子来解释。假设有一个字符串，它长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br></pre></td></tr></table></figure><p>我们可以用5个字符来表示：<code>192个1</code>。这就相当于把192个字符压缩成了5个字符，压缩率高达97.4%。</p><p>如果我们可以把一个1GB的文件压缩成1MB，那么对服务器来说，仅仅是返回了1MB的二进制数据，不会造成任何影响。但是对客户端或者爬虫来说，它拿到这个1MB的数据以后，就会在内存中把它还原成1GB的内容。这样一瞬间爬虫占用的内存就增大了1GB。如果我们再进一步增大这个原始数据，那么很容易就可以把爬虫所在的服务器内存全部沾满，轻者服务器直接杀死爬虫进程，重则爬虫服务器直接死机。</p><p>你别以为这个压缩比听起来很夸张，其实我们使用很简单的一行命令就可以生成这样的压缩文件。</p><p>如果你用的是Linux，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1M count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>如果你的电脑是macOS，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1048576 count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>执行过程如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200621.png" alt></p><p>生成的这个<code>boom.gz</code>文件只有995KB。但是如果我们使用<code>gzip -d boom.gz</code>对这个文件解压缩，就会发现生成了一个1GB的<code>boom</code>文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200731.png" alt></p><p>只要大家把命令里面的<code>count=1000</code>改成一个更大的数字，就能得到更大的文件。</p><p>我现在把<code>count</code>改成<code>10</code>，给大家做一个演示（不敢用1GB的数据来做测试，害怕我的Jupyter崩溃）。生成的<code>boom.gz</code>文件只有10KB：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201125.png" alt></p><p>服务器返回一个10KB的二进制数据，没有任何问题。</p><p>现在我们用requests去请求这个接口，然后查看一下<code>resp</code>这个对象占用的内存大小：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201007.png" alt></p><p>可以看到，由于requests自动会对返回的数据解压缩，因此最终获得的resp对象竟然有10MB这么大。</p><p>如果大家想使用这个方法，一定要先确定这个请求是爬虫发的，再使用。否则被你干死的不是爬虫而是真实用户就麻烦了。</p><p>本文的写作过程中，参考了文章<a href="http://da.dadaaierer.com/?p=577" target="_blank" rel="noopener">网站gzip炸弹 – 王春伟的技术博客</a>，特别感谢原作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。&lt;/p&gt;
&lt;p&gt;看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：轻松排雷，爬虫让gzip炸弹变成哑炮</title>
    <link href="https://www.kingname.info/2022/03/06/kill-gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/kill-gzip-boom/</id>
    <published>2022-03-06T15:15:59.000Z</published>
    <updated>2022-03-06T15:26:19.914Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章《<a href="https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg" target="_blank" rel="noopener">一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</a>》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。</p><p>大家都知道我的公众号风格，要<del>得罪</del>讨好就两边一起<del>得罪</del>讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？</p><p>最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。</p><p>如果你没有把握隐藏爬虫，那么，请继续往下看。</p><a id="more"></a><p>查看gzip炸弹的URL返回的Headers，你会发现如下图所示的字段：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184230.png" alt></p><p>你只需要判断<code>resp.headers</code>中，是否有一个名为<code>content-encoding</code>，值包含<code>gzip</code>或<code>deflate</code>的字段。如果没有这个字段，或者值不含<code>gzip</code>、<code>deflate</code>那么你就可以放心，它大概率不是炸弹。</p><p>值得一提的是，当你不读取<code>resp.content</code>、<code>resp.text</code>的时候，Requests是不会擅自给你解压缩的，如下图所示。因此你可以放心查看Headers。：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184347.png" alt></p><p>那么，如果你发现网站返回的内容确实是<code>gzip</code>压缩后的内容了怎么办呢？这个时候，我们如何做到既不解压缩，又能获取到解压以后的大小？</p><p>如果你本地检查一个<code>.gz</code>文件，那么你可以使用命令<code>gzip -l xxx.gz</code>来查看它的头信息：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184943.png" alt></p><p>打印出来的数据中，第一个数字是压缩后的大小，第二个数字是解压以后的大小，第三个百分比是压缩率。这些信息是储存在压缩文件的头部信息中的，不用解压就能获取到。</p><p>那么当我使用Requests的时候，如何获得压缩后的二进制数据，防止它擅自解压缩？方法其实非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line">print(resp.raw.read())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185246.png" alt></p><p>此时可以看到，这个大小是压缩后的二进制数据的大小。现在，我们可以使用如下代码，在不解压的情况下，查询到解压缩后的文件大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">decompressed = resp.raw.read()</span><br><span class="line"><span class="keyword">with</span> gzip.open(io.BytesIO(decompressed), <span class="string">'rb'</span>) <span class="keyword">as</span> g:</span><br><span class="line">    g.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    origin_size = g.tell()</span><br><span class="line">    print(origin_size)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185700.png" alt></p><p>打印出来的数字转成MB就是10MB，也就是我们昨天测试的解压后的文件大小。</p><p>使用这个方法，我们就可以在不解压的情况下，知道网站返回的gzip压缩数据的实际大小。如果发现实际尺寸大得离谱，那就可以确定是gzip炸弹了，赶紧把它丢掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器&lt;/a&gt;》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。&lt;/p&gt;
&lt;p&gt;大家都知道我的公众号风格，要&lt;del&gt;得罪&lt;/del&gt;讨好就两边一起&lt;del&gt;得罪&lt;/del&gt;讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？&lt;/p&gt;
&lt;p&gt;最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。&lt;/p&gt;
&lt;p&gt;如果你没有把握隐藏爬虫，那么，请继续往下看。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：8行炫技代码，知识点多得不得了</title>
    <link href="https://www.kingname.info/2022/03/06/knowledge-in-bad-code/"/>
    <id>https://www.kingname.info/2022/03/06/knowledge-in-bad-code/</id>
    <published>2022-03-06T15:15:43.000Z</published>
    <updated>2022-03-06T15:23:40.546Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。</p><a id="more"></a><p>例如，我们知道Python里面的<code>range</code>函数，最少可以接收1个参数，最多能够接收3个参数。当只有两个参数的时候，格式为<code>range(开始, 结束)</code>，从开始数字到结束数字逐次加1，左闭右开。使用今天的方法，可以把它的写法改为<code>开始 |到| 结束</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127191711.png" alt></p><p>又比如，<code>urllib.parse.urljoin</code>可以把域名和一个相对路径拼接起来: <code>urljoin(域名, 相对路径)</code>，我们也可以改写成如下图所示的格式：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127192252.png" alt></p><p>这种炫技有余，实用不足的功能是怎么实现的呢？其实原理非常简单，只有8行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Change</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func(other)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        self.func = partial(self.func, other)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>这里就涉及到一个盲点和两个真正的知识点。这个盲点就是，你可能以为<br><code>|到|</code>是一个字符，但是它是3个字符；你可能会把<code>|拼接|</code>看做一个整体，但是它实际上是3个部分：左边的<code>|</code>、<code>拼接</code>和右边的<code>|</code>。</p><p>我们把空格加上，就很明显了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127194754.png" alt></p><p>两个真正的知识点，就是<code>__or__</code>和<code>__ror__</code>这两个魔术方法和偏函数<code>partial</code>。而<code>Change</code>本身就是一个普通的类而已，<code>__or__</code>和<code>__ror__</code>定义了这个类的实例在左侧遇到<code>|</code>时，右侧遇到<code>|</code>时的具体行为。</p><p>我们一个一个来讲。首先是<code>__or__</code>。它定义了实例的右侧遇到<code>|</code>时的具体行为。例如，我们用一个简单的代码来进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">f'我右边有一个东西，它是：<span class="subst">&#123;other&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">x = Test(<span class="number">100</span>)</span><br><span class="line">x | <span class="number">55</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193556.png" alt></p><p>但如果你把竖线放在左边，他就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193742.png" alt></p><p>而<code>__ror__</code>就是用来定义<code>|</code>在实例左边的时候，它的行为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193858.png" alt></p><p>所以，我们最开始的例子中，<code>2 |到| 10</code>，实际上应该理解为：</p><ol><li><code>到</code>是<code>Change(range)</code>返回的实例</li><li><code>2 | 到</code>  生成一个中间对象，我们假设它是<code>x</code></li><li><code>x | 10</code> 生成结果</li></ol><p>在我们演示的例子中，<code>2 | 到</code>首先进入了<code>Change</code>类的<code>__ror__</code>方法中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    self.func = partial(self.func, other)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>其中，一开始的<code>self.func</code>就是我们在初始化实例<code>Change(range)</code>时传入的参数<code>range</code>。所以<code>partial(self.func, other)</code>等价于<code>partial(range, 2)</code>。关于偏函数<code>partial</code>，大家可以看我这篇文章：<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g" target="_blank" rel="noopener">偏函数：在Python中设定默认参数的另一种办法</a>。简单来说，使用偏函数，可以给一个真正的函数传一部分参数，过一会再补剩下的参数。</p><p>可能大家在日常的开发者，很少会让一个实例方法返回<code>self</code>。关于这个写法，大家可以看我的这一篇文章：<a href="https://mp.weixin.qq.com/s/Y689WhpOopHdI8hbCGcFMg" target="_blank" rel="noopener">一日一技：在Python里面实现链式调用</a>。也就是说，<code>1 | 到</code>返回的，依然是<code>Change</code>类的一个实例，我们简称它为<code>x</code>。这个实例的属性<code>self.func</code>的值是<code>partial(range, 2)</code>。</p><p>接下来，<code>x | 10</code>，调用的是<code>__or__</code>方法，于是，此时执行的是<code>partial(range, 2)(10)</code>。偏函数的参数补全了，于是它里面的<code>range</code>真正运行了起来，成为了<code>range(2, 10)</code>。</p><p>至此，这个<code>Change</code>类我们就解析透了。大家知道，在Python里面，魔术方法是有很多的，如果你不想用<code>|</code>，你还可以用其它的，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195758.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195832.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195904.png" alt></p><p>同时，这个<code>Change</code>类，你甚至可以直接当做装饰器来使用。任何能够接收两个参数的函数，都能使用这个装饰器。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127200446.png" alt></p><p>最后总结一下。大家都知道，我是非常反对在工作代码中炫技的，因为炫技的写法很难读，很难维护。今天这个炫技的方法，虽然我也不推荐大家用在工作中，但是它短短8行代码里面，包含了很多个知识点，这就值得大家玩一玩了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>你以为的万能爬虫方法，其实一行代码就能识别！</title>
    <link href="https://www.kingname.info/2022/03/06/detect-js-click/"/>
    <id>https://www.kingname.info/2022/03/06/detect-js-click/</id>
    <published>2022-03-06T15:15:22.000Z</published>
    <updated>2022-03-06T15:24:52.501Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。</p><p>这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png" alt></p><a id="more"></a><p>而Chrome插件访问自己的服务器后端是没有跨域问题的，完全可以让插件获取到数据以后，发送给自己的服务器，这样就可以把数据收入囊中了。</p><p>你还可以通过JavaScript自动点击按钮，实现自动翻页。所以你只需要把网页打开，启动插件，然后他就能自动刷新，自动获取数据了。</p><p>这个方法看起来非常万能，而且无法被防御……</p><p>事实真的是这样吗？我写了一个Demo来做测试。Demo页面长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204724.png" alt></p><p>当我手动点击<code>点击我</code>按钮的时候，会弹出一个框：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204814.png" alt></p><p>现在，我使用JavaScript来选择这个按钮，然后点击它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204936.png" alt></p><p>为什么网站知道我在用JavaScript点击了按钮呢？其实只要我给你看这个页面的HTML，你就知道了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"spider"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>你这个狗爬虫<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"check"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                spider: <span class="literal">false</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                check: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                    if (event.isTrusted) &#123;</span><br><span class="line"><span class="javascript">                        alert(<span class="string">'主人你好，欢迎回家！'</span>)</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.spider = <span class="literal">true</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关键的点就是这个<code>event.isTrusted</code>。它是浏览器的一个功能，如果这个事件是人通过鼠标点击的，那么它是<code>true</code>。如果事件是通过JavaScript触发的，那么它是<code>false</code>。</p><p>关于这个属性，你可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/isTrusted" target="_blank" rel="noopener">Event.isTrusted - Web API 接口参考 | MDN</a>。这个例子里面，我用的是Vue来操作页面，但实际上<code>event</code>是浏览器的特性，使用原生JavaScript也可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.isTrusted) &#123;</span><br><span class="line">      alert(<span class="string">'主人你好，欢迎回家！'</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.spider = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>那么如何绕过这个<code>event.isTrusted</code>呢？其实很简单，你使用Selenium/Puppeteer，天然就能绕过它。</p><p>看到这里，大家肯定发现一个很好笑的问题，Selenium/Puppeteer不能解决的问题，用JavaScript轻松就能解决。但JavaScript解决不了的问题，用Selenium/Puppeteer又完全没有问题。</p><p>这就像是猫吃老鼠，老虎吃猫，大象吃老虎，但是老鼠可以吃大象。寸有所长，必有所短，寸有所短，也可能有所长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。&lt;/p&gt;
&lt;p&gt;这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何在浏览器中使用npm包？</title>
    <link href="https://www.kingname.info/2022/03/06/use-npm-package-in-browser/"/>
    <id>https://www.kingname.info/2022/03/06/use-npm-package-in-browser/</id>
    <published>2022-03-06T15:15:09.000Z</published>
    <updated>2022-03-06T15:21:16.742Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python的第三方库一般可以使用pip来安装。如果代码比较简单，我们甚至可以把第三方库的代码复制下来，放到项目里面导入。</p><p>但由于JavaScript生态里面，有Node.js这个东西，这就导致第三方库有两种不同的导入方式。如果我们要做一个网站，我们通常会在HTML中，使用<code>&lt;script&gt;</code>标签引入.js文件，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样导入了.js文件以后，里面的代码在网页加载完成后就会运行。</p><p>但在Node.js生态里面，第三方包一般需要使用<code>npm</code>安装，然后在代码里面通过<code>require</code>导入。最后再用webpack打包编译成能直接在浏览器中运行的JavaScript代码。</p><p>如果我找到一个第三方的包，它只提供了npm版本，没有提供直接在浏览器中导入的版本怎么办？</p><a id="more"></a><p>举个例子，我想把<code>CSS Selector</code>转换成<code>XPath</code>。在Github上面，可以搜索到很多这种第三方包，例如：<a href="https://github.com/featurist/css-to-xpath" target="_blank" rel="noopener">featurist/css-to-xpath: Convert CSS selectors to XPaths, in JavaScript</a> 或者<a href="https://github.com/sergeidyga/cssxpath" target="_blank" rel="noopener">sergeidyga/cssxpath</a>。</p><p>但你会发现，这些包都只提供npm安装的版本，没有办法直接在浏览器中通过<script>标签导入。如果我想做一个如下图所示的简单网页，难道我还要用webpack去编译？</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216193906.png" alt=""></p><p>在浏览器能运行的JavaScript中，<code>require</code>关键字都是不存在的，如下图所示。因此，我们甚至没有办法把包里面的代码复制出来用：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216192852.png" alt=""></p><p>遇到这种问题怎么办呢？难道我们需要人工一行一行去改写这个包里面的代码让它能直接在浏览器运行？还是必须用webpack来打包编译？其实我们有一个方法，可以把npm版本的包转换成浏览器能运行的包。虽然这个办法还是要依赖Node.js和npm，但是非常简单。你完全不需要知道webpack是什么就可以完成。</p><p>以<code>cssxpath</code>为例，我们首先用npm安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i cssxpath</span><br></pre></td></tr></table></figure><p>然后，我们写一个<code>main.js</code>文件，只需要两行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssxpath = <span class="built_in">require</span>(<span class="string">'css-to-xpath'</span>)</span><br><span class="line"><span class="built_in">window</span>.cssxpath = cssxpath</span><br></pre></td></tr></table></figure><p>接下来，使用<code>npm</code>全局安装<code>browserify</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browserify</span><br></pre></td></tr></table></figure><p>安装完成以后，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserify main.js -o bundle.js</span><br></pre></td></tr></table></figure><p>命令运行完成以后，会生成一个<code>bundle.js</code>文件。现在我们就可以把这个文件和HTML代码放在一起，通过<code>&lt;script&gt;</code>标签导入了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Css Selector 转 XPath<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Css Selector转XPath<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"selector"</span> <span class="attr">style</span>=<span class="string">"width: 500px"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"translate"</span> <span class="attr">x-on:click</span>=<span class="string">"translate(selector)"</span>&gt;</span>转换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>转换结果：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'.translate'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            selector = $(<span class="string">'.selector'</span>).val()</span></span><br><span class="line"><span class="javascript">            result = <span class="built_in">window</span>.cssxpath(selector)</span></span><br><span class="line"><span class="javascript">            $(<span class="string">'.result'</span>).text(result)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220216192731.png" alt=""></p><p>在<code>main.js</code>中，我们定义了<code>window.cssxpath = cssxpath</code>，所以，在HTML代码里面，我们就可以通过<code>window.cssxpath(selector)</code>来使用它了。</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python的第三方库一般可以使用pip来安装。如果代码比较简单，我们甚至可以把第三方库的代码复制下来，放到项目里面导入。&lt;/p&gt;
&lt;p&gt;但由于JavaScript生态里面，有Node.js这个东西，这就导致第三方库有两种不同的导入方式。如果我们要做一个网站，我们通常会在HTML中，使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入.js文件，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样导入了.js文件以后，里面的代码在网页加载完成后就会运行。&lt;/p&gt;
&lt;p&gt;但在Node.js生态里面，第三方包一般需要使用&lt;code&gt;npm&lt;/code&gt;安装，然后在代码里面通过&lt;code&gt;require&lt;/code&gt;导入。最后再用webpack打包编译成能直接在浏览器中运行的JavaScript代码。&lt;/p&gt;
&lt;p&gt;如果我找到一个第三方的包，它只提供了npm版本，没有提供直接在浏览器中导入的版本怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.kingname.info/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://www.kingname.info/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>我做了一个App，如何让别人限时使用？</title>
    <link href="https://www.kingname.info/2022/03/06/limit-use-time/"/>
    <id>https://www.kingname.info/2022/03/06/limit-use-time/</id>
    <published>2022-03-06T15:14:45.000Z</published>
    <updated>2022-03-06T15:19:48.473Z</updated>
    
    <content type="html"><![CDATA[<p>假设有这样一个场景，你接了一个私活，帮别人做一个软件，软件没有联网功能。东西做好以后，客户还没有给钱，说要先试用一下。你选择了相信客户，把软件发送给了他。然后他就把你拉黑了。</p><a id="more"></a><p>为了避免这种情况发生，你首先想到的办法，肯定是把过期时间写死到代码里面，时间到了App自动销毁。对方付钱以后，你再把这个写死的时间延长或者去掉。再重新编译后发给客户。</p><p>但问题是，每次重新编译代码并发给用户是非常麻烦的事情，有没有更简单的办法呢？能不能软件始终是一个软件，但是给用户一个注册码，这个注册码里面标记了有效时间。等到过期以后，只需要给用户一个新的注册码，就可以继续使用了。</p><p>看到这里，有同学肯定会想，怎么在注册码指定有效期呢？首先这个时间肯定不能是明文的，否则用户把它一改，岂不是就可以自行延长了。</p><p>但如果加密的话，就必须把解密算法放到软件里面，一旦用户对程序进行初步的反编译，就能拿到解密算法或者对称加密的密钥。</p><p>因此，我们只能使用非对称加密。而非对称加密里面，通过公钥加密，使用私钥解密。如果我们要让软件从注册码里面解码出有效时间，难道要在软件里面放私钥？</p><p>私钥不能泄露，因此放到软件里面的只能是公钥。但是难道能使用私钥加密，用公钥解密？</p><p>实际上，真的可以这样做，但这不叫做私钥加密公钥解密，这叫做私钥签名(sign)，公钥验证(verify)。并且，使用这个方法有一个好处，就是有效时间可以直接明文存放，不怕用户修改。因为一旦修改了，签名就匹配不上。</p><p>假设我们有一个字符串<code>message</code>，使用私钥，可以对这个字符串进行签名，获得一个签名字符串<code>signature</code>。而我们用公钥，可以验证<code>message</code>是否能够生成签名字符串<code>signature</code>。如果<code>message</code>发生了修改，或者<code>signature</code>发生了修改，或者<code>message</code>和<code>signature</code>同时发生了修改，公钥验证都会失败。</p><p>各个语言都有非对称加密相关的第三方库。我们用Python中的<code>PyCryptodome</code>来进行演示。</p><p>首先，我们在macOS下面，生成一对公钥和私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>根据提示输入密钥的储存路径就可以了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222182848.png" alt></p><p>在当前文件夹，生成了私钥<code>sign</code>和公钥<code>sign.pub</code>。</p><p>接下来，使用<code>pip</code>安装<code>PyCryptodome</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>接下来，导入公钥和私钥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'sign'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span> private = f.read()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'sign.pub'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span> public = f.read()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>private_key = RSA.import_key(private)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_key = RSA.import_key(public)</span><br></pre></td></tr></table></figure><p>由于我们之前生成密钥使用的是<code>SHA256</code>算法，因此我们需要用<code>SHA256</code>算法对需要签名的数据生成摘要。这一步在签名和验证签名的时候都需要做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digest = SHA256.new()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'expire: 2022-03-01'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>digest.update(message.encode())</span><br></pre></td></tr></table></figure><p>接下来，对这个数据进行签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>signer = PKCS1_v1_5.new(private_key)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code = signer.sign(digest)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>signature = base64.b64encode(code)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(signature.decode())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222183837.png" alt></p><p>现在，你只需要把字符串<code>expire: 2022-03-01</code>和签名字符串<code>xbelbTNpq8M...很长一串...</code>发送给客户就可以了。</p><p>客户把过期时间的字符串和签名字符串输入到软件以后，软件使用公钥来验证这个字符串是不是由自己对应的私钥签名的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; message = &apos;expire: 2022-03-01&apos;</span><br><span class="line">&gt;&gt;&gt; signature = &apos;xbelbTNpq8MCFkSxGBoTq7SwQ+oqHRAObrj5p8K2gyY+7uWs5dXGjsQ+GP2XTS5YskCtGjYIBZmAmeM5ey69lRQyk5S1m7t68pYNbUvf3o39Ym0rcmK7XGkBh3euZzVeRErs4JCl7ffTbfcqM4aAsWldDKESrZvaDNQ5DkC8VRYHPBfZfScHqPw/zcHCMRhC9Dch8j9eQlnk8/UKY0MM92jXT4map94PzZRfMLkD4vsciZTtMJm4a42UiiWDUpA6zIgQCYru2YyKspS1uZFE51atYP5DcgPWvJUVRDJS/ZjdPfi9chRjx0dS/Df1sFEreZ7myzXAJP7Y8FA6rvi7EZLlHZ1ViM9tTJp9ut/ZlKgnPAuDCp1JSyKMUk/doVqzUjTqTNHuORe+p3Hhb+xkCASyD8eUH+CyEDVLRcDkSMH5U3o/uONnOQao2o9dbkGiSYNkToElQJ2v20S3MnncPciij8H7iI2dDp1dwt8bkcZOD+E1Tf88LMvRaxB7YnhJ&apos;</span><br><span class="line">&gt;&gt;&gt; digest = SHA256.new()</span><br><span class="line">&gt;&gt;&gt; digest.update(message.encode())</span><br><span class="line">&gt;&gt;&gt; reader = PKCS1_v1_5.new(public_key)</span><br><span class="line">&gt;&gt;&gt; reader.verify(digest, base64.b64decode(signature.encode()))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>但如果你篡改了<code>message</code>的内容，那么验证就会失败，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220222192954.png" alt></p><p>软件第一次验证通过以后，就可以把这个过期时间的字符串和签名字符串一起用文件的形式存到硬盘上，每次启动软件的时候都检查一遍。发现合法并且没有过期就正常运行。发现过期了或者不合法就就重新弹出输入注册码的对话框。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有这样一个场景，你接了一个私活，帮别人做一个软件，软件没有联网功能。东西做好以后，客户还没有给钱，说要先试用一下。你选择了相信客户，把软件发送给了他。然后他就把你拉黑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：在 Golang 中运行 JavaScript</title>
    <link href="https://www.kingname.info/2022/01/18/run-js-in-golang/"/>
    <id>https://www.kingname.info/2022/01/18/run-js-in-golang/</id>
    <published>2022-01-18T13:07:01.000Z</published>
    <updated>2022-01-18T13:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用<code>execJS</code>这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？</p><p>最近我发现一个使用 Golang 开发的 JavaScript 引擎：<a href="https://github.com/dop251/goja" target="_blank" rel="noopener">Goja</a>。它实现了<code>ES 5.1</code>的所有语法和大部分的<code>ES 6</code>语法，比 Python 的<code>execJS</code>要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。</p><a id="more"></a><p>我们来看看如使用它运行一段 JavaScript 代码。首先，我来写一段递归版的 JavaScript 代码计算斐波那契数列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在浏览器上面运行的效果如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118194307.png" alt></p><p>现在，我们来安装这个<code>Goja</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dop251/goja</span><br></pre></td></tr></table></figure><p>接下来我们在 Go 中运行 js 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/dop251/goja"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">    function fib(n) &#123;</span></span><br><span class="line"><span class="string">        if (n === 1 || n === 2) &#123;</span></span><br><span class="line"><span class="string">            return 1 </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return fib(n - 1) + fib(n - 2)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    vm := goja.New()</span><br><span class="line">    _, err := vm.RunString(script)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"JS代码有问题！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int32</span>)</span> <span class="title">int32</span></span></span><br><span class="line">    err = vm.ExportTo(vm.Get(<span class="string">"fib"</span>), &amp;fn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Js函数映射到 Go 函数失败！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"斐波那契数列第30项的值为："</span>, fn(<span class="number">30</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118195256.png" alt></p><p>我们来解释一下上面代码的意思。请大家关注截图中的代码行号。第19行，我们创建了一个 JavaScript 的虚拟机。然后在第20行，把这个函数加载到了虚拟机当中。</p><p>第25行，我们创建了一个变量，这个变量是函数类型，这个函数接收一个 <code>int32</code>作为参数，并返回另一个<code>int32</code>类型的数据。</p><p>第26行，我们把 Golang 里面的这个函数变量与 JavaScript 里面的函数<code>fib</code>关联起来，这样我们就能直接写 Go 代码来调用 JavaScript 代码了。</p><p>第31行，我们像调用普通的 Go 函数一样传入参数，然后获得结果。</p><p>有一些同学在做爬虫的时候，需要运行一段 JavaScript 代码来生成一段 token，那你不妨试一试<code>Goja</code>，它的速度肯定要比你用Python 版本的快很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用&lt;code&gt;execJS&lt;/code&gt;这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？&lt;/p&gt;
&lt;p&gt;最近我发现一个使用 Golang 开发的 JavaScript 引擎：&lt;a href=&quot;https://github.com/dop251/goja&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Goja&lt;/a&gt;。它实现了&lt;code&gt;ES 5.1&lt;/code&gt;的所有语法和大部分的&lt;code&gt;ES 6&lt;/code&gt;语法，比 Python 的&lt;code&gt;execJS&lt;/code&gt;要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何阅读技术文档（直播文案）</title>
    <link href="https://www.kingname.info/2022/01/18/how-to-read-doc/"/>
    <id>https://www.kingname.info/2022/01/18/how-to-read-doc/</id>
    <published>2022-01-18T13:05:46.000Z</published>
    <updated>2022-01-18T13:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。</p></blockquote><a id="more"></a><p>我平常在公众号粉丝群里面常说，要多看官方文档，少看博客。有些同学就说，官方文档看不懂啊。例如你想学习Python的logging模块，然后你会看到<a href="https://docs.python.org/zh-cn/3/library/logging.html" target="_blank" rel="noopener">logging — Python 的日志记录工具 — Python 3.10.2 文档</a>是下面这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174433.png" alt></p><p>又比如你想学习Golang里面<code>net/http</code>的使用，你会看到它的文档<a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener">http package - net/http - pkg.go.dev</a>是这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174611.png" alt></p><p>这样的文档，你看完以后，可能也写不出一个完整的可以运行的程序。但还有另一种文档，你就算第一次接触这个软件或者框架，你也能跟着它的指导写代码，例如Scrapy的官方教程<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">Scrapy Tutorial — Scrapy 2.5.1 documentation</a>。你甚至不会英语也没关系，你就跟着黄绿背景的框框写命令，复制代码，你也可以把爬虫搞出来。</p><p>为什么会有这样的差异呢？因为我们平常笼统地叫做<code>文档</code>的东西，其实有两种。前两个反例是<code>API Reference</code>，API接口文档。Scrapy的叫做<code>教程</code>。API接口文档和教程文档是面向两种不同用途的。</p><p>Python的Logging模块也有教程文档版：<a href="https://docs.python.org/3/howto/logging.html#logging-howto" target="_blank" rel="noopener">Logging HOWTO</a>。</p><p>教程文档其实没有什么好说的，就是一步一步跟着走就能完成。教程文档会告诉你，<code>你不知道你不知道</code>的东西。</p><p>而API接口文档看起来就会比较费劲，因为它是用来告诉你<code>你知道你不知道</code>的东西。例如你知道有某个功能某个函数，但是你不知道它的具体语法怎么写，这个时候就用API接口文档。</p><p>在直播里面，我以Scrapy下载器中间件和Pyppeteer为例来进行说明。我知道下载器中间件怎么激活，我也知道我要修改代理IP，应该编写下载器中间件的<code>process_request</code>方法，但是这个方法接受哪些参数？它能返回什么东西？这个时候我就可以到API接口文档里面进行查询。</p><p>同理，在Pyppeteer的Github仓库里面，Readme写了两个简单的例子告诉我怎么使用它打开一个网页。但是我应该怎么使用XPath从页面上选中一个元素，然后点击它？这个时候就可以到API接口文档里面，搜索<code>xpath</code>，找到对应的方法，看它接受什么参数，返回什么内容，会报什么错。</p><p>直播的最后，我和大家一起试图从<code>net/http</code>的API文档里面寻找怎么更换代理IP。由于我用Go发起网络请求，主要是使用<code>imroc/req</code>，很少使用<code>net/http</code>，我处于<code>我不知道我不知道</code>的状态，于是我跟大家一起崩溃在了这个API接口文档里面。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="直播" scheme="https://www.kingname.info/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：拼接个URL你也能搞错，还写个屁的爬虫。</title>
    <link href="https://www.kingname.info/2022/01/18/relative-url/"/>
    <id>https://www.kingname.info/2022/01/18/relative-url/</id>
    <published>2022-01-18T13:04:25.000Z</published>
    <updated>2022-01-18T13:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫的过程中，我们经常需要解析网站的列表页。</p><a id="more"></a><p>例如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185621.png" alt></p><p>这种情况下，我想获取每一项的URL非常简单，直接写一个XPath就可以了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185741.png" alt></p><p>仔细观察你会发现，每一个连接的URL都是以<code>http://127.0.0.1:8000</code>开头的。而当前列表页的地址也是<code>http://127.0.0.1：8000</code>。所以为了简单起见，<code>&lt;a&gt;</code>标签里面可以使用相对路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示，用XPath只能提取到半截URL：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190417.png" alt></p><p>但是浏览器可以正确识别这样的相对地址，并且当你点击的时候，它能自动跳转到正确的地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190616.png" alt></p><p>相对路径如果是以<code>/</code>开头，那么就会在相对路径前面拼接上网站的主域名。</p><p>但如果当前列表页的地址跟链接的相对路径有一部分重叠怎么办？如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190934.png" alt></p><p>当前页面的地址是<code>http://127.0.0.1:8000/book</code>。而相对地址是<code>/book/1.html</code>。这种情况下，还可以进一步简化，在相对路径的前面不要加斜杠，把HTML改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191249.png" alt></p><p>这种情况下，浏览器依然能给正确识别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191347.png" alt></p><p>浏览器知道，如果相对路径没有用<code>/</code>开头，那么它就会把当前页面的URL与相对路径拼接起来。但需要注意的是，在拼接的时候，会取最右侧斜杠左边的部分。而右边的部分会丢弃。就相当于拼接文件地址的时候，用这个文件所在的文件夹来拼接新的地址。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203350.png" alt></p><p>如果你记不住怎么区分的话，你可以使用Python自带的<code>urllib.parse.urljoin</code>来连接，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203722.png" alt></p><p>看到这里，你可能觉得我今天又水了一篇文章。这么简单的东西也值得写一篇文章来讲？</p><p>那么我们来看下面这个例子：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108204350.png" alt></p><p>域名是<code>http://127.0.0.1:8000/book/index.html</code>，相对域名是<code>1.html</code>，但为什么浏览器自动识别出来的URL是<code>www.kingname.info/1.html</code>？</p><p>这个问题的关键，在于源代码里面的<base>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.kingname.info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果HTML代码头部有<base>标签，那么，它的<code>href</code>属性的值，会被用来跟相对路径拼接出一个绝对路径，而不会再用当前页面的URL来拼接。</p><p>如果你不知道这一点的话，你的爬虫在拼接子页面URL的时候可能就会出问题。网站也可以使用这个机制构造出一个蜜罐，根据<base>标签拼出来的URL才是真正的子页面地址，而用当前页面URL去拼接的URL是蜜罐地址，爬虫访问进去以后，就会抓到假数据，或者被立即屏蔽。</p><p>关于<base>标签的详细说明，大家可以阅读：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank" rel="noopener"><base>: The Document Base URL element</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫的过程中，我们经常需要解析网站的列表页。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：在 Puppeteer 中如何拦截并修改网站的 JavaScript 代码</title>
    <link href="https://www.kingname.info/2022/01/18/mitm-in-puppeteer/"/>
    <id>https://www.kingname.info/2022/01/18/mitm-in-puppeteer/</id>
    <published>2022-01-18T13:03:20.000Z</published>
    <updated>2022-01-18T13:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。</p><p>今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。</p><a id="more"></a><p>首先，我们用以下代码访问网站<code>http://exercise.kingname.info/exercise_ajax_1.html</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-57-05.png" alt></p><p>现在，我想拦截网站返回的数据，并篡改它。首先我们打开 Chrome 的开发者工具，看看这个页面有哪些 Ajax 请求：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-58-54.png" alt></p><p>红框框住的这个 Ajax 请求，返回了网页上面的文字。这个请求对应的地址是：<code>http://exercise.kingname.info/ajax_1_backend</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-59-51.png" alt></p><p>现在，我们就来尝试篡改这个请求的返回数据。首先使用<code>npm</code>安装一个包：<code>npm install puppeteer-interceptor</code>。然后修改代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-06-35.png" alt></p><p>其中关键的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这一段代码指定，要修改一个 XHR 请求的返回。这个 XHR 请求的 URL 是以<code>ajax_1_backend</code>结尾的。所谓的 XHR 请求，全称是<code>XMLHttpRequest</code>，大家可以把它近似看做 Ajax 请求。</p><p>当检测到满足这个通配符的请求时，无论它的内容是什么，都改写成<code>You are hacked by me</code>，然后返回给浏览器。</p><p>有人可能会问，你这样修改，简单是简单，但它有什么用呢？它的用处非常大，比如你在做爬虫的时候，把网站的 JavaScript 的一部分代码替换了，这样就能绕过反爬虫检测。</p><p>我做了一个示例的页面来说明。这个页面直接访问，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-26-57.png" alt></p><p>使用开发者工具，我们可以看到核心的反爬虫逻辑在<code>http://127.0.0.1:8000/backend.js</code>这个 js 文件中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-29-35.png" alt></p><p>这个演示的例子中，这个反爬虫函数非常简单。但在真实的场景中，它的逻辑非常复杂。然而，逻辑再复杂，也有个调用入口。简单分析这个JavaScript 代码，我们可以知道，只需要把代码第14行注释掉，强制设置<code>is_spider = false</code>，就可以绕过这个反爬虫逻辑了。</p><p>为了绕过反爬虫逻辑，首先，我们把网站的这个JavaScript 代码复制下来，保存成<code>safe.js</code>文件。然后修改里面的代码，绕过反爬虫逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antispider</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检测爬虫'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始收集浏览器指纹'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检查是否是模拟浏览器'</span>);</span><br><span class="line">    <span class="keyword">if</span> (a + b === <span class="number">3</span>) &#123;  <span class="comment">// 是爬虫！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_spider = <span class="literal">false</span>;  <span class="comment">//这里强制写成 false</span></span><br><span class="line"><span class="keyword">if</span>(is_spider) &#123;</span><br><span class="line">    alert(<span class="string">'你是爬虫！'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML = <span class="string">"In America, leave airplane, inner People, related to the benefit, know everything, know nothing, said nothing, above."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，修改 Puppeteer 的代码，从本地读取这个修改后的 js 文件，然后拦截真正的请求并使用修改后的代码替换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> safe_code = fs.readFileSync(<span class="string">'./safe.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.Script(<span class="string">'*backend.js'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            event.response.body = safe_code;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://127.0.0.1:8000'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-57-28.png" alt></p><p>从图中可以看到，我们成功绕过了反爬虫的逻辑，获得了真正的页面数据。</p><p>这里有两个地方需要注意：</p><ol><li>要拦截哪个请求，对应到的是<code>intercept</code>函数的第二个参数。这个参数的值是<code>patterns.XXX(地址通配符)</code>。其中的 XXX 可以是如下几个关键词：<code>Document, Stylesheet, Image, Media, Font, Script, TextTrack, XHR, Fetch, EventSource, WebSocket, Manifest, SignedExchange, Ping, CSPViolationReport, Preflight, Other</code>。地址通配符注意是<code>通配符</code>不是正则表达式。通配符里面，<code>*</code>表示多个字符，<code>?</code>表示一个字符。</li><li><code>puppeteer-interceptor</code>对中文的支持不太好。拦截到请求返回的数据以后，如果要修改文本，尽量修改成英文的。否则可能会报错。</li></ol><p><code>puppeteer-interceptor</code>不仅可以修改返回的内容，还可以修改网站的请求。更多强大功能，大家可以阅读它的<a href="https://www.npmjs.com/package/puppeteer-interceptor" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。&lt;/p&gt;
&lt;p&gt;今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：macOS如何找回已经连接的Wi-Fi密码？</title>
    <link href="https://www.kingname.info/2022/01/18/find-password/"/>
    <id>https://www.kingname.info/2022/01/18/find-password/</id>
    <published>2022-01-18T13:02:04.000Z</published>
    <updated>2022-01-18T13:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。</p><p>我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。</p><p>现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？</p><a id="more"></a><p>首先尝试了暴力破解。我试了所有我能想到的密码，均告失败。</p><p>接下来我尝试登陆路由器后台，试图从路由器管理页面找到密码。但我发现路由器管理密码也忘记了。</p><p>如果不重置路由器，还有什么办法找回密码呢？</p><p>其实macOS是有办法查到已经连过的Wi-Fi的明文密码，方法非常简单。</p><p>首先在启动台中，找到一个叫做<code>钥匙串访问</code>的功能，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-23-30.png" alt></p><p>选择<code>系统</code>-<code>密码</code>，然后找到 Wi-Fi的名字，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-25-15.png" alt></p><p>在Wi-Fi 名字上右键，选择<code>将密码拷贝到剪贴板</code>，并输入电脑的账号和密码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-26-45.png" alt></p><p>然后找任何一个可以打字的输入框，粘贴一下，就知道密码是什么了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。&lt;/p&gt;
&lt;p&gt;我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。&lt;/p&gt;
&lt;p&gt;现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技巧" scheme="https://www.kingname.info/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://www.kingname.info/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="macOS" scheme="https://www.kingname.info/tags/macOS/"/>
    
  </entry>
  
</feed>
