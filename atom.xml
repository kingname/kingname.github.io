<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2022-05-05T02:54:22.913Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一日一技：如何批量给PDF添加水印？</title>
    <link href="https://www.kingname.info/2022/05/05/add-watermark-on-pdf/"/>
    <id>https://www.kingname.info/2022/05/05/add-watermark-on-pdf/</id>
    <published>2022-05-05T02:53:12.000Z</published>
    <updated>2022-05-05T02:54:22.913Z</updated>
    
    <content type="html"><![CDATA[<p>我们有时候需要把一些机密文件发给多个客户，为了避免客户泄露文件，会在机密文件中添加水印。每个客户收到的文件内容相同，但是水印都不相同。这样一来，如果资料泄露了，通过水印就知道是从谁手上泄露的。</p><p>今天，一个做市场的朋友找我咨询一个加水印的问题，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503222817.png" alt></p><p>他有一个Excel文件，文件里面有10000个经销商的名字，他要把价目表PDF发给这些经销商，每个经销商收到的PDF文件上面的水印都是这个经销商自己的名字。</p><p>这个需求手动操作肯定要累死人。但是如果用Python来做，就非常简单。代码不超过30行。</p><a id="more"></a><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>要完成这个需求，需要安装两个模块，分别叫做<code>reportlab</code>和<code>pikepdf</code>。使用Pip安装就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install reportlab pikepdf</span><br></pre></td></tr></table></figure><p>然后，需要找到一个<code>.ttf</code>或者<code>.ttc</code>格式的中文字体。你可以直接从网上下载中文字体文件。也可以使用系统自带的中文字体。这里以寻找macOS系统默认的宋体为例。</p><p>macOS系统字体在<code>/System/Library/Fonts</code>，宋体对应的<code>.ttc</code>文件地址是<code>/System/Library/Fonts/Supplemental/Songti.ttc</code>。对于系统默认的字体，我们只需要知道它的对应的文件名叫做<code>Songti.ttc</code>就可以了。如果是从网上下载的第三方字体，需要使用绝对路径或者相对于项目代码的相对路径。</p><h2 id="获得经销商名字对应的列表"><a href="#获得经销商名字对应的列表" class="headerlink" title="获得经销商名字对应的列表"></a>获得经销商名字对应的列表</h2><p>由于这位朋友不会使用pandas，那么我们就尽量使用Python原生的方法来获得经销商名字列表。假设经销商信息对应的Excel如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224007.png" alt></p><p>我们首先把这个Excel文件导出成csv文件：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224408.png" alt></p><p>然后，我们用Python读取这个csv文件，获得经销商名字列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'经销商信息.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    name_list = [x[<span class="string">'经销商名字'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> reader]</span><br><span class="line"></span><br><span class="line">print(name_list)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503224437.png" alt></p><h2 id="生成水印PDF"><a href="#生成水印PDF" class="headerlink" title="生成水印PDF"></a>生成水印PDF</h2><p>一般来说，我们不能直接把一段文字作为水印添加到另一个PDF文件中。我们只有先把这段文字生成图片或者生成水印PDF文件，然后把这个图片或者水印PDF作为『图层』覆盖到目标PDF上面。</p><p>因此，现在需要把给每一个经销商生成对应的水印PDF文件。这个PDF中只含有水印文字。效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503225754.png" alt></p><p>对应的代码<code>create_watermark.py</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> reportlab.lib <span class="keyword">import</span> units</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfgen <span class="keyword">import</span> canvas</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfbase <span class="keyword">import</span> pdfmetrics</span><br><span class="line"><span class="keyword">from</span> reportlab.pdfbase.ttfonts <span class="keyword">import</span> TTFont</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'经销商信息.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.DictReader(f)</span><br><span class="line">    name_list = [x[<span class="string">'经销商名字'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> reader]</span><br><span class="line"></span><br><span class="line">pdfmetrics.registerFont(TTFont(<span class="string">'Songti'</span>, <span class="string">'Songti.ttc'</span>)) <span class="comment"># 加载中文字体</span></span><br><span class="line"></span><br><span class="line">water_mark_folder = Path(<span class="string">'water_pdf'</span>) <span class="comment"># 用一个文件夹存放所有的水印PDF</span></span><br><span class="line">water_mark_folder.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    path = str(water_mark_folder / Path(<span class="string">f'<span class="subst">&#123;name&#125;</span>.pdf'</span>))</span><br><span class="line">    c = canvas.Canvas(path, pagesize=(<span class="number">200</span> * units.mm, <span class="number">200</span> * units.mm)) <span class="comment"># 生成画布，长宽都是200毫米</span></span><br><span class="line">    c.translate(<span class="number">0.1</span> * <span class="number">200</span> * units.mm, <span class="number">0.1</span> * <span class="number">200</span> * units.mm)  </span><br><span class="line">    c.rotate(<span class="number">45</span>)  <span class="comment"># 把水印文字旋转45°</span></span><br><span class="line">    c.setFont(<span class="string">'Songti'</span>, <span class="number">35</span>)  <span class="comment"># 字体大小</span></span><br><span class="line">    c.setStrokeColorRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 设置字体颜色</span></span><br><span class="line">    c.setFillColorRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 设置填充颜色</span></span><br><span class="line">    c.setFillAlpha(<span class="number">0.3</span>)  <span class="comment"># 设置透明度，越小越透明</span></span><br><span class="line">    c.drawString(<span class="number">0</span>, <span class="number">0</span>, <span class="string">f'<span class="subst">&#123;name&#125;</span>专用价目表，严禁泄露！'</span>)</span><br><span class="line">    c.save()</span><br></pre></td></tr></table></figure><p>代码的具体作用，已经写到注释中了。运行以后会在当前项目根目录生成<code>water_pdf</code>文件夹，里面就是生成的水印PDF。</p><h2 id="合并水印与目标PDF"><a href="#合并水印与目标PDF" class="headerlink" title="合并水印与目标PDF"></a>合并水印与目标PDF</h2><p>最后一步，把每一个经销商的水印PDF与目标PDF进行合并。水印PDF作为一个图层覆盖到目标PDF上面。</p><p>使用<code>pikepdf</code>完成这个工作非常简单，编写一个<code>combine.py</code>文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> pikepdf <span class="keyword">import</span> Pdf, Page, Rectangle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">water_pdf_list = glob.glob(<span class="string">'water_pdf/*.pdf'</span>)</span><br><span class="line">result = Path(<span class="string">'result'</span>)</span><br><span class="line">result.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">col = <span class="number">2</span>  <span class="comment"># 每页多少列水印</span></span><br><span class="line">row = <span class="number">3</span>  <span class="comment"># 每页多少行水印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> water_pdf_list:</span><br><span class="line">    target = Pdf.open(<span class="string">'./PythonisinstanceGolang.pdf'</span>)  <span class="comment"># 必须每次重新打开PDF，因为添加水印是inplace的操作</span></span><br><span class="line">    file = Path(path)</span><br><span class="line">    name = file.stem</span><br><span class="line">    water_mark_pdf = Pdf.open(path)</span><br><span class="line">    water_mark = water_mark_pdf.pages[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> target.pages:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(col):  <span class="comment"># 每一行显示多少列水印</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(row): <span class="comment"># 每一页显示多少行PDF</span></span><br><span class="line">                page.add_overlay(water_mark,</span><br><span class="line">                                 Rectangle(page.trimbox[<span class="number">2</span>] * x / col,</span><br><span class="line">                                           page.trimbox[<span class="number">3</span>] * y / row,</span><br><span class="line">                                           page.trimbox[<span class="number">2</span>] * (x + <span class="number">1</span>) / col,</span><br><span class="line">                                           page.trimbox[<span class="number">3</span>] * (y + <span class="number">1</span>) / row))</span><br><span class="line"></span><br><span class="line">    result_name = Path(<span class="string">'result'</span>, <span class="string">f'<span class="subst">&#123;name&#125;</span>_添加水印.pdf'</span>)</span><br><span class="line">    target.save(str(result_name))</span><br></pre></td></tr></table></figure><p>运行以后，会在项目根目录生成一个<code>result</code>文件夹，里面就是添加了水印的PDF文件了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503231815.png" alt></p><p>这里有必要对代码中的一些地方进行解释。带上行号的代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503232736.png" alt></p><p>代码第21行和22行，有两个<code>for</code>循环，他们的作用是给一个页面上添加多个水印。请大家注意下图我画圈的地方：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503232313.png" alt></p><p>每一页都有6个水印，分成3行2列。其中的3行对应了变量<code>row</code>的值。2列对应了变量col的值。大家也可以根据自己的需要修改这两个数字。甚至每一页的水印随机变换位置，防止被去水印的程序移除。</p><p><code>page.trimbox[2]</code>是PDF页面的宽度，<code>page.trimbox[3]</code>是PDF页面的高度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大家注意在这篇文章中，我把任务分成了3个部分，分别是：</p><ul><li>Excel转CSV，让Python方便读取</li><li>Python读取CSV生成水印PDF</li><li>水印PDF与目标PDF文件合并</li></ul><p>这三个部分的代码是可以合并在一个<code>.py</code>文件里面的，但是我没有这样做，是考虑到问这个问题的同学不是程序员，Python水平只是入门，如果合并在一起，代码量多了以后，出问题都不知道错在哪里。</p><p>在计算机领域，所有问题都可以通过把问题拆分成多个部分分别单独运行或者增加若干个中间层来解决。今天用的方法就是把问题拆分的方法。对于初学者来说，每一步都是相对独立的，都能立刻看到效果。第二步只需要依赖第一步的结果，第三步只需要依赖第二步的结果，这样每一步的输入输出非常清楚，可以显著降低问题的复杂度。如果报错了，也更容易知道是哪个地方有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们有时候需要把一些机密文件发给多个客户，为了避免客户泄露文件，会在机密文件中添加水印。每个客户收到的文件内容相同，但是水印都不相同。这样一来，如果资料泄露了，通过水印就知道是从谁手上泄露的。&lt;/p&gt;
&lt;p&gt;今天，一个做市场的朋友找我咨询一个加水印的问题，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220503222817.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;他有一个Excel文件，文件里面有10000个经销商的名字，他要把价目表PDF发给这些经销商，每个经销商收到的PDF文件上面的水印都是这个经销商自己的名字。&lt;/p&gt;
&lt;p&gt;这个需求手动操作肯定要累死人。但是如果用Python来做，就非常简单。代码不超过30行。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="水印" scheme="https://www.kingname.info/tags/%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>写在公众号粉丝2w时</title>
    <link href="https://www.kingname.info/2022/04/22/20000-fans/"/>
    <id>https://www.kingname.info/2022/04/22/20000-fans/</id>
    <published>2022-04-22T07:38:30.000Z</published>
    <updated>2022-04-22T07:41:34.458Z</updated>
    
    <content type="html"><![CDATA[<p>今天，2022年4月21日，公众号未闻Code粉丝突破20000！</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220421143345.png" alt></p><p>感谢现在正在看这篇文章的各位。</p><a id="more"></a><p>这个公众号其实在2014年就开通了，如果我当时就认真经营的话，现在可能已经财务自由了吧（笑）。</p><p>认真更新未闻Code是从2018年底开始的，当时我的爬虫书《Python爬虫开发，从入门到实战》快要出版了，于是我想着写点公众号文章来造造势。没想到这一写就是4年。</p><p>我平时记录的技术笔记已经有几百篇了，所以第一个半年，我可以保证每天一篇原创小技巧文章的更新。后来，存货用完了，但因为我本来就有习惯记录工作中遇到的问题和解决方案，所以也能保证每两天一篇文章的更新频率。后来开通了公众号的粉丝群，大家在群里面提的问题，也成了我写作的素材。</p><p>在这四年写公众号的过程中，很多同学私聊我，表示对我文章的感谢，我的文章帮他解决了难题，帮他找到了工作。但其实我也要感谢所有问我问题的同学，是你们一次又一次的帮我验证了费曼学习法的正确。以教促学确实是最好的学习方法，在给你们解答的时候，在为了解答你们的问题，我去翻软件源代码的时候，我的知识得以进一步巩固和完善，我们都变得比以往更强了。</p><p>4月18号有一个同学给我发邮件，咨询知识管理的问题：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220419112405.png" alt></p><p>这里我也贴一下我给他的回复，大家也可以参考一下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220419112720.png" alt></p><p>在这四年中，不时有同学跟我说，我的文章被某某培训机构拿去做教材，一次收费几千上万，但为什么我依然要坚持免费写这些文章？</p><p>我觉得，坚持写文章并免费发布，是为了表达我对互联网的感谢吧。我是开源运动的受益者，我也是互联网上浩如烟海的技术文章的受益者。我从Coursera上面的课程入门Python，通过互联网上的文档学会各种框架和技术。既然我走到现在，没有花一分钱，那我没有理由在输出的时候收费。</p><p>我很赞同吴恩达说过的一句话：让全世界所有人免费享受高品质的教育。</p><p>如果大家在其它地方看到了我的文章被收费出售，只需要顺手点个举报，然后让被骗的人知道原文出自我这里就好了。当更多的人知道在哪里可以第一时间免费获取到高质量的干货，那么他们自然不会去花钱购买二手货了。</p><p>未闻Code现在以及未来，所有文章都是免费的，对所有人开放的。不会出现让你读一半然后交费才能读剩下一半的情况。</p><p>在公众号粉丝群里面，我发现很多同学咨询的问题都是我文章写过的，但是大家都知道公众号的搜索功能非常垃圾，所以公众号文章我也会同步到我的个人博客上：<a href="https://www.kingname.info">https://www.kingname.info</a> 如果你在公众号搜索不到内容，不妨通过Google搜索我的博客，也许可以找到你想要的内容。</p><p>除了公众号和博客，如果你想看视频，我也在B站也有大量录播的视频：<a href="https://space.bilibili.com/10089274" target="_blank" rel="noopener">https://space.bilibili.com/10089274</a> ；如果你喜欢邮件订阅，在竹白上也有Newsletter: <a href="https://kingname.zhubai.love/" target="_blank" rel="noopener">https://kingname.zhubai.love/</a> 以上所有地方发布的所有内容，都是完全免费的。</p><p>另外，如果你觉得这些免费的内容还不够的话，我还开通了知识星球『未闻Code』，相比于以上免费的内容，付费的星球额外提供了：软件架构咨询，线上一对一职业生涯规划咨询，直播等等附加的服务。</p><p>最后，再一次表示对各位读者的感谢。我会从评论区选7个同学，赠送7本签名版的《Python爬虫开发，从入门到实战》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，2022年4月21日，公众号未闻Code粉丝突破20000！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220421143345.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;感谢现在正在看这篇文章的各位。&lt;/p&gt;
    
    </summary>
    
      <category term="感想" scheme="https://www.kingname.info/categories/%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="公众号" scheme="https://www.kingname.info/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="未闻 Code" scheme="https://www.kingname.info/tags/%E6%9C%AA%E9%97%BB-Code/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：优雅地加载Yaml配置文件</title>
    <link href="https://www.kingname.info/2022/04/22/hydra/"/>
    <id>https://www.kingname.info/2022/04/22/hydra/</id>
    <published>2022-04-22T07:38:11.000Z</published>
    <updated>2022-04-22T07:40:33.783Z</updated>
    
    <content type="html"><![CDATA[<p>我在多篇文章里面都说过，我非常喜欢使用Yaml格式来写配置文件。Yaml是一个对人非常友好的配置格式。</p><p>有时候，我们在开发环境、测试环境和线上环境会有多套不同的配置文件，如何在不修改代码的情况下方便的切换配置文件呢？我以前的文章讲过一种方法，使用环境变量来指定配置文件名。今天我们来介绍一个更先进的工具，专门用来高效加载配置文件。这就是Facebook开源的Hydra。</p><a id="more"></a><p>这个工具有多简单呢？我们先写两个配置文件，然后看看怎么读取它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220420191201.png" alt></p><p>使用pip安装Hydra:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install hydra-core</span><br></pre></td></tr></table></figure><p>接下来，我们写一段代码，来读取配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig</span><br><span class="line"></span><br><span class="line">env = os.getenv(<span class="string">'DATA_CENTER'</span>, <span class="string">'dev'</span>)</span><br><span class="line"><span class="meta">@hydra.main(config_path="config", config_name=env)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(cfg: DictConfig)</span>:</span></span><br><span class="line">    print(<span class="string">'MongoDB链接地址是：'</span>, cfg.mongo.uri)</span><br><span class="line">    print(<span class="string">'Redis的key是：'</span>, cfg.redis.key)</span><br><span class="line">    print(<span class="string">'黑名单是：'</span>, cfg.detail.black_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220420191749.png" alt></p><p>其中，装饰器<code>hydra.main</code>的参数<code>config_path</code>指定存放配置文件的文件夹，<code>config_name</code>用来指定配置文件的名字（去掉.yaml）。</p><p>这样一来，我们可以通过环境变量指定要使用哪个配置文件。</p><p>这样看起来似乎跟我以前讲的方法没什么区别啊。那么，高级的功能来了。例如现在我使用dev环境时，临时想修改一下Redis的Key怎么办呢？以前的方法，我就必须去修改Yaml文件，把Key改掉。但是，既然是临时修改，测试完了又要改回来，显然非常麻烦。</p><p>使用Hydra，这个问题就不再是问题了。我们来看看直接在命令中覆盖数据的方法：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220420192315.png" alt></p><p>请看图中，我代码没有做任何修改，Yaml也没有做任何修改。只需要在启动命令的时候增加一个参数<code>redis.key=new_key</code>，那么程序读取到的就是新的值了。这对临时测试的时候非常有用。</p><p>除了我上面介绍的这些，Hydra还可以实现自动补全，自动提示参数名，自动以多个不同的配置连续运行等等功能。大家可以在它的<a href="https://hydra.cc/docs/intro/" target="_blank" rel="noopener">官方文档</a>中看到使用方法。</p><p>最后，我补充一个点。有同学在公众号粉丝群提问，Hydra为什么不能在调用函数的时候，传递额外的参数，例如下面这样写就会报错：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220420193112.png" alt></p><p>这是因为，Hydra的装饰对象应该是程序的<strong>入口函数</strong>。给入口函数传递参数是很奇怪的。如果你的入口函数要根据参数的不同值执行不同的逻辑，那么这个参数你完全可以放到配置文件中。而不是用函数参数来传入。</p><p>所以，这里报错应该是功能而不是bug。本来就不应该在入口函数中添加额外的参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在多篇文章里面都说过，我非常喜欢使用Yaml格式来写配置文件。Yaml是一个对人非常友好的配置格式。&lt;/p&gt;
&lt;p&gt;有时候，我们在开发环境、测试环境和线上环境会有多套不同的配置文件，如何在不修改代码的情况下方便的切换配置文件呢？我以前的文章讲过一种方法，使用环境变量来指定配置文件名。今天我们来介绍一个更先进的工具，专门用来高效加载配置文件。这就是Facebook开源的Hydra。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Yaml" scheme="https://www.kingname.info/tags/Yaml/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：协程与多进程的完美结合</title>
    <link href="https://www.kingname.info/2022/04/22/aiomultiprocess/"/>
    <id>https://www.kingname.info/2022/04/22/aiomultiprocess/</id>
    <published>2022-04-22T07:37:55.000Z</published>
    <updated>2022-04-22T07:39:45.605Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，协程本质上是单线程单进程，通过充分利用IO等待时间来实现高并发。在IO等待时间之外的代码，还是串行运行的。因此，如果协程非常多，多少每个协程内部的串行代码运行时间超过了IO请求的等待时间，那么它的并发就会有一个上限。</p><a id="more"></a><p>举个例子，电饭煲煮饭，洗衣机洗衣服，热水壶烧水，他们都是启动设备以后就能自己运行，我们可以利用他们自己运行的时间，让这三件事情看起来几乎在同时进行。但如果除了这三件事情外，还有开电视，开空调，发微信……等等几十个事情。每个事情单独拿出来确实都只需要做个开头，剩下的就是等，但由于做这个开头也需要时间，因此把他们全部启动起来也要不少时间，你的效率还是被卡住。</p><p>现在，如果有两个人一起来做这些事情，那情况就不一样了。一个人煮饭和烧水，另一个人开洗衣机，开电视和空调。效率进一步提升。</p><p>这就是协程与多进程的结合，每个进程里面多个协程同时运行，充分利用CPU的每一个核心，又充分利用了IO等待时间，把CPU跑满，把网络带宽跑满。强强联合，速度更快。</p><p>有一个第三方库<code>aiomultiprocess</code>，让你能用几行代码就实现多进程与协程的组合。</p><p>首先使用pip安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install aiomultiprocess</span><br></pre></td></tr></table></figure><p>它的语法非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiomultiprocess <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">    results = <span class="keyword">await</span> pool.map(协程, 参数列表)</span><br></pre></td></tr></table></figure><p>只需要3行代码，它就会在你CPU上每个核启动一个进程，每个进程中不停启动协程。</p><p>我们来写一段实际代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">from</span> aiomultiprocess <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        resp = <span class="keyword">await</span> client.get(url)</span><br><span class="line">        <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [url1, url2, url3]</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> result <span class="keyword">in</span> pool.map(get, urls):</span><br><span class="line">            print(result)  <span class="comment"># 每一个URL返回的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>之前我写异步协程文章的时候，有些人同学会问我，爬虫的速度真的那么重要吗？难道不是突破反爬虫最重要吗？</p><p>我的回答是，不要看到用aiohttp请求网址就觉得是做爬虫。在微服务里面，自己请求自己的HTTP接口，也需要使用httpx或者aiohttp。在这样的场景里面，速度就是非常的重要，有时候就是需要做到越快越好。</p><p>关于<code>aiomultiprocess</code>的更多使用，可以参阅它的<a href="https://aiomultiprocess.omnilib.dev/en/latest/guide.html" target="_blank" rel="noopener">官方文档</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，协程本质上是单线程单进程，通过充分利用IO等待时间来实现高并发。在IO等待时间之外的代码，还是串行运行的。因此，如果协程非常多，多少每个协程内部的串行代码运行时间超过了IO请求的等待时间，那么它的并发就会有一个上限。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="协程" scheme="https://www.kingname.info/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="多进程" scheme="https://www.kingname.info/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>爬虫出海Step by Step(一)</title>
    <link href="https://www.kingname.info/2022/04/13/global-crawler-1/"/>
    <id>https://www.kingname.info/2022/04/13/global-crawler-1/</id>
    <published>2022-04-13T13:54:07.000Z</published>
    <updated>2022-04-13T13:56:02.219Z</updated>
    
    <content type="html"><![CDATA[<p>上周的文章《<a href="https://mp.weixin.qq.com/s/63iemJ72--Y6BT5FxzNQzg" target="_blank" rel="noopener">一日一知：国内爬虫开发人员的未来</a>》发布以后，很多同学私信我表示对爬虫出海很有兴趣，希望我能详细介绍一下。因此，我准备用几篇文章来介绍爬虫出海的具体做法细节和注意事项。</p><p>今天我们的话题是，如何规避法律风险。</p><a id="more"></a><p>如果你是个人开发者，那么你直接写爬虫爬就可以了。不会有人跨国来抓你的。</p><p>如果你是小公司，并且在海外没有分公司，那么你也可以像个人开发者一样直接爬。</p><p>如果你是大公司，关注自己的国际声誉；或者你的公司在海外有分公司，那么你需要注意如下的几个问题。</p><h2 id="藏好自己"><a href="#藏好自己" class="headerlink" title="藏好自己"></a>藏好自己</h2><p>很多网站几乎没有反爬虫机制。你直接使用<code>requests.get(url)</code>就能获取数据，连<code>headers</code>参数都不需要加。网站反不反爬虫是网站的事情，但作为爬虫，把自己伪装成正常的浏览器请求，并使用代理IP是基本的要求和素质。</p><p>否则，等有一天有人在推特上@你的公司，并附上了Nginx的IP记录，那你的公司可就倒了大霉了。</p><h2 id="GDPR或者其它相关法律条文"><a href="#GDPR或者其它相关法律条文" class="headerlink" title="GDPR或者其它相关法律条文"></a>GDPR或者其它相关法律条文</h2><p><a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation" target="_blank" rel="noopener">GDPR</a>是欧洲的数据保护法规，它要求你不能在未经允许的情况下擅自收集欧洲用户的个人信息。在欧洲运营的互联网公司，数据也不能离开欧洲。</p><p>Google和Facebook曾经都因为违反了GDPR而遭受上亿欧元的罚款。如果你的公司在欧洲有分公司，就需要特别注意这一点，否则你将会面临巨额罚款或者被查封公司。</p><p>这种情况下，如果你要做爬虫，建议是爬哪个国家的数据，就在那个国家本土部署爬虫。通过Aws或者GCP购买那个国家的服务器，把爬虫部署到服务器上面。同时，Hive/Hue等等数据分析相关的服务，也需要部署到对应的国家。</p><p>如果你能招聘外籍员当然最好，只让那边的员工来接触数据。如果你需要让中国的员工去分析数据，那么你需要准备一个VPN，把中国的电脑和爬虫服务器、数据分析服务器组建起一个虚拟的局域网，然后让这边的员工连上去进行操作。</p><p>如果最后分析以后的数据，会以网页的形式呈现给客户，也需要把网站搭建在对应国家的服务器上，然后客户通过VPN连上去查看。</p><p>如果某个大洲有多个国家都需要爬取，你也可以在Aws或者GCP上购买这个洲的服务器，而不是具体每一个国家。例如你要爬英法意德的数据，你不需要在四个国家各搭建一套系统。整个欧洲共用一套就可以了。</p><p>另外，就是无论如何，不要涉及用户个人信息。</p><h2 id="数据不只有一家"><a href="#数据不只有一家" class="headerlink" title="数据不只有一家"></a>数据不只有一家</h2><p>国外有些网站的反爬虫特别强，例如Facebook，封账号封得非常厉害。又比如App Store的App评论和星级，也不太好直接抓。但是，已经有一些第三方网站使用某种我们不知道的方法，抓了他们的数据并在自家网站公布了，那么，你可以去抓这些第三方网站的数据。</p><p>有些网站开放了API，申请他们的API以后，直接就能根据文档调用API拿到数据，例如推特。不过现在推特已经不批准新API的申请了。我们公众号粉丝群里面有一个同学手上还有一个获得了开放API权限的账号，很多人找他借来爬数据。</p><p>还有很多网站，直接开放了全文的RSS，你直接解析RSS地址就能拿到最新的内容了。</p><h2 id="善于利用网站的多个版本"><a href="#善于利用网站的多个版本" class="headerlink" title="善于利用网站的多个版本"></a>善于利用网站的多个版本</h2><p>欧美这些注重政治正确国家，会额外关注残障人士和老年人的网页使用体验，并设置了专门的页面。当主站特别难爬的时候，找到他们给残疾人设计的页面或者老手机设计的页面，爬起来就很容易。</p><p>例如Facebook主站非常难爬，但是如果访问<code>https://mbasic.facebook.com/</code>就非常简单，这个版本的页面是给2G老手机使用的，页面上没有JavaScript，所有请求都是通过GET或者POST的参数实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你是国内的一家大公司，担心做海外爬虫影响公司的声誉，那么你可以在目标国家开个分公司来爬，或者找对应国家的爬虫外包团队。数据爬好以后，就存在那个国家的服务器上。国内的数据分析员工通过VPN连上去以后，远程分析数据。不要尝试把数据拉回国内。即使加密以后传回国内也不行。</p><p>另外，一个数据有多种抓取方式，一种方式不行，就多试几种，总会有一个意想不到的渠道获取数据。</p><p>下一篇文章，我们来聊聊怎么寻找数据源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/63iemJ72--Y6BT5FxzNQzg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一知：国内爬虫开发人员的未来&lt;/a&gt;》发布以后，很多同学私信我表示对爬虫出海很有兴趣，希望我能详细介绍一下。因此，我准备用几篇文章来介绍爬虫出海的具体做法细节和注意事项。&lt;/p&gt;
&lt;p&gt;今天我们的话题是，如何规避法律风险。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：多个Python项目怎么调用我自己的工具函数？</title>
    <link href="https://www.kingname.info/2022/04/13/use-pth/"/>
    <id>https://www.kingname.info/2022/04/13/use-pth/</id>
    <published>2022-04-13T13:53:56.000Z</published>
    <updated>2022-04-13T13:55:10.147Z</updated>
    
    <content type="html"><![CDATA[<p>在多年写代码的过程中，我总结了不少常用的工具函数。这些工具函数有的能够实现快速重试网络请求，有的可以把任意格式的时间转成标准格式，还有的可以自动生成正则表达式。</p><a id="more"></a><p>我把这些工具函数分别放到多个<code>.py</code>文件中。然后把这些<code>.py</code>文件放在一个叫做<code>my_awesome_util</code>的文件夹中。</p><p>由于我没有把这些代码上传到Pypi或者Github，因此我每次在新的项目中要使用时，都要把<code>my_awesome_util</code>文件夹复制到新的项目中，非常麻烦，而且会形成大量的重复代码。</p><p>有没有什么办法，能让新开的项目直接就能导入这些工具函数呢？就像导入官方模块<code>import time</code>一样，如果我要使用时间相关的工具函数，我只需要<code>import time_util</code>就可以了。</p><p>首先要排除的方法，就是手动在代码里面，通过<code>sys.path</code>添加文件夹。因为这个方法需要在每个项目的入口文件中增加两行代码，无法做到<code>全自动</code>。</p><p>今天的方法，是在Python的<code>site-packages</code>文件夹中做文章。相信很多同学都知道，任何放到<code>site-packages</code>文件夹里面的<code>.py</code>文件或者文件夹，都可以在Python中直接导入：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220411175822.png" alt></p><p>看到这里，肯定有同学要问，那是不是把<code>my_awesome_util</code>文件夹整个复制到<code>site-packages</code>文件夹中呢？</p><p>当然不是的。因为我的工具包里面的代码是在持续演进的，我会经常更新里面的代码，放到<code>site-packages</code>里面以后，代码修改起来很不方便。</p><p>我们要用到的，是Python的一个特性，叫做<code>.pth</code>文件。在<code>site-packages</code>文件夹中，任意创建一个<code>.pth</code>文件。文件名可以随便取，只要不跟已有的模块冲突就可以了。例如叫做<code>xxxx.pth</code>。这个文件里面只有一行，就是<code>my_awesome_util</code>文件夹的绝对路径。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220411180625.png" alt></p><p>现在，我在任何一个文件夹中启动Python，直接就可以导入<code>my_awesome_util</code>文件夹中的任何<code>.py</code>文件：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220411180531.png" alt></p><p><code>.pth</code>文件可以有很多行，每行一个文件夹的绝对路径，就可以让Python同时导入这些文件夹里面的所有<code>.py</code>文件。</p><p>有时候，我们的电脑上有多个虚拟环境。A环境有pandas，没有pymongo；B环境有pymongo，但没有pandas。现在我在B环境里面要写一段代码，既需要pandas，又需要pymongo怎么办呢？如果不想重新安装，我可以把A环境的<code>site-packages</code>文件夹的绝对路径，写入到一个<code>.pth</code>文件中，然后把这个文件存放到B环境的<code>site-packages</code>文件夹中。这样，我就可以在B环境里面直接使用A环境中的所有第三方库了。</p><p>有同学会问，怎么知道<code>site-packages</code>文件夹在哪里呢？其实只需要执行下面两行代码就能查询到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sysconfig</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sysconfig.get_path(<span class="string">'purelib'</span>))</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220411181203.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多年写代码的过程中，我总结了不少常用的工具函数。这些工具函数有的能够实现快速重试网络请求，有的可以把任意格式的时间转成标准格式，还有的可以自动生成正则表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>为什么我认为爬虫开发的新征途在海外市场？</title>
    <link href="https://www.kingname.info/2022/04/04/new-future-of-crawler/"/>
    <id>https://www.kingname.info/2022/04/04/new-future-of-crawler/</id>
    <published>2022-04-04T09:32:25.000Z</published>
    <updated>2022-04-04T09:33:49.776Z</updated>
    
    <content type="html"><![CDATA[<p>开篇先抛出我的观点：希望各位做爬虫的同学，尽快，尽可能多地做海外的爬虫项目，爬海外的网站。这才是你们新的未来。</p><p>我最近两年时间，已经没有做过任何国内网站的爬虫了，根据这两年爬海外网站的一些经验，谈谈我的发现和想法。</p><a id="more"></a><h2 id="内地的环境不适合做爬虫"><a href="#内地的环境不适合做爬虫" class="headerlink" title="内地的环境不适合做爬虫"></a>内地的环境不适合做爬虫</h2><p>国内的网站在这么多年的爬虫与反爬虫的斗争中，反爬能力越来越强，瑞数、极验和其它第三方专业反爬虫系统，就能挡住很多人了。</p><p>国内值得爬的网站就只有这么几个，大家都在爬，你有1GB的数据，他有1TB的数据，内卷极其严重。很多工作室直接使用群控技术，几万台机器一起爬。普通人很难跟他们竞争。</p><p>国内一些专门做舆情分析的公司，他们甚至可以通过地下渠道直接拿到网站的内部API，数据质量比你通过爬虫爬的数据高多了。</p><p>爬国内的大网站，很容易被请喝茶。轻者拘留，重者在档案里面留下一辈子的污点。</p><h2 id="海外数据的新机遇"><a href="#海外数据的新机遇" class="headerlink" title="海外数据的新机遇"></a>海外数据的新机遇</h2><h3 id="NLP的语料"><a href="#NLP的语料" class="headerlink" title="NLP的语料"></a>NLP的语料</h3><p>NLP最重要的四个元素就是：语料、模型、算法、算力。其中模型和算力可以复用，自然不是问题。但因为没有人抓海外的数据，因此缺少了语料，没有语料，就没有办法训练模型。NLP里面的ABSA、语意理解、文本生成、智能问答也全都做不下去。特别是小众语言——法语、俄语、韩语、西班牙语，几乎就没有国内的公司在做。</p><p>抓数据不难，但难在对数据的标注。现在国内对小众语言的标注，还停留在使用Google翻译把小众语言先翻译成英文，再让人去给英文打标的阶段。</p><p>如果你能尽早收集小语种的语料，然后让懂这个语料的人去打标，那么以后即便你不直接做NLP，光出售小语种的标注数据，你都可以大赚一笔。国内学习小语种的大学生，找工作都很困难。如果你能让他们兼职给你标注数据，不仅提供了就业岗位，而且价格非常低廉，属于是双赢。</p><p>语料抓取的壁垒不是爬虫技术，而是数据量和数据多样性。数据量达到一定规模以后，壁垒自然就能形成。别人的爬虫再先进，只要它短期收集不了那么多的数据，那么它就没有办法超过你。</p><p>总之，越早开始收集海外语料，越早能形成自己的壁垒。</p><h3 id="游戏出海"><a href="#游戏出海" class="headerlink" title="游戏出海"></a>游戏出海</h3><p>众所周知，游戏在内地已经没有未来了，各大游戏厂商在接下来的几年会把游戏出海作为最重要的目标。目前已经有几家公司的游戏在东南亚大杀四方，在欧美市场也一路血洗当地的产品。想必大家都知道我说的是哪几个游戏。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220404152553.png" alt></p><p>但可以确定的是，目前国内做舆情分析的公司，还没有谁能够把海外舆情（特指非英语国家）分析做好。如果你有丰富的海外舆情抓取经验，那么当这些公司招聘的时候，你就有很高的竞争力。</p><h3 id="尽职调查"><a href="#尽职调查" class="headerlink" title="尽职调查"></a>尽职调查</h3><p>除了游戏外，基于数据的尽职调查也是一个方向。投资人在确定是否要投资某个创业公司前，都会做尽职调查（DD）。其中基于数据的尽职调查（DDD）就是其中的重要一环。例如一个电商初创公司告诉投资人，他每个月的销售额有几百亿，然后你用爬虫爬一下他的商城，根据每个商品的销量和评论，反推出他的月销售额只有几百元，那么你就能知道这个电商公司在骗投资人了。</p><p>又比如某个直播网站，对投资人宣称自己的日活月活非常高，然后你用爬虫监控一下热门主播的评论数，礼物数，设计一个公式计算出它的真实日活月活，两边一对比你就知道他们有没有骗人了。</p><h2 id="海外网站是新的蓝海"><a href="#海外网站是新的蓝海" class="headerlink" title="海外网站是新的蓝海"></a>海外网站是新的蓝海</h2><p>只要你把视野放开，稍微研究一下我国台湾、香港的网站，以及英法意德，巴西韩国，俄罗斯东南亚的网站，你就会发现：</p><ol><li>大部分网站几乎没有反爬虫机制</li><li>语料极其丰富</li><li>小部分网站有极难的反爬虫系统（Akamai），但是可以通过曲折绕过的方式拿到数据</li><li>国内几乎没有竞争对手，你爬得越多，你积累的原始资本就越大</li></ol><p>如果你是个人开发者，你几乎不用担心有什么风险。因为不会有人来找你喝茶。</p><h2 id="怎么跟外国的公司竞争？"><a href="#怎么跟外国的公司竞争？" class="headerlink" title="怎么跟外国的公司竞争？"></a>怎么跟外国的公司竞争？</h2><p>有人可能会问，难道美国、欧洲自己没有做爬虫、做舆情的公司吗？他们肯定也做了很多年了，为什么国内的公司要找你，而不去找这些欧美本土的公司？</p><p>我认为，就凭这五个字：<code>你是自己人</code>。</p><p>如果你是一家中国的公司，专注分析海外舆情。即便你的业务能力跟一家欧美公司差不多甚至稍微低一些（当然低太多可不行），国内的大公司在选择合作伙伴的时候，一定会优先考虑你，而不是欧美当地的公司。</p><p>无论从人性上，还是从法律合规上，选择自己人都会安心很多。从人性上，中国人会选择跟中国人合作。大家都在互联网圈子，你这个公司怎么样，你这个老板怎么样，稍稍打听一下就知道了。只要知道你确实有实力，为什么不找你？</p><p>从业务上，两边公司沟通都用中文，有什么问题线上聊一下或者出个差，早上出发中午就能到，沟通起来很方便。</p><h2 id="大公司应该怎么做爬虫？"><a href="#大公司应该怎么做爬虫？" class="headerlink" title="大公司应该怎么做爬虫？"></a>大公司应该怎么做爬虫？</h2><p>我提到如果你是个人开发者或者小公司，那么你几乎不用担心任何风险。尽管爬就是了。</p><p>但如果你是国内的大公司，那么还是有一些注意事项的。因为大公司会担心像GDPR这样的信息保护法，也会担心如果爬虫被发现了会影响自己的国际声誉。但这些其实都不是什么大问题，都有办法绕过去的。</p><p>具体做法跟本文的关系不大，我就先不讲了。如果大家对爬虫出海有兴趣的话，请留言告诉我，我可以再分享一些具体的实践经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开篇先抛出我的观点：希望各位做爬虫的同学，尽快，尽可能多地做海外的爬虫项目，爬海外的网站。这才是你们新的未来。&lt;/p&gt;
&lt;p&gt;我最近两年时间，已经没有做过任何国内网站的爬虫了，根据这两年爬海外网站的一些经验，谈谈我的发现和想法。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>极其简单，加速Github Release 下载</title>
    <link href="https://www.kingname.info/2022/04/01/easy-github-download/"/>
    <id>https://www.kingname.info/2022/04/01/easy-github-download/</id>
    <published>2022-04-01T09:38:00.000Z</published>
    <updated>2022-04-04T09:39:12.393Z</updated>
    
    <content type="html"><![CDATA[<p>不是程序员的同学，别忙着走。不要看到Github就觉得这篇文章跟你无关。无论你是不是程序员，这篇文章都能帮到你。</p><a id="more"></a><p>有一些开源软件，它的新版本是通过Github Release来发布的。你在它的官网点击下载以后，实际上是从一个Github的地址下载文件。</p><p>以我最近很喜欢用的LogSeq为例，这个软件版本更新比较频繁，但是每次更新以后，都需要从Github Release里面找到最新版本来安装，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220326175525.png" alt></p><p>但如果你从这里下载过东西，你就会发现这个下载速度太恼火了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220326175624.png" alt></p><p>我Steam下载50GB的游戏不到1小时，可现在下载一个141MB的文件，竟然要2小时？</p><p>程序员同学自然有各种方法加速下载，但这些方法，要不就比较复杂，对不懂代码的同学不友好，要不就是方法涉及到一些众所周知却不能明说的东西。</p><p>不过，看到这篇文章的同学有福了，我们现在有一个<code>完全合法</code>，而且<code>极其简单</code>的方法来加速下载。</p><p>操作方法非常简单，只有3步：</p><ol><li>复制Github Release里面对应文件的下载地址</li><li>访问<a href="https://github.abskoop.workers.dev/" target="_blank" rel="noopener">GitHub 文件加速</a></li><li>粘贴Github Release文件的链接，并点击<code>下载按钮</code></li></ol><p>我们来具体操作一下。首先在Release页面，找到你要下载的那一个文件，在上面右键，点击<code>复制链接</code>：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220326180740.png" alt></p><p>复制出来的链接长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/logseq/logseq/releases/download/0.6.5/Logseq-darwin-x64-0.6.5.dmg</span><br></pre></td></tr></table></figure><p>然后把这个地址粘贴到加速网站里面并下载，下载速度有了质的提高：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220326181144.png" alt></p><p>这个网站的原理，是使用了Cloudflare Workers的全球CDN进行加速，完全合理合法。并且你甚至可以自己部署到自己服务器上面。这个网站的源代码也已经开源：<a href="https://github.com/hunshcn/gh-proxy" target="_blank" rel="noopener">GitHub - hunshcn/gh-proxy: github release、archive以及项目文件的加速项目</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不是程序员的同学，别忙着走。不要看到Github就觉得这篇文章跟你无关。无论你是不是程序员，这篇文章都能帮到你。&lt;/p&gt;
    
    </summary>
    
      <category term="技巧" scheme="https://www.kingname.info/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://www.kingname.info/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：为什么网站知道我的爬虫使用了代理？</title>
    <link href="https://www.kingname.info/2022/03/20/proxy-is-not-everything/"/>
    <id>https://www.kingname.info/2022/03/20/proxy-is-not-everything/</id>
    <published>2022-03-20T15:34:55.000Z</published>
    <updated>2022-03-20T15:37:56.964Z</updated>
    
    <content type="html"><![CDATA[<p>在公众号粉丝群里面，经常有同学问：为什么自己的爬虫明明设置了代理，但一访问网站就能被发现。我总结了几种常见的情况。</p><p>实际上，网站要识别你是否使用了代理，并不一定非要什么高深的反爬虫机制，也不需要使用AI识别用户行为。下面这几种情况，要识别代理简直是易如反掌。</p><a id="more"></a><h2 id="你根本没有使用代理"><a href="#你根本没有使用代理" class="headerlink" title="你根本没有使用代理"></a>你根本没有使用代理</h2><p>有一些初学者在使用Requests请求网站的时候，是这样写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>).text</span><br><span class="line"></span><br><span class="line">print(<span class="string">'不使用代理：'</span>, resp)</span><br><span class="line"></span><br><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>: <span class="string">'http://IP:port'</span>&#125;).text</span><br><span class="line">print(<span class="string">'使用代理：'</span>, resp)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220320141719.png" alt></p><p>为什么使用了代理以后，IP没有变呢？这是很多刚刚使用Requests的同学常常犯的错误。因为你根本没有给https网站使用代理，你的代理只会对http网站生效。要对https网站生效，需要给它指定代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(<span class="string">'https://httpbin.org/ip'</span>, proxies=&#123;<span class="string">'http'</span>: <span class="string">'http://IP:port'</span>, <span class="string">'https'</span>: <span class="string">'http://IP:port'</span>&#125;).text</span><br></pre></td></tr></table></figure><blockquote><p>P.S.: 注意看上面的代码，给https网址设置代理的时候，key是<code>https</code>，但值依然是<code>http://</code>开头。对一些代理供应商来说，如果你把这里设置成了<code>https://</code>开头，就会报错。不过这个原理跟本文无关，就暂时不讲了。如果大家有兴趣的话，我再写一篇文章来讲。</p></blockquote><h2 id="你的代理IP是服务器IP"><a href="#你的代理IP是服务器IP" class="headerlink" title="你的代理IP是服务器IP"></a>你的代理IP是服务器IP</h2><p>有很多代理供应商，他们批量采购云服务器来搭建代理服务。例如国内的供应商会采购阿里云、腾讯云、华为云的服务器来搭建代理。海外的供应商会采购AWS或者Google云服务器。</p><p>如果你在云服务器上跑过不加代理的爬虫，你会发现，有时候一个爬虫，不加代理，在自己电脑上跑一点问题都没有，但是在云服务器上一跑就会被识别。这是因为云服务器的IP地址范围跟家用宽带是不一样的。</p><p>像AWS和Google云，他们的云服务器IP范围是公开的，只要网站提前把来自这个范围的所有请求全部禁掉，那么从AWS、Google云服务器上面发起的请求直接就会被当做爬虫请求。因此搭建在上面的代理服务自然就不会生效了。</p><p>国内的云服务供应商的服务器IP地址是否公布过我不太清楚，但他们的IP范围肯定是跟家用IP不一样的。网址遇到来自这些可疑IP范围的请求时，虽然不一定完全封禁，但是弹一个验证码出来测一测，还是可以挡住很多爬虫。</p><p>遇到这种情况，爬虫只有设法采购一些使用家用宽带搭建代理服务的供应商，才能解决问题。但这种代理价格肯定会翻好几倍。</p><h2 id="你的代理IP不是高匿代理"><a href="#你的代理IP不是高匿代理" class="headerlink" title="你的代理IP不是高匿代理"></a>你的代理IP不是高匿代理</h2><p>代理IP有三种常见的类型，透明代理，匿名代理和高匿代理。</p><p>使用透明代理的时候，网站可以同时看到代理IP和你的真实IP。用了等于白用。</p><p>使用匿名代理的时候，网站看不到你的真实IP，但是在请求里面有一个特征，可以告诉网站，你正在使用代理访问。</p><p>而只有真正的高匿代理，才能把你的爬虫请求隐藏起来。</p><p>有一些同学可能会从网上搜索免费的代理IP来使用。但这里面很多代理并不是高匿代理。肯定会被发现。</p><h2 id="服务器供应商的IP池被污染"><a href="#服务器供应商的IP池被污染" class="headerlink" title="服务器供应商的IP池被污染"></a>服务器供应商的IP池被污染</h2><p>有些人的爬虫写得非常垃圾，自以为有代理就无所畏惧，爬虫请求漏掉百出，网站即使不检查IP频率，也可以从其它特征知道这是爬虫请求，于是网站就会连带着这个代理IP一起封掉。而偏偏这种垃圾爬虫的请求速度又极快。哪怕代理供应商的IP池中有几百万个IP，也会很快被这些垃圾爬虫全部害死。</p><p>国内头部网站每天都会被数以千万计的爬虫请求访问，而主流的代理供应商就那么几家。如果很多垃圾爬虫都选中了同一家供应商，而他们的代理池更新又不及时。那么你使用了这家供应商的代理IP，自然一来就会被发现。</p><h2 id="代理不支持HTTP-2"><a href="#代理不支持HTTP-2" class="headerlink" title="代理不支持HTTP/2"></a>代理不支持HTTP/2</h2><p>有一些网站需要使用HTTP/2请求。在Python里面，已经有不少HTTP客户端库支持发起HTTP/2的请求了，例如<code>httpx</code>。但是，现在很少有代理供应商能提供支持HTTP/2的代理，因为它搭建起来比较麻烦。于是，当你使用了支持HTTP/2的客户端，通过一个HTTP/1.1的代理IP访问一个HTTP/2的网站的时候，网站并不能正常返回内容。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网站要检测爬虫有非常多的方法，要检测一个请求是不是使用了代理来发起，也有很多种方法。而且这些方法并不需要什么高深的技术，一个初级工程师都能写出来。</p><p>那些自以为给爬虫加了代理就可随便爬网站的人，你们不仅害了自己，还害了别的爬虫。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在公众号粉丝群里面，经常有同学问：为什么自己的爬虫明明设置了代理，但一访问网站就能被发现。我总结了几种常见的情况。&lt;/p&gt;
&lt;p&gt;实际上，网站要识别你是否使用了代理，并不一定非要什么高深的反爬虫机制，也不需要使用AI识别用户行为。下面这几种情况，要识别代理简直是易如反掌。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="代理" scheme="https://www.kingname.info/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用装饰器简化大量if判断（二）</title>
    <link href="https://www.kingname.info/2022/03/20/decrease-if-2/"/>
    <id>https://www.kingname.info/2022/03/20/decrease-if-2/</id>
    <published>2022-03-20T15:34:39.000Z</published>
    <updated>2022-03-20T15:39:31.630Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章：<a href="https://mp.weixin.qq.com/s/eGji_6PBkf-vK2SQPB0WTQ" target="_blank" rel="noopener">一日一技：使用装饰器简化大量 if…elif…代码</a>发布以后，有很多同学说想看后续，如何在装饰器中表示大于小于。甚至有同学每周来催一次稿：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_0672.jpg" alt></p><p>于是，今天我们就来看看大于小于应该怎么来判断。为了实现我们今天的目标，有两个前置知识需要掌握，一个是Python自带的<code>operator</code>模块，另一个是偏函数。</p><a id="more"></a><h2 id="2-gt-1还有另一种写法？"><a href="#2-gt-1还有另一种写法？" class="headerlink" title="2 &gt; 1还有另一种写法？"></a>2 &gt; 1还有另一种写法？</h2><p>当我们要表达<code>大于</code>这个意思的时候，你想到的肯定是大于符号<code>&gt;</code>。所以<code>2大于1</code>，肯定写作<code>2 &gt; 1</code>。这看起来是很正常的事情。现在，如果我让你不准使用大于符号<code>&gt;</code>，怎么表示大于？</p><p>实际上，在Python里面，除了<code>&gt;</code>外，还有一种写法，就是使用自带的<code>operator</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">operator.gt(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中的<code>.gt(参数1, 参数2)</code>就表示<code>参数1 &gt; 参数2</code>。如果成立，返回<code>True</code>，否则返回<code>False</code>。</p><p>类似的还有：</p><ul><li>大于等于：operator.ge</li><li>小于：operator.lt</li><li>小于等于：operator.le</li><li>不等于：operator.ne</li><li>等于：operator.eq</li></ul><p>因此，下面两个写法是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt;= b:</span><br><span class="line">    print(<span class="string">'成功'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> operator.le(a, b):</span><br><span class="line">    print(<span class="string">'成功'</span>)</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>我在很久以前的公众号文章里面已经介绍过偏函数了：<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g" target="_blank" rel="noopener">偏函数：在Python中设定默认参数的另一种办法</a>。因此本文就不再讲它的基础用法了，大家点击链接去看那篇文章就可以掌握。</p><p>为什么我们需要偏函数呢？这是因为我们今天要做的事情，它需要给函数先传一半的参数，另一半的参数要在未来才能传入。例如，循环等待用户输入数字，如果其中一次输入的数字大于等于5，就打印<code>你好世界</code>。</p><p>如果不知道偏函数，你可能是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入数字：'</span>))</span><br><span class="line">    <span class="keyword">if</span> num &gt;= <span class="number">5</span>:</span><br><span class="line">        print(<span class="string">'你好世界'</span>)</span><br></pre></td></tr></table></figure><p>有了偏函数以后，你的写法是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">ge_5 = partial(operator.le, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入数字：'</span>))</span><br><span class="line">    <span class="keyword">if</span> ge_5(num):</span><br><span class="line">        print(<span class="string">'你好世界'</span>)</span><br></pre></td></tr></table></figure><p>特别注意，这里我在偏函数中传入的第一个参数是<code>operator.le</code>：小于。因为<code>operator.xx</code>表示第一个参数对第二个参数的比较，所以<code>x &gt;= 5</code> 就相当于5 &lt;= x 也就是<code>operator.le(5, x)</code>。</p><h2 id="在装饰器中实现大小比较"><a href="#在装饰器中实现大小比较" class="headerlink" title="在装饰器中实现大小比较"></a>在装饰器中实现大小比较</h2><p>前置知识掌握以后，我们就能看如何在装饰器里面实现大小比较。在第一篇文章中，我们只实现了参数等于，它的原理是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(value)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> registry:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                    <span class="string">f'registered for <span class="subst">&#123;value!r&#125;</span>'</span></span><br><span class="line">                )</span><br><span class="line">            registry[value] = func</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p><code>register</code>只接收了一个位置参数<code>value</code>。但实际上，我们还可以通过修改这段注册的代码，实现如下的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(3, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级大于3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(3, op='le')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_le3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级小于等于3'</span>)</span><br></pre></td></tr></table></figure><p>有同学问，有没有可能实现这样的写法呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, le=3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt3</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级为2'</span>)</span><br></pre></td></tr></table></figure><p>我觉得这样写是没有什么必要的。因为<code>register()</code>里面，多个参数之间的关系是<code>且</code>。那么只有两种情况，要么，就等于这个数，例如<code>@get_discount.register(2, le=3)</code>，既要等于2，又要小于等于3，那显然就等于2。不需要写这个<code>le=3</code>。要么，就不存在结果，例如<code>@get_discount.register(2, gt=3)</code>，既要等于2，又要大于3，显然下面被装饰的函数永远不会执行。因为找不到这个数。</p><p>因此，我们的装饰器函数就可以做如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value_dispatch</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">    registry_eq = &#123;&#125;</span><br><span class="line">    registry_other = &#123;&#125;</span><br><span class="line">    key_op_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(arg0, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> arg0 <span class="keyword">in</span> registry_eq:</span><br><span class="line">            delegate = registry_eq[arg0]</span><br><span class="line">            <span class="keyword">return</span> delegate(arg0, *args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> key, op <span class="keyword">in</span> key_op_map.items():</span><br><span class="line">                <span class="keyword">if</span> op(arg0):</span><br><span class="line">                    delegate = registry_other[key]</span><br><span class="line">                    <span class="keyword">return</span> delegate(arg0, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(arg0, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(value, op=<span class="string">'eq'</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'eq'</span>:</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> value <span class="keyword">in</span> registry_eq:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(</span><br><span class="line">                        <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                        <span class="string">f'registered for <span class="subst">&#123;value!r&#125;</span>'</span></span><br><span class="line">                    )</span><br><span class="line">                registry_eq[value] = func</span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">return</span> wrap</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'gt'</span>:</span><br><span class="line">                op_func = functools.partial(operator.lt, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'ge'</span>:</span><br><span class="line">                op_func = functools.partial(operator.le, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'lt'</span>:</span><br><span class="line">                op_func = functools.partial(operator.gt, value)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'le'</span>:</span><br><span class="line">                op_func = functools.partial(operator.ge, value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'op 参数只能是：gt/ge/lt/le之一'</span>)</span><br><span class="line">            key = <span class="string">f'<span class="subst">&#123;op&#125;</span>_<span class="subst">&#123;value&#125;</span>'</span></span><br><span class="line">            key_op_map[key] = op_func</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> registry_other:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(</span><br><span class="line">                        <span class="string">f'@value_dispatch: there is already a handler '</span></span><br><span class="line">                        <span class="string">f'registered for <span class="subst">&#123;key!r&#125;</span>'</span></span><br><span class="line">                    )</span><br><span class="line">                registry_other[key] = func</span><br><span class="line">                <span class="keyword">return</span> func</span><br><span class="line">            <span class="keyword">return</span> wrap</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    wrapper.register = register</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>它的使用方法还是跟以前一样，先定义默认的函数逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value_dispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_discount</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'等级错误'</span></span><br></pre></td></tr></table></figure><p>如果定义相等的逻辑，写法跟以前完全一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_1</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="string">"大量计算代码"</span></span><br><span class="line">    discount = <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>如果要定义不等于逻辑，就在<code>.register()</code>中添加一个参数<code>op</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220315203458.png" alt></p><p>由于我们定义了大于2时，始终返回1，所以可以看到<code>get_discount(6)</code>和<code>get_discount(10)</code>返回的都是1.</p><p>由于我们只定义了等于1和大于2的逻辑，所以当传入的参数为2时，就返回<code>等级错误</code>.</p><p>到这里，本文要讲的内容就结束了。但最后还是要考大家3个问题：</p><h3 id="如果不使用偏函数和operator模块，你会怎么做"><a href="#如果不使用偏函数和operator模块，你会怎么做" class="headerlink" title="如果不使用偏函数和operator模块，你会怎么做"></a>如果不使用偏函数和operator模块，你会怎么做</h3><p>你可以试一试在不实用偏函数和<code>operator</code>的情况下，实现这个需求。</p><h3 id="如果定义的条件有重叠怎么办？"><a href="#如果定义的条件有重叠怎么办？" class="headerlink" title="如果定义的条件有重叠怎么办？"></a>如果定义的条件有重叠怎么办？</h3><p>例如对于下面的两个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(2, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(10, op='gt')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_gt2</span><span class="params">(level)</span>:</span></span><br><span class="line">    discount = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>当level的值是20的时候，同时满足两个条件，应该运行哪一个呢？</p><h3 id="如何定义区间？"><a href="#如何定义区间？" class="headerlink" title="如何定义区间？"></a>如何定义区间？</h3><p>怎么实现这样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(ge=2, lt=5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_level_between2_5</span><span class="params">(level)</span>:</span></span><br><span class="line">    print(<span class="string">'等级2&lt;=level&lt;5'</span>)</span><br><span class="line">    discount = <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure><p>如果区间存在全包含、部分包含应该运行哪个函数？例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get_discount.register(ge=2, lt=00)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(ge=20, lt=50)</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_discount.register(ge=80, lt=200)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>请大家把你对这两个问题的答案回答在评论区里面。提示（想清楚什么是真需求，什么是伪需求，再考虑怎么解决）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/eGji_6PBkf-vK2SQPB0WTQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：使用装饰器简化大量 if…elif…代码&lt;/a&gt;发布以后，有很多同学说想看后续，如何在装饰器中表示大于小于。甚至有同学每周来催一次稿：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_0672.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;于是，今天我们就来看看大于小于应该怎么来判断。为了实现我们今天的目标，有两个前置知识需要掌握，一个是Python自带的&lt;code&gt;operator&lt;/code&gt;模块，另一个是偏函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何准备简历和面试（未闻Code直播录像）</title>
    <link href="https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/"/>
    <id>https://www.kingname.info/2022/03/09/how-to-prepare-for-interview/</id>
    <published>2022-03-09T09:26:09.000Z</published>
    <updated>2022-03-09T09:27:02.721Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1t3411B7XW&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1t3411B7XW&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="面试" scheme="https://www.kingname.info/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="面试" scheme="https://www.kingname.info/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>不走弯路的Docker入门</title>
    <link href="https://www.kingname.info/2022/03/09/intro-to-docker/"/>
    <id>https://www.kingname.info/2022/03/09/intro-to-docker/</id>
    <published>2022-03-09T09:24:02.000Z</published>
    <updated>2022-03-09T09:25:33.107Z</updated>
    
    <content type="html"><![CDATA[<p>保证你看完这个视频，就能使用 Docker。</p><iframe src="//player.bilibili.com/player.html?bvid=BV1Tg41157j4&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保证你看完这个视频，就能使用 Docker。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1Tg41157j4&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder
      
    
    </summary>
    
      <category term="Docker" scheme="https://www.kingname.info/categories/Docker/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="Docker" scheme="https://www.kingname.info/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GneList 来了！抓取列表页-极-其-简-单！</title>
    <link href="https://www.kingname.info/2022/03/09/this-is-gnelist/"/>
    <id>https://www.kingname.info/2022/03/09/this-is-gnelist/</id>
    <published>2022-03-09T08:56:05.000Z</published>
    <updated>2022-03-09T09:06:54.954Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/GeneralNewsExtractor/GeneralNewsExtractor" target="_blank" rel="noopener">Gne</a>发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。</p><a id="more"></a><h2 id="GneList-是什么"><a href="#GneList-是什么" class="headerlink" title="GneList 是什么"></a>GneList 是什么</h2><p>GneList是一个浏览器插件，专门用来生成列表页的 XPath。使用这个 XPath，你可以快速获取到列表页中的每一个条目。</p><h2 id="GneList-怎么用？"><a href="#GneList-怎么用？" class="headerlink" title="GneList 怎么用？"></a>GneList 怎么用？</h2><iframe src="//player.bilibili.com/player.html?bvid=BV1Nb4y1s7Lc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe><p>GneList 的使用非常简单，几乎不需要说明。</p><ol><li>打开带有列表的页面</li><li>点击插件</li><li>输入名字，点击<code>开始抓取</code></li><li>鼠标点击列表的前两项，GneList 会自动选中所有项</li><li>点击<code>提交</code>按钮</li><li>去数据库查看 XPath</li></ol><h2 id="怎么安装-GneList"><a href="#怎么安装-GneList" class="headerlink" title="怎么安装 GneList?"></a>怎么安装 GneList?</h2><p>GneList 由两个部分组成：插件端与后端。</p><p>插件端的下载地址：<a href="https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneList/releases/download/0.1/GneList.zip</a></p><p>后端的代码：<a href="https://github.com/GeneralNewsExtractor/GneListBackend" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GneListBackend</a> ，并且后端依赖 MongoDB。</p><h3 id="安装后端"><a href="#安装后端" class="headerlink" title="安装后端"></a>安装后端</h3><p>首先确保你有一个可以连接的 MongoDB，我们假设它的 URI 是：<code>mongodb://localhost</code>。从 Github上面 clone 后端的代码：<code>https://github.com/GeneralNewsExtractor/GneListBackend.git</code>。</p><p>进入后端代码的根目录中的 config 文件夹中，你会发现一个<code>local.yml</code>文件。打开它，第一行填写 MongoDB 的 URI 地址，第二行是数据库名，第三行是集合名。插件生成的 XPath 会保存在这里供你的下游调用。</p><p>改好配置文件以后，回到后端的根目录，分别执行如下命令(你需要先安装 Pipenv)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipenv install</span><br><span class="line">pipenv shell</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">local</span> <span class="comment"># 你自己创建的 yml文件的名字</span></span><br><span class="line">uvicorn main:app --port 8800 --host 0.0.0.0  <span class="comment"># 使用8800端口</span></span><br></pre></td></tr></table></figure><p>命令执行完成后，如果你使用浏览器访问<code>http://127.0.0.1:8800</code>，应该会看到下图的内容，说明后端搭建成功。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-40-38.png" alt></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>GneList 插件支持所有基于 Chromium 内核的浏览器，包括但不限于 Chrome/Chromium/Edge。</p><p>从上面的地址下载<code>GneList.zip</code>后，把它解压到任何一个文件夹中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-45-08.png" alt></p><p>然后打开你的浏览器的插件管理页面，启动<code>开发人员模式</code>，例如下图是我在 Edge 中开启开发人员模式的方法。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-47-02.png" alt></p><p>然后点击右上角的<code>加载解压缩的扩展</code>，选中<code>GneList</code>文件夹。完成。</p><p>现在，刷新已有的列表页，或者重新开一个新的列表页，然后点击插件，试用一下吧。</p><h3 id="管理配置页面"><a href="#管理配置页面" class="headerlink" title="管理配置页面"></a>管理配置页面</h3><p>在插件上右键，选择<code>扩展选项</code>。Chrome 上面，名字可能是叫做<code>选项</code>或者英文<code>Options</code>。可以打开如下图所示的页面：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-51-06.png" alt></p><p>如果你没有启动后端，或者后端地址不是<code>http://127.0.0.1:8800</code>（例如你把后端部署在服务器上，需要使用 IP 或者域名来访问，或者端口不是8800），那么这个页面应该如上图所示。</p><p>你可以把输入框中的地址改为<code>后端地址/rule</code>，例如<code>http://123.56.78.99:8888/rule</code>。然后点击<code>提交</code>按钮。接下来刷新页面，你就可以看到如下图所示的内容：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-03-08-22-54-35.png" alt></p><p>这个页面显示了你已经添加的所有网站的XPath，你可以对他们进行修改或者删除。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><blockquote><p>为什么插件生成的 XPath 这么奇怪？</p></blockquote><p>因为这些 XPath 是从 CssSelector 转成的 XPath，我用了一个第三方的 JavaScript 包。那个包转出来的就是这么奇怪。但不影响它的功能。我后面会更换更好的包，让 XPath 变得更好看。</p><blockquote><p>我的爬虫怎么使用这些 XPath？</p></blockquote><p>还记得一开始配置的 MongoDB 吗？让你的爬虫去里面读取就可以了。</p><blockquote><p>为什么我启动插件以后，点网页上面的元素第一次没有反应？</p></blockquote><p>第一次点击的时候，如果发现没有生成红框框，就多点一下。看到红框框了再点第二个元素。</p><h2 id="GneList-的原理是什么？"><a href="#GneList-的原理是什么？" class="headerlink" title="GneList 的原理是什么？"></a>GneList 的原理是什么？</h2><p>接下来的几篇文章，我会介绍 GneList 的原理。如果你等不及的话，也可以到 Github上查看<a href="https://github.com/GeneralNewsExtractor/GneList" target="_blank" rel="noopener">源代码</a>。GneList 与 Gne 一样，他们是站在其他优秀开源项目的肩膀上做出来的，尤其是受到 <a href="https://github.com/martinsbalodis/web-scraper-chrome-extension" target="_blank" rel="noopener">web-scraper-chrome-extension</a>的启发。因此，GneList也是完全开源的，允许非商业使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gne&lt;/a&gt;发布以后，大家自动化抓取新闻正文页的需求被解决了。但随之而来的，不断有同学希望能出一个抓取列表页的工具，于是，就有了今天的 GneList。&lt;/p&gt;
    
    </summary>
    
      <category term="Gne" scheme="https://www.kingname.info/categories/Gne/"/>
    
    
      <category term="Gne" scheme="https://www.kingname.info/tags/Gne/"/>
    
      <category term="GneList" scheme="https://www.kingname.info/tags/GneList/"/>
    
  </entry>
  
  <entry>
    <title>使用 LogSeq 阅读 PDF体验极好</title>
    <link href="https://www.kingname.info/2022/03/09/read-pdf-by-logseq/"/>
    <id>https://www.kingname.info/2022/03/09/read-pdf-by-logseq/</id>
    <published>2022-03-09T07:10:49.000Z</published>
    <updated>2022-03-09T09:28:56.104Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?bvid=BV1iL411N7sq&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="720px" height="500px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1iL411N7sq&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfu
      
    
    </summary>
    
      <category term="LogSeq" scheme="https://www.kingname.info/categories/LogSeq/"/>
    
    
      <category term="视频" scheme="https://www.kingname.info/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="LogSeq" scheme="https://www.kingname.info/tags/LogSeq/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI的小兄弟，开发命令行工具更给力</title>
    <link href="https://www.kingname.info/2022/03/06/typer/"/>
    <id>https://www.kingname.info/2022/03/06/typer/</id>
    <published>2022-03-06T15:16:46.000Z</published>
    <updated>2022-03-06T15:27:53.637Z</updated>
    
    <content type="html"><![CDATA[<p>关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。</p><p>FastAPI的开发组织叫做<code>tiangolo</code>，他家除了FastAPI外，还有另一个项目也非常好用，叫做<code>typer</code>。</p><p>三年前，我写过一篇文章<a href="https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ" target="_blank" rel="noopener">一日一技：快速实现Python 命令行参数</a>介绍另一个命令行工具fire. 而<code>typer</code>做得比fire还要好。</p><a id="more"></a><p>首先使用pip来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer</span><br></pre></td></tr></table></figure><h2 id="函数参数等于命令行参数"><a href="#函数参数等于命令行参数" class="headerlink" title="函数参数等于命令行参数"></a>函数参数等于命令行参数</h2><p>我们首先来看看typer怎么使用。创建一个<code>example_1.py</code>文件，写入如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(name: str, salary: int)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span>月薪<span class="subst">&#123;salary&#125;</span>元'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    typer.run(main)</span><br></pre></td></tr></table></figure><p>直接运行，Python会报错：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182532.png" alt></p><p>使用参数<code>--help</code>可以查看这个脚本的命令行参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182619.png" alt></p><p>于是我们根据这里的提示，输入正确的参数，从而正常运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119182659.png" alt></p><h2 id="子命令与自动补全更好用"><a href="#子命令与自动补全更好用" class="headerlink" title="子命令与自动补全更好用"></a>子命令与自动补全更好用</h2><p>假设我们有一个神经网络的程序，其中的入口函数代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>显然，这个程序可以用来训练数据，也可以用来预测数据，所以有两种不同的命令，每一种命令有不同的参数。</p><p>这种情况下，使用typer非常方便，只需要加两个装饰器就可以了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183543.png" alt></p><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183621.png" alt></p><p>输入具体的子命令，还可以查看每个子命令的参数：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119183725.png" alt></p><p>因此，我可以使用两个不同的子命令来运行程序：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185959.png" alt></p><p>你以为这样就完了？我们再安装它的一个辅助工具<code>typer-cli</code>，还可以做更多事情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install typer-cli</span><br><span class="line">typer --install-completion</span><br></pre></td></tr></table></figure><p>有了这个东西，我们运行程序可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer example_2.py run 子命令 参数1 参数2 --可选参数1 可选参数1的值</span><br></pre></td></tr></table></figure><p>例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184434.png" alt></p><p>并且，typer可以帮我们可以实现自动补全：</p><p>输入<code>typer example_2.py run</code> 然后按下<code>Tab</code>键，自动告诉你可以输入哪些子命令，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184218.png" alt></p><p>除此之外，如果你的命令行程序只有一个命令，那么你甚至只需要写一个函数，连typer都不需要导入，就可以使用typer来运行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119184837.png" alt></p><h2 id="自动生成文档也简单"><a href="#自动生成文档也简单" class="headerlink" title="自动生成文档也简单"></a>自动生成文档也简单</h2><p>我们知道，FastAPI自动生成接口文档的功能非常好用。typer作为它的兄弟，也继承了这个高级功能。我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line">app = typer.Typer(help=<span class="string">"人脸检测模型"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">(train_folder: str, test_folder: str, rate: float = <span class="number">0.8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    训练人脸检测模型</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'使用文件夹<span class="subst">&#123;train_folder&#125;</span>中的数据进行训练'</span>)</span><br><span class="line">    print(<span class="string">f'使用<span class="subst">&#123;test_folder&#125;</span>中的数据用来验证训练效果，确保准确率&gt;<span class="subst">&#123;rate&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(folder: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用训练好的模型预测</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f'对文件夹<span class="subst">&#123;folder&#125;</span>中的数据进行预测。'</span>)</span><br></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typer main.py utils docs --name <span class="string">"python3 main.py"</span> --output readme.md</span><br></pre></td></tr></table></figure><p>自动在当前文件夹生成一个<code>readme.md</code>文件。我们使用任何能够渲染Markdown的软件打开这个文档，可以看到文档内容如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220119185537.png" alt></p><p>这样一来，我们不需要额外花心思去维护文档，只需要在修改完代码、增删新的命令或者参数以后，运行这个命令，就可以把文档自动更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关注我公众号的同学都知道，我非常喜欢FastAPI这个web框架。它在易用性上面做到了极致，帮助开发者减少了很多不必要的工作。&lt;/p&gt;
&lt;p&gt;FastAPI的开发组织叫做&lt;code&gt;tiangolo&lt;/code&gt;，他家除了FastAPI外，还有另一个项目也非常好用，叫做&lt;code&gt;typer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;三年前，我写过一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/lO42vHaYz1TToiUO8Q2wcQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：快速实现Python 命令行参数&lt;/a&gt;介绍另一个命令行工具fire. 而&lt;code&gt;typer&lt;/code&gt;做得比fire还要好。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="FastAPI" scheme="https://www.kingname.info/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>舍近求远，为什么 Golang 要这样读取本地的 package？</title>
    <link href="https://www.kingname.info/2022/03/06/gomod/"/>
    <id>https://www.kingname.info/2022/03/06/gomod/</id>
    <published>2022-03-06T15:16:38.000Z</published>
    <updated>2022-03-06T15:28:07.028Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 <code>pip</code> 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 <code>go get</code> 进行安装。</p><p>有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。</p><a id="more"></a><p>例如我们看这个项目：<a href="https://github.com/kingname/handsome" target="_blank" rel="noopener">https://github.com/kingname/handsome</a> ，它的入口文件是<code>main.go</code>。我们打开这个文件，会看到里面<code>import</code>语句中，从 Github导入自身的<code>util</code>包：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193156.png" alt></p><p>可问题是，这个 <code>util</code>文件夹就在<code>main.go</code>旁边啊：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120193259.png" alt></p><p>如果是在 Python 里面，入口文件<code>main.py</code>旁边有一个<code>util</code>文件夹，这个文件夹里面有一个<code>util.py</code>的文件，那么我们直接写<code>from util.util import xxx</code>就可以导入<code>util.py</code>文件中的函数了。为什么 Golang 里面要从 Github 导入？那如果我更新了<code>util/util.go</code>文件里面的内容，但是我没有把这次修改上传到 Github 中，当我运行<code>go run main.go</code>的时候，运行的是老代码还是新代码？用的是我本地的版本还是 Github 上面的版本？</p><p>这个问题的关键，就在<code>go.mod</code>这个文件中。打开请看这个文件的第一行：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220120194356.png" alt></p><p>可以看到，这个项目是使用 <code>go mod</code> 进行管理的，并且指定这个模块的名字，就叫做<code>github.com/kingname/handsome</code>。</p><p>所以，当我们执行命令<code>go run main.go</code>的时候，Golang 的编译器知道自己就是<code>github.com/kingname/handsome</code>，那么<code>main.go</code>里面导入<code>github.com/kingname/handsome/util</code>，实际上就是本项目自身根目录的 <code>util</code>文件夹中的包，它不会发起网络请求，不会从 Github 上面重新下载。每次运行的时候，使用的总是项目<code>util/util.go</code>中的内容。</p><p>但是，如果你现在在另外一个项目里面导入<code>github.com/kingname/handsome/util</code>，Golang 从<code>go.mod</code>中知道当前运行的项目跟即将导入的这个包不在同一个项目中，于是它就会去 Github 上面拉代码下来运行。</p><p>这个规则，可以在 Golang 的官方文档<strong>Module paths</strong>这一节找到：<a href="https://go.dev/ref/mod#introduction" target="_blank" rel="noopener">Go Modules Reference - The Go Programming Language</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python 的第三方库一般是托管到 Pypi 上面的，使用 &lt;code&gt;pip&lt;/code&gt; 命令进行安装。而 Golang 很多第三方库是托管在 Github 上面的，使用 &lt;code&gt;go get&lt;/code&gt; 进行安装。&lt;/p&gt;
&lt;p&gt;有时候，我们会发现一个很奇怪的现象，很多 Golang 的项目，在引用自己项目里面的包的时候，竟然用的是 Github 上面的地址。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</title>
    <link href="https://www.kingname.info/2022/03/06/gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/gzip-boom/</id>
    <published>2022-03-06T15:16:09.000Z</published>
    <updated>2022-03-06T15:26:02.606Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。</p><p>看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。</p><a id="more"></a><blockquote><p>本文有一个前提：你已经知道某个请求是爬虫发来的了，你不满足于单单屏蔽对方，而是想搞死对方。</p></blockquote><p>很多人的爬虫是使用Requests来写的，如果你阅读过Requests的文档，那么你可能在文档中的<a href="https://2.python-requests.org/en/master/user/quickstart/#binary-response-content" target="_blank" rel="noopener">Binary Response Content</a>这一小节，看到这样一句话：</p><blockquote><p>The gzip and deflate transfer-encodings are automatically decoded for you.<br>（Request）会自动为你把gzip和deflate转码后的数据进行解码</p></blockquote><p>网站服务器可能会使用<code>gzip</code>压缩一些大资源，这些资源在网络上传输的时候，是压缩后的二进制格式。客户端收到返回以后，如果发现返回的Headers里面有一个字段叫做<code>Content-Encoding</code>，其中的值包含<code>gzip</code>，那么客户端就会先使用<code>gzip</code>对数据进行解压，解压完成以后再把它呈现到客户端上面。浏览器自动就会做这个事情，用户是感知不到这个事情发生的。而<code>requests</code>、<code>Scrapy</code>这种网络请求库或者爬虫框架，也会帮你做这个事情，因此你不需要手动对网站返回的数据解压缩。</p><p>这个功能原本是一个方便开发者的功能，但我们可以利用这个功能来做报复爬虫的事情。</p><p>我们首先写一个客户端，来测试一下返回<code>gzip</code>压缩数据的方法。</p><p>我首先在硬盘上创建一个文本文件<code>text.txt</code>，里面有两行内容，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124194721.png" alt></p><p>然后，我是用<code>gzip</code>命令把它压缩成一个<code>.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat text.txt | gzip &gt; data.gz</span><br></pre></td></tr></table></figure><p>接下来，我们使用FastAPI写一个HTTP服务器<code>server.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>然后使用命令<code>uvicorn server:app</code>启动这个服务。</p><p>接下来，我们使用requests来请求这个接口，会发现返回的数据是乱码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195107.png" alt></p><p>返回的数据是乱码，这是因为服务器没有告诉客户端，这个数据是<code>gzip</code>压缩的，因此客户端只有原样展示。由于压缩后的数据是二进制内容，强行转成字符串就会变成乱码。</p><p>现在，我们稍微修改一下<code>server.py</code>的代码，通过Headers告诉客户端，这个数据是经过<code>gzip</code>压缩的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Response</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    resp = FileResponse(<span class="string">'data.gz'</span>)</span><br><span class="line">    resp.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'gzip'</span>  <span class="comment"># 说明这是gzip压缩的数据</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>修改以后，重新启动服务器，再次使用requests请求，发现已经可以正常显示数据了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124195422.png" alt></p><p>这个功能已经展示完了，那么我们怎么利用它呢？这就不得不提到压缩文件的原理了。</p><p>文件之所以能压缩，是因为里面有大量重复的元素，这些元素可以通过一种更简单的方式来表示。压缩的算法有很多种，其中最常见的一种方式，我们用一个例子来解释。假设有一个字符串，它长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">1111111111111111</span><br></pre></td></tr></table></figure><p>我们可以用5个字符来表示：<code>192个1</code>。这就相当于把192个字符压缩成了5个字符，压缩率高达97.4%。</p><p>如果我们可以把一个1GB的文件压缩成1MB，那么对服务器来说，仅仅是返回了1MB的二进制数据，不会造成任何影响。但是对客户端或者爬虫来说，它拿到这个1MB的数据以后，就会在内存中把它还原成1GB的内容。这样一瞬间爬虫占用的内存就增大了1GB。如果我们再进一步增大这个原始数据，那么很容易就可以把爬虫所在的服务器内存全部沾满，轻者服务器直接杀死爬虫进程，重则爬虫服务器直接死机。</p><p>你别以为这个压缩比听起来很夸张，其实我们使用很简单的一行命令就可以生成这样的压缩文件。</p><p>如果你用的是Linux，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1M count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>如果你的电脑是macOS，那么请执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero bs=1048576 count=1000 | gzip &gt; boom.gz</span><br></pre></td></tr></table></figure><p>执行过程如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200621.png" alt></p><p>生成的这个<code>boom.gz</code>文件只有995KB。但是如果我们使用<code>gzip -d boom.gz</code>对这个文件解压缩，就会发现生成了一个1GB的<code>boom</code>文件，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124200731.png" alt></p><p>只要大家把命令里面的<code>count=1000</code>改成一个更大的数字，就能得到更大的文件。</p><p>我现在把<code>count</code>改成<code>10</code>，给大家做一个演示（不敢用1GB的数据来做测试，害怕我的Jupyter崩溃）。生成的<code>boom.gz</code>文件只有10KB：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201125.png" alt></p><p>服务器返回一个10KB的二进制数据，没有任何问题。</p><p>现在我们用requests去请求这个接口，然后查看一下<code>resp</code>这个对象占用的内存大小：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220124201007.png" alt></p><p>可以看到，由于requests自动会对返回的数据解压缩，因此最终获得的resp对象竟然有10MB这么大。</p><p>如果大家想使用这个方法，一定要先确定这个请求是爬虫发的，再使用。否则被你干死的不是爬虫而是真实用户就麻烦了。</p><p>本文的写作过程中，参考了文章<a href="http://da.dadaaierer.com/?p=577" target="_blank" rel="noopener">网站gzip炸弹 – 王春伟的技术博客</a>，特别感谢原作者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个站长，你是不是对爬虫不胜其烦？爬虫天天来爬，速度又快，频率又高，服务器的大量资源被白白浪费。&lt;/p&gt;
&lt;p&gt;看这篇文章的你有福了，我们今天一起来报复一下爬虫，直接把爬虫的服务器给干死机。&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：轻松排雷，爬虫让gzip炸弹变成哑炮</title>
    <link href="https://www.kingname.info/2022/03/06/kill-gzip-boom/"/>
    <id>https://www.kingname.info/2022/03/06/kill-gzip-boom/</id>
    <published>2022-03-06T15:15:59.000Z</published>
    <updated>2022-03-06T15:26:19.914Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章《<a href="https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg" target="_blank" rel="noopener">一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器</a>》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。</p><p>大家都知道我的公众号风格，要<del>得罪</del>讨好就两边一起<del>得罪</del>讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？</p><p>最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。</p><p>如果你没有把握隐藏爬虫，那么，请继续往下看。</p><a id="more"></a><p>查看gzip炸弹的URL返回的Headers，你会发现如下图所示的字段：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184230.png" alt></p><p>你只需要判断<code>resp.headers</code>中，是否有一个名为<code>content-encoding</code>，值包含<code>gzip</code>或<code>deflate</code>的字段。如果没有这个字段，或者值不含<code>gzip</code>、<code>deflate</code>那么你就可以放心，它大概率不是炸弹。</p><p>值得一提的是，当你不读取<code>resp.content</code>、<code>resp.text</code>的时候，Requests是不会擅自给你解压缩的，如下图所示。因此你可以放心查看Headers。：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184347.png" alt></p><p>那么，如果你发现网站返回的内容确实是<code>gzip</code>压缩后的内容了怎么办呢？这个时候，我们如何做到既不解压缩，又能获取到解压以后的大小？</p><p>如果你本地检查一个<code>.gz</code>文件，那么你可以使用命令<code>gzip -l xxx.gz</code>来查看它的头信息：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125184943.png" alt></p><p>打印出来的数据中，第一个数字是压缩后的大小，第二个数字是解压以后的大小，第三个百分比是压缩率。这些信息是储存在压缩文件的头部信息中的，不用解压就能获取到。</p><p>那么当我使用Requests的时候，如何获得压缩后的二进制数据，防止它擅自解压缩？方法其实非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line">print(resp.raw.read())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185246.png" alt></p><p>此时可以看到，这个大小是压缩后的二进制数据的大小。现在，我们可以使用如下代码，在不解压的情况下，查询到解压缩后的文件大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(url, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">decompressed = resp.raw.read()</span><br><span class="line"><span class="keyword">with</span> gzip.open(io.BytesIO(decompressed), <span class="string">'rb'</span>) <span class="keyword">as</span> g:</span><br><span class="line">    g.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    origin_size = g.tell()</span><br><span class="line">    print(origin_size)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220125185700.png" alt></p><p>打印出来的数字转成MB就是10MB，也就是我们昨天测试的解压后的文件大小。</p><p>使用这个方法，我们就可以在不解压的情况下，知道网站返回的gzip压缩数据的实际大小。如果发现实际尺寸大得离谱，那就可以确定是gzip炸弹了，赶紧把它丢掉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/Lzo6Pm09XsOqPkz3O91Mgg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：反爬虫的极致手段，几行代码直接炸了爬虫服务器&lt;/a&gt;》中，我讲到了后端如何使用gzip返回极高压缩率的文件，从而瞬间卡死爬虫。&lt;/p&gt;
&lt;p&gt;大家都知道我的公众号风格，要&lt;del&gt;得罪&lt;/del&gt;讨好就两边一起&lt;del&gt;得罪&lt;/del&gt;讨好。昨天我帮了后端，今天我就帮帮爬虫。作为爬虫，如何避免踩中gzip炸弹？&lt;/p&gt;
&lt;p&gt;最直接的方法，就是把你的爬虫隐藏起来，因为gzip炸弹只能在发现了爬虫以后使用，否则就会影响到正常用户。只要你的爬虫让网站无法发现，那么自然就不会踩中炸弹。&lt;/p&gt;
&lt;p&gt;如果你没有把握隐藏爬虫，那么，请继续往下看。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：8行炫技代码，知识点多得不得了</title>
    <link href="https://www.kingname.info/2022/03/06/knowledge-in-bad-code/"/>
    <id>https://www.kingname.info/2022/03/06/knowledge-in-bad-code/</id>
    <published>2022-03-06T15:15:43.000Z</published>
    <updated>2022-03-06T15:23:40.546Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。</p><a id="more"></a><p>例如，我们知道Python里面的<code>range</code>函数，最少可以接收1个参数，最多能够接收3个参数。当只有两个参数的时候，格式为<code>range(开始, 结束)</code>，从开始数字到结束数字逐次加1，左闭右开。使用今天的方法，可以把它的写法改为<code>开始 |到| 结束</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127191711.png" alt></p><p>又比如，<code>urllib.parse.urljoin</code>可以把域名和一个相对路径拼接起来: <code>urljoin(域名, 相对路径)</code>，我们也可以改写成如下图所示的格式：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127192252.png" alt></p><p>这种炫技有余，实用不足的功能是怎么实现的呢？其实原理非常简单，只有8行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Change</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func(other)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        self.func = partial(self.func, other)</span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>这里就涉及到一个盲点和两个真正的知识点。这个盲点就是，你可能以为<br><code>|到|</code>是一个字符，但是它是3个字符；你可能会把<code>|拼接|</code>看做一个整体，但是它实际上是3个部分：左边的<code>|</code>、<code>拼接</code>和右边的<code>|</code>。</p><p>我们把空格加上，就很明显了：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127194754.png" alt></p><p>两个真正的知识点，就是<code>__or__</code>和<code>__ror__</code>这两个魔术方法和偏函数<code>partial</code>。而<code>Change</code>本身就是一个普通的类而已，<code>__or__</code>和<code>__ror__</code>定义了这个类的实例在左侧遇到<code>|</code>时，右侧遇到<code>|</code>时的具体行为。</p><p>我们一个一个来讲。首先是<code>__or__</code>。它定义了实例的右侧遇到<code>|</code>时的具体行为。例如，我们用一个简单的代码来进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">f'我右边有一个东西，它是：<span class="subst">&#123;other&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">x = Test(<span class="number">100</span>)</span><br><span class="line">x | <span class="number">55</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193556.png" alt></p><p>但如果你把竖线放在左边，他就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193742.png" alt></p><p>而<code>__ror__</code>就是用来定义<code>|</code>在实例左边的时候，它的行为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127193858.png" alt></p><p>所以，我们最开始的例子中，<code>2 |到| 10</code>，实际上应该理解为：</p><ol><li><code>到</code>是<code>Change(range)</code>返回的实例</li><li><code>2 | 到</code>  生成一个中间对象，我们假设它是<code>x</code></li><li><code>x | 10</code> 生成结果</li></ol><p>在我们演示的例子中，<code>2 | 到</code>首先进入了<code>Change</code>类的<code>__ror__</code>方法中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    self.func = partial(self.func, other)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>其中，一开始的<code>self.func</code>就是我们在初始化实例<code>Change(range)</code>时传入的参数<code>range</code>。所以<code>partial(self.func, other)</code>等价于<code>partial(range, 2)</code>。关于偏函数<code>partial</code>，大家可以看我这篇文章：<a href="https://mp.weixin.qq.com/s/veP19kUQgnyiivDoJH8_9g" target="_blank" rel="noopener">偏函数：在Python中设定默认参数的另一种办法</a>。简单来说，使用偏函数，可以给一个真正的函数传一部分参数，过一会再补剩下的参数。</p><p>可能大家在日常的开发者，很少会让一个实例方法返回<code>self</code>。关于这个写法，大家可以看我的这一篇文章：<a href="https://mp.weixin.qq.com/s/Y689WhpOopHdI8hbCGcFMg" target="_blank" rel="noopener">一日一技：在Python里面实现链式调用</a>。也就是说，<code>1 | 到</code>返回的，依然是<code>Change</code>类的一个实例，我们简称它为<code>x</code>。这个实例的属性<code>self.func</code>的值是<code>partial(range, 2)</code>。</p><p>接下来，<code>x | 10</code>，调用的是<code>__or__</code>方法，于是，此时执行的是<code>partial(range, 2)(10)</code>。偏函数的参数补全了，于是它里面的<code>range</code>真正运行了起来，成为了<code>range(2, 10)</code>。</p><p>至此，这个<code>Change</code>类我们就解析透了。大家知道，在Python里面，魔术方法是有很多的，如果你不想用<code>|</code>，你还可以用其它的，例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195758.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195832.png" alt></p><p>或者：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127195904.png" alt></p><p>同时，这个<code>Change</code>类，你甚至可以直接当做装饰器来使用。任何能够接收两个参数的函数，都能使用这个装饰器。例如：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220127200446.png" alt></p><p>最后总结一下。大家都知道，我是非常反对在工作代码中炫技的，因为炫技的写法很难读，很难维护。今天这个炫技的方法，虽然我也不推荐大家用在工作中，但是它短短8行代码里面，包含了很多个知识点，这就值得大家玩一玩了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们今天来看一段炫技代码。它可以把任何能接收两个参数的函数定义成一个特殊的运算符。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>你以为的万能爬虫方法，其实一行代码就能识别！</title>
    <link href="https://www.kingname.info/2022/03/06/detect-js-click/"/>
    <id>https://www.kingname.info/2022/03/06/detect-js-click/</id>
    <published>2022-03-06T15:15:22.000Z</published>
    <updated>2022-03-06T15:24:52.501Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。</p><p>这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png" alt></p><a id="more"></a><p>而Chrome插件访问自己的服务器后端是没有跨域问题的，完全可以让插件获取到数据以后，发送给自己的服务器，这样就可以把数据收入囊中了。</p><p>你还可以通过JavaScript自动点击按钮，实现自动翻页。所以你只需要把网页打开，启动插件，然后他就能自动刷新，自动获取数据了。</p><p>这个方法看起来非常万能，而且无法被防御……</p><p>事实真的是这样吗？我写了一个Demo来做测试。Demo页面长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204724.png" alt></p><p>当我手动点击<code>点击我</code>按钮的时候，会弹出一个框：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204814.png" alt></p><p>现在，我使用JavaScript来选择这个按钮，然后点击它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204936.png" alt></p><p>为什么网站知道我在用JavaScript点击了按钮呢？其实只要我给你看这个页面的HTML，你就知道了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"spider"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>你这个狗爬虫<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"check"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                spider: <span class="literal">false</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                check: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                    if (event.isTrusted) &#123;</span><br><span class="line"><span class="javascript">                        alert(<span class="string">'主人你好，欢迎回家！'</span>)</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.spider = <span class="literal">true</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关键的点就是这个<code>event.isTrusted</code>。它是浏览器的一个功能，如果这个事件是人通过鼠标点击的，那么它是<code>true</code>。如果事件是通过JavaScript触发的，那么它是<code>false</code>。</p><p>关于这个属性，你可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/isTrusted" target="_blank" rel="noopener">Event.isTrusted - Web API 接口参考 | MDN</a>。这个例子里面，我用的是Vue来操作页面，但实际上<code>event</code>是浏览器的特性，使用原生JavaScript也可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"button"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.isTrusted) &#123;</span><br><span class="line">      alert(<span class="string">'主人你好，欢迎回家！'</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.spider = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>那么如何绕过这个<code>event.isTrusted</code>呢？其实很简单，你使用Selenium/Puppeteer，天然就能绕过它。</p><p>看到这里，大家肯定发现一个很好笑的问题，Selenium/Puppeteer不能解决的问题，用JavaScript轻松就能解决。但JavaScript解决不了的问题，用Selenium/Puppeteer又完全没有问题。</p><p>这就像是猫吃老鼠，老虎吃猫，大象吃老虎，但是老鼠可以吃大象。寸有所长，必有所短，寸有所短，也可能有所长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的公众号中，我提到Selenium/Puppeteer/Pyppeteer有很多特征可以被网站检测到。于是，有些同学想到了另一个方法，就是自己写一个Chrome插件，在网站打开的时候，注入到页面中，然后通过这个注入的JavaScript代码来操作页面，获取数据。&lt;/p&gt;
&lt;p&gt;这个方法理论上说是万能的，因为注入的JavaScript能够获取当前Dom树，任何接口签名都无法拦截到自己注入的JavaScript代码，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220208204228.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="反爬虫" scheme="https://www.kingname.info/categories/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="反爬虫" scheme="https://www.kingname.info/tags/%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
