<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2018-12-23T10:20:29.746Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目经理必备——使用燃尽图监控项目整体进度</title>
    <link href="https://www.kingname.info/2018/12/23/use-burndown-chart/"/>
    <id>https://www.kingname.info/2018/12/23/use-burndown-chart/</id>
    <published>2018-12-23T09:11:13.000Z</published>
    <updated>2018-12-23T10:20:29.746Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.kingname.info/2018/10/17/use-gantt-enhanced/">《跳出任务管理的泥沼，拥抱甘特图的怀抱》</a>一文中，我谈到了使用甘特图来规划任务。甘特图更多的关注每一个任务的进度上。那么如果我希望了解项目整体的进度，应该如何选择呢？此时就需要引入另一个简单又强大的工具：燃尽图（Burn down chart）。</p>
<a id="more"></a>
<h2 id="什么是燃尽图"><a href="#什么是燃尽图" class="headerlink" title="什么是燃尽图"></a>什么是燃尽图</h2><p>假设项目X有5个任务，我们在预估这些任务的时候，时间安排如下：</p>
<table>
<thead>
<tr>
<th>项目名称</th>
<th>预计用时（小时）</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务1</td>
<td>5</td>
</tr>
<tr>
<td>任务2</td>
<td>6</td>
</tr>
<tr>
<td>任务3</td>
<td>7</td>
</tr>
<tr>
<td>任务4</td>
<td>4</td>
</tr>
<tr>
<td>任务5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>这个任务预计需要25小时完成，考虑到可能需要处理各种突发事件留出机动时间，因此，我需要在7天内完成这个项目，项目时间定为：2018-12-01到2018-12-07。</p>
<p>在非常理想的情况下，平均分配工作时间，到2018-12-07这一个公众日结束时刚刚好完成任务。此时的时间消耗，绘制为折线图如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-25-21.png" alt=""></p>
<p>纵坐标为任务剩余时间，横坐标为日期，</p>
<p>然而，在实际情况中，可能有些任务能提前完成，有些任务时间又需要延迟，实际上的剩余时间和日期的折线图可能如下图橙色曲线所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-28-33.png" alt=""></p>
<p>这就是<code>燃尽图</code>。非常简单又非常直观。</p>
<p>从这一幅燃尽图中，我们可以看到：在2018-12-01到2018-12-05时，我们的开发进度是领先于计划的，看起来任务应该能够提前完成，橙色曲线斜率负得越多，越陡，表示实际开发进度领先得越多。然而从2018-12-03开始，开发速度下降，到2018-12-06时进度和预期时间重合。到2018-12-07，开发进度落后于预期，任务无法如期完成。</p>
<p>我们再来看几个例子：</p>
<ul>
<li>按时完成任务：</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-34-27.png" alt="按时完成任务"></p>
<ul>
<li>提前完成任务</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-37-05.png" alt="提前完成任务"></p>
<ul>
<li>没有完成任务</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-38-53.png" alt="没有完成任务"></p>
<ul>
<li>前期落后进度，后期加速赶上</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-40-23.png" alt="前期落后进度，后期加速赶上"></p>
<h2 id="如何绘制燃尽图"><a href="#如何绘制燃尽图" class="headerlink" title="如何绘制燃尽图"></a>如何绘制燃尽图</h2><p>燃尽图是敏捷开发中的一个概念，不少敏捷开发的相关的项目管理系统中都能够生成燃尽图。由于燃尽图非常简单，使用Excel自带的画图功能，稍稍费一些功夫也能够正常生成。</p>
<p>本着使用Python提高日常办公效率的考虑，我使用macOS自带的numbers表格工具 + Python来生成燃尽图。当然你也可以使用Excel来完成。其中表格用于记录任务的剩余时间，Python用于格式化任务时间并生成燃尽图。</p>
<h3 id="表格的填写规范"><a href="#表格的填写规范" class="headerlink" title="表格的填写规范"></a>表格的填写规范</h3><p>其中表格如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-47-16.png" alt=""></p>
<p>其中，表格的第一行是任务名称，第一列是日期。表格中间填写的数字，表示任务的剩余时间。表格的填写规则如下：</p>
<ul>
<li>某一格留空，表示这一天没有做这个任务。</li>
<li>某一格为0，表示任务完成。</li>
<li>某一格为大于0的数字，表示任务剩余的时间。</li>
<li>不需要提前填写没有发生的日期。例如任务安排为2018-12-01到2018-12-07，今天是2018-12-06，那么不需要提前填写2018-12-07这一行。</li>
<li>请按照日期正序排序，不要打乱日期。</li>
</ul>
<h3 id="分析程序的使用说明"><a href="#分析程序的使用说明" class="headerlink" title="分析程序的使用说明"></a>分析程序的使用说明</h3><p>填写好表格以后，把它保存为excel的xlsx文件。假设路径为：<code>/Users/kingname/Desktop/test.xlsx</code>（或者Windows系统保存在：<code>D:\work\test.xlsx</code>）。</p>
<p>使用Anaconda中的Jupyter打开分析程序的ipynb文件，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-58-02.png" alt=""></p>
<p>只需要修改这三行数据中，单引号里面的内容，其余内容不需要修改。</p>
<p>修改完成以后，点击工具栏的<code>Kernel-Restart &amp; Run All</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-17-59-36.png" alt=""></p>
<p>静静等待2秒钟，燃尽图将会出现在页面的最下方。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-12-23-18-03-04.png" alt=""></p>
<h2 id="获取Excel模板和源代码"><a href="#获取Excel模板和源代码" class="headerlink" title="获取Excel模板和源代码"></a>获取Excel模板和源代码</h2><p>Excel与ipynb文件地址：<a href="https://github.com/kingname/Automatic/tree/master/burndown_chart" target="_blank" rel="external">https://github.com/kingname/Automatic/tree/master/burndown_chart</a></p>
<p>使用Jupyter打开ipynb文件可以看到分析程序。</p>
<h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>如果你不知道Jupyter是什么，或者你没有任何编程基础，但是想尝试一些燃尽图，那么你可以添加我的公众号联系我，我会告诉你如何使用Jupyter。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.kingname.info/2018/10/17/use-gantt-enhanced/&quot;&gt;《跳出任务管理的泥沼，拥抱甘特图的怀抱》&lt;/a&gt;一文中，我谈到了使用甘特图来规划任务。甘特图更多的关注每一个任务的进度上。那么如果我希望了解项目整体的进度，应该如何选择呢？此时就需要引入另一个简单又强大的工具：燃尽图（Burn down chart）。&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="https://www.kingname.info/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="燃尽图" scheme="https://www.kingname.info/tags/%E7%87%83%E5%B0%BD%E5%9B%BE/"/>
    
      <category term="Scrum" scheme="https://www.kingname.info/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Scrapy的中间件（三）</title>
    <link href="https://www.kingname.info/2018/11/20/know-middleware-of-scrapy-3/"/>
    <id>https://www.kingname.info/2018/11/20/know-middleware-of-scrapy-3/</id>
    <published>2018-11-20T14:46:17.000Z</published>
    <updated>2018-11-20T15:15:31.071Z</updated>
    
    <content type="html"><![CDATA[<p>在前面两篇文章介绍了下载器中间件的使用，这篇文章将会介绍爬虫中间件（Spider Middleware）的使用。</p>
<a id="more"></a>
<h2 id="爬虫中间件"><a href="#爬虫中间件" class="headerlink" title="爬虫中间件"></a>爬虫中间件</h2><p>爬虫中间件的用法与下载器中间件非常相似，只是它们的作用对象不同。下载器中间件的作用对象是请求request和返回response；爬虫中间件的作用对象是爬虫，更具体地来说，就是写在spiders文件夹下面的各个文件。它们的关系，在Scrapy的数据流图上可以很好地区分开来，如下图所示。</p>
<p> <img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-49-17.png" alt=""></p>
<p>其中，4、5表示下载器中间件，6、7表示爬虫中间件。爬虫中间件会在以下几种情况被调用。</p>
<ol>
<li>当运行到<code>yield scrapy.Request()</code>或者<code>yield item</code>的时候，爬虫中间件的<code>process_spider_output()</code>方法被调用。</li>
<li>当爬虫本身的代码出现了<code>Exception</code>的时候，爬虫中间件的<code>process_spider_exception()</code>方法被调用。</li>
<li>当爬虫里面的某一个回调函数<code>parse_xxx()</code>被调用之前，爬虫中间件的<code>process_spider_input()</code>方法被调用。</li>
<li>当运行到<code>start_requests()</code>的时候，爬虫中间件的<code>process_start_requests()</code>方法被调用。</li>
</ol>
<h3 id="在中间件处理爬虫本身的异常"><a href="#在中间件处理爬虫本身的异常" class="headerlink" title="在中间件处理爬虫本身的异常"></a>在中间件处理爬虫本身的异常</h3><p>在爬虫中间件里面可以处理爬虫本身的异常。例如编写一个爬虫，爬取UA练习页面<a href="http://exercise.kingname.info/exercise_middleware_ua" target="_blank" rel="external">http://exercise.kingname.info/exercise_middleware_ua</a> ，故意在爬虫中制造一个异常，如图12-26所示。</p>
<p> <img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-51-03.png" alt=""></p>
<p>由于网站返回的只是一段普通的字符串，并不是JSON格式的字符串，因此使用JSON去解析，就一定会导致报错。这种报错和下载器中间件里面遇到的报错不一样。下载器中间件里面的报错一般是由于外部原因引起的，和代码层面无关。而现在的这种报错是由于代码本身的问题导致的，是代码写得不够周全引起的。</p>
<p>为了解决这个问题，除了仔细检查代码、考虑各种情况外，还可以通过开发爬虫中间件来跳过或者处理这种报错。在middlewares.py中编写一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionCheckSpider</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_exception</span><span class="params">(self, response, exception, spider)</span>:</span></div><div class="line">        print(f<span class="string">'返回的内容是：&#123;response.body.decode()&#125;\n报错原因：&#123;type(exception)&#125;'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>这个类仅仅起到记录Log的作用。在使用JSON解析网站返回内容出错的时候，将网站返回的内容打印出来。</p>
<p><code>process_spider_exception()</code>这个方法，它可以返回<code>None</code>，也可以运行<code>yield item</code>语句或者像爬虫的代码一样，使用<code>yield scrapy.Request()</code>发起新的请求。如果运行了<code>yield item</code>或者<code>yield scrapy.Request()</code>，程序就会绕过爬虫里面原有的代码。</p>
<p>例如，对于有异常的请求，不需要进行重试，但是需要记录是哪一个请求出现了异常，此时就可以在爬虫中间件里面检测异常，然后生成一个只包含标记的item。还是以抓取<a href="http://exercise.kingname.info/exercise_middleware_retry.html" target="_blank" rel="external">http://exercise.kingname.info/exercise_middleware_retry.html</a>这个练习页的内容为例，但是这一次不进行重试，只记录哪一页出现了问题。先看爬虫的代码，这一次在meta中把页数带上，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-53-02.png" alt=""></p>
<p>爬虫里面如果发现了参数错误，就使用raise这个关键字人工抛出一个自定义的异常。在实际爬虫开发中，读者也可以在某些地方故意不使用try … except捕获异常，而是让异常直接抛出。例如XPath匹配处理的结果，直接读里面的值，不用先判断列表是否为空。这样如果列表为空，就会被抛出一个IndexError，于是就能让爬虫的流程进入到爬虫中间件的<code>process_spider_exception()</code>中。</p>
<p>在items.py里面创建了一个ErrorItem来记录哪一页出现了问题，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-53-45.png" alt=""></p>
<p>接下来，在爬虫中间件中将出错的页面和当前时间存放到ErrorItem里面，并提交给pipeline，保存到MongoDB中，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-54-41.png" alt=""></p>
<p>这样就实现了记录错误页数的功能，方便在后面对错误原因进行分析。由于这里会把item提交给pipeline，所以不要忘记在settings.py里面打开pipeline，并配置好MongoDB。储存错误页数到MongoDB的代码如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-55-43.png" alt=""></p>
<h3 id="激活爬虫中间件"><a href="#激活爬虫中间件" class="headerlink" title="激活爬虫中间件"></a>激活爬虫中间件</h3><p>爬虫中间件的激活方式与下载器中间件非常相似，在settings.py中，在下载器中间件配置项的上面就是爬虫中间件的配置项，它默认也是被注释了的，解除注释，并把自定义的爬虫中间件添加进去即可，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-56-15.png" alt=""></p>
<p>Scrapy也有几个自带的爬虫中间件，它们的名字和顺序如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-20-22-57-03.png" alt=""></p>
<p>下载器中间件的数字越小越接近Scrapy引擎，数字越大越接近爬虫。如果不能确定自己的自定义中间件应该靠近哪个方向，那么就在500～700之间选择最为妥当。</p>
<h3 id="爬虫中间件输入-输出"><a href="#爬虫中间件输入-输出" class="headerlink" title="爬虫中间件输入/输出"></a>爬虫中间件输入/输出</h3><p>在爬虫中间件里面还有两个不太常用的方法，分别为<code>process_spider_input(response, spider)</code>和<code>process_spider_output(response, result, spider)</code>。其中，<code>process_spider_input(response, spider)</code>在下载器中间件处理完成后，马上要进入某个回调函数parse_xxx()前调用。<code>process_spider_output(response, result, output)</code>是在爬虫运行<code>yield item</code>或者<code>yield scrapy.Request()</code>的时候调用。在这个方法处理完成以后，数据如果是item，就会被交给pipeline；如果是请求，就会被交给调度器，然后下载器中间件才会开始运行。所以在这个方法里面可以进一步对item或者请求做一些修改。这个方法的参数result就是爬虫爬出来的item或者<code>scrapy.Request()</code>。由于yield得到的是一个生成器，生成器是可以迭代的，所以result也是可以迭代的，可以使用for循环来把它展开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_spider_output</span><span class="params">(response, result, spider)</span>:</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</div><div class="line">        <span class="keyword">if</span> isinstance(item, scrapy.Item):</div><div class="line">            <span class="comment"># 这里可以对即将被提交给pipeline的item进行各种操作</span></div><div class="line">            print(f<span class="string">'item将会被提交给pipeline'</span>)</div><div class="line">        <span class="keyword">yield</span> item</div></pre></td></tr></table></figure>
<p>或者对请求进行监控和修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_spider_output</span><span class="params">(response, result, spider)</span>:</span></div><div class="line">    <span class="keyword">for</span> request <span class="keyword">in</span> result:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(request, scrapy.Item):</div><div class="line">            <span class="comment"># 这里可以对请求进行各种修改</span></div><div class="line">            print(<span class="string">'现在还可以对请求对象进行修改。。。。'</span>)</div><div class="line">        request.meta[<span class="string">'request_start_time'</span>] = time.time()</div><div class="line">        <span class="keyword">yield</span> request</div></pre></td></tr></table></figure>
<blockquote>
<p>本文节选自我的新书《Python爬虫开发  从入门到实战》完整目录可以在京东查询到 <a href="https://item.jd.com/12436581.html" target="_blank" rel="external">https://item.jd.com/12436581.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面两篇文章介绍了下载器中间件的使用，这篇文章将会介绍爬虫中间件（Spider Middleware）的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Scrapy的中间件（二）</title>
    <link href="https://www.kingname.info/2018/11/18/know-middleware-of-scrapy-2/"/>
    <id>https://www.kingname.info/2018/11/18/know-middleware-of-scrapy-2/</id>
    <published>2018-11-18T15:41:24.000Z</published>
    <updated>2018-11-18T16:11:56.205Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了下载器中间件的一些简单应用，现在再来通过案例说说如何使用下载器中间件集成Selenium、重试和处理请求异常。</p>
<a id="more"></a>
<h2 id="在中间件中集成Selenium"><a href="#在中间件中集成Selenium" class="headerlink" title="在中间件中集成Selenium"></a>在中间件中集成Selenium</h2><p>对于一些很麻烦的异步加载页面，手动寻找它的后台API代价可能太大。这种情况下可以使用Selenium和ChromeDriver或者Selenium和PhantomJS来实现渲染网页。</p>
<p>这是前面的章节已经讲到的内容。那么，如何把Scrapy与Selenium结合起来呢？这个时候又要用到中间件了。</p>
<p>创建一个SeleniumMiddleware，其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeleniumMiddleware</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.driver = webdriver.Chrome(<span class="string">'./chromedriver'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        <span class="keyword">if</span> spider.name == <span class="string">'seleniumSpider'</span>:</div><div class="line">            self.driver.get(request.url)</div><div class="line">            time.sleep(<span class="number">2</span>)</div><div class="line">            body = self.driver.page_source</div><div class="line">        <span class="keyword">return</span> HtmlResponse(self.driver.current_url,</div><div class="line">                           body=body,</div><div class="line">                           encoding=<span class="string">'utf-8'</span>,</div><div class="line">                           request=request)</div></pre></td></tr></table></figure>
<p>这个中间件的作用，就是对名为“seleniumSpider”的爬虫请求的网址，使用ChromeDriver先进行渲染，然后用返回的渲染后的HTML代码构造一个Response对象。如果是其他的爬虫，就什么都不做。在上面的代码中，等待页面渲染完成是通过time.sleep(2)来实现的，当然读者也可以使用前面章节讲到的等待某个元素出现的方法来实现。</p>
<p>有了这个中间件以后，就可以像访问普通网页那样直接处理需要异步加载的页面，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-52-26.png" alt=""></p>
<h2 id="在中间件里重试"><a href="#在中间件里重试" class="headerlink" title="在中间件里重试"></a>在中间件里重试</h2><p>在爬虫的运行过程中，可能会因为网络问题或者是网站反爬虫机制生效等原因，导致一些请求失败。在某些情况下，少量的数据丢失是无关紧要的，例如在几亿次请求里面失败了十几次，损失微乎其微，没有必要重试。但还有一些情况，每一条请求都至关重要，容不得有一次失败。此时就需要使用中间件来进行重试。</p>
<p>有的网站的反爬虫机制被触发了，它会自动将请求重定向到一个<code>xxx/404.html</code>页面。那么如果发现了这种自动的重定向，就没有必要让这一次的请求返回的内容进入数据提取的逻辑，而应该直接丢掉或者重试。</p>
<p>还有一种情况，某网站的请求参数里面有一项，Key为date，Value为发起请求的这一天的日期或者发起请求的这一天的前一天的日期。例如今天是“2017-08-10”，但是这个参数的值是今天早上10点之前，都必须使用“2017-08-09”，在10点之后才能使用“2017-08-10”，否则，网站就不会返回正确的结果，而是返回“参数错误”这4个字。然而，这个日期切换的时间点受到其他参数的影响，有可能第1个请求使用“2017-08-10”可以成功访问，而第2个请求却只有使用“2017-08-09”才能访问。遇到这种情况，与其花费大量的时间和精力去追踪时间切换点的变化规律，不如简单粗暴，直接先用今天去试，再用昨天的日期去试，反正最多两次，总有一个是正确的。</p>
<p>以上的两种场景，使用重试中间件都能轻松搞定。</p>
<p>打开练习页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/exercise_middleware_retry.html。</div></pre></td></tr></table></figure>
<p>这个页面实现了翻页逻辑，可以上一页、下一页地翻页，也可以直接跳到任意页数，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-53-12.png" alt=""></p>
<p>现在需要获取1～9页的内容，那么使用前面章节学到的内容，通过Chrome浏览器的开发者工具很容易就能发现翻页实际上是一个POST请求，提交的参数为“date”，它的值是日期“2017-08-12”，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-53-37.png" alt=""></p>
<p>使用Scrapy写一个爬虫来获取1～9页的内容，运行结果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-54-00.png" alt=""></p>
<p>从上图可以看到，第5页没有正常获取到，返回的结果是参数错误。于是在网页上看一下，发现第5页的请求中body里面的date对应的日期是“2017-08-11”，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-54-22.png" alt=""></p>
<p>如果测试的次数足够多，时间足够长，就会发现以下内容。</p>
<ol>
<li>同一个时间点，不同页数提交的参数中，date对应的日期可能是今天的也可能是昨天的。</li>
<li>同一个页数，不同时间提交的参数中，date对应的日期可能是今天的也可能是昨天的。</li>
</ol>
<p>由于日期不是今天，就是昨天，所以针对这种情况，写一个重试中间件是最简单粗暴且有效的解决办法。中间件的代码如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-54-44.png" alt=""></p>
<p>这个中间件只对名为“middlewareSpider”的爬虫有用。由于middlewareSpider爬虫默认使用的是“今天”的日期，所以如果被网站返回了“参数错误”，那么正确的日期就必然是昨天的了。所以在这个中间件里面，第119行，直接把原来请求的body换成了昨天的日期，这个请求的其他参数不变。让这个中间件生效以后，爬虫就能成功爬取第5页了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-55-01.png" alt=""></p>
<p>爬虫本身的代码，数据提取部分完全没有做任何修改，如果不看中间件代码，完全感觉不出爬虫在第5页重试过。</p>
<p>除了检查网站返回的内容外，还可以检查返回内容对应的网址。将上面练习页后台网址的第1个参数“para”改为404，暂时禁用重试中间件，再跑一次爬虫。其运行结果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-55-25.png" alt=""></p>
<p>此时，对于参数不正确的请求，网站会自动重定向到以下网址对应的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/404.html</div></pre></td></tr></table></figure>
<p>由于Scrapy自带网址自动去重机制，因此虽然第3页、第6页和第7页都被自动转到了404页面，但是爬虫只会爬一次404页面，剩下两个404页面会被自动过滤。</p>
<p>对于这种情况，在重试中间件里面判断返回的网址即可解决，如下图12-21所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-55-47.png" alt=""></p>
<p>在代码的第115行，判断是否被自动跳转到了404页面，或者是否被返回了“参数错误”。如果都不是，说明这一次请求目前看起来正常，直接把response返回，交给后面的中间件来处理。如果被重定向到了404页面，或者被返回“参数错误”，那么进入重试的逻辑。如果返回了“参数错误”，那么进入第126行，直接替换原来请求的body即可重新发起请求。</p>
<p>如果自动跳转到了404页面，那么这里有一点需要特别注意：此时的请求，request这个对象对应的是向404页面发起的GET请求，而不是原来的向练习页后台发起的请求。所以，重新构造新的请求时必须把URL、body、请求方式、Headers全部都换一遍才可以。</p>
<p>由于request对应的是向404页面发起的请求，所以resquest.url对应的网址是404页面的网址。因此，如果想知道调整之前的URL，可以使用如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">request.meta[<span class="string">'redirect_urls'</span>]</div></pre></td></tr></table></figure>
<p>这个值对应的是一个列表。请求自动跳转了几次，这个列表里面就有几个URL。这些URL是按照跳转的先后次序依次append进列表的。由于本例中只跳转了一次，所以直接读取下标为0的元素即可，也就是原始网址。</p>
<p>重新激活这个重试中间件，不改变爬虫数据抓取部分的代码，直接运行以后可以正确得到1～9页的全部内容，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-56-15.png" alt=""></p>
<h2 id="在中间件里处理异常"><a href="#在中间件里处理异常" class="headerlink" title="在中间件里处理异常"></a>在中间件里处理异常</h2><p>在默认情况下，一次请求失败了，Scrapy会立刻原地重试，再失败再重试，如此3次。如果3次都失败了，就放弃这个请求。这种重试逻辑存在一些缺陷。以代理IP为例，代理存在不稳定性，特别是免费的代理，差不多10个里面只有3个能用。而现在市面上有一些收费代理IP提供商，购买他们的服务以后，会直接提供一个固定的网址。把这个网址设为Scrapy的代理，就能实现每分钟自动以不同的IP访问网站。如果其中一个IP出现了故障，那么需要等一分钟以后才会更换新的IP。在这种场景下，Scrapy自带的重试逻辑就会导致3次重试都失败。</p>
<p>这种场景下，如果能立刻更换代理就立刻更换；如果不能立刻更换代理，比较好的处理方法是延迟重试。而使用Scrapy_redis就能实现这一点。爬虫的请求来自于Redis，请求失败以后的URL又放回Redis的末尾。一旦一个请求原地重试3次还是失败，那么就把它放到Redis的末尾，这样Scrapy需要把Redis列表前面的请求都消费以后才会重试之前的失败请求。这就为更换IP带来了足够的时间。</p>
<p>重新打开代理中间件，这一次故意设置一个有问题的代理，于是可以看到Scrapy控制台打印出了报错信息，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-56-34.png" alt=""></p>
<p>从上图可以看到Scrapy自动重试的过程。由于代理有问题，最后会抛出方框框住的异常，表示TCP超时。在中间件里面如果捕获到了这个异常，就可以提前更换代理，或者进行重试。这里以更换代理为例。首先根据上图中方框框住的内容导入TCPTimeOutError这个异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> twisted.internet.error <span class="keyword">import</span> TCPTimedOutError</div></pre></td></tr></table></figure>
<p>修改前面开发的重试中间件，添加一个process_exception()方法。这个方法接收3个参数，分别为request、exception和spider，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-56-58.png" alt=""></p>
<p>process_exception()方法只对名为“exceptionSpider”的爬虫生效，如果请求遇到了TCPTimeOutError，那么就首先调用remove_broken_proxy()方法把失效的这个代理IP移除，然后返回这个请求对象request。返回以后，Scrapy会重新调度这个请求，就像它第一次调度一样。由于原来的ProxyMiddleware依然在工作，于是它就会再一次给这个请求更换代理IP。又由于刚才已经移除了失效的代理IP，所以ProxyMiddleware会从剩下的代理IP里面随机找一个来给这个请求换上。</p>
<p>特别提醒：图片中的remove_broken_proxy()函数体里面写的是pass，但是在实际开发过程中，读者可根据实际情况实现这个方法，写出移除失效代理的具体逻辑。</p>
<h2 id="下载器中间件功能总结"><a href="#下载器中间件功能总结" class="headerlink" title="下载器中间件功能总结"></a>下载器中间件功能总结</h2><p>能在中间件中实现的功能，都能通过直接把代码写到爬虫中实现。使用中间件的好处在于，它可以把数据爬取和其他操作分开。在爬虫的代码里面专心写数据爬取的代码；在中间件里面专心写突破反爬虫、登录、重试和渲染AJAX等操作。</p>
<p>对团队来说，这种写法能实现多人同时开发，提高开发效率；对个人来说，写爬虫的时候不用考虑反爬虫、登录、验证码和异步加载等操作。另外，写中间件的时候不用考虑数据怎样提取。一段时间只做一件事，思路更清晰。</p>
<blockquote>
<p>本文节选自我的新书《Python爬虫开发  从入门到实战》完整目录可以在京东查询到 <a href="https://item.jd.com/12436581.html" target="_blank" rel="external">https://item.jd.com/12436581.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了下载器中间件的一些简单应用，现在再来通过案例说说如何使用下载器中间件集成Selenium、重试和处理请求异常。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Scrapy的中间件（一）</title>
    <link href="https://www.kingname.info/2018/11/18/know-middleware-of-scrapy/"/>
    <id>https://www.kingname.info/2018/11/18/know-middleware-of-scrapy/</id>
    <published>2018-11-18T14:21:35.000Z</published>
    <updated>2018-11-18T15:18:55.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中间件（Middleware）"><a href="#中间件（Middleware）" class="headerlink" title="中间件（Middleware）"></a>中间件（Middleware）</h2><p>中间件是Scrapy里面的一个核心概念。使用中间件可以在爬虫的请求发起之前或者请求返回之后对数据进行定制化修改，从而开发出适应不同情况的爬虫。</p>
<p>“中间件”这个中文名字和前面章节讲到的“中间人”只有一字之差。它们做的事情确实也非常相似。中间件和中间人都能在中途劫持数据，做一些修改再把数据传递出去。不同点在于，中间件是开发者主动加进去的组件，而中间人是被动的，一般是恶意地加进去的环节。中间件主要用来辅助开发，而中间人却多被用来进行数据的窃取、伪造甚至攻击。</p>
<p>在Scrapy中有两种中间件：下载器中间件（Downloader Middleware）和爬虫中间件（Spider Middleware）。</p>
<p>这一篇主要讲解下载器中间件的第一部分。</p>
<a id="more"></a>
<h2 id="下载器中间件"><a href="#下载器中间件" class="headerlink" title="下载器中间件"></a>下载器中间件</h2><p>Scrapy的官方文档中，对下载器中间件的解释如下。</p>
<blockquote>
<p>下载器中间件是介于Scrapy的request/response处理的钩子框架，是用于全局修改Scrapy request和response的一个轻量、底层的系统。</p>
</blockquote>
<p>这个介绍看起来非常绕口，但其实用容易理解的话表述就是：更换代理IP，更换Cookies，更换User-Agent，自动重试。</p>
<p>如果完全没有中间件，爬虫的流程如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-04-14.png" alt=""></p>
<p>使用了中间件以后，爬虫的流程如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-04-44.png" alt=""></p>
<h3 id="开发代理中间件"><a href="#开发代理中间件" class="headerlink" title="开发代理中间件"></a>开发代理中间件</h3><p>在爬虫开发中，更换代理IP是非常常见的情况，有时候每一次访问都需要随机选择一个代理IP来进行。</p>
<p>中间件本身是一个Python的类，只要爬虫每次访问网站之前都先“经过”这个类，它就能给请求换新的代理IP，这样就能实现动态改变代理。</p>
<p>在创建一个Scrapy工程以后，工程文件夹下会有一个middlewares.py文件，打开以后其内容如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-05-13.png" alt=""></p>
<p>Scrapy自动生成的这个文件名称为middlewares.py，名字后面的s表示复数，说明这个文件里面可以放很多个中间件。Scrapy自动创建的这个中间件是一个爬虫中间件，这种类型在第三篇文章会讲解。现在先来创建一个自动更换代理IP的中间件。</p>
<p>在middlewares.py中添加下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddleware</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        proxy = random.choice(settings[<span class="string">'PROXIES'</span>])</div><div class="line">        request.meta[<span class="string">'proxy'</span>] = proxy</div></pre></td></tr></table></figure>
<p>要修改请求的代理，就需要在请求的meta里面添加一个Key为proxy，Value为代理IP的项。</p>
<p>由于用到了random和settings，所以需要在middlewares.py开头导入它们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> scrapy.conf <span class="keyword">import</span> settings</div></pre></td></tr></table></figure>
<p>在下载器中间件里面有一个名为<code>process_request()</code>的方法，这个方法中的代码会在每次爬虫访问网页之前执行。</p>
<p>打开settings.py，首先添加几个代理IP：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PROXIES = [<span class="string">'https://114.217.243.25:8118'</span>,</div><div class="line">          <span class="string">'https://125.37.175.233:8118'</span>,</div><div class="line">          <span class="string">'http://1.85.116.218:8118'</span>]</div></pre></td></tr></table></figure>
<p>需要注意的是，代理IP是有类型的，需要先看清楚是HTTP型的代理IP还是HTTPS型的代理IP。如果用错了，就会导致无法访问。</p>
<h3 id="激活中间件"><a href="#激活中间件" class="headerlink" title="激活中间件"></a>激活中间件</h3><p>中间件写好以后，需要去settings.py中启动。在settings.py中找到下面这一段被注释的语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Enable or disable downloader middlewares</span></div><div class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html</span></div><div class="line"><span class="comment">#DOWNLOADER_MIDDLEWARES = &#123;</span></div><div class="line"><span class="comment">#    'AdvanceSpider.middlewares.MyCustomDownloaderMiddleware': 543,</span></div><div class="line"><span class="comment">#&#125;</span></div></pre></td></tr></table></figure>
<p>解除注释并修改，从而引用ProxyMiddleware。修改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DOWNLOADER_MIDDLEWARES = &#123;</div><div class="line">  <span class="string">'AdvanceSpider.middlewares.ProxyMiddleware'</span>: <span class="number">543</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其实就是一个字典，字典的Key就是用点分隔的中间件路径，后面的数字表示这种中间件的顺序。由于中间件是按顺序运行的，因此如果遇到后一个中间件依赖前一个中间件的情况，中间件的顺序就至关重要。</p>
<p>如何确定后面的数字应该怎么写呢？最简单的办法就是从543开始，逐渐加一，这样一般不会出现什么大问题。如果想把中间件做得更专业一点，那就需要知道Scrapy自带中间件的顺序，如图下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-05-42.png" alt=""></p>
<p>数字越小的中间件越先执行，例如Scrapy自带的第1个中间件<code>RobotsTxtMiddleware</code>，它的作用是首先查看settings.py中<code>ROBOTSTXT_OBEY</code>这一项的配置是<code>True</code>还是<code>False</code>。如果是<code>True</code>，表示要遵守Robots.txt协议，它就会检查将要访问的网址能不能被运行访问，如果不被允许访问，那么直接就取消这一次请求，接下来的和这次请求有关的各种操作全部都不需要继续了。</p>
<p>开发者自定义的中间件，会被按顺序插入到Scrapy自带的中间件中。爬虫会按照从100～900的顺序依次运行所有的中间件。直到所有中间件全部运行完成，或者遇到某一个中间件而取消了这次请求。</p>
<p>Scrapy其实自带了UA中间件（UserAgentMiddleware）、代理中间件（HttpProxyMiddleware）和重试中间件（RetryMiddleware）。所以，从“原则上”说，要自己开发这3个中间件，需要先禁用Scrapy里面自带的这3个中间件。要禁用Scrapy的中间件，需要在settings.py里面将这个中间件的顺序设为None：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DOWNLOADER_MIDDLEWARES = &#123;</div><div class="line">  <span class="string">'AdvanceSpider.middlewares.ProxyMiddleware'</span>: <span class="number">543</span>,</div><div class="line">  <span class="string">'scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware'</span>: <span class="keyword">None</span>,</div><div class="line">  <span class="string">'scrapy.contrib.downloadermiddleware.httpproxy.HttpProxyMiddleware'</span>: <span class="keyword">None</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么说“原则上”应该禁用呢？先查看Scrapy自带的代理中间件的源代码，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-06-06.png" alt=""></p>
<p>从上图可以看出，如果Scrapy发现这个请求已经被设置了代理，那么这个中间件就会什么也不做，直接返回。因此虽然Scrapy自带的这个代理中间件顺序为750，比开发者自定义的代理中间件的顺序543大，但是它并不会覆盖开发者自己定义的代理信息，所以即使不禁用系统自带的这个代理中间件也没有关系。</p>
<p>完整地激活自定义中间件的settings.py的部分内容如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-06-31.png" alt=""></p>
<p>配置好以后运行爬虫，爬虫会在每次请求前都随机设置一个代理。要测试代理中间件的运行效果，可以使用下面这个练习页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/exercise_middleware_ip</div></pre></td></tr></table></figure>
<p>这个页面会返回爬虫的IP地址，直接在网页上打开，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-06-48.png" alt=""></p>
<p>这个练习页支持翻页功能，在网址后面加上“/页数”即可翻页。例如第100页的网址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/exercise_middleware_ip/100</div></pre></td></tr></table></figure>
<p>使用了代理中间件为每次请求更换代理的运行结果，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-07-06.png" alt=""></p>
<p>代理中间件的可用代理列表不一定非要写在settings.py里面，也可以将它们写到数据库或者Redis中。一个可行的自动更换代理的爬虫系统，应该有如下的3个功能。</p>
<ol>
<li>有一个小爬虫ProxySpider去各大代理网站爬取免费代理并验证，将可以使用的代理IP保存到数据库中。</li>
<li>在ProxyMiddlerware的process_request中，每次从数据库里面随机选择一条代理IP地址使用。</li>
<li>周期性验证数据库中的无效代理，及时将其删除。<br>由于免费代理极其容易失效，因此如果有一定开发预算的话，建议购买专业代理机构的代理服务，高速而稳定。</li>
</ol>
<h3 id="开发UA中间件"><a href="#开发UA中间件" class="headerlink" title="开发UA中间件"></a>开发UA中间件</h3><p>开发UA中间件和开发代理中间件几乎一样，它也是从settings.py配置好的UA列表中随机选择一项，加入到请求头中。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UAMiddleware</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        ua = random.choice(settings[<span class="string">'USER_AGENT_LIST'</span>])</div><div class="line">        request.headers[<span class="string">'User-Agent'</span>] = ua</div></pre></td></tr></table></figure>
<p>比IP更好的是，UA不会存在失效的问题，所以只要收集几十个UA，就可以一直使用。常见的UA如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">USER_AGENT_LIST = [</div><div class="line"><span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36"</span>,</div><div class="line">  <span class="string">"Dalvik/1.6.0 (Linux; U; Android 4.2.1; 2013022 MIUI/JHACNBL30.0)"</span>,</div><div class="line">  <span class="string">"Mozilla/5.0 (Linux; U; Android 4.4.2; zh-cn; HUAWEI MT7-TL00 Build/HuaweiMT7-TL00) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1"</span>,</div><div class="line">  <span class="string">"AndroidDownloadManager"</span>,</div><div class="line">  <span class="string">"Apache-HttpClient/UNAVAILABLE (java 1.4)"</span>,</div><div class="line">  <span class="string">"Dalvik/1.6.0 (Linux; U; Android 4.3; SM-N7508V Build/JLS36C)"</span>,</div><div class="line">  <span class="string">"Android50-AndroidPhone-8000-76-0-Statistics-wifi"</span>,</div><div class="line">  <span class="string">"Dalvik/1.6.0 (Linux; U; Android 4.4.4; MI 3 MIUI/V7.2.1.0.KXCCNDA)"</span>,</div><div class="line">  <span class="string">"Dalvik/1.6.0 (Linux; U; Android 4.4.2; Lenovo A3800-d Build/LenovoA3800-d)"</span>,</div><div class="line">  <span class="string">"Lite 1.0 ( http://litesuits.com )"</span>,</div><div class="line">  <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727)"</span>,</div><div class="line">  <span class="string">"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0"</span>,</div><div class="line">  <span class="string">"Mozilla/5.0 (Linux; U; Android 4.1.1; zh-cn; HTC T528t Build/JRO03H) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30; 360browser(securitypay,securityinstalled); 360(android,uppayplugin); 360 Aphone Browser (2.0.4)"</span>,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>配置好UA以后，在settings.py下载器中间件里面激活它，并使用UA练习页来验证UA是否每一次都不一样。练习页的地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/exercise_middleware_ua。</div></pre></td></tr></table></figure>
<p>UA练习页和代理练习页一样，也是可以无限制翻页的。</p>
<p>运行结果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-07-41.png" alt=""></p>
<h3 id="开发Cookies中间件"><a href="#开发Cookies中间件" class="headerlink" title="开发Cookies中间件"></a>开发Cookies中间件</h3><p>对于需要登录的网站，可以使用Cookies来保持登录状态。那么如果单独写一个小程序，用Selenium持续不断地用不同的账号登录网站，就可以得到很多不同的Cookies。由于Cookies本质上就是一段文本，所以可以把这段文本放在Redis里面。这样一来，当Scrapy爬虫请求网页时，可以从Redis中读取Cookies并给爬虫换上。这样爬虫就可以一直保持登录状态。</p>
<p>以下面这个练习页面为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://exercise.kingname.info/exercise_login_success</div></pre></td></tr></table></figure>
<p>如果直接用Scrapy访问，得到的是登录界面的源代码，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-08-14.png" alt=""></p>
<p>现在，使用中间件，可以实现完全不改动这个loginSpider.py里面的代码，就打印出登录以后才显示的内容。</p>
<p>首先开发一个小程序，通过Selenium登录这个页面，并将网站返回的Headers保存到Redis中。这个小程序的代码如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-08-34.png" alt=""></p>
<p>这段代码的作用是使用Selenium和ChromeDriver填写用户名和密码，实现登录练习页面，然后将登录以后的Cookies转换为JSON格式的字符串并保存到Redis中。</p>
<p>接下来，再写一个中间件，用来从Redis中读取Cookies，并把这个Cookies给Scrapy使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginMiddleware</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.client = redis.StrictRedis()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        <span class="keyword">if</span> spider.name == <span class="string">'loginSpider'</span>:</div><div class="line">            cookies = json.loads(self.client.lpop(<span class="string">'cookies'</span>).decode())</div><div class="line">            request.cookies = cookies</div></pre></td></tr></table></figure>
<p>设置了这个中间件以后，爬虫里面的代码不需要做任何修改就可以成功得到登录以后才能看到的HTML，如图12-12所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-11-18-23-08-55.png" alt=""></p>
<p>如果有某网站的100个账号，那么单独写一个程序，持续不断地用Selenium和ChromeDriver或者Selenium 和PhantomJS登录，获取Cookies，并将Cookies存放到Redis中。爬虫每次访问都从Redis中读取一个新的Cookies来进行爬取，就大大降低了被网站发现或者封锁的可能性。</p>
<p>这种方式不仅适用于登录，也适用于验证码的处理。</p>
<p>这一篇就讲到这里，在下一篇，我们将会介绍如何在下载器中间件中集成Selenium，进行请求重试和处理异常。</p>
<blockquote>
<p>本文节选自我的新书《Python爬虫开发  从入门到实战》完整目录可以在京东查询到 <a href="https://item.jd.com/12436581.html" target="_blank" rel="external">https://item.jd.com/12436581.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;中间件（Middleware）&quot;&gt;&lt;a href=&quot;#中间件（Middleware）&quot; class=&quot;headerlink&quot; title=&quot;中间件（Middleware）&quot;&gt;&lt;/a&gt;中间件（Middleware）&lt;/h2&gt;&lt;p&gt;中间件是Scrapy里面的一个核心概念。使用中间件可以在爬虫的请求发起之前或者请求返回之后对数据进行定制化修改，从而开发出适应不同情况的爬虫。&lt;/p&gt;
&lt;p&gt;“中间件”这个中文名字和前面章节讲到的“中间人”只有一字之差。它们做的事情确实也非常相似。中间件和中间人都能在中途劫持数据，做一些修改再把数据传递出去。不同点在于，中间件是开发者主动加进去的组件，而中间人是被动的，一般是恶意地加进去的环节。中间件主要用来辅助开发，而中间人却多被用来进行数据的窃取、伪造甚至攻击。&lt;/p&gt;
&lt;p&gt;在Scrapy中有两种中间件：下载器中间件（Downloader Middleware）和爬虫中间件（Spider Middleware）。&lt;/p&gt;
&lt;p&gt;这一篇主要讲解下载器中间件的第一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>跳出任务管理的泥沼，拥抱甘特图的怀抱（完整版）</title>
    <link href="https://www.kingname.info/2018/10/17/use-gantt-enhanced/"/>
    <id>https://www.kingname.info/2018/10/17/use-gantt-enhanced/</id>
    <published>2018-10-17T12:36:39.000Z</published>
    <updated>2018-10-21T01:47:16.966Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/photo-1523958399470-c15bf82fcea9.jpeg" alt=""></p>
<p>写这篇文章，我不是要黑任何一个任务管理类的App或者方法论。相反，我是一个工具控，在试用各种任务管理类App上总是不遗余力。常见的Things 3，Todoist，Teambition，Trello，Any.do，Doit.im我都试用过。最后，我选择了<a href="https://todoist.com" target="_blank" rel="external">Todoist</a>，在Todoist上，我已经完成了1292个任务。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-09-24-22-26-08.png" alt="我的Todoist任务记录"></p>
<a id="more"></a>
<h2 id="任务管理类App有什么问题"><a href="#任务管理类App有什么问题" class="headerlink" title="任务管理类App有什么问题"></a>任务管理类App有什么问题</h2><p>Things3，Todoist为首的任务管理App，核心功能就是记录<strong>未完成</strong>的任务，勾掉<strong>已完成</strong>的任务。至于分类，标签，自然语言识别之类的功能算是锦上添花。</p>
<p>他们有一个缺点，那就是你只知道一个任务没有做，或者已经做完了。但是你不知道在一群没有完成的任务中，哪些是正在做的。（当然，你可以创建一个分类，叫做“正在做”，然后把正在做的任务放进这个分类中。）</p>
<p>而Teambition与Trello稍微进步一点，引入了看板的概念，于是能够显示任务在各个阶段的状态，如下图所示。这张图是少数派的Trello看板，用来让作者选题。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-10-26-51.png" alt=""></p>
<p>在看板中，你可以知道哪些任务是计划中，哪些任务是准备做，哪些是正在做，哪些是已经完成。然而这样就够了吗？</p>
<p>看板比单纯的To do list类应用进了一步，能够关注任务的状态了。但它们的局限也在于此，因为他们关注的，只是每一个任务。</p>
<p>做一个比喻，修汽车需要拧螺丝，组装宜家的家具也需要拧螺丝。你如果只关注拧螺丝这个动作，那么修汽车和组装家具对你来说没有区别。组装宜家的家具，看一下说明书，一般人半个小时就搞定，但是你半个小时能学会修汽车吗？</p>
<p>如果只使用任务管理类的工具，你就会陷入一个怪圈：你做了很多任务，但是你不知道你做这些任务是为了什么。任务管理类App适合用来记录和追踪各种琐碎的任务和相关性不强的任务。就像是少数派的每一篇文章，文章与文章之间不是一个系列的关系，他们各自独立，谁都可以领选题写文章，哪个选题先写哪个选题后写，关系不大。</p>
<p>一旦要规划一个项目，对于规划项目的人和做项目的人，用任务管理类App都会让人觉得使不上劲。对于做任务的人，看到每一个独立的任务，对项目没有整体的概念；对于规划项目的人，不知道任务是不是已经切分得足够细，是否有遗漏。</p>
<p>假设你把一个项目拆分成了100个子任务，两周以后，你做完了其中的八十个子任务，请问你真的完成了这个项目80%的工作吗？项目的完成度能够单纯用子任务的数量来衡量吗？</p>
<p>如果你回答，项目的完成度，不能单纯用子任务的数量来衡量。那么继续思考下一个问题，是不是有一些子任务，就是比别的任务重要呢？</p>
<p>如果你回答，确实有一些子任务比别的任务都重要。那么继续思考下一个问题，是不是最重要的子任务必需优先完成呢？</p>
<p>如果你回答，确实最重要的子任务必需优先完成。那么继续思考下一个问题，最重要的子任务要优先多少呢？能单纯把最重要的子任务作为第一个完成的任务吗？它有前置任务吗？如果必需先把前置任务做完，才能做这个最重要的子任务，那么，是不是其实这个前置任务才是最重要的子任务呢？如此说来，能够单纯用时间先后顺序来标明任务的重要性吗？先做的总是比后做的重要吗？那如果这个先做的任务，它做完以后完全看不到产出，必需等后面的任务做完了才能看到效果，那么到底是先做的任务重要还是后做的任务重要？</p>
<p>上面还只是一个人做多个任务的情况，现在如果把一个项目拆分成100个任务，分给ABCDE5个人做同时做。每个人都有一些任务可以单独完成不依赖其他人。但是也有一些任务A依赖B的成果，B依赖C的成果，D可以帮B做一些工作，还有一些工作需要C和D要一起同时完成，还有一些工作，B和C可以先做一部分，剩下的一部分再一起完成……</p>
<p>好了，现在给你一个任务管理类的App，上面列了100个任务，其中有20个任务优先级最高，50个优先级一般，30个优先级低。你们五个人自己看着选任务做吧。两周以后项目上线。</p>
<p>13天后：</p>
<p>B：C你的后台接口怎么还没有写好，我等着跟你联合调试都等了三天了！<br>D：糟糕，有一个任务忘记做了，现在这个代码不能运行，等我把那边的服务搭建好才能测试。<br>A：嘿嘿我完成了30个任务，奖金我拿定了。<br>C：D你早应该搭建服务的，你忘了我也要用吗！<br>……</p>
<p>所以，单纯用优先级来排任务，你觉得靠谱吗？你不加班，谁来加班？</p>
<h2 id="寻找解决办法"><a href="#寻找解决办法" class="headerlink" title="寻找解决办法"></a>寻找解决办法</h2><h3 id="使用脑图拆分任务"><a href="#使用脑图拆分任务" class="headerlink" title="使用脑图拆分任务"></a>使用脑图拆分任务</h3><p>有项目经验的人，看到我上面举得例子，肯定会不屑一顾——难道在规划项目的时候就拿一张白纸，拍着脑袋想，这个项目需要做哪些工作，想到一个写一个？这样凭脑袋空想肯定会漏掉任务的。</p>
<p>用脑图来规划任务是一个不错的主意，首先把项目拆分成几个主要的组成模块。然后首先看第一个模块，又把它拆分成几个子模块。然后看第一个模块的第一个子模块，又拆分……第一个模块拆分好了，再来看第二个模块，把它又拆分成几个子模块……通过这样深度优先的方式把所有任务都拆分到可以完成的程度。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/x3_project.png" alt="使用脑图拆分项目任务"></p>
<p>脑图解决了任务拆分的问题，使用脑图来拆分任务，理论上确实不容易漏掉任务。那么问题是，脑图如何确定任务的依赖关系？如何确定每个任务的完成时间？项目进行了若干天以后，如何知道当前项目进度怎么样了？在某一天，如何让所有人都一眼就知道，哪些任务没有按时完成，哪些任务已经提前完成了？</p>
<h3 id="使用时间轴确定进度"><a href="#使用时间轴确定进度" class="headerlink" title="使用时间轴确定进度"></a>使用时间轴确定进度</h3><p>现在回到任务管理的App中。如果把所有待完成的任务全部都用一个Excel写在第一列，然后在右侧用不同的色块标记任务从开始到结束的时间。那么可以得到下面这一张图。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/timeline.png" alt="使用Excel画一个时间轴"></p>
<p>其中，不同的颜色表示不同的人。每一行表示一个任务。从第二列开始，每一列表示一天。如果一个任务一天可以做完，就涂一个格子，如果需要三天才能做完，就涂三个格子。</p>
<p>这样一来，通过这些色块，就可以清楚地看到每个人需要做多少事情。例如B列，紫色这个人一天同时要做5个任务。但是这5个任务中有4个任务都是联系别的部门让他们提供接口。那么这四个任务应该可以很容易做完，于是可以放在一天完成。</p>
<p>又比如，红色这个人，他做的任务很困难，所以两个任务各要做三天。</p>
<p>又比如，绿色这个人，他先搭建ES系统。然后再搭建Kafka。任务的先后顺序也就有了。</p>
<p>如果在某一天，想知道按计划今天哪些人需要做哪些事，那么直接看这一天对应的这一列就可以了。</p>
<h3 id="压缩，组合"><a href="#压缩，组合" class="headerlink" title="压缩，组合"></a>压缩，组合</h3><p>用时间轴来表示任务的进度，可以更加直观地让人看到任务的进度。但前提是先把所有子任务确定好。也就是要先做一个脑图，然后根据脑图再做这个Excel。看任务的时候，要同时看两张图。</p>
<p>那有没有办法把这两张图合在一起呢？</p>
<p>实际上，脑图本质上就是一个层次结构，层次结构也可以写成大纲的形式，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/outline.png" alt="脑图的大纲形式"></p>
<p>这个结构就可以放到Excel中了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/outlinewithtimeline.png" alt="简化版的甘特图"></p>
<p>到目前为止，你已经实现了一个简化版的甘特图了。</p>
<h2 id="什么是甘特图"><a href="#什么是甘特图" class="headerlink" title="什么是甘特图"></a>什么是甘特图</h2><p>甘特图是一张二维的图表，它的横轴是时间，纵轴是任务。从甘特图上可以一目了然看到一个任务从什么时候开始什么时候结束，不同任务之间是否有时间重叠，以及哪些任务可以同时做哪些任务必需有先后顺序。</p>
<p>我个人认为，在项目管理中，任务周期是非常重要的，任务的开始时间和结束时间一定要把控好。使用甘特图就可以实现这样一个目的。</p>
<p>对于规划任务的人，在用甘特图规划任务的时候，如果你发现一个任务时间太长，无论怎么调整都会和后面的任务有重叠，那么你就会发现这个任务可能需要拆分为更小的任务。而且由于甘特图立足于项目的整体，你也可以更容易发现是否有任务漏掉了。</p>
<p>对于做任务的人，甘特图也可以帮他们了解到他们所做的任务在整个项目中处于一个什么样的位置，从而让他们知道自己正在做的任务是不是非常重要必需按时完成。</p>
<p>如果你是要开发一个App，或者是要写一本书，或者是要做一个其他什么项目，只要它是由一系列不同的任务构成的，那么你就可以考虑使用甘特图来帮你提高效率。</p>
<p>下面这张图就是甘特图。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/gantt.png" alt=""></p>
<ul>
<li>不同的颜色表示不同的人</li>
<li>每一行表示一个任务</li>
<li>红色竖线表示今天应该完成的任务</li>
<li>任务与任务之间的黑色箭头表示任务之间的依赖关系，必需完成前面的才能完成后面的</li>
<li>带中心黑线的任务表示已经完成的任务</li>
</ul>
<p>通过这一张甘特图，我能一眼看出以下信息：</p>
<ol>
<li>今天谁应该做什么任务</li>
<li>这个任务从什么时候开始，到什么时候结束</li>
<li>一个人在一段时间有哪些任务</li>
<li>应该先做哪些任务再做哪些任务</li>
<li>哪些任务可以同时做</li>
<li>这个任务是否被其他任务依赖，如果是，那么这个任务就不能推迟，必需按时完成或者提前完成，否则会影响后面的任务</li>
<li>每个任务已经完成多少还剩多少</li>
<li>大任务下面有哪些子任务</li>
<li>任务的里程碑是什么时候</li>
</ol>
<h2 id="为什么要用甘特图"><a href="#为什么要用甘特图" class="headerlink" title="为什么要用甘特图"></a>为什么要用甘特图</h2><p>因为为了绘制出甘特图，你必需强迫自己完成以下几件事情：</p>
<ol>
<li>确定每一个任务的开始时间和结束时间</li>
<li>确定任务的依赖关系</li>
<li>分离可以同时运行的任务</li>
<li>确定不同人的任务间的时间关系</li>
</ol>
<p>当你根据以上的规则绘制好第一版甘特图以后，你会发现有些地方是可以继续调整的，但是这种调整，在你没有画图之前是不能发现的。于是你会在调整甘特图的过程中，让项目的规划越来越清晰。</p>
<h2 id="怎么做甘特图"><a href="#怎么做甘特图" class="headerlink" title="怎么做甘特图"></a>怎么做甘特图</h2><p>甘特图是一种项目管理工具，你可以在纸上画甘特图，也可以在Excel中画甘特图，也可以使用专门的甘特图软件来做甘特图。下面这张基于Excel的甘特图来自网络。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-20-03.png" alt=""></p>
<p>这是使用Excel做出来的效果，但是做起来稍显麻烦。</p>
<p>Omniplan和MS Project都是非常专业的甘特图制作软件，但是价格非常高。毕竟这是生产力软件，使用这个软件你是可以赚大钱的，自然软件本身就会比较贵。</p>
<p>开源的甘特图软件也有不少，不过不是功能不全就是界面丑陋。这里介绍一个相对比较完整的开源甘特图制作软件：GanttProject</p>
<p>GanttProject的官方网站为<a href="http://www.ganttproject.biz/" target="_blank" rel="external">http://www.ganttproject.biz/</a>，在这里你可以下载到macOS，Windows或者Linux版本的软件。</p>
<p>GanttProject运行以后的界面如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-47-11.png" alt=""></p>
<p>在左侧任务面板右键或者按下键盘<code>Command</code> + <code>T</code>就可以添加任务，Windows和Linux对应的快捷键为<code>Ctrl</code> + <code>T</code>。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-48-11.png" alt=""></p>
<p>创建好了一个任务，它默认的开始时间和结束时间都是今天。在任务上面右键，选择<code>任务属性</code>，可以打开任务属性设置界面，在这里可以设置任务的开始时间和任务时长。但是你不能设置任务结束时间。因为任务结束时间会根据开始时间和任务时长自动计算。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-03-16.png" alt=""></p>
<p>在这个界面，还可以设置任务的颜色，实现不同人不同颜色，或者不同项目不同颜色。也可以在这里更新任务进度。</p>
<p>创建多个任务，如果后面的任务依赖前面的任务，那么在右侧被依赖的任务色条上单击鼠标左键，按住并拖动到依赖它的任务上。依赖它的任务的起始时间自动就会变为被依赖任务的结束时间，如下图所示。此时，后一个任务只能设置任务的时长，不能修改任务的起始时间。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-08-17.png" alt=""></p>
<p>如果依赖关系设置错误，打开依赖任务的任务属性，定位到<code>前置任务</code>选项卡，在这里可以删除被依赖的任务或者修改被依赖任务。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-11-10.png" alt=""></p>
<p>如果你需要移动任务的顺序，鼠标单击选中它，按下键盘上的<code>Alt</code> + <code>方向键上或下</code>即可移动任务。</p>
<p>我认为甘特图有一个非常重要的元素，就是竖直红线，它指向了今天的任务。要打开这跟红线，需要单击菜单栏的<code>编辑</code>-<code>设置</code>，定位到<code>甘特图设定</code>，在<code>将今天显示为红色</code>点选为<code>是</code>，如下图所示。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-20-55.png" alt=""><br>单击确定回到甘特图的界面，可以看到图中出现了一条红色竖线。这条竖线指向了今天应该做的事情。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-23-06.png" alt=""></p>
<p>每天打开甘特图，这根红线都会指向当天。</p>
<p>GanttProject可以把做好的甘特图导出为图片，CSV，HTML或者PDF文件。单击<code>项目</code>-<code>导出</code>，点选<code>Raster图像文件</code>，并单击<code>下一步</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-24-34.png" alt=""></p>
<p>设置保存路径和甘特图的日期范围即可导出为PNG文件，以方便分享。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我非常喜欢使用甘特图来规划我的工作。我的第一本书<br>《Python爬虫开发 从入门到实战》已经在<a href="https://item.jd.com/12436581.html" target="_blank" rel="external">京东</a>、<a href="http://product.dangdang.com/25349717.html" target="_blank" rel="external">当当</a>、<a href="https://www.amazon.cn/dp/B07HGBRXFW" target="_blank" rel="external">亚马逊</a>在亚马逊上线。这本书的写作过程就是我用甘特图的最好实践。因为有了甘特图，我才能控制好写作过程中的每一个重要的时间节点，确保每一章都能够按时交付，让我能够兼顾工作，写书和自我成长。</p>
<p>甘特图并不是为了取代任务管理工具而存在的。甘特图的目的是为了规划项目，并且让你在项目的进行过程中知道自己处于什么位置。</p>
<p>你需要时刻记得，低头看任务管理工具，让你知道自己正在做什么。抬头看甘特图，让你知道你将能够做成什么。</p>
<p>我创建了一个微信群，用来交流各种效率工具和提高生产力的方法。有兴趣的同学可以进来和大家一起探讨。扫码关注公众号 <code>未闻Code</code>（或搜索ID：itskingname）回复：<code>生产力</code>即可获得入群方式。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/photo-1523958399470-c15bf82fcea9.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;写这篇文章，我不是要黑任何一个任务管理类的App或者方法论。相反，我是一个工具控，在试用各种任务管理类App上总是不遗余力。常见的Things 3，Todoist，Teambition，Trello，Any.do，Doit.im我都试用过。最后，我选择了&lt;a href=&quot;https://todoist.com&quot;&gt;Todoist&lt;/a&gt;，在Todoist上，我已经完成了1292个任务。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-09-24-22-26-08.png&quot; alt=&quot;我的Todoist任务记录&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="项目管理" scheme="https://www.kingname.info/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="时间管理" scheme="https://www.kingname.info/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="GTD" scheme="https://www.kingname.info/tags/GTD/"/>
    
      <category term="项目管理" scheme="https://www.kingname.info/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>英文文档帮查&amp;翻译计划</title>
    <link href="https://www.kingname.info/2018/10/15/translate-help/"/>
    <id>https://www.kingname.info/2018/10/15/translate-help/</id>
    <published>2018-10-15T14:15:08.000Z</published>
    <updated>2018-10-16T00:10:21.175Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/photo-1512153472310-d72327c26cf0.jpeg" alt=""></p>
<p>以CSDN为首，知乎其次，cnblog带路的一大批博客上充斥着大量低质量的编程入门教程，代码粗制滥造，毫无缩进，没有高亮，东抄西抄。初学者如果长期参照这种垃圾博客来解决问题，将会适得其反，走入歧途。</p>
<p>其实，初学者最应该看的，是编程软件的<code>官方文档</code>，是软件工具的<code>官方文档</code>，是开源项目的<code>官方文档</code>……</p>
<p>但是鉴于有一些文档没有中文翻译，让不少不会英文的同学望而却步。</p>
<p>为此，我将会启动英文文档代查、翻译计划。</p>
<p>如果你想学习一门编程语言，但是它没有官方中文文档；如果你想实现一个功能，但是官方教程对API的描述是英文；如果你想用一个软件，但是这个软件没有中文说明书；如果你想参与一个开源项目，但是看不懂上面的英文讨论……那么你可以在这个公众号上获得帮助。</p>
<h2 id="如何寻求帮助​"><a href="#如何寻求帮助​" class="headerlink" title="如何寻求帮助​"></a>如何寻求帮助​</h2><p>扫描本文末尾的微信公众号二维码添加<code>未闻Code</code>，公众号私聊中，把你的诉求发送给我。我帮你寻找官方文档，帮你翻译，然后用公众号文章的形式发布出来，让更多人看到。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#文档翻译#我想知道Scrapy的下载器中间件中，process_response可以返回哪些数据。</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_1635.PNG" alt=""></p>
<h2 id="我接收哪些请求"><a href="#我接收哪些请求" class="headerlink" title="我接收哪些请求"></a>我接收哪些请求</h2><ul>
<li>StackOverflow上面具体某一个问题的回答。您可以把网址发送给我</li>
<li>编程语言具体功能</li>
<li>开源项目具体某个API的使用</li>
<li>Medium中具体某一篇文章的某一段落</li>
</ul>
<p>总之，你的需求越具体，我就越能找到你需要的内容并为你翻译。</p>
<p>当然，你也可以尝试给我发送一些非技术性的内容，例如《经济学人》《华盛顿邮报》中的具体<code>某个段落</code>，如果我有时间的话，也会帮你翻译。</p>
<h2 id="我拒接哪些请求"><a href="#我拒接哪些请求" class="headerlink" title="我拒接哪些请求"></a>我拒接哪些请求</h2><ul>
<li>请帮我翻译Python官方文档</li>
<li>请帮我翻译这一篇Quora下面的所有回答</li>
<li>请帮我翻译这个开源项目的官方文档</li>
</ul>
<h2 id="我怎么给你结果"><a href="#我怎么给你结果" class="headerlink" title="我怎么给你结果"></a>我怎么给你结果</h2><p>我会汇总每一周的请求，并在周六更新的公众号文章中，为你呈现你需要的结果。</p>
<h2 id="这个项目收费吗"><a href="#这个项目收费吗" class="headerlink" title="这个项目收费吗"></a>这个项目收费吗</h2><p>本计划完全免费。不会以任何形式收取任何费用。不收费不代表没有成本，因此请勿滥用。</p>
<h2 id="我为什么要启动这个项目"><a href="#我为什么要启动这个项目" class="headerlink" title="我为什么要启动这个项目"></a>我为什么要启动这个项目</h2><ol>
<li>我看不惯那些装逼货粗制滥造的博客。</li>
<li>我深深体会到阅读官方文档的重要性，因此我希望我能让更多的人能在遇到问题时首先想到官方文档而不是用百度搜索中文博客。</li>
<li>你们问的东西可能也是我不知道的，通过这个项目我可以学到更多好用的工具</li>
<li>把我的英语单词量扩展到10000词以上。</li>
</ol>
<h2 id="如何找到我"><a href="#如何找到我" class="headerlink" title="如何找到我"></a>如何找到我</h2><p>请扫描下面的二维码，添加我的微信公众号<code>未闻Code</code>。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/photo-1512153472310-d72327c26cf0.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以CSDN为首，知乎其次，cnbl
    
    </summary>
    
      <category term="学习" scheme="https://www.kingname.info/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="翻译" scheme="https://www.kingname.info/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="开源" scheme="https://www.kingname.info/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker Swarm搭建分布式爬虫集群</title>
    <link href="https://www.kingname.info/2018/10/13/use-docker-swarm/"/>
    <id>https://www.kingname.info/2018/10/13/use-docker-swarm/</id>
    <published>2018-10-13T13:23:51.000Z</published>
    <updated>2018-10-14T09:05:09.791Z</updated>
    
    <content type="html"><![CDATA[<p>在爬虫开发过程中，你肯定遇到过需要把爬虫部署在多个服务器上面的情况。此时你是怎么操作的呢？逐一SSH登录每个服务器，使用git拉下代码，然后运行？代码修改了，于是又要一个服务器一个服务器登录上去依次更新？</p>
<p>有时候爬虫只需要在一个服务器上面运行，有时候需要在200个服务器上面运行。你是怎么快速切换的呢？一个服务器一个服务器登录上去开关？或者聪明一点，在Redis里面设置一个可以修改的标记，只有标记对应的服务器上面的爬虫运行？</p>
<p>A爬虫已经在所有服务器上面部署了，现在又做了一个B爬虫，你是不是又得依次登录每个服务器再一次部署？</p>
<p>如果你确实是这么做的，那么你应该后悔没有早一点看到这篇文章。看完本文以后，你能够做到：</p>
<ul>
<li>2分钟内把一个新爬虫部署到50台服务器上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker build -t localhost:8003/spider:0.01 .</div><div class="line">docker push localhost:8002/spider:0.01</div><div class="line">docker service create --name spider --replicas 50 --network host 45.77.138.242:8003/spider:0.01</div></pre></td></tr></table></figure>
<ul>
<li>30秒内把爬虫从50台服务器扩展到500台服务器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=500</div></pre></td></tr></table></figure>
<ul>
<li>30秒内批量关闭所有服务器上的爬虫：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=0</div></pre></td></tr></table></figure>
<ul>
<li>1分钟内批量更新所有机器上的爬虫：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker build -t localhost:8003/spider:0.02 .</div><div class="line">docker push localhost:8003/spider:0.02</div><div class="line">docker service update --image 45.77.138.242:8003/spider:0.02 spider</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>这篇文章不会教你怎么使用Docker，所以请确定你有一些Docker基础再来看本文。</p>
<h2 id="Docker-Swarm是什么"><a href="#Docker-Swarm是什么" class="headerlink" title="Docker Swarm是什么"></a>Docker Swarm是什么</h2><p>Docker Swarm是Docker自带的一个集群管理模块。他能够实现Docker集群的创建和管理。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本文将会使用3台Ubuntu 18.04的服务器来进行演示。这三台服务器安排如下：</p>
<ul>
<li>Master：45.77.138.242</li>
<li>Slave-1：199.247.30.74</li>
<li>Slave-2：95.179.143.21</li>
</ul>
<p>Docker Swarm是基于Docker的模块，所以首先要在3台服务器上安装Docker。安装完成Docker以后，所有的操作都在Docker中完成。</p>
<h3 id="在Master上安装Docker"><a href="#在Master上安装Docker" class="headerlink" title="在Master上安装Docker"></a>在Master上安装Docker</h3><p>通过依次执行下面的命令，在Master服务器上安装Docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install -y apt-transport-https ca-certificates curl software-properties-common</div><div class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</div><div class="line">add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</div><div class="line">apt-get update</div><div class="line">apt-get install -y docker-ce</div></pre></td></tr></table></figure>
<h3 id="创建Manager节点"><a href="#创建Manager节点" class="headerlink" title="创建Manager节点"></a>创建Manager节点</h3><p>一个Docker Swarm集群需要Manager节点。现在初始化Master服务器，作为集群的Manager节点。运行下面一条命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker swarm init</div></pre></td></tr></table></figure>
<p>运行完成以后，可以看到的返回结果下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_2.png" alt=""></p>
<p>这个返回结果中，给出了一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker swarm join --token SWMTKN-1-0hqsajb64iynkg8ocp8uruktii5esuo4qiaxmqw2pddnkls9av-dfj7nf1x3vr5qcj4cqiusu4pv 45.77.138.242:2377</div></pre></td></tr></table></figure>
<p>这条命令需要在每一个从节点（Slave）中执行。现在先把这个命令记录下来。</p>
<p>初始化完成以后，得到一个只有1台服务器的Docker 集群。执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker node ls</div></pre></td></tr></table></figure>
<p>可以看到当前这个集群的状态，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_3.png" alt=""></p>
<h3 id="创建私有源（可选）"><a href="#创建私有源（可选）" class="headerlink" title="创建私有源（可选）"></a>创建私有源（可选）</h3><p>创建私有源并不是一个必需的操作。之所以需要私有源，是因为项目的Docker镜像可能会涉及到公司机密，不能上传到DockerHub这种公共平台。如果你的镜像可以公开上传DockerHub，或者你已经有一个可以用的私有镜像源，那么你可以直接使用它们，跳过本小节和下一小节。</p>
<p>私有源本身也是一个Docker的镜像，先将拉取下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull registry:latest</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_4.png" alt=""></p>
<p>现在启动私有源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8003:5000 --name registry -v /tmp/registry:/tmp/registry docker.io/registry:latest</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_5.png" alt=""></p>
<p>在启动命令中，设置了对外开放的端口为8003端口，所以私有源的地址为：45.77.138.242:8003</p>
<blockquote>
<p>提示:<br>这样搭建的私有源是HTTP方式，并且没有权限验证机制，所以如果对公网开放，你需要再使用防火墙做一下IP白名单，从而保证数据的安全。</p>
</blockquote>
<h3 id="允许docker使用可信任的http私有源（可选）"><a href="#允许docker使用可信任的http私有源（可选）" class="headerlink" title="允许docker使用可信任的http私有源（可选）"></a>允许docker使用可信任的http私有源（可选）</h3><p>如果你使用上面一个小节的命令搭建了自己的私有源，由于Docker默认是不允许使用HTTP方式的私有源的，因此你需要配置Docker，让Docker信任它。</p>
<p>使用下面命令配置Docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;&#123; &quot;insecure-registries&quot;:[&quot;45.77.138.242:8003&quot;] &#125;&apos; &gt;&gt; /etc/docker/daemon.json</div></pre></td></tr></table></figure>
<p>然后使用下面这个命令重启docker。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart docker</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_6.png" alt=""></p>
<p>重启完成以后，Manager节点就配置好了。</p>
<h2 id="创建子节点初始化脚本"><a href="#创建子节点初始化脚本" class="headerlink" title="创建子节点初始化脚本"></a>创建子节点初始化脚本</h2><p>对于Slave服务器来说，只需要做三件事情：</p>
<ol>
<li>安装Docker</li>
<li>加入集群</li>
<li>信任源</li>
</ol>
<p>从此以后，剩下的事情全部交给Docker Swarm自己管理，你再也不用SSH登录这个服务器了。</p>
<p>为了简化操作，可以写一个shell脚本来批量运行。在Slave-1和Slave-2服务器下创建一个<code>init.sh</code>文件，其内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install -y apt-transport-https ca-certificates curl software-properties-common</div><div class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</div><div class="line">add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</div><div class="line">apt-get update</div><div class="line">apt-get install -y docker-ce</div><div class="line">echo &apos;&#123; &quot;insecure-registries&quot;:[&quot;45.77.138.242:8003&quot;] &#125;&apos; &gt;&gt; /etc/docker/daemon.json</div><div class="line">systemctl restart docker </div><div class="line">docker swarm join --token SWMTKN-1-0hqsajb64iynkg8ocp8uruktii5esuo4qiaxmqw2pddnkls9av-dfj7nf1x3vr5qcj4cqiusu4pv 45.77.138.242:2377</div></pre></td></tr></table></figure>
<p>把这个文件设置为可自行文件，并运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x init.sh</div><div class="line">./init.sh</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_7.png" alt=""></p>
<p>等待脚本运行完成以后，你就可以从Slave-1和Slave-2的SSH上面登出了。以后也不需要再进来了。</p>
<p>回到Master服务器，执行下面的命令，来确认现在集群已经有3个节点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker node ls</div></pre></td></tr></table></figure>
<p>看到现在集群中已经有3个节点了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_9.png" alt=""></p>
<p>到止为止，最复杂最麻烦的过程已经结束了。剩下的就是体验Docker Swarm带来的便利了。</p>
<h2 id="创建测试程序"><a href="#创建测试程序" class="headerlink" title="创建测试程序"></a>创建测试程序</h2><h3 id="搭建测试Redis"><a href="#搭建测试Redis" class="headerlink" title="搭建测试Redis"></a>搭建测试Redis</h3><p>由于这里需要模拟一个分布式爬虫的运行效果，所以先使用Docker搭建一个临时的Redis服务：</p>
<p>在Master服务器上执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --name redis -p 7891:6379 redis --requirepass &quot;KingnameISHandSome8877&quot;</div></pre></td></tr></table></figure>
<p>这个Redis对外使用<code>7891</code>端口，密码为<code>KingnameISHandSome8877</code>，IP就是Master服务器的IP地址。</p>
<h3 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h3><p>编写一个简单的Python程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line"></div><div class="line">client = redis.Redis(host=<span class="string">'45.77.138.242'</span>, port=<span class="string">'7891'</span>, password=<span class="string">'KingnameISHandSome8877'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data = client.lpop(<span class="string">'example:swarm:spider'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(f<span class="string">'我现在获取的数据为：&#123;data.decode()&#125;'</span>)</div><div class="line">    time.sleep(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>这个Python每10秒钟从Redis中读取一个数，并打印出来。</p>
<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>编写Dockerfile，基于Python3.6的镜像创建我们自己的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from python:3.6</div><div class="line">label mantainer=&apos;contact@kingname.info&apos;</div><div class="line"></div><div class="line">user root</div><div class="line">ENV PYTHONUNBUFFERED=0</div><div class="line">ENV PYTHONIOENCODING=utf-8</div><div class="line"></div><div class="line">run python3 -m pip install redis</div><div class="line"></div><div class="line">copy spider.py spider.py</div><div class="line">cmd python3 spider.py</div></pre></td></tr></table></figure>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>编写完成Dockerfile以后，执行下面的命令，开始构建我们自己的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t localhost:8003/spider:0.01 .</div></pre></td></tr></table></figure>
<p>这里需要特别注意，由于我们要把这个镜像上传到私有源供Slave服务器上面的从节点下载，所以镜像的命名方式需要满足<code>localhost:8003/自定义名字:版本号</code>这样的格式。其中的<code>自定义名字</code>和<code>版本号</code>可以根据实际情况进行修改。在本文的例子中，我由于要模拟一个爬虫的程序，所以给它取名为spider，由于是第1次构建，所以版本号用的是0.01。</p>
<p>整个过程如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_10.png" alt=""></p>
<h3 id="上传镜像到私有源"><a href="#上传镜像到私有源" class="headerlink" title="上传镜像到私有源"></a>上传镜像到私有源</h3><p>镜像构建完成以后，需要把它上传到私有源。此时需要执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push localhost:8003/spider:0.01</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_11.png" alt=""></p>
<p>大家记住这个构建和上传的命令，以后每一次更新代码，都需要使用这两条命令。</p>
<h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><p>Docker Swarm上面运行的是一个一个的服务，因此需要使用docker service命令创建服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service create --name spider --network host 45.77.138.242:8003/spider:0.01</div></pre></td></tr></table></figure>
<p>这个命令创建了一个名为<code>spider</code>的服务。默认运行1个容器。运行情况如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_12.png" alt=""></p>
<p>当然也可以一创建就用很多容器来运行，此时只需要添加一个<code>--replicas</code>参数即可。例如一创建服务就使用50个容器运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service create --name spider --replicas 50 --network host 45.77.138.242:8003/spider:0.01</div></pre></td></tr></table></figure>
<p>但是一般一开始的代码可能会有不少bug，所以建议先使用1个容器来运行，观察日志，发现没有问题以后再进行扩展。</p>
<p>回到默认1个容器的情况下，这个容器可能在目前三台机器在的任何一台上面。通过执行下面的命令来观察这一个默认的容器运行情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service ps spider</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_13.png" alt=""></p>
<h2 id="查看节点Log"><a href="#查看节点Log" class="headerlink" title="查看节点Log"></a>查看节点Log</h2><p>根据上图执行结果，可以看到这个运行中的容器的ID为<code>rusps0ofwids</code>，那么执行下面的命令动态查看Log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service logs -f 容器ID</div></pre></td></tr></table></figure>
<p>此时就会持续跟踪这一个容器的Log。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_14.png" alt=""></p>
<h2 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h2><p>现在，只有1台服务器运行了一个容器，我想使用3台服务器运行这个爬虫，那么我需要执行一条命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=3</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_15.png" alt=""></p>
<p>此时，再一次查看爬虫的运行情况，可以发现三台机器上面会各自运行一个容器。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_16.png" alt=""></p>
<p>现在，我们登录slave-1机器上，看看是不是真的有一个任务在运行。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_17.png" alt=""></p>
<p>可以看到确实有一个容器在上面运行着。这是Docker Swarm自动分配过来的。</p>
<p>现在我们使用下面的命令强行把slave-1上面的Docker给关了，再来看看效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl stop docker</div></pre></td></tr></table></figure>
<p>回到master服务器，再次查看爬虫的运行效果，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_18.png" alt=""></p>
<p>可以看到，Docker Swarm探测到Slave-1掉线以后，他就会自动重新找个机器启动任务，保证始终有3个任务在运行。在这一次的例子中，Docker Swarm自动在master机器上启动了2个spider容器。</p>
<p>如果机器性能比较好，甚至可以在3每台机器上面多运行几个容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=10</div></pre></td></tr></table></figure>
<p>此时，就会启动10个容器来运行这些爬虫。这10个爬虫之间互相隔离。</p>
<p>如果想让所有爬虫全部停止怎么办？非常简单，一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=0</div></pre></td></tr></table></figure>
<p>这样所有爬虫就会全部停止。</p>
<h2 id="同时查看多个容器的日志"><a href="#同时查看多个容器的日志" class="headerlink" title="同时查看多个容器的日志"></a>同时查看多个容器的日志</h2><p>如果想同时看所有容器怎么办呢？可以使用如下命令查看所有容器的最新的20行日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service ps robot | grep Running | awk &apos;&#123;print $1&#125;&apos; | xargs -i docker service logs --tail 20 &#123;&#125;</div></pre></td></tr></table></figure>
<p>这样，日志就会按顺序显示出来了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_19.png" alt=""></p>
<h2 id="更新爬虫"><a href="#更新爬虫" class="headerlink" title="更新爬虫"></a>更新爬虫</h2><p>如果你的代码做了修改。那么你需要更新爬虫。</p>
<p>先修改代码，重新构建，重新提交新的镜像到私有源中。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_20.png" alt=""></p>
<p>接下来需要更新服务中的镜像。更新镜像有两种做法。一种是先把所有爬虫关闭，再更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker service scale spider=0</div><div class="line">docker service update --image 45.77.138.242:8003/spider:0.02 spider</div><div class="line">docker service scale spider=3</div></pre></td></tr></table></figure>
<p>第二种是直接执行更新命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service update --image 45.77.138.242:8003/spider:0.02 spider</div></pre></td></tr></table></figure>
<p>他们的区别在于，直接执行更新命令时，正在运行的容器会一个一个更新。</p>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/docker_swarm_21.png" alt=""></p>
<h2 id="你可以用Docker-Swarm做更多事情"><a href="#你可以用Docker-Swarm做更多事情" class="headerlink" title="你可以用Docker Swarm做更多事情"></a>你可以用Docker Swarm做更多事情</h2><p>本文使用的是一个模拟爬虫的例子，但是显然，任何可以批量运行的程序都能够用Docker Swarm来运行，无论你用Redis还是Celery来通信，无论你是否需要通信，只要能批量运行，就能用Docker Swarm。</p>
<p>在同一个Swarm集群里面，可以运行多个不同的服务，各个服务之间互不影响。真正做到了搭建一次Docker Swarm集群，然后就再也不用管了，以后的所有操作你都只需要在Manager节点所在的这个服务器上面运行。</p>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>本文是多种部署分布式爬虫方法中的一种，其他方法，可以参阅我的新书《Python爬虫开发 从入门到实战》。现已在京东、当当、亚马逊上架。</p>
<ul>
<li>京东：<a href="https://item.jd.com/12436581.html" target="_blank" rel="external">https://item.jd.com/12436581.html</a></li>
<li>当当：<a href="http://product.m.dangdang.com/25349717.html" target="_blank" rel="external">http://product.m.dangdang.com/25349717.html</a></li>
<li>亚马逊：<a href="https://www.amazon.cn/dp/B07HGBRXFW" target="_blank" rel="external">https://www.amazon.cn/dp/B07HGBRXFW</a></li>
</ul>
<p>本书读者交流群也已经开通，扫码添加公众号，回复：读者交流 即可获得加群方式。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在爬虫开发过程中，你肯定遇到过需要把爬虫部署在多个服务器上面的情况。此时你是怎么操作的呢？逐一SSH登录每个服务器，使用git拉下代码，然后运行？代码修改了，于是又要一个服务器一个服务器登录上去依次更新？&lt;/p&gt;
&lt;p&gt;有时候爬虫只需要在一个服务器上面运行，有时候需要在200个服务器上面运行。你是怎么快速切换的呢？一个服务器一个服务器登录上去开关？或者聪明一点，在Redis里面设置一个可以修改的标记，只有标记对应的服务器上面的爬虫运行？&lt;/p&gt;
&lt;p&gt;A爬虫已经在所有服务器上面部署了，现在又做了一个B爬虫，你是不是又得依次登录每个服务器再一次部署？&lt;/p&gt;
&lt;p&gt;如果你确实是这么做的，那么你应该后悔没有早一点看到这篇文章。看完本文以后，你能够做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2分钟内把一个新爬虫部署到50台服务器上：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker build -t localhost:8003/spider:0.01 .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker push localhost:8002/spider:0.01&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker service create --name spider --replicas 50 --network host 45.77.138.242:8003/spider:0.01&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;30秒内把爬虫从50台服务器扩展到500台服务器：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker service scale spider=500&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;30秒内批量关闭所有服务器上的爬虫：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker service scale spider=0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;1分钟内批量更新所有机器上的爬虫：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker build -t localhost:8003/spider:0.02 .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker push localhost:8003/spider:0.02&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker service update --image 45.77.138.242:8003/spider:0.02 spider&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.kingname.info/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.kingname.info/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://www.kingname.info/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>如果你不知道做什么，那就学一门杂学吧</title>
    <link href="https://www.kingname.info/2018/10/01/my-new-book/"/>
    <id>https://www.kingname.info/2018/10/01/my-new-book/</id>
    <published>2018-10-01T10:31:11.000Z</published>
    <updated>2018-10-30T16:24:19.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这篇文章没有代码，请放心阅读。</p>
<p>多年以后，面对人工智能研究员那混乱不堪的代码，我会想起第一次和S君相见的那个遥远的下午。那时的B公司，还是一个仅有6个人的小团队，Mac和显示器在桌上依次排开，大家坐在一起，不需要称呼姓名，转过脸去，对方就知道你在和他说话。一切看起来都那么美好，我们所有人，都希望自己和这个公司能够一起成长。</p>
<p>彼时S君刚从加拿大回来，老板把他介绍给我们，于是S君作为数据产品经理跟我有了项目上的接触。</p>
<p>创业公司里面，每一个人都需要会很多的技艺，于是S君开始自学Python。</p>
<p>有一天，S君问我：“你玩MineCraft吗？“</p>
<p>“玩，但我更喜欢在B站上看别人的世界。”我答道。</p>
<p>“我觉得我现在写程序，像是在玩我的世界。”S君笑着说道。</p>
<p>“是不是觉得你已经掌握了Python的基本语法，看着别人把Python用的溜溜转，而你自己却不知道用它来做什么？”</p>
<p>“是这样的，你懂我。”</p>
<p>“那你学一门杂学吧。”</p>
<p>于是S君被我诱拐过来跟我一起写爬虫。</p>
<p>后来，S君离开了B公司。</p>
<p>三个月后，我也离开了。</p>
<p>从此，我们再也没有见过。</p>
<a id="more"></a>
<h2 id="编程最重要的能力是变通"><a href="#编程最重要的能力是变通" class="headerlink" title="编程最重要的能力是变通"></a>编程最重要的能力是变通</h2><p>S君是一个老实孩子。</p>
<p>在开发一个爬虫的过程中，网站接口返回给他的数据看起来是JSON格式，于是他就用Python自带的JSON库去解析。结果解析失败了。因为这些所谓的看起来像JSON的东西，竟然没有双引号。</p>
<p>难道是JSON的超集？S君一通搜索，发现用YMAL库也许可以解析这种数据。于是安装YMAL库，一解析又报错。</p>
<p>难道这些数据直接就是Python的字典？于是S君用上了邪恶的eval。又报错，因为里面有null和小写的true。</p>
<p>“你为什么不试一试直接用正则表达式呢？”我对S君说。</p>
<p>“靠！”S君一拍桌子，旁边的老板吓得把搪瓷杯子里面的快乐水洒在了白衬衣上。</p>
<p>然后S君用正则表达式花了10秒钟结束了战斗。</p>
<h2 id="写爬虫与三峡大坝"><a href="#写爬虫与三峡大坝" class="headerlink" title="写爬虫与三峡大坝"></a>写爬虫与三峡大坝</h2><p>有一天，S君兴冲冲地跑来跟我说：“我体会到三峡大坝的伟大功能了！”</p>
<p>“你是爬虫工程师还是水利工程师？”</p>
<p>“你知道吗，不管上游的水势多么凶猛，从大坝出来以后总是安全而稳定。”S君并没有回答我的问题，而是自顾自地说道。</p>
<p>“原来你开始用Kafka。不错，孺子可教。”</p>
<p>S君吐了一下舌头：“还是师傅教导有方。”</p>
<p>前不久，S君的爬虫刚刚达到了日产数据千万条的目标。然而他只高兴了一天。因为他发现，数据写到数据库以后，读起来很麻烦。</p>
<p>S君有多个数据分析的系统需要从数据库里面读取爬虫爬好的数据，但是从每天千万量级的数据中寻找特定的数据是一个很慢的过程。如果程序遇到异常导致崩溃，又得从头开始读。</p>
<p>S君问我：“现在我每一个数据分析的脚本都要从数据库里面读一次数据，做了太多重复的工作，单机单节点的数据库快要撑不住了。我是不是要去学习分库分表搭建集群啊？”</p>
<p>我告诉S君：“这个后面你自然是需要去做的。但现在，你可以先试一试Kafka，我已经搭建好了一个Kafka的集群了，你这样使用……”。</p>
<p>后来，S君让所有爬虫把爬到的数据到直接送进了Kafka，然后再从Kafka里面读数据出来，一个Group用来备份原始数据，一份Group用来生成中间表，一份Group用来监控报警，一份Group用来绘制DashBoard。无论爬虫塞给Kafka的数据有多少，有多快，从Kafka读数据的地方都能按照自己的节奏来消费和使用。</p>
<h2 id="既然收集了数据就要让它发光发热"><a href="#既然收集了数据就要让它发光发热" class="headerlink" title="既然收集了数据就要让它发光发热"></a>既然收集了数据就要让它发光发热</h2><p>S君在加拿大留学时学的专业是金融数学和统计。所以他对数据分析也很有兴趣。在他爬虫收集的数据够用以后，我跟他讲了如何使用Pandas来分析数据。</p>
<p>S君把他分析的酒店价格变化数据给分享给了我们。不愧是金融+数学+统计学背景的高级知识分子 + 超级强大的Pandas + 超级好用的Jupyter。这份数据不仅完美再现了过去一年的价格走势，还预测了未来的任何变化，多达四十六张图表似乎穷尽了所有的组合。</p>
<h2 id="草木竹石皆可破敌"><a href="#草木竹石皆可破敌" class="headerlink" title="草木竹石皆可破敌"></a>草木竹石皆可破敌</h2><p>S君曾经遇到过一个特别简单的电商网站。页面几乎像素级抄袭淘宝，但是完全没有任何反爬虫的机制。以S君的水平，从审查元素，到开发完成，仅仅用了半个小时。爬虫安全平稳又顺利地运行了三个星期。</p>
<p>然后，有一天早上，爬虫死掉了。</p>
<p>S君用尽毕生所学，无法再从这个网站上爬到任何有价值的信息。这个网站似乎请来了一个机器行为对抗的大神级人物。人用浏览器一点问题都没有，但S君的任何隐藏爬虫的手段都被轻易识破。</p>
<p>S君找到我：“师傅，这个网站我搞不定。”</p>
<p>“你能搞定。动动脑子。”</p>
<p>“我会的所有技术都用上了，完全看不出破解他反爬虫机制的方法。”S君已经失去了信心。</p>
<p>“那就，不要用技术去对抗。用你的脑子。”</p>
<p>S君抱着显示器用头一遍一遍的撞。</p>
<p>我问S君：“你有没有思考一个问题，这个网站模仿了淘宝的皮，却又毫无反爬虫机制。你觉得他的老板是一个什么样的人？你听过那个段子吗？”</p>
<p>S君突然一跃而起：“我给你一万元，你帮我做一个网站吧。你想要什么样的网站？很简单，就淘宝那样的。你是说这个段子吗？”</p>
<p>“对。”</p>
<p>S君突然之间荣光焕发：“有办法了！”</p>
<p>只见S君重新在浏览器打开了这个网站，找到了客户服务热线。电话一拨通他就开始一通污言秽语骂起来：“……你们网站到底在搞什么？为什么今天一会能登录一会不能登录？找你们老板来！我来教他怎么做网站！……”</p>
<p>半小时以后，网站反爬虫机制全部解除。</p>
<p>此刻，S君面向西面双手合十，自言自语：“兄弟，对不起了，只有让你来背这个锅了。”</p>
<h2 id="你小学上课传过纸条吗"><a href="#你小学上课传过纸条吗" class="headerlink" title="你小学上课传过纸条吗"></a>你小学上课传过纸条吗</h2><p>“我现在能体会那些半路拦截纸条的人是什么心态了。”这是S君第一次使用Charles时对我说的话。</p>
<p>从此以后，我很少看到S君分析网页了。因为他学会了在爬虫开发的过程中，首先通过中间人攻击技术分析微信小程序和手机App。这种方式往往能够直接获得数据，拿到数据以后就能直接储存，再也不用写烦人的XPath或者长的跟表情符号一样的正则表达式了。</p>
<p>有一天，我在玩一个网页版的黑客解密游戏，在网页上寻找某个地方隐藏起来的密码，然后输入每一关的回答框中，答对才能进入下一关。</p>
<p>游戏有12关，而我卡在了第6关。只见S君拿着电脑走到我面前，指着第12关的通关页面跟我炫耀。</p>
<p>“你是不是用MITMProxy替换了这个网站的Js文件？”</p>
<p>“果然还是瞒不过师傅你啊。”</p>
<p>“你拦截了别人的纸条，做了修改，然后又叠好继续传下去，你有考虑过发纸条的人和收纸条的人的感受吗？”</p>
<p>“我小学时候不传纸条，都是妹子直接约我的。”</p>
<h2 id="加密？不存在的"><a href="#加密？不存在的" class="headerlink" title="加密？不存在的"></a>加密？不存在的</h2><p>“前端没有秘密”。S君在成功逆向了一个网站的Js文件以后如是对我说。</p>
<p>“那是因为这个网站的Js代码就赤裸裸地放在你面前，完全没有混淆。”我对S君说道。</p>
<p>“不怕，我可以用Node.js来运行混淆过的代码。我已经搭建好Node.js服务了，只要把Js代码传进去，他就会把结果给我返回回来。”S君对此似乎一脸自行。</p>
<p>“你什么时候学会的Node.js？”</p>
<p>“这不是师傅你说过技多不压身吗？既然做爬虫需要动JavaScript，那我顺手就把Node.js给学了。”S君毫不畏惧的表情，似乎证明他已经猜透了我要问什么。</p>
<p>“那如果目标没有网站，只有App呢？”</p>
<p>“不怕，Android 逆向工程我也顺便研究了一点。Java我也看得懂。”</p>
<p>“看来这些已经不需要我再教你了。”</p>
<h2 id="我一根指头就能捏死你，但我不想伤害你"><a href="#我一根指头就能捏死你，但我不想伤害你" class="headerlink" title="我一根指头就能捏死你，但我不想伤害你"></a>我一根指头就能捏死你，但我不想伤害你</h2><p>S君有一天问我：“假设你现在在小学课堂上，前面的同学让你把纸条传给后面的女生，你会怎么做？”</p>
<p>我说：“查看复制/修改删除/拦截丢弃”。</p>
<p>S君嘿嘿一笑：“比如说，前后三次的纸条分别为‘听说你奶奶生病了，我们周末一起去看望她吧‘，’今晚我爸妈不在，去我家玩吗？’， ‘我刚拿到这个月压岁钱，老师一下课我们就去吃好吃的。’”</p>
<p>我说：“女孩漂亮的话，我改一下第二张纸条，改成‘今晚我爸妈不在，我们一起去青南家玩吗？’”。</p>
<p>S君露出了嫌弃的眼神：“师傅，你可是说过你最讨厌技术含量低的事情啊，你涂改了纸条，别人不会发现？你笔迹都不一样啊！”。</p>
<p>我问S君：“那你有何高见？”</p>
<p>S君抬头仰望这窗外的天空：“如果是我，那么我会临摹第一张纸条上面的<code>生病了</code> <code>去看望</code> <code>她</code> <code>我</code>，第二张纸条上面的<code>爸妈</code>，第三张纸条上面的<code>拿</code> <code>钱</code> <code>老师</code>这些字的笔迹。然后改换一下顺序就变成了：<code>爸妈，我老师生病了，我拿钱去看望她</code>。最后我把这张伪造的纸条拿去找写纸条的那个同学他爸妈要钱。”</p>
<p>“我猜，你想用中间人攻击截取别人的Cookies，然后用这些Cookies偷偷登录网站，进行你的不可告人的目的。”</p>
<p>S君笑道：“哈哈哈，我想想都害怕。但是每当我想到，我拥有一种可怕的力量，而我还能控制住这种力量。我就知道我和街上的普通人不一样了。”</p>
<h2 id="你肯定薅了直播答题的羊毛吧"><a href="#你肯定薅了直播答题的羊毛吧" class="headerlink" title="你肯定薅了直播答题的羊毛吧"></a>你肯定薅了直播答题的羊毛吧</h2><p>去年年底的直播答题着实火了一把。那个时候，我和S君分开已经有一段时间了。我相信，在全民答题的每一个夜晚，S君的电脑上一定连着不少于六台安卓手机。这些手机运行着不同的答题平台，能够自动读取屏幕上的问题并自动选择答案。</p>
<p>我把安卓自动化测试技术教给S君，本来是让他结合爬虫，实现群控从而抓取一些难以处理的数据，但我相信他肯定会用来答题。</p>
<p>变通，这一点他学的越来越好了。</p>
<p>只希望他不要成为羊毛党。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来，我再也没有见过S君这样有趣的人。所以我把我教给S君的东西，写成了一本书：《Python爬虫开发 从入门到实战》，现在已在京东，当当与亚马逊上架。希望你也能变成S君一样有趣而又厉害的人。</p>
<ul>
<li>京东：<a href="https://item.jd.com/12436581.html" target="_blank" rel="external">https://item.jd.com/12436581.html</a></li>
<li>当当：<a href="http://product.m.         dangdang.com/25349717.html" target="_blank" rel="external">http://product.m.dangdang.com/25349717.html</a></li>
<li>亚马逊：<a href="https://www.amazon.cn/dp/       B07HGBRXFW" target="_blank" rel="external">https://www.amazon.cn/dp/B07HGBRXFW</a></li>
</ul>
<p>爬虫是一门杂学。因为在一个完整的开发过程中，需要涉及到的知识可以包括但不限于：Python，HTML，JavaScript，正则表达式，XPath，数据库，Redis，消息队列，Docker，ELK，Hadoop，数据分析，ETL，中间人攻击，自动化测试技术，可视化……</p>
<p>这其中的任何一项，在一个大公司里面都可以让很多人来做。</p>
<p>爬虫开发，就像这篇文章里面反复出现的一个词：变通——只要能够获得数据，任何技术都可以使用。所谓草木竹石皆可为剑。爬虫不应该是一个枯燥的一成不变的模式化的工作。而是一个充满了创意和挑战，能够让旁观者大呼“我X还能这样搞”的工作。</p>
<p>爬虫开发，绝对不仅仅是Scrapy，PySpider，requests这些框架或者库的使用。所以在这本书里面，我也刻意减少了框架使用说明的部分，而把重点放在了各种突破反爬虫机制或者使用变通的方法绕过反爬虫机制的方法论和实践中。</p>
<p>通过学习爬虫，你最后不一定选择爬虫工程师这个岗位，但是在学习爬虫的过程中，你将会接触到的各种工具，方法，服务组件，都会在你以后的生活和工作中帮到你，让你知道，在遇到一个问题的时候，解决方法在哪个地方。</p>
<p>**</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;这篇文章没有代码，请放心阅读。&lt;/p&gt;
&lt;p&gt;多年以后，面对人工智能研究员那混乱不堪的代码，我会想起第一次和S君相见的那个遥远的下午。那时的B公司，还是一个仅有6个人的小团队，Mac和显示器在桌上依次排开，大家坐在一起，不需要称呼姓名，转过脸去，对方就知道你在和他说话。一切看起来都那么美好，我们所有人，都希望自己和这个公司能够一起成长。&lt;/p&gt;
&lt;p&gt;彼时S君刚从加拿大回来，老板把他介绍给我们，于是S君作为数据产品经理跟我有了项目上的接触。&lt;/p&gt;
&lt;p&gt;创业公司里面，每一个人都需要会很多的技艺，于是S君开始自学Python。&lt;/p&gt;
&lt;p&gt;有一天，S君问我：“你玩MineCraft吗？“&lt;/p&gt;
&lt;p&gt;“玩，但我更喜欢在B站上看别人的世界。”我答道。&lt;/p&gt;
&lt;p&gt;“我觉得我现在写程序，像是在玩我的世界。”S君笑着说道。&lt;/p&gt;
&lt;p&gt;“是不是觉得你已经掌握了Python的基本语法，看着别人把Python用的溜溜转，而你自己却不知道用它来做什么？”&lt;/p&gt;
&lt;p&gt;“是这样的，你懂我。”&lt;/p&gt;
&lt;p&gt;“那你学一门杂学吧。”&lt;/p&gt;
&lt;p&gt;于是S君被我诱拐过来跟我一起写爬虫。&lt;/p&gt;
&lt;p&gt;后来，S君离开了B公司。&lt;/p&gt;
&lt;p&gt;三个月后，我也离开了。&lt;/p&gt;
&lt;p&gt;从此，我们再也没有见过。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="学习方法" scheme="https://www.kingname.info/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式re.sub替换不完整的问题现象及其根本原因</title>
    <link href="https://www.kingname.info/2018/08/27/re-sandthepositionofparaminsub/"/>
    <id>https://www.kingname.info/2018/08/27/re-sandthepositionofparaminsub/</id>
    <published>2018-08-27T13:48:22.000Z</published>
    <updated>2018-09-25T13:33:27.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>问题的起因来自于一段正则替换。为了从一段HTML代码里面提取出正文，去掉所有的HTML标签和属性，可以写一个Python函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_tag</span><span class="params">(html)</span>:</span></div><div class="line">    text = re.sub(<span class="string">'&lt;.*?&gt;'</span>, <span class="string">''</span>, html, re.S)</div><div class="line">    <span class="keyword">return</span> text</div></pre></td></tr></table></figure>
<p>这段代码的使用了正则表达式的替换功能<code>re.sub</code>。这个函数的第一个参数表示需要被替换的内容的正则表达式，由于HTML标签都是使用尖括号包起来的，因此使用<code>&lt;.*?&gt;</code>就可以匹配所有<code>&lt;xxx yyy=&quot;zzz&quot;&gt;</code>和<code>&lt;/xxx&gt;</code>。</p>
<p>第二个参数表示被匹配到的内容将要被替换成什么内容。由于我需要提取正文，那么只要把所有HTML标签都替换为空字符串即可。第三个参数就是需要被替换的文本，在这个例子中是HTML源代码段。</p>
<p>至于<code>re.S</code>，在4年前的一篇文章中我讲到了它的用法：<a href="https://www.kingname.info/2014/12/21/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84re-S/">Python正则表达式中的re.S</a>。</p>
<p>现在使用一段HTML代码来测试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_tag</span><span class="params">(html)</span>:</span></div><div class="line">    text = re.sub(<span class="string">'&lt;.*?&gt;'</span>, <span class="string">''</span>, html, re.S)</div><div class="line">    <span class="keyword">return</span> text</div><div class="line"></div><div class="line"></div><div class="line">source_1 = <span class="string">'''</span></div><div class="line">&lt;div class="content"&gt;今天的主角是&lt;a href="xxx"&gt;kingname&lt;/a&gt;，我们掌声欢迎！&lt;/div&gt;</div><div class="line">'''</div><div class="line"></div><div class="line"></div><div class="line">text = remove_tag(source_1)</div><div class="line">print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示，功能完全符合预期</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-22-54.png" alt=""></p>
<p>再来测试一下代码中有换行符的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_tag</span><span class="params">(html)</span>:</span></div><div class="line">    text = re.sub(<span class="string">'&lt;.*?&gt;'</span>, <span class="string">''</span>, html, re.S)</div><div class="line">    <span class="keyword">return</span> text</div><div class="line"></div><div class="line">source_2 = <span class="string">'''</span></div><div class="line">&lt;div class="content"&gt;</div><div class="line">    今天的主角是</div><div class="line">    &lt;a href="xxx"&gt;kingname&lt;/a&gt;</div><div class="line">    ，我们掌声欢迎！</div><div class="line">&lt;/div&gt;</div><div class="line">'''</div><div class="line">text = remove_tag(source_2)</div><div class="line">print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示，完全符合预期。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-25-29.png" alt=""></p>
<p>经过测试，在绝大多数情况下，能够从的HTML代码段中提取出正文。但也有例外。</p>
<a id="more"></a>
<h2 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h2><p>有一段HTML代码段比较长，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img&gt;&lt;/span&gt;&lt;span&gt;遇见kingname&lt;/span&gt;&lt;/a &gt;&lt;a  &gt;&lt;span class=&apos;url-icon&apos;&gt;&lt; img &apos;&gt;&lt;/span&gt;&lt;span &gt;温柔&lt;/span&gt;&lt;/a &gt;&lt;a  &gt;&lt;span &gt;#青南#&lt;/span&gt;&lt;/a &gt; &lt;br /&gt;就在这里…&lt;br /&gt;我的小侯爷呢？？？</div></pre></td></tr></table></figure>
<p>运行效果如下图所示，最后两个HTML标签替换失败。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-31-59.png" alt=""></p>
<p>一开始我以为是HTML里面的空格或者引号引起的问题，于是我把HTML代码进行简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img&gt;&lt;/span&gt;&lt;span&gt;遇见kingname&lt;/span&gt;&lt;/a&gt;&lt;a&gt;&lt;span&gt;&lt;img&gt;&lt;/span&gt;&lt;span&gt;温柔&lt;/span&gt;&lt;/a&gt;&lt;a&gt;&lt;span&gt;#青南#&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;就在这里…&lt;br/&gt;我的小侯爷呢</div></pre></td></tr></table></figure>
<p>问题依然存在，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-36-14.png" alt=""></p>
<p>而且更令人惊讶的是，如果把第一个标签<code>&lt;img&gt;</code>删了，那么替换结果里面就少了一个标签，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-45-09.png" alt=""></p>
<p>实际上，不仅仅是删除第一个标签，前面任意一个标签删了都可以减少结果里面的一个标签。如果删除前面两个或以上标签，那么结果就正常了。</p>
<h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><p>这个看起来很奇怪的问题，根本原因在re.sub的第4个参数。从函数原型可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def sub(pattern, repl, string, count=0, flags=0)</div></pre></td></tr></table></figure>
<p>第四个参数是count表示替换个数，re.S如果要用，应该作为第五个参数。所以如果把<code>remove_tag</code>函数做一些修改，那么结果就正确了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def remove_tag(html):</div><div class="line">    text = re.sub(&apos;&lt;.*?&gt;&apos;, &apos;&apos;, html, flags=re.S)</div><div class="line">    return text</div></pre></td></tr></table></figure>
<p>那么问题来了，把re.S放在count的位置，为什么代码没有报错？难道<code>re.S</code>是数字？实际上，如果打印一下就会发现，<code>re.S</code>确实可以作为数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re</div><div class="line">&gt;&gt;&gt; print(int(re.S))</div><div class="line">16</div></pre></td></tr></table></figure>
<p>现在回头数一数出问题的HTML代码，发现最后多出来的两个<code>&lt;br&gt;</code>标签，刚刚好是第17和18个标签，而由于<code>count</code>填写的<code>re.S</code>可以当做16来处理，那么Python就会把前16个标签替换为空字符串，从而留下最后两个。</p>
<p>至此问题的原因搞清楚了。</p>
<p>这个问题没有被及早发现，有以下几个原因：</p>
<ol>
<li>被替换的HTML代码是代码段，大多数情况下HTML标签不足16个，所以问题被隐藏。</li>
<li><code>re.S</code>是一个对象，但也是数字，count接收的参数刚好也是数字。在很多编程语言里面，常量都会使用数字，然后用一个有意义的大写字母来表示。</li>
<li><code>re.S</code> 处理的情况是<code>&lt;div class=&quot;123&quot; \n&gt;</code> 而不是<code>&lt;div class=&quot;123&quot;&gt;\n&lt;/div&gt;</code>但测试的代码段标签都是第二种情况，所以在代码段里面实际上加不加<code>re.S</code>效果是一样的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;问题的起因来自于一段正则替换。为了从一段HTML代码里面提取出正文，去掉所有的HTML标签和属性，可以写一个Python函数：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_tag&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(html)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    text = re.sub(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;.*?&amp;gt;&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, html, re.S)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码的使用了正则表达式的替换功能&lt;code&gt;re.sub&lt;/code&gt;。这个函数的第一个参数表示需要被替换的内容的正则表达式，由于HTML标签都是使用尖括号包起来的，因此使用&lt;code&gt;&amp;lt;.*?&amp;gt;&lt;/code&gt;就可以匹配所有&lt;code&gt;&amp;lt;xxx yyy=&amp;quot;zzz&amp;quot;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;/xxx&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二个参数表示被匹配到的内容将要被替换成什么内容。由于我需要提取正文，那么只要把所有HTML标签都替换为空字符串即可。第三个参数就是需要被替换的文本，在这个例子中是HTML源代码段。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;re.S&lt;/code&gt;，在4年前的一篇文章中我讲到了它的用法：&lt;a href=&quot;https://www.kingname.info/2014/12/21/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84re-S/&quot;&gt;Python正则表达式中的re.S&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在使用一段HTML代码来测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_tag&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(html)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    text = re.sub(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;.*?&amp;gt;&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, html, re.S)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;source_1 = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div class=&quot;content&quot;&amp;gt;今天的主角是&amp;lt;a href=&quot;xxx&quot;&amp;gt;kingname&amp;lt;/a&amp;gt;，我们掌声欢迎！&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;text = remove_tag(source_1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(text)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行效果如下图所示，功能完全符合预期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-22-54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再来测试一下代码中有换行符的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_tag&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(html)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    text = re.sub(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;.*?&amp;gt;&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, html, re.S)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;source_2 = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div class=&quot;content&quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    今天的主角是&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;a href=&quot;xxx&quot;&amp;gt;kingname&amp;lt;/a&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ，我们掌声欢迎！&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;text = remove_tag(source_2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(text)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行效果如下图所示，完全符合预期。&lt;br&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-08-27-22-25-29.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过测试，在绝大多数情况下，能够从的HTML代码段中提取出正文。但也有例外。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1806</title>
    <link href="https://www.kingname.info/2018/06/21/tweet-201806/"/>
    <id>https://www.kingname.info/2018/06/21/tweet-201806/</id>
    <published>2018-06-21T14:36:39.000Z</published>
    <updated>2018-09-25T13:33:27.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018-05"><a href="#2018-05" class="headerlink" title="2018.05"></a>2018.05</h2><p>grep持续监控Log：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail <span class="_">-f</span> file | grep --line-buffered my_pattern</div></pre></td></tr></table></figure></p>
<hr>
<p>列表和deque的区别：</p>
<ul>
<li>根据index读list，时间复杂度为O(1)但deque是O(n)</li>
<li>在两头插入数据，deque的时间复杂度为O(1), list为O(n)</li>
<li>deque是一个双向链表，所以操作头尾非常简单。</li>
<li>随机往中间插入数据，deque与list的时间复杂度都是O(n)</li>
</ul>
<a id="more"></a>
<h2 id="2018-04"><a href="#2018-04" class="headerlink" title="2018.04"></a>2018.04</h2><p>MongoDB的聚合查询中，<code>$substr</code>只能匹配ASCII的数据，对于中文要使用<code>$substrCP</code></p>
<hr>
<p>Flask的上下文对象current_app只能在请求线程里存在，因此它的生命周期也是在应用上下文里，离开了应用上下文也就无法使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app = Flask(<span class="string">'__name__'</span>)</div><div class="line">print(current_app.name)</div></pre></td></tr></table></figure></p>
<p>会报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RuntimeError: working outside of application context</div></pre></td></tr></table></figure></p>
<p>此时可以手动创建应用上下文：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> app.app_context():</div><div class="line">    print(current_app.name)</div></pre></td></tr></table></figure></p>
<hr>
<p>扩展AWS的磁盘空间：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-06-21-22-31-04.png" alt=""></p>
<p>点击<code>修改卷</code>增加磁盘配额，SSH进入服务器，输入以下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsblk  <span class="comment">#这条命令用来确定当前可用的磁盘空间小于磁盘配额</span></div><div class="line">sudo growpart /dev/xvda 1</div><div class="line">sudo resize2fs /dev/xvda1</div></pre></td></tr></table></figure>
<p>再次执行<code>df -h</code>可以看到已经使用了新的空间</p>
<h2 id="2018-03"><a href="#2018-03" class="headerlink" title="2018.03"></a>2018.03</h2><p>在Docker查看正在运行的容器是通过什么命令启动的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a --no-trunc</div></pre></td></tr></table></figure></p>
<hr>
<p>在全新的Ubuntu中安装pip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get upgrade</div><div class="line">sudo apt-get install python3-pip</div><div class="line">sudo apt-get install build-essential libssl-dev libffi-dev python3-dev</div></pre></td></tr></table></figure></p>
<hr>
<p>tar压缩文件的时候排除特定文件和文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar --exclude=&apos;./folder&apos; --exclude=&apos;./upload/folder2&apos; -zcvf /backup/filename.tgz .</div></pre></td></tr></table></figure></p>
<h2 id="2018-02"><a href="#2018-02" class="headerlink" title="2018.02"></a>2018.02</h2><p>在MongoDB使用自带的mongodump备份数据的时候，如果数据库设置了密码，那么在指定mongodump的<code>--password 密码</code>参数的同时，还必须指定<code>--authenticationDatabase admin</code></p>
<h2 id="2018-01"><a href="#2018-01" class="headerlink" title="2018.01"></a>2018.01</h2><p>使用grep持续监控Log：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail <span class="_">-f</span> file | grep --line-buffered my_pattern</div></pre></td></tr></table></figure></p>
<hr>
<p>使用rsync通过SSH从服务器拉取数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -avzP ubuntu@xx.xxx.xx.xxx:Projects/sample.csv ~/sample.csv</div></pre></td></tr></table></figure></p>
<p>如果有SSH Key的话，使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -avzP <span class="_">-e</span> <span class="string">"ssh -i ~/sshkey.pem"</span> ubuntu@xx.xxx.xx.xxx:Projects/sample.csv ~/sample.csv</div></pre></td></tr></table></figure></p>
<hr>
<p>在Ubuntu中修改时区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</div></pre></td></tr></table></figure></p>
<hr>
<p>使用XPath获取名称包含特定字符的属性的属性值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//span/img/@*[contains(name(), <span class="string">"src"</span>)]</div></pre></td></tr></table></figure></p>
<hr>
<p>AWS在一年免费期间内，换机房不用给钱。先在老的实例生成AMI，再把AMI复制到新的城市，再从新城市的AMI创建实例。然后把老城市的实例彻底终结，取消老城市和新城市的AMI。全程不收费。</p>
<hr>
<p>在Python中执行Shell命令并获取返回结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">shell_result = subprocess.check_output(<span class="string">'ps -ef | grep 进程名 | grep -v grep'</span>, shell=<span class="keyword">True</span>).decode().strip().split(<span class="string">'\n)</span></div></pre></td></tr></table></figure></p>
<p>如果命令本身没有返回，则会抛出一个<code>subprocess.CalledProcessError</code></p>
<hr>
<p>在Shell中判断一个进程是否存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ps -ef | grep 进程名 | grep -v grep &gt; /dev/null</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"进程存在"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"进程不存在"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></p>
<h2 id="2017-12"><a href="#2017-12" class="headerlink" title="2017.12"></a>2017.12</h2><p>firewalld对特定IP开放特定端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=public --add-rich-rule=&apos;rule family=&quot;ipv4&quot; source address=&quot;特定IP&quot; port protocol=&quot;tcp&quot; port=&quot;特定端口&quot; accept&apos;</div></pre></td></tr></table></figure></p>
<hr>
<p>生成文件树并过滤特定文件或文件夹：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tree -I <span class="string">'__pycache__|pyc|Logs'</span></div></pre></td></tr></table></figure></p>
<hr>
<p>统计代码行数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">"*.py"</span> | xargs wc <span class="_">-l</span></div></pre></td></tr></table></figure></p>
<hr>
<p>为pip设置代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3.6 --proxy http://代理IP:端口 install -r requirements.txt</div></pre></td></tr></table></figure></p>
<hr>
<p>为Git设置代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RUN git config --global http.proxy http://代理IP:端口</div><div class="line">RUN git config --global http.sslverify <span class="string">"false"</span></div></pre></td></tr></table></figure></p>
<hr>
<p>为Ubuntu的<code>apt-get</code>设置代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/apt/apt.conf.d/01turnkey</div></pre></td></tr></table></figure></p>
<p>在里面插入一行：<br><code>Acquire::http::Proxy &quot;http://your.proxy.here:port/&quot;;</code><br>保存以后，下一次执行<code>apt-get</code>命令就会使用代理了。</p>
<h2 id="2017-11"><a href="#2017-11" class="headerlink" title="2017.11"></a>2017.11</h2><p>修改Elasticsearch默认的数据文件地址到/mnt/es文件夹，需要首先创建这个文件夹，然后为elasticsearch这个用户添加这个文件夹的权限:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chown -R elasticsearch:elasticsearch /mnt/es/</div></pre></td></tr></table></figure></p>
<p>然后再修改elasticsearch的配置文件。</p>
<hr>
<p>在postgres中，占位符是<code>$1</code>, <code>$2</code>而不是MySQL中的<code>？</code></p>
<h2 id="2017-10"><a href="#2017-10" class="headerlink" title="2017.10"></a>2017.10</h2><p>使用<code>urlpare</code>从URL中获取Host：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://nanjirenlk.tmall.com/shop/view_shop.htm'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = urlparse(url)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.netloc</div><div class="line"><span class="string">'nanjirenlk.tmall.com'</span></div></pre></td></tr></table></figure></p>
<hr>
<p>解压<code>tar.gz</code>压缩文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf 文件名</div></pre></td></tr></table></figure>
<hr>
<p>根据进程名字在Linux里杀进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep <span class="string">"进程关键字"</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span> | xargs <span class="built_in">kill</span> -9</div></pre></td></tr></table></figure>
<hr>
<p>在Python 的<code>try ... except Exception ...</code>中显示tracebook:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> traceback</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="number">1</span> + <span class="string">'a'</span></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">    tb = traceback.format_exc()</div><div class="line">    print(tb)</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></div></pre></td></tr></table></figure>
<p>这个功能在多层<code>try ... except Exception ...</code> 嵌套的时候特别有用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2018-05&quot;&gt;&lt;a href=&quot;#2018-05&quot; class=&quot;headerlink&quot; title=&quot;2018.05&quot;&gt;&lt;/a&gt;2018.05&lt;/h2&gt;&lt;p&gt;grep持续监控Log：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;tail &lt;span class=&quot;_&quot;&gt;-f&lt;/span&gt; file | grep --line-buffered my_pattern&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;列表和deque的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据index读list，时间复杂度为O(1)但deque是O(n)&lt;/li&gt;
&lt;li&gt;在两头插入数据，deque的时间复杂度为O(1), list为O(n)&lt;/li&gt;
&lt;li&gt;deque是一个双向链表，所以操作头尾非常简单。&lt;/li&gt;
&lt;li&gt;随机往中间插入数据，deque与list的时间复杂度都是O(n)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://www.kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="Craft" scheme="https://www.kingname.info/tags/Craft/"/>
    
      <category term="MongoDB" scheme="https://www.kingname.info/tags/MongoDB/"/>
    
      <category term="Docker" scheme="https://www.kingname.info/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用生成器把Kafka写入速度提高1000倍</title>
    <link href="https://www.kingname.info/2018/04/13/the-suitable-situation-for-yield/"/>
    <id>https://www.kingname.info/2018/04/13/the-suitable-situation-for-yield/</id>
    <published>2018-04-13T13:35:09.000Z</published>
    <updated>2018-09-25T13:33:27.419Z</updated>
    
    <content type="html"><![CDATA[<p>通过本文你会知道Python里面什么时候用yield最合适。本文不会给你讲生成器是什么，所以你需要先了解Python的yield，再来看本文。</p>
<a id="more"></a>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>多年以前，当我刚刚开始学习Python协程的时候，我看到绝大多数的文章都举了一个生产者-消费者的例子，用来表示在生产者内部可以随时调用消费者，达到和多线程相同的效果。这里凭记忆简单还原一下当年我看到的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line">    product = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> product <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">'consumer: &#123;&#125;'</span>.format(product))</div><div class="line">        product = <span class="keyword">yield</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></div><div class="line">    c = consumer()</div><div class="line">    next(c)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        c.send(i)</div><div class="line"></div><div class="line">start = time.time()</div><div class="line">producer()</div><div class="line">end = time.time()</div><div class="line">print(f<span class="string">'直到把所有数据塞入Kafka，一共耗时：&#123;end - start&#125;秒'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-04-13-23-05-55.png" alt=""></p>
<p>这些文章的说法，就像统一好了口径一样，说这样写可以减少线程切换开销，从而大大提高程序的运行效率。但是当年我始终想不明白，这种写法与直接调用函数有什么区别，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-04-13-21-51-37.png" alt=""></p>
<p>直到后来我需要操作Kafka的时候，我明白了使用yield的好处。</p>
<h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>为了便于理解，我会把实际场景做一些简化，以方便说明事件的产生发展和解决过程。事件的起因是我需要把一些信息写入到Kafka中，我的代码一开始是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</div><div class="line"></div><div class="line">client = KafkaClient(hosts=<span class="string">"127.0.0.1:9092"</span>)</div><div class="line">topic = client.topics[<span class="string">b'test'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(product)</span>:</span></div><div class="line">    <span class="keyword">with</span> topic.get_producer(delivery_reports=<span class="keyword">True</span>) <span class="keyword">as</span> producer:</div><div class="line">        producer.produce(str(product).encode())</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        consumer(i)</div><div class="line"></div><div class="line"></div><div class="line">start = time.time()</div><div class="line">feed()</div><div class="line">end = time.time()</div><div class="line">print(f<span class="string">'直到把所有数据塞入Kafka，一共耗时：&#123;end - start&#125;秒'</span>)</div></pre></td></tr></table></figure>
<p>这段代码的运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/witoutyield1.png" alt=""></p>
<p>写入10条数据需要100秒，这样的龟速显然是有问题的。问题就出在这一句代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> topic.get_producer(delivery_reports=<span class="keyword">True</span>) <span class="keyword">as</span> producer</div></pre></td></tr></table></figure>
<p>获得Kafka生产者对象是一个非常耗费时间的过程，每获取一次都需要10秒钟才能完成。所以写入10个数据就获取十次生产者对象。这消耗的100秒主要就是在获取生产者对象，而真正写入数据的时间短到可以忽略不计。</p>
<p>由于生产者对象是可以复用的，于是我对代码作了一些修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</div><div class="line"></div><div class="line">client = KafkaClient(hosts=<span class="string">"127.0.0.1:9092"</span>)</div><div class="line">topic = client.topics[<span class="string">b'test'</span>]</div><div class="line">products = []</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(product_list)</span>:</span></div><div class="line">    <span class="keyword">with</span> topic.get_producer(delivery_reports=<span class="keyword">True</span>) <span class="keyword">as</span> producer:</div><div class="line">        <span class="keyword">for</span> product <span class="keyword">in</span> product_list:</div><div class="line">            producer.produce(str(product).encode())</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        products.append(i)</div><div class="line">    consumer(products)</div><div class="line"></div><div class="line"></div><div class="line">start = time.time()</div><div class="line">feed()</div><div class="line">end = time.time()</div><div class="line">print(f<span class="string">'直到把所有数据塞入Kafka，一共耗时：&#123;end - start&#125;秒'</span>)</div></pre></td></tr></table></figure>
<p>首先把所有数据存放在一个列表中，最后再一次性给consumer函数。在一个Kafka生产者对象中展开列表，再把数据一条一条塞入Kafka。这样由于只需要获取一次生产者对象，所以需要耗费的时间大大缩短，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/witoutyield2.png" alt=""></p>
<p>这种写法在数据量小的时候是没有问题的，但数据量一旦大起来，如果全部先放在一个列表里面的话，服务器内存就爆了。</p>
<p>于是我又修改了代码。每100条数据保存一次，并清空暂存的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</div><div class="line"></div><div class="line">client = KafkaClient(hosts=<span class="string">"127.0.0.1:9092"</span>)</div><div class="line">topic = client.topics[<span class="string">b'test'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(product_list)</span>:</span></div><div class="line">    <span class="keyword">with</span> topic.get_producer(delivery_reports=<span class="keyword">True</span>) <span class="keyword">as</span> producer:</div><div class="line">        <span class="keyword">for</span> product <span class="keyword">in</span> product_list:</div><div class="line">            producer.produce(str(product).encode())</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed</span><span class="params">()</span>:</span></div><div class="line">    products = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1003</span>):</div><div class="line">        products.append(i)</div><div class="line">        <span class="keyword">if</span> len(products) &gt;= <span class="number">100</span>:</div><div class="line">            consumer(products)</div><div class="line">            products = []</div><div class="line"></div><div class="line">    <span class="keyword">if</span> products:</div><div class="line">        consumer(products)</div><div class="line"></div><div class="line"></div><div class="line">start = time.time()</div><div class="line">feed()</div><div class="line">end = time.time()</div><div class="line">print(f<span class="string">'直到把所有数据塞入Kafka，一共耗时：&#123;end - start&#125;秒'</span>)</div></pre></td></tr></table></figure>
<p>由于最后一轮循环可能无法凑够100条数据，所以<code>feed</code>函数里面，循环结束以后还需要判断<code>products</code>列表是否为空，如果不为空，还要再消费一次。这样的写法，在上面这段代码中，一共1003条数据，每100条数据获取一次生产者对象，那么需要获取11次生产者对象，耗时至少为110秒。</p>
<p>显然，要解决这个问题，最直接的办法就是减少获取Kafka生产者对象的次数并最大限度复用生产者对象。如果读者举一反三的能力比较强，那么根据开关文件的两种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 写法一</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(<span class="string">'xxx'</span>)</div><div class="line">    </div><div class="line"><span class="comment"># 写法二</span></div><div class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</div><div class="line">f.write(<span class="string">'xxx'</span>)</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>可以推测出获取Kafka生产者对象的另一种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 写法二</span></div><div class="line">producer = topic.get_producer(delivery_reports=<span class="keyword">True</span>)</div><div class="line">producer.produce(<span class="string">b'xxxx'</span>)</div><div class="line">producer.close()</div></pre></td></tr></table></figure>
<p>这样一来，只要获取一次生产者对象并把它作为全局变量就可以一直使用了。</p>
<p>然而，pykafka的官方文档中使用的是第一种写法，通过上下文管理器<code>with</code>来获得生产者对象。暂且不论第二种方式是否会报错，只从写法上来说，第二种方式必需要手动关闭对象。开发者经常会出现开了忘记关的情况，从而导致很多问题。而且如果中间出现了异常，使用上下文管理器的第一种方式会自动关闭生产者对象，但第二种方式仍然需要开发者手动关闭。</p>
<h2 id="函数VS生成器"><a href="#函数VS生成器" class="headerlink" title="函数VS生成器"></a>函数VS生成器</h2><p>但是如果使用第一种方式，怎么能在一个上下文里面接收生产者传进来的数据呢？这个时候才是yield派上用场的时候。</p>
<p>首先需要明白，使用yield以后，函数就变成了一个生成器。生成器与普通函数的不同之处可以通过下面两段代码来进行说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">funciton</span><span class="params">(i)</span>:</span></div><div class="line">    print(<span class="string">'进入'</span>)</div><div class="line">    print(i)</div><div class="line">    print(<span class="string">'结束'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    funciton(i)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-04-13-22-29-40.png" alt=""></p>
<p>函数在被调用的时候，函数会从里面的第一行代码一直运行到某个<code>return</code>或者函数的最后一行才会退出。</p>
<p>而生成器可以从中间开始运行，从中间跳出。例如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'进入'</span>)</div><div class="line">    i = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> i <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            print(i)</div><div class="line">        print(<span class="string">'跳出'</span>)</div><div class="line">        i = <span class="keyword">yield</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">g = generator()</div><div class="line">next(g)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    g.send(i)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-04-13-23-09-43.png" alt=""></p>
<p>从图中可以看到，<code>进入</code>只打印了一次。代码运行到<code>i = yield None</code>后就跳到外面，外面的数据可以通过<code>g.send(i)</code>的形式传进生成器，生成器内部拿到外面传进来的数据以后继续执行下一轮<code>while</code>循环，打印出被传进来的内容，然后到<code>i = yield None</code>的时候又跳出。如此反复。</p>
<p>所以回到最开始的Kafka问题。如果把<code>with topic.get_producer(delivery_reports=True) as producer</code>写在上面这一段代码的<code>print(&#39;进入&#39;)</code>这个位置上，那岂不是只需要获取一次Kafka生产者对象，然后就可以一直使用了？</p>
<p>根据这个逻辑，设计如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</div><div class="line"></div><div class="line">client = KafkaClient(hosts=<span class="string">"127.0.0.1:9092"</span>)</div><div class="line">topic = client.topics[<span class="string">b'test'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> topic.get_producer(delivery_reports=<span class="keyword">True</span>) <span class="keyword">as</span> producer:</div><div class="line">        print(<span class="string">'init finished..'</span>)</div><div class="line">        next_data = <span class="string">''</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> next_data:</div><div class="line">                producer.produce(str(next_data).encode())</div><div class="line">            next_data = <span class="keyword">yield</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed</span><span class="params">()</span>:</span></div><div class="line">    c = consumer()</div><div class="line">    next(c)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">        c.send(i)</div><div class="line"></div><div class="line">start = time.time()</div><div class="line">feed()</div><div class="line">end = time.time()</div><div class="line">print(f<span class="string">'直到把所有数据塞入Kafka，一共耗时：&#123;end - start&#125;秒'</span>)</div></pre></td></tr></table></figure>
<p>这一次直接插入1000条数据，总共只需要10秒钟，相比于每插入一次都获取一次Kafka生产者对象的方法，效率提高了1000倍。运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/withyield.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>读者如果仔细对比第一段代码和最后一段代码，就会发现他们本质上是一回事。但是第一段代码，也就是网上很多人讲yield的时候举的生产者-消费者的例子之所以会让人觉得毫无用处，就在于他们的消费者几乎就是秒运行，这样看不出和函数调用的差别。而我最后这一段代码，它的消费者分成两个部分，第一部分是获取Kafka生产者对象，这个过程非常耗时；第二部分是把数据通过Kafka生产者对象插入Kafka，这一部分运行速度极快。在这种情况下，使用生成器把这个消费者代码分开，让耗时长的部分只运行一次，让耗时短的反复运行，这样就能体现出生成器的优势。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过本文你会知道Python里面什么时候用yield最合适。本文不会给你讲生成器是什么，所以你需要先了解Python的yield，再来看本文。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>从Workflowy到印象笔记</title>
    <link href="https://www.kingname.info/2018/03/17/from-workflowy-to-evernote/"/>
    <id>https://www.kingname.info/2018/03/17/from-workflowy-to-evernote/</id>
    <published>2018-03-17T02:05:54.000Z</published>
    <updated>2018-09-25T13:33:27.414Z</updated>
    
    <content type="html"><![CDATA[<p>Workflowy是一个极简风格的大纲写作工具，使用它提供的无限层级缩进和各种快捷键，可以非常方便的理清思路，写出一个好看而实用的大纲。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-17-58.png" alt=""></p>
<p>印象笔记更是家喻户晓，无人不知的跨平台笔记应用。虽然有很多竞争产品在和印象笔记争抢市场，但是印象笔记强大的搜索功能还是牢牢抓住了不少用户。</p>
<p>如果能够把用Workflowy写大纲的便利性，与印象笔记强大的搜索功能结合起来，那岂不是如虎添翼？如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-21-31.png" alt=""></p>
<p>EverFlowy就是这样一个小工具。它可以自动把Workflowy上面的条目拉下来再同步到印象笔记中。如果Workflowy有更新，再运行一下这个小工具，它就会同步更新印象笔记上面的内容。Workflowy负责写，印象笔记负责存，各尽其能，各得其所。</p>
<a id="more"></a>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>Everflowy基于Python 3开发，代码托管在Github中，地址为：<a href="https://github.com/kingname/EverFlowy" target="_blank" rel="external">https://github.com/kingname/EverFlowy</a>这个小工具在持续开发中，目前可以实现Workflowy单向同步到印象笔记和差异更新。由于印象笔记的Oauth验证方式需要申请才能对正式的账号使用，但它又不会通过这种个人小工具的申请，所以目前暂时使用开发者Token。关于如何申请开通正式账号的开发者Token，在后文会有详细的说明。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要保证电脑中安装了Python 3，否则无法运行这个小工具。代码的依赖关系使用Pipenv来管理，所以需要首先使用pip安装pipenv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 -m pip install pipenv</div></pre></td></tr></table></figure>
<p>有了Pipenv以后，使用Git把代码拉到本地再安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/kingname/EverFlowy.git</div><div class="line"><span class="built_in">cd</span> EverFlowy</div><div class="line">pipenv install</div><div class="line">pipenv shell</div></pre></td></tr></table></figure>
<p>运行了上面的4条命令以后，你的终端窗口应该如下图类似。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-43-11.png" alt=""></p>
<p>Pipenv会自动创建一个基于Virtualenv的虚拟环境，然后把EverFlowy依赖的第三方库自动安装到这个虚拟环境中，再自动激活这个虚拟环境。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在代码的根目录，有一个config.json文件，打开以后如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-46-26.png" alt=""></p>
<p>你需要修改三个地方，分别是<code>username</code>，<code>password</code>和<code>dev_token</code>。其中<code>username</code>和<code>password</code>分别对应了Workflowy的用户名和密码，而<code>dev_token</code>是印象笔记的开发者Token。</p>
<p>这里需要说明一下印象笔记的开发者Token。印象笔记的开发者Token有两套，分别是沙盒环境的开发者Token和生产环境的开发者Token。所谓沙盒环境，就是一个测试开发环境，这个环境是专门为了快速开发印象笔记App而设计的，它的地址为：<a href="https://sandbox.evernote.com" target="_blank" rel="external">https://sandbox.evernote.com</a>。打开这个网址，可以看到页面上弹出了警告，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-56-01.png" alt=""></p>
<p>无论你之前是否有印象笔记的账号，要使用沙盒环境，都必需重新注册。注册完成以后，通过访问<a href="https://sandbox.evernote.com/api/DeveloperToken.action" target="_blank" rel="external">https://sandbox.evernote.com/api/DeveloperToken.action</a>获取沙盒环境的开发者Token。</p>
<p>关于印象笔记的沙盒环境，我将另外开一篇文章来说明。本文主要介绍如何申请生产环境的开发者Token，从而可以使用正式的印象笔记账号。</p>
<p>在2017年6月以后，印象笔记关闭了生产环境开发者Token的申请通道，如果打开申请网址：<a href="https://app.yinxiang.com/api/DeveloperToken.action" target="_blank" rel="external">https://app.yinxiang.com/api/DeveloperToken.action</a>，你会发现申请的按钮是灰色的且无法点击。要解决这个问题，就需要让印象笔记的客服帮忙。</p>
<p>登录自己的印象笔记正式账号，打开印象笔记首页，把页面拉到最下面，可以看到有一个“联系我们”，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-11-13-41.png" alt=""></p>
<p>进入“联系我们”，点击“联系客服”，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-11-14-06.png" alt=""></p>
<p>在联系客服的页面填写如下信息，最后一项“简要描述问题”填写“我需要基于印象笔记API开发，请帮我开通生产环境开发者Token”并提交。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-11-17-01.png" alt=""></p>
<p>大约24小时内，就可以受到客服回复的邮件，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-11-19-02.png" alt=""></p>
<p>此时再次打开<a href="https://app.yinxiang.com/api/DeveloperToken.action" target="_blank" rel="external">https://app.yinxiang.com/api/DeveloperToken.action</a>就可以申请开发者Token了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-11-20-23.png" alt=""></p>
<p>需要注意的是，开发者Token只会显示一次，所以你需要立刻把它记录下来。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了生产环境的开发者Token以后，把它填写到config.json中，配置就算完成了。在终端输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 EverFlowy.py</div></pre></td></tr></table></figure>
<p>程序就可以开始同步Workflowy的数据到印象笔记了。</p>
<p>同步完成以后，你会发现程序的根目录出现了一个history.db文件。这是一个sqllite的文件，里面就是你在Workflowy中的所有大纲内容和对应的印象笔记GUID和enml格式的内容。这是为了实现数据的差异更新而生成的。你可以使用各种能够浏览sqllite的工具来查看里面的内容。</p>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ul>
<li>如果删除了history.db，那么再次运行Everflowy，Workflowy中的所有内容都会再次写入印象笔记。</li>
<li>如果单独删除了EverFlowy写入印象笔记中的某一条目，却不删除history.db中的对应条目，WorkFlowy会因为找不到GUID而抛出异常。</li>
<li>没有测试国际版印象笔记账号是否可用。</li>
<li>如过你想测试沙盒环境的开发者账号，请修改<code>evernote_util/EverNoteUtil.py</code>第98行，把</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = EvernoteClient(token=self.dev_token, sandbox=<span class="keyword">False</span>, service_host=<span class="string">'app.yinxiang.com'</span>)</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = EvernoteClient(token=self.dev_token)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Workflowy是一个极简风格的大纲写作工具，使用它提供的无限层级缩进和各种快捷键，可以非常方便的理清思路，写出一个好看而实用的大纲。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-17-58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;印象笔记更是家喻户晓，无人不知的跨平台笔记应用。虽然有很多竞争产品在和印象笔记争抢市场，但是印象笔记强大的搜索功能还是牢牢抓住了不少用户。&lt;/p&gt;
&lt;p&gt;如果能够把用Workflowy写大纲的便利性，与印象笔记强大的搜索功能结合起来，那岂不是如虎添翼？如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-03-17-10-21-31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;EverFlowy就是这样一个小工具。它可以自动把Workflowy上面的条目拉下来再同步到印象笔记中。如果Workflowy有更新，再运行一下这个小工具，它就会同步更新印象笔记上面的内容。Workflowy负责写，印象笔记负责存，各尽其能，各得其所。&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://www.kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Workflowy" scheme="https://www.kingname.info/tags/Workflowy/"/>
    
      <category term="Evernote" scheme="https://www.kingname.info/tags/Evernote/"/>
    
  </entry>
  
  <entry>
    <title>任务管理，项目管理和目标管理</title>
    <link href="https://www.kingname.info/2018/01/01/task-project-target/"/>
    <id>https://www.kingname.info/2018/01/01/task-project-target/</id>
    <published>2018-01-01T02:11:14.000Z</published>
    <updated>2018-09-25T13:33:27.404Z</updated>
    
    <content type="html"><![CDATA[<p>我是一个工具控，经常尝试各种生产力工具。我发现任务管理App汗牛充栋，项目管理工具乏善可陈，而目标管理App更是少得可怜。</p>
<a id="more"></a>
<h2 id="任务管理App"><a href="#任务管理App" class="headerlink" title="任务管理App"></a>任务管理App</h2><p>任务管理App，包括常见的Things 3，Todoist，Teambition，Trello。其中Things 3和Todoist，本质上就像是一个增强版的提醒工具，你要做什么事情，填上去，设置好Deadline，事情做完了勾掉。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-10-22-53.png" alt=""></p>
<p>但这种类型的App有一个缺点——任务只有<code>未做</code>和<code>完成</code>两个状态，没有<code>正在做</code>的状态。</p>
<p>而Teambition与Trello稍微进步一点，引入了看板的概念，于是能够显示任务在各个阶段的状态，如下图所示。这张图是少数派的Trello看板，用来让作者选题。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-10-26-51.png" alt=""></p>
<p>这种类型的App有一个很大的问题：你做了很多任务，但是你不知道你做这些任务是为了什么。任务管理类App适合用来记录和追踪各种琐碎的任务和相关性不强的任务。就像是少数派的每一篇文章，文章与文章之间不是一个系列的关系，他们各自独立，谁都可以领选题写文章，哪个选题先写哪个选题后写，关系不大。</p>
<p>一旦要规划一个项目，对于规划项目的人和做项目的人，用任务管理类App都会让人觉得使不上劲。对于做任务的人，看到每一个独立的任务，对项目没有整体的概念；对于规划项目的人，不知道任务是不是已经切分得足够细，是否有遗漏。举一个例子，下面是一些任务：</p>
<ul>
<li>找IT申请服务器</li>
<li>配置Dockerfile</li>
<li>配置Docker Swarm</li>
<li>搭建Jenkins</li>
<li>配置Github Hook</li>
<li>选择三个Repo测试</li>
</ul>
<p>现在看到上面的几个任务，你知道我是想做什么吗？我想实现持续集成（CI），实现开发人员把代码一推到Github，系统自动使用Jenkins把代码拉到测试服务器，检查代码风格，做单元测试，做功能测试，自动生成Code Review申请发送给相关人员，Code Review以后自动把代码集成到主干并部署。但是对于做任务的人，却很难根据上面的任务发现要做这个事情。对于规划任务的人，也很难发现是否漏掉了任务，以及是否其中的一个或者多个任务可以继续拆分。</p>
<p>再一个问题，在为每一个任务设定时间的时候，任务一旦多，很难把控每个任务的具体时长。也难以发现哪些任务可以同时做，哪些任务有依赖必需先做这个再做那个，前置任务必需按时完成。即使设置了任务优先级，但是对于同级的任务谁先做谁后做，你却无法把控，只有看App上哪个排前面就先做哪个。</p>
<p>我曾经有一篇文章，就是因为考虑到Teambition的这个问题，所以把Teambition与大纲工具Workflowy结合起来使用。文章地址为：<a href="https://kingname.info/2017/10/03/teamflowy/" target="_blank" rel="external">TeamFlowy——结合Teambition与Workflowy
</a></p>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>正是由于任务管理App存在诸多不便，于是在规划一个项目的时候，必需使用一些项目管理的方法或者软件来提高效率。</p>
<p>关于项目管理，我个人最推崇使用甘特图。在我的另一篇文章<a href="https://kingname.info/2017/12/31/you-should-use-gantt/" target="_blank" rel="external">不用甘特图，你做什么项目管理</a>中，我讲到了从一张甘特图里面，你将会额外获得哪些信息。</p>
<p>甘特图是一张二维的图表，它的横轴是时间，纵轴是任务。从甘特图上可以一目了然看到一个任务从什么时候开始什么时候结束，不同任务之间是否有时间重叠，以及哪些任务可以同时做哪些任务必需有先后顺序。</p>
<p>我个人认为，在项目管理中，任务周期是非常重要的，任务的开始时间和结束时间一定要把控好。使用甘特图就可以实现这样一个目的。</p>
<p>对于规划任务的人，在用甘特图规划任务的时候，如果你发现一个任务时间太长，无论怎么调整都会和后面的任务有重叠，那么你就会发现这个任务可能需要拆分为更小的任务。而且由于甘特图立足于项目的整体，你也可以更容易发现是否有任务漏掉了。</p>
<p>对于做任务的人，甘特图也可以帮他们了解到他们所做的任务在整个项目中处于一个什么样的位置，从而让他们知道自己正在做的任务是不是非常重要必需按时完成。</p>
<p>如果你是要开发一个App，或者是要写一本书，或者是要做一个其他什么项目，只要它是由一系列不同的任务构成的，那么你就可以考虑使用甘特图来帮你提高效率。</p>
<h2 id="目标管理"><a href="#目标管理" class="headerlink" title="目标管理"></a>目标管理</h2><p>今天是2018年第一天，不知道有多少人把2017年第一天许下的新年愿望原封不动的搬到了今天。为什么很多人的目标总是不能实现呢？因为他们没有做好目标管理。</p>
<p>关于目标管理，我推崇的是OKR系统。这虽然是一个发源于Intel后被Google发扬光大的企业管理系统，但是对个人依然有用。OKR的意思是<code>Objective and Key Results</code>目标和关键成果。很多人的目标之所以没有实现，是因为他们只设定目标，却不设定成果检查。例如一个人的目标是打算学好英语，但是由于没有设定结果，那么他在设定目标的第二天背了三个单词，在他的潜意识里面就会认为自己已经完成了这个任务，自然后面就会越来越松懈。但如果一个人设定目标为学好英语，再设定几个关键成果，例如：</p>
<ul>
<li>4月1之前，与10个以上美国人聊天</li>
<li>在3月10日节之前，单词书随意翻开一页，这一页的单词至少认识90%</li>
<li>在4月1日前面试三个国外的公司，不为工作就为面着玩</li>
</ul>
<p>这样的目标，就更容易实现了。</p>
<p>使用OKR方法，用纸和笔就可以完成，在设定目标关键结果的时候，一定要使用<code>Smart</code>法则：</p>
<ul>
<li>Specific-具体的</li>
<li>Measurable-可衡量的</li>
<li>Attainable-可实现的</li>
<li>Relevant-相关的</li>
<li>Time-based-有时限的</li>
</ul>
<p>关键结果要足够具体，这样它才是可衡量的。而所谓的可衡量，自然就是可以量化的，可以用数字来定量的检查这个关键结果是否完成，如果没有完全完成，那么完成了多少。如果目标是学好英语，那么关键结果里面肯定不能是“每个月吃一次素菜”。因为这个关键结果和这个目标无关。最后也是非常重要的一点，设定Deadline，防止拖延。</p>
<p>如果你基于OKR系统订好了几个目标和他们的关键结果，然后你100%完成了所有目标。那么恭喜你，你的这个OKR系统是<code>不成功</code>的。100%完成的基于OKR系统的目标对你的帮助不会太大，因为你设定得太简单了。一个完美的<code>OKR</code>系统，应该是在你用尽全力绞尽脑汁的情况下，完成了70%的目标。这样它才会促使你不断挑战自己的极限，不断变得更好。</p>
<p>基于OKR系统的目标，时间也不应该设置太长，以季度为节点检查一次，增加新的目标或者关键结果。最长也需要保证半年至少检查一次，否则很容易出现赶Deadline的情况。</p>
<h2 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h2><p>一个目标，最终会被拆分为一个或者多个项目，每个项目又会被拆分为一个或者多个具体的任务。所以在我自己的实践中，我会把本文讲到的三个东西结合起来。通过OKR系统制定我的目标，使用甘特图来规划我的项目，而使用Todoist来做任务管理。</p>
<p>当我形成了这样一个工作流以后，我发现他们之间可以合作得很好，并不会让人手忙脚乱。我在季度开始的时候制定OKR，然后每周检查一次。在绘制好甘特图以后，我每天也只在下班的时候看一次，更新好项目进度，然后把明天要做的任务添加到Todoist里面。所以我每天使用最多的，更新得最多的还是Todoist。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是一个工具控，经常尝试各种生产力工具。我发现任务管理App汗牛充栋，项目管理工具乏善可陈，而目标管理App更是少得可怜。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="生产力" scheme="https://www.kingname.info/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="效率" scheme="https://www.kingname.info/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>不用甘特图，你做什么项目管理</title>
    <link href="https://www.kingname.info/2017/12/31/you-should-use-gantt/"/>
    <id>https://www.kingname.info/2017/12/31/you-should-use-gantt/</id>
    <published>2017-12-31T14:45:55.000Z</published>
    <updated>2018-09-25T13:33:27.450Z</updated>
    
    <content type="html"><![CDATA[<p>我非常喜欢使用甘特图来做项目管理。不用甘特图的公司，我觉得很奇怪。<br><a id="more"></a></p>
<h2 id="什么是甘特图"><a href="#什么是甘特图" class="headerlink" title="什么是甘特图"></a>什么是甘特图</h2><p>什么是甘特图呢？下面这张图就是甘特图。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-22-53-21.png" alt=""></p>
<p>这张图是我12月离职做交接时候的甘特图。</p>
<ul>
<li>不同的颜色表示不同的人</li>
<li>每一行表示一个任务</li>
<li>红色竖线表示今天应该完成的任务</li>
<li>任务与任务之间的黑色箭头表示任务之间的依赖关系，必需完成前面的才能完成后面的</li>
<li>带中心黑线的任务表示已经完成的任务</li>
</ul>
<p>通过这一张甘特图，我能一眼看出以下信息：</p>
<ol>
<li>今天谁应该做什么任务</li>
<li>这个任务从什么时候开始，到什么时候结束</li>
<li>一个人在一段时间有哪些任务</li>
<li>应该先做哪些任务再做哪些任务</li>
<li>哪些任务可以同时做</li>
<li>这个任务是否被其他任务依赖，如果是，那么这个任务就不能推迟，必需按时完成或者提前完成，否则会影响后面的任务</li>
<li>每个任务已经完成多少还剩多少</li>
<li>大任务下面有哪些子任务</li>
<li>任务的里程碑是什么时候</li>
</ol>
<h2 id="为什么要用甘特图"><a href="#为什么要用甘特图" class="headerlink" title="为什么要用甘特图"></a>为什么要用甘特图</h2><p>因为为了绘制出甘特图，你必需强迫自己完成以下几件事情：</p>
<ol>
<li>确定每一个任务的开始时间和结束时间</li>
<li>确定任务的依赖关系</li>
<li>分离可以同时运行的任务</li>
<li>确定不同人的任务间的时间关系</li>
</ol>
<p>当你根据以上的规则绘制好第一版甘特图以后，你会发现有些地方是可以继续调整的，但是这种调整，在你没有画图之前是不能发现的。于是你会在调整甘特图的过程中，让项目的规划越来越清晰。</p>
<h2 id="怎么做甘特图"><a href="#怎么做甘特图" class="headerlink" title="怎么做甘特图"></a>怎么做甘特图</h2><p>你可以在纸上做甘特图，也可以用Excel来做。下面这张图是来自网络。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-20-03.png" alt=""></p>
<p>这是使用Excel做出来的效果，但是做起来稍显麻烦。</p>
<p>Omniplan和MS Project都是非常专业的甘特图制作软件，但是价格非常高。毕竟这是生产力软件，使用这个软件你是可以赚大钱的，自然软件本身就会比较贵。</p>
<p>开源的甘特图软件也有不少，不过不是功能不全就是界面丑陋。这里介绍一个相对比较完整的甘特图制作软件：GanttProject</p>
<p>GanttProject的官方网站为<a href="http://www.ganttproject.biz/" target="_blank" rel="external">http://www.ganttproject.biz/</a>，在这里你可以下载到macOS，Windows或者Linux版本的软件。</p>
<p>GanttProject运行以后的界面如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-47-11.png" alt=""></p>
<p>在左侧任务面板右键或者按下键盘<code>Command</code> + <code>T</code>就可以添加任务，Windows和Linux对应的快捷键为<code>Ctrl</code> + <code>T</code>。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-31-23-48-11.png" alt=""></p>
<p>创建好了一个任务，它默认的开始时间和结束时间都是今天。在任务上面右键，选择<code>任务属性</code>，可以打开任务属性设置界面，在这里可以设置任务的开始时间和任务时长。但是你不能设置任务结束时间。因为任务结束时间会根据开始时间和任务时长自动计算。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-03-16.png" alt=""></p>
<p>在这个界面，还可以设置任务的颜色，实现不同人不同颜色，或者不同项目不同颜色。也可以在这里更新任务进度。</p>
<p>创建多个任务，如果后面的任务依赖前面的任务，那么在右侧被依赖的任务色条上单击鼠标左键，按住并拖动到依赖它的任务上。依赖它的任务的起始时间自动就会变为被依赖任务的结束时间，如下图所示。此时，后一个任务只能设置任务的时长，不能修改任务的起始时间。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-08-17.png" alt=""></p>
<p>如果依赖关系设置错误，打开依赖任务的任务属性，定位到<code>前置任务</code>选项卡，在这里可以删除被依赖的任务或者修改被依赖任务。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-11-10.png" alt=""></p>
<p>如果你需要移动任务的顺序，鼠标单击选中它，按下键盘上的<code>Alt</code> + <code>方向键上或下</code>即可移动任务。</p>
<p>我认为甘特图有一个非常重要的元素，就是竖直红线，它指向了今天的任务。要打开这跟红线，需要单击菜单栏的<code>编辑</code>-<code>设置</code>，定位到<code>甘特图设定</code>，在<code>将今天显示为红色</code>点选为<code>是</code>，如下图所示。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-20-55.png" alt=""><br>单击确定回到甘特图的界面，可以看到图中出现了一条红色竖线。这条竖线指向了今天应该做的事情。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-23-06.png" alt=""></p>
<p>每天打开甘特图，这根红线都会指向当天。</p>
<p>GanttProject可以把做好的甘特图导出为图片，CSV，HTML或者PDF文件。单击<code>项目</code>-<code>导出</code>，点选<code>Raster图像文件</code>，并单击<code>下一步</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2018-01-01-00-24-34.png" alt=""></p>
<p>设置保存路径和甘特图的日期范围即可导出为PNG文件，以方便分享。</p>
<p>GanttProject还有更多功能，你可以安装以后慢慢研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我非常喜欢使用甘特图来做项目管理。不用甘特图的公司，我觉得很奇怪。&lt;br&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="甘特图" scheme="https://www.kingname.info/tags/%E7%94%98%E7%89%B9%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins自动部署博客</title>
    <link href="https://www.kingname.info/2017/12/17/auto-deploy-blog/"/>
    <id>https://www.kingname.info/2017/12/17/auto-deploy-blog/</id>
    <published>2017-12-17T11:48:10.000Z</published>
    <updated>2018-09-25T13:33:27.383Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章比较简单，适合初学<code>持续集成</code>的读者，本文可以帮助你对基于Jenkins的持续集成有一个比较全局的概念。</p>
<a id="more"></a>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>为了使用HTTPS，我将博客从GitHub Pages迁移到了我的服务器上。由于博客基于Hexo，在迁移之前，我的工作流程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本地写Markdown格式文章-&gt;Hexo生成HTML并推送到GitHub-&gt;GitHub Pages自动使用最新内容</div></pre></td></tr></table></figure>
<p>现在由于Hexo渲染以后的HTML文件需要放到服务器上，那么工作流程变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">本地写Markdown格式文章-&gt;Hexo生成HTML并推送到GitHub-&gt;手动登录服务器</div><div class="line">-&gt;进入放博客文章的文件夹-&gt;执行命令git pull</div></pre></td></tr></table></figure>
<p>增加的两步虽然说操作量不大，但是总显得很麻烦。于是我希望，在我把博客的HTML文件push到GitHub以后，服务器能自动从GitHub上把HTML内容拉下来。由于使用了Nginx，所以只要博客的HTML发生了更新，那么使用浏览器访问<a href="https://kingname.info" target="_blank" rel="external">https://kingname.info</a>时，新内容自动就会出现。这样一来，对我来说，看起来就像是我刚刚push了网页内容到GitHub，博客就自动更新了。</p>
<p>让服务器从GitHub上面拉代码，这个操作本身很简单。人来操作就一行代码<code>git pull</code>。写个Python脚本也就两行代码。但问题是，服务器怎么知道GitHub发生了更新？</p>
<p>有人说，Kingname，你不是做爬虫吗？你写个爬虫，每一秒检查一下GitHub不就可以了吗？这种办法当然可以。但问题是，我一周就更新一次博客，但这个爬虫为了等这一次更新，一周要访问GitHub高达604800次？更何况我有时候一个月都不更新。</p>
<p>所以显然不能让服务器主动检查GitHub更新，这种“轮询”操作效率太低。那么如果反过来，一旦GitHub有更新，它就通知服务器，然后服务器再去拉代码，这不就简单高效了吗？</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>为了实现这个目的，就需要使用一些持续集成的工具。本文使用的是Jenkins。</p>
<p>Jenkins在<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" target="_blank" rel="external">敏捷开发</a>界可以说是大名鼎鼎了。使用Jenkins搭建一整套<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成</a>环境，可以实现开发者往代码仓库一提交代码，代码自动进行单元测试，覆盖率测试，代码风格检查自动生成报告，自动通知部门同事开始Code Review。当代码被合并入主干以后，服务器自动拉下最新代码，自动编译，自动在几千几万台服务器上部署。在整个过程中，开发者只需要做一件事，那就是<code>git push</code>（当然在实际情况下，后面还会加一些参数）。</p>
<p>本文实现的是博客的自动部署，没有任何测试，也没有Code Review，也没有编译，服务器也只有一台，复杂程度当然远远低于持续集成。不过管中窥豹，来看看这个简单地流程是如何走通的，对初学者也会有帮助。</p>
<p>本文假设你已经在服务器上面搭建好了Jenkins环境。如果你还没有安装Jenkins或者不会安装，那么可以“参考”这篇文章：<a href="https://kingname.info/2016/05/29/raspberryCI-1/" target="_blank" rel="external">搭建持续集成环境(一)</a>。由于这篇文章是18个月以前写的，系统也是小众的Arch Linux，所以建议你还是在网上搜一下最新的Jenkins安装教程比较好。</p>
<h3 id="设置GitHub"><a href="#设置GitHub" class="headerlink" title="设置GitHub"></a>设置GitHub</h3><p>在GitHub中进入博客所在的Repo，并点击<code>Settings</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-23-18.png" alt=""></p>
<p>在设置页面，单击左侧的<code>Integrations &amp; services</code>，并选择<code>Add service</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-25-25.png" alt=""></p>
<p>从下拉菜单中，选中<code>Jenkins (GitHub plugin)</code>。在新打开的界面，填写Jenkins的信息，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-27-06.png" alt=""></p>
<p>其中<code>Jenkins hook url</code>填写的是我的服务器的Jenkins地址加上<code>/GitHub-webhook/</code>，所以完整的地址为<code>http://xx.xx.xx.xx:8080/GitHub-webhook/</code>。把这里的<code>xx</code>换成实际的IP地址或者域名即可。需要注意的是，网址末尾的斜杠一定不能省略。</p>
<p>填写好信息以后保存，GitHub就配置好了。</p>
<h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><p>Jenkins需要安装<code>GitHub Plugin</code>才能接收到GitHub发来的通知。进入Jenkins的<code>系统管理</code>-<code>管理插件</code>，在<code>可选插件</code>选项卡中，搜索<code>GitHub plugin</code>并安装，安装完成Jenkins会重启。重启以后可以在<code>已安装</code>选项卡下面发现<code>GitHub plugin</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-35-50.png" alt=""></p>
<p>回到Jenkins首页，单击左上角<code>新建</code>按钮，新建一个项目，项目类型为<code>构建一个自由风格的软件项目</code>。任务的配置信息如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-37-57.png" alt=""></p>
<p>其中的<code>项目名称</code>和<code>描述</code>可以随意填写。勾选<code>GitHub project</code>，并把博客对应的GitHub Repo的地址填入。往下拉，看到<code>源码管理</code>，点选<code>Git</code>，依然填写博客对应的Repo地址。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-39-09.png" alt=""></p>
<p>继续往下拉，在<code>构建触发器</code>单击<code>增加构建步骤</code>，在弹出的下拉菜单中选择<code>Execute shell</code>。勾选<code>GitHub hook trigger for GITScm polling</code>。在<code>Execute shell</code>对应的输入框中输入命令，将当前目录下的所有文件和文件夹全部复制到<code>/home/bexercise/kingname.github.io/</code>文件夹下。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-20-43-09.png" alt=""></p>
<p>其中，文件夹<code>/home/bexercise/kingname.GitHub.io/</code>里面的内容如下图所示。这是Hexo生成的HTML文件和资源文件。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-21-06-45.png" alt=""></p>
<p>这里需要解释一下这一条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -r ./* /home/bexercise/kingname.GitHub.io/</div></pre></td></tr></table></figure>
<p>其中的<code>cp -r</code>表示复制文件和文件夹。<code>./</code>表示当前目录。<code>./*</code>表示当前目录下面的所有内容。因此整条命令的意思是把当前目录下的所有内容全部复制到<code>/home/bexercise/kingname.GitHub.io/</code>下，并且如果文件名相同，就会直接覆盖。需要注意的是，<code>kingname.GitHub.io</code>这仅仅是一个普通的文件夹而已，别看它的名字长得像个网址，但其实它只是一个名字比较怪的普通文件夹而已，没有什么特殊的意义。</p>
<p>这个项目在构建的时候，它会自动从GitHub上面对应Repo所有的文件拉取到当前的文件夹下，所以执行了这一条复制命令以后，博客HTML文件自然就被复制到了网站的根目录下。</p>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>由于Jenkins在安装的时候，会自动创建一个名为<code>jenkins</code>的普通账号，这个账号没有管理员权限。jenkins执行命令的时候，它也会使用这个账号。但是由于<code>kingname.GitHub.io</code>这个文件夹是用户<code>bexercise</code>创建的，所以<code>jenkins</code>账号默认是没有权限读写这个文件夹的。现在需要给<code>jenkins</code>账号授予权限。使用<code>bexercise</code>这个账号登录服务器，使用以下命令给<code>jenkins</code>赋予权限，让它可以读写<code>kingname.GitHub.io</code>文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R jenkins:jenkins /home/bexercise/kingname.GitHub.io</div></pre></td></tr></table></figure>
<p>执行完成这一行命令以后，jenkins才可以把其他地方的文件复制到这个文件夹里面。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>没有什么复杂的使用方法，在Hexo中，执行命令<code>hexo d</code>就可以把本地生成好的HTML文件提交到GitHub中。然后打开浏览器，打开博客，发现新的文章已经出现在首页了。</p>
<p>在Jenkins项目的执行历史里面，也可以看到它被自动触发而产生的历史记录。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-17-21-11-50.png" alt=""></p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>由于Jenkins可以运行Shell命令，进行单元测试本质上也是运行一条命令，那这不就可以实现自动进行单元测试了吗？那么如果把Shell命令改成运行一个Python脚本，那不就可以做任何事情了吗？如果Python脚本里面写了发送邮件的代码，那不就实现了你一提交代码，其他人就收到邮件了吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章比较简单，适合初学&lt;code&gt;持续集成&lt;/code&gt;的读者，本文可以帮助你对基于Jenkins的持续集成有一个比较全局的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Jenkins" scheme="https://www.kingname.info/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://www.kingname.info/tags/Jenkins/"/>
    
      <category term="CI" scheme="https://www.kingname.info/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>使用有限状态机原理实现英文分词</title>
    <link href="https://www.kingname.info/2017/12/10/use-fsm/"/>
    <id>https://www.kingname.info/2017/12/10/use-fsm/</id>
    <published>2017-12-10T04:12:55.000Z</published>
    <updated>2018-09-25T13:33:27.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>使用Python开发一个英文句子分词程序，把一段英文句子切分为每一个单词。不能导入任何官方的或者第三方的库，也不能使用字符串的split()方法。</p>
<a id="more"></a>
<h2 id="代码是如何一步一步恶化的"><a href="#代码是如何一步一步恶化的" class="headerlink" title="代码是如何一步一步恶化的"></a>代码是如何一步一步恶化的</h2><h3 id="单词与空格"><a href="#单词与空格" class="headerlink" title="单词与空格"></a>单词与空格</h3><p>对于只有单词和空格，不含其他符号的英语句子，可以使用空格来切分单词。于是对于句子<code>I am kingname</code>, 一个字符一个字符的进行遍历。首先遍历到<code>I</code>，发现它是一个字母，于是把它存到一个变量<code>word</code>中，然后遍历到空格，于是把变量<code>word</code>的值添加到变量<code>word_list</code>中，再把<code>word</code>清空。接下来遍历到字母<code>a</code>，又把<code>a</code>放到变量<code>word</code>中。再遍历到<code>m</code>，发现它还是一个字母，于是把字母<code>m</code>拼接到变量<code>word</code>的末尾。此时变量<code>word</code>的值为<code>am</code>。再遍历到第二个空格，于是把<code>word</code>的值添加到<code>word_list</code>中，清空<code>word</code>。</p>
<p>最后，由于第三个单词<code>kingname</code>的末尾没有空格，所以需要手动把它添加到列表<code>word_list</code>中。</p>
<p>完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter == <span class="string">' '</span>:</div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-03-28.png" alt=""></p>
<h3 id="单词空格与逗号句号"><a href="#单词空格与逗号句号" class="headerlink" title="单词空格与逗号句号"></a>单词空格与逗号句号</h3><p>现在不仅仅只有单词和空格，还有逗号和句号。有这样一个句子：”I am kingname,you should remember me.”如果使用上一小节的程序，那么代码就会出现问题，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-04-07.png" alt=""></p>
<p>其中，”kingname,you”应该是两个单词，但是在这里变成了一个单词。所以现在不仅遇到空格要进行切分，遇到逗号句号还需要进行切分。那么对代码做一些修改，变成如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> [<span class="string">' '</span>, <span class="string">','</span>, <span class="string">'.'</span>]:</div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname,you should remember me.'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>现在运行起来看上去没有问题了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-06-53.png" alt=""></p>
<p>然而，有些人写英文的时候喜欢在标点符号右侧加一个空格，例如：”I am kingname, you should remember me.”这样小小的一修改，上面的代码又出问题了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-09-39.png" alt=""></p>
<p>分词出来的结果里面凭空多出来一个空字符串。为了解决这个问题，再加一层判断，只有发现<code>word</code>不为空字符串的时候才把它加入到<code>word_list</code>中，代码继续修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> [<span class="string">' '</span>, <span class="string">','</span>, <span class="string">'.'</span>]:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname, you should remember me.'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>代码看起来又可以正常工作了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-12-26.png" alt=""></p>
<h3 id="单词空格与各种标点符号"><a href="#单词空格与各种标点符号" class="headerlink" title="单词空格与各种标点符号"></a>单词空格与各种标点符号</h3><p>标点符号可不仅仅只有逗号句号。现在又出现了冒号分号双引号感叹号问号等等杂七杂八的符号。英文句子变为：”I am kingname, you should say: “Kingname Oba” to me, will you?”</p>
<p>使用上面的代码，发现运行起来又出问题了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-21-15.png" alt=""></p>
<p>为了能覆盖到所有的标点符号，现在修改一下逻辑。原来是“遇到空格/逗号/句号”就把<code>word</code>放到<code>word_list</code>中。现在要改为“如果当前字符不是字母，就把<code>word</code>放到<code>word_list</code>中”。于是代码进一步做修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> constant:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'I am kingname, you should say: "Kingname Oba" to me, will you?'</span></div><div class="line">    result_word_list = split(sentence)</div><div class="line">    print(result_word_list)</div></pre></td></tr></table></figure>
<p>代码修改以后又可以正常工作了，其运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-24-52.png" alt=""></p>
<h3 id="奇奇怪怪的单引号"><a href="#奇奇怪怪的单引号" class="headerlink" title="奇奇怪怪的单引号"></a>奇奇怪怪的单引号</h3><p>如果双引号包含的句子里面还需要用到引号，那么就需要在内部使用单引号。例如有这样一个句子：“I am kingname, you should say: “Kingname Oba, I always remember your motto: ‘kingname is genius’” to me, will you?”</p>
<p>使用前面的代码，运行起来似乎没有问题，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-36-20.png" alt=""></p>
<p>但是，单引号还有其他用途——有人喜欢把两个单词合并成一个单词，例如：</p>
<ul>
<li>“do not” == “don’t”</li>
<li>“is not” == “isn’t”</li>
<li>“I will” == “I’ll”</li>
<li>“I have” == “I’ve”</li>
</ul>
<p>在这种情况下，就应该把单引号连接的两部分看作是一个单词，不应该把它们切开。</p>
<p>如果句子变成：<code>I&#39;m kingname, you should say: &quot;Kingname Oba, I always remember your motto: &#39;kingname&#39;s genius&#39;&quot; to me, won&#39;t you?</code>继续使用上面的代码，就发现返回的单词列表又不对了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-13-42-16.png" alt=""></p>
<p>要解决这个问题，就需要确定单引号具体是做普通的引号来使用，还是放在缩写里使用。</p>
<p>作为普通单引号使用的时候，如果是前单引号，那么它的左边必定不是字母，如果作为后单引号，那么它的右边必定不是字母。而缩写里面的单引号，它左右两侧必定都是字母。并且需要注意，如果是句子里面第一个符号就是单引号，那么此时它左边没有字符；如果句子里面最后一个符号是单引号，那么它右边没有字符，此时如果使用下标来查找，就需要当心下标越界。</p>
<p>对代码进一步修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(target)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> target:</div><div class="line">        <span class="keyword">return</span> []</div><div class="line">    word_list = []</div><div class="line">    word = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> enumerate(target):</div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> constant <span class="keyword">and</span> letter != <span class="string">"'"</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            word_list.append(word)</div><div class="line">            word = <span class="string">''</span></div><div class="line">        <span class="keyword">elif</span> letter == <span class="string">"'"</span>:</div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; index &lt; len(target) - <span class="number">1</span> \</div><div class="line">                    <span class="keyword">and</span> target[index - <span class="number">1</span>] <span class="keyword">in</span> constant \</div><div class="line">                    <span class="keyword">and</span> target[index + <span class="number">1</span>] <span class="keyword">in</span> constant:</div><div class="line">                word += letter</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            word += letter</div><div class="line">    <span class="keyword">if</span> word:</div><div class="line">        word_list.append(word)</div><div class="line">    <span class="keyword">return</span> word_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    sentence = <span class="string">'''I'm kingname, you should say: "Kingname Oba, </span></div><div class="line">                  I always remember your motto: 'kingname's genius'" to me, won't you?'''</div><div class="line">    result_word_list = split(sentence)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> result_word_list:</div><div class="line">        print(word)</div></pre></td></tr></table></figure>
<p>现在代码又可以成功运行了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-14-13-43.png" alt=""></p>
<p>但是请细看代码，现在已经混乱到难以阅读难以理解了。如果再增加一个连字符又怎么改？如果单词内部出现了两个单引号怎么改？这种为了增加一个功能，要把很多不相干代码也进行修改的编码方式，相信可以击中很多初学者甚至是不少自称为软件工程师的人。</p>
<h2 id="状态转义图"><a href="#状态转义图" class="headerlink" title="状态转义图"></a>状态转义图</h2><p>根据分词逻辑，遇到各种符号应该怎么处理，画一个分词的状态转移图出来。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/split_fms3.png" alt=""></p>
<p>从这个图上可以看出来，其实程序只需要知道当前是什么状态，以及遇到什么字符需要转移到什么状态就可以了。没有必要知道自己是从哪个状态转移过来的，也没有必要知道和自己不相干的其他状态。</p>
<p>举一个例子：<code>I&#39;m kingname, you should say: &quot;Kingname Oba, I always remember your motto: &#39;kingname&#39;s genius&#39;&quot; to me, won&#39;t you?</code>这个句子中，<code>should</code>这个单词就是处于“单词状态”。它不在单引号内部，它也不是一个缩写。当我们对句子每个字符进行遍历的时候，遍历到“should”的“s”时进入“单词状态”，在单词状态，只需要关心接下来过来的下一个字符是什么，如果是字母，那依然是单词状态，把字母直接拼接上来即可。如果是单引号，那么进入“单引号在单词中状态”。至于“单引号在单词中状态”有什么逻辑，单词状态的代码根本不需要知道。这就像是接力赛，我把棒交给下一个人，我的任务就做完了，下一个人是跑到终点还是爬到终点，都和我没有关系。</p>
<p>这就是有限状态机FSM的原理。</p>
<h2 id="使用状态机"><a href="#使用状态机" class="headerlink" title="使用状态机"></a>使用状态机</h2><p>根据这个原理，使用状态和转移关系来改写代码，就可以让代码的逻辑变得非常清晰。改进以后的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spliter</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.constant = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></div><div class="line">        self.state = <span class="string">'初始状态'</span></div><div class="line">        self.word = <span class="string">''</span></div><div class="line">        self.word_list = []</div><div class="line">        self.state_dict = &#123;<span class="string">'初始状态'</span>: self.parse_init,</div><div class="line">                           <span class="string">'单词状态'</span>: self.parse_word,</div><div class="line">                           <span class="string">'单引号在单词中状态'</span>: self.parse_contraction&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_init</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.state = <span class="string">'单词状态'</span></div><div class="line">            self.word += letter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_word</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.word += letter</div><div class="line">        <span class="keyword">elif</span> letter == <span class="string">"'"</span>:</div><div class="line">            self.state = <span class="string">'单引号在单词中状态'</span></div><div class="line">            self.word += <span class="string">"'"</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.word_list.append(self.word)</div><div class="line">            self.state = <span class="string">'初始状态'</span></div><div class="line">            self.word = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_contraction</span><span class="params">(self, letter)</span>:</span></div><div class="line">        <span class="keyword">if</span> letter <span class="keyword">in</span> self.constant:</div><div class="line">            self.word += letter</div><div class="line">            self.state = <span class="string">'单词状态'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.word_list.append(self.word[:<span class="number">-1</span>])</div><div class="line">            self.word = <span class="string">''</span></div><div class="line">            self.state = <span class="string">'初始状态'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(self, target)</span>:</span></div><div class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> target:</div><div class="line">            self.state_dict[self.state](letter)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.word_list</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    spliter = Spliter()</div><div class="line">    sentence = <span class="string">'''I'm kingname, you should say: "Kingname Oba, </span></div><div class="line">                      I always remember your motto: 'kingname's genius'" to me, won't you?'''</div><div class="line">    print(spliter.split(sentence))</div></pre></td></tr></table></figure></p>
<p>代码运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-12-10-15-50-27.png" alt=""></p>
<p>需要注意的是，图中的代码只是使用了有限状态机的原理，而并非一个有限状态机。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h2&gt;&lt;p&gt;使用Python开发一个英文句子分词程序，把一段英文句子切分为每一个单词。不能导入任何官方的或者第三方的库，也不能使用字符串的split()方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="FSM" scheme="https://www.kingname.info/tags/FSM/"/>
    
      <category term="有限状态机" scheme="https://www.kingname.info/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>TeamFlowy——结合Teambition与Workflowy</title>
    <link href="https://www.kingname.info/2017/10/03/teamflowy/"/>
    <id>https://www.kingname.info/2017/10/03/teamflowy/</id>
    <published>2017-10-03T15:29:05.000Z</published>
    <updated>2018-09-25T13:33:27.387Z</updated>
    
    <content type="html"><![CDATA[<p>Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-45-13.png" alt=""></p>
<p>Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-47-38.png" alt=""></p>
<p>面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。</p>
<p>当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-53-06.png" alt=""></p>
<p>但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。</p>
<a id="more"></a>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>TeamFlowy是一个Python脚本，运行以后，它会登录Workflowy账号，读取上面所有的条目。名为[Teambition]的条目是任务开始的标记，这个条目下面的一级条目会作为任务被添加到Teambition中。如果任务下面还有二级条目，这些二级条目会作为子任务被添加到任务中。由于Teambition是按照项目-Stage-任务-子任务的形式组织一个工程（其中Stage对应了Teambition中工程下面的面板，例如：“待处理”，“进行中”，“完成”。）不会存在子任务的子任务，所以Workflowy中[Teambition]这个条目下面最多出现二级缩进。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-10-28-13.png" alt=""></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="Workflowy"><a href="#Workflowy" class="headerlink" title="Workflowy"></a>Workflowy</h3><p>获取Workflowy上面的条目，需要进行三步操作：</p>
<ol>
<li>登录Workflowy</li>
<li>获取所有条目对应的JSON字符串</li>
<li>提取需要添加到Teambition中的条目</li>
</ol>
<h4 id="登录Workflowy"><a href="#登录Workflowy" class="headerlink" title="登录Workflowy"></a>登录Workflowy</h4><p>打开Chrome监控登录Wokrflowy的过程，可以看到登录Workflowy需要访问的接口为：<code>https://workflowy.com/accounts/login/</code>。使用HTTP <code>POST</code>方式发送请求，提交的数据包括<code>username</code>，<code>password</code>和一个不知道用途的<code>next</code>。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-10-47-51.png" alt=""></p>
<p>使用Python的第三方网络模块<code>requests</code>向这个模块发送<code>POST</code>请求，提交用户名和密码即可实现登录。其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">login_url = <span class="string">'https://workflowy.com/accounts/login/'</span></div><div class="line">session = requests.Session()</div><div class="line">session.post(login_url,</div><div class="line">             data=&#123;<span class="string">'username'</span>: <span class="string">'12345@qq.com'</span>,</div><div class="line">                   <span class="string">'password'</span>: <span class="string">'8888888'</span>,</div><div class="line">                   <span class="string">'next'</span>: <span class="string">''</span>&#125;)</div></pre></td></tr></table></figure>
<h4 id="获取所有条目"><a href="#获取所有条目" class="headerlink" title="获取所有条目"></a>获取所有条目</h4><p>使用<code>requests</code>的<code>session</code>登录Workflowy以后，Cookies会被自动保存到<code>session</code>这个对象里面。于是使用<code>session</code>继续访问Workfowy就可以以登录后的身份查看自己的各个条目。</p>
<p>通过Chrome可以看到获取所有条目的接口为<code>https://workflowy.com/get_initialization_data?client_version=18</code>，接口返回的数据是一个包含所有条目的超大型JSON字符串，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-10-55-40.png" alt=""></p>
<p>使用Python的json模块可以解析这个JSON字符串为字典，并获取所有条目，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">outline_url = <span class="string">'https://workflowy.com/get_initialization_data?client_version=18'</span></div><div class="line">outlines_json = session.get(outline_url).text</div><div class="line">outlines_dict = json.loads(outlines_json)</div><div class="line">project_list = outlines_dict.get(<span class="string">'projectTreeData'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'mainProjectTreeInfo'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'rootProjectChildren'</span>, [])</div></pre></td></tr></table></figure>
<h4 id="提取任务与子任务"><a href="#提取任务与子任务" class="headerlink" title="提取任务与子任务"></a>提取任务与子任务</h4><p>所有的条目层层嵌套在列表-字典结构中，其基本的形态如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"ch"</span>: [子条目], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">308496</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"957996b9-67ce-51c7-a796-bfbee44e3d3f"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"AutoEmo"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>nm</code>为这个条目的名字。如果一个条目有子条目，那么<code>ch</code>列表中就会有很多个字典，每个字典的都是这个结构，如果一个条目没有子条目，那么就没有<code>ch</code>这个key。这样一层一层嵌套下去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> &#123;</div><div class="line">    <span class="string">"ch"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"5117e20b-25ba-ba91-59e1-790c0636f78e"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"准备并熟背一段自我介绍，在任何需要自我介绍的场合都有用"</span></div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fb315fc4e6f"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"姓名，来自哪里，什么工作"</span>,</div><div class="line">            <span class="string">"ch"</span>: [</div><div class="line">                &#123;<span class="string">"lm"</span>: <span class="number">5435246</span>, </div><div class="line">                 <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fbadfasdc4e6f"</span>, </div><div class="line">                 <span class="string">"nm"</span>: <span class="string">"工作经验"</span>&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"ea282a1c-94f3-1a44-c5b3-7907792e9e6e"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"自我介绍"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于条目和子条目的结构是一样的，那么就可以使用递归来解析每一个条目。由于需要添加到Teambition的任务，从名为[Teambition]的条目开始，于是可以使用下面这样一个函数来解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">task_dict = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_task</span><span class="params">(sections, task_dict, target_section=False)</span>:</span></div><div class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> sections:</div><div class="line">        name = section[<span class="string">'nm'</span>]</div><div class="line">        <span class="keyword">if</span> target_section:</div><div class="line">            task_dict[name] = [x[<span class="string">'nm'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> section.get(<span class="string">'ch'</span>, [])]</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'[Teambition]'</span>:</div><div class="line">            target_section = <span class="keyword">True</span></div><div class="line">        sub_sections = section.get(<span class="string">'ch'</span>, [])</div><div class="line">        extract_task(sub_sections, task_dict, target_section=target_section)</div></pre></td></tr></table></figure>
<p>下图所示为一段需要添加到Teambition中的条目，运行这段函数以后，得到的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'登录Workflowy'</span>: [], <span class="string">'获取需要添加到Teambition的内容'</span>: [<span class="string">'获取任务'</span>, <span class="string">'获取子任务'</span>], <span class="string">'调试Teambition API'</span>: [], <span class="string">'添加任务到Teambition'</span>: []&#125;</div></pre></td></tr></table></figure>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-09-03.png" alt=""></p>
<h2 id="Teambition"><a href="#Teambition" class="headerlink" title="Teambition"></a>Teambition</h2><p>将任务添加到Teambition，需要使用Teambition的Python SDK登录Teambition并调用API添加任务。Teambition的Python SDK在使用<code>OAuth2</code>获取<code>access_token</code>的时候有一个坑，需要特别注意。</p>
<h3 id="登录Teambition"><a href="#登录Teambition" class="headerlink" title="登录Teambition"></a>登录Teambition</h3><h4 id="设置Teambition应用"><a href="#设置Teambition应用" class="headerlink" title="设置Teambition应用"></a>设置Teambition应用</h4><p>Teambition 是使用<code>OAuth2</code>来进行权限验证的，所以需要获取<code>access_token</code>。</p>
<p>首先打开Teambition的<a href="https://developer.teambition.com/dashboard" target="_blank" rel="external">开发者中心</a>并单击<code>新建应用</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-14-38.png" alt=""></p>
<p>应用名称可以随便写。创建好应用以后，可以看到应用的信息，需要记录<code>Client ID</code>和<code>Client Secret</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-18-20.png" alt=""></p>
<p>点击左侧的<code>OAuth2</code>配置，填写回调URL，如下图所示。这里的这个URL其实使用任何一个可以访问的网站的域名都可以，这里以我的博客地址为例。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-20-49.png" alt=""></p>
<h4 id="使用Python获取access-token"><a href="#使用Python获取access-token" class="headerlink" title="使用Python获取access_token"></a>使用Python获取access_token</h4><p>首先在Python中安装Teambition的SDK：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install teambition</div></pre></td></tr></table></figure>
<p>接下来，在Python中获取授权URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> teambition <span class="keyword">import</span> Teambition</div><div class="line"></div><div class="line">tb_client_id = <span class="string">'7bfae080-a8dc-11e7-b543-77a936726657'</span></div><div class="line">tb_client_secret = <span class="string">'9830fc8c-81b3-45ed-b3c0-e039ab8f2d8b'</span></div><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret)</div><div class="line">authorize_url = tb.oauth.get_authorize_url(<span class="string">'https://kingname.info'</span>)</div><div class="line">print(authorize_url)</div></pre></td></tr></table></figure>
<p>代码运行以后，会得到一段形如下面这段URL的授权URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://account.teambition.com/oauth2/authorize?client_id=7bfae080-a8dc-11e7-b543-77a936726657&amp;redirect_uri=https://kingname.info&amp;state=&amp;lang=zh</div></pre></td></tr></table></figure>
<p>在电脑浏览器中<strong>人工</strong>访问这个URL，会出现下面这样的页面。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-31-25.png" alt=""></p>
<p>单击<code>授权并登录</code>，可以看到浏览器上面的网址变为形如：<code>https://kingname.info/?code=Pn7ebs4sZh3NYOz2FvVJQ4uu</code>，此时，需要记录<code>code=</code>后面的这一串字符串<code>Pn7ebs4sZh3NYOz2FvVJQ4uu</code>。</p>
<p>接下来就是Teambition的SDK的坑点了，根据Teambition官方文档的说法，要获取access_token，只需要如下两段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">tb.oauth.fetch_access_token(code)</div><div class="line"><span class="comment"># 上面的代码完成授权，接下来直接使用tb.xxxx就可以操作任务了。</span></div></pre></td></tr></table></figure>
<p>但实际上，上面这一段代码一定会报错。提示<code>grant invaild</code>。要解决这个问题，就必需使用Teambition的HTTP 接口来人工获取access_token。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">fetch_result_dict = session.post(<span class="string">'https://account.teambition.com/oauth2/access_token'</span>,</div><div class="line">                  data=&#123;<span class="string">'client_id'</span>: tb_client_id,</div><div class="line">                        <span class="string">'client_secret'</span>: tb_client_secret,</div><div class="line">                        <span class="string">'code'</span>: code,</div><div class="line">                        <span class="string">'grant_type'</span>: <span class="string">'code'</span>&#125;).json()</div><div class="line">tb_access_token = fetch_result_dict.get(<span class="string">'access_token'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p>此时得到的access_token是一段非常长的字符串。接下来，重新初始化tb变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret,</div><div class="line">                access_token=tb_access_token)</div></pre></td></tr></table></figure>
<p>初始化以后，使用tb这个变量，就可以对工程和任务进行各种操作了。</p>
<h4 id="Teambition的简单使用"><a href="#Teambition的简单使用" class="headerlink" title="Teambition的简单使用"></a>Teambition的简单使用</h4><p>要在某个工程里面创建任务，就需要知道工程的ID。首先在Teambition中手动创建一个工程，在浏览器中打开工程，URL中可以看到工程的ID，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-45-51.png" alt=""></p>
<p>有了工程ID以后，就可以使用下面的代码创建任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(task_name, sub_task_list)</span>:</span></div><div class="line">    tasklist = tb.tasklists.get(project_id=<span class="string">'59d396ee1013d919f3348675'</span>)[<span class="number">0</span>]</div><div class="line">    tasklist_id = tasklist[<span class="string">'_id'</span>]</div><div class="line">    todo_stage_id = tasklist[<span class="string">'stageIds'</span>][<span class="number">0</span>]</div><div class="line">    task_info = tb.tasks.create(task_name, tasklist_id=tasklist_id, stage_id=todo_stage_id)</div><div class="line">    <span class="keyword">if</span> sub_task_list:</div><div class="line">        task_id = task_info[<span class="string">'_id'</span>]</div><div class="line">        <span class="keyword">for</span> sub_task_name <span class="keyword">in</span> sub_task_list:</div><div class="line">            tb.subtasks.create(sub_task_name, task_id=task_id)</div><div class="line">    print(f<span class="string">'task: &#123;task_name&#125; with sub tasks: &#123;sub_task_list&#125; added.'</span>)</div></pre></td></tr></table></figure>
<p>这段代码首先使用<code>tb.tasklists.get()</code>根据工程ID获得任务组的ID和<code>待处理</code>这个面板的ID，接下来调用<code>tb.tasks.create()</code>接口添加任务。从添加任务返回的信息里面拿到任务的ID，再根据任务ID，调用<code>tb.subtasks.create()</code>添加子任务ID。</p>
<h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>上面的代码实现了TeamFlowy的基本逻辑。运行TeamFlowy脚本以后，[Teambition]这个条目下面的任务被成功的添加到了Teambition中，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-16-55-34.png" alt=""></p>
<p>将代码组合起来并进行完善，让代码更容易使用，完整的代码可以查看<a href="https://github.com/kingname/TeamFlowy" target="_blank" rel="external">https://github.com/kingname/TeamFlowy</a>。完整的代码运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-04-17-01-11.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-45-13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-47-38.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。&lt;/p&gt;
&lt;p&gt;当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-10-03-23-53-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://www.kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Workflowy" scheme="https://www.kingname.info/tags/Workflowy/"/>
    
      <category term="Teambition" scheme="https://www.kingname.info/tags/Teambition/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1709</title>
    <link href="https://www.kingname.info/2017/09/22/tweet-201709/"/>
    <id>https://www.kingname.info/2017/09/22/tweet-201709/</id>
    <published>2017-09-22T14:34:01.000Z</published>
    <updated>2018-09-25T13:33:27.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-09"><a href="#2017-09" class="headerlink" title="2017.09"></a>2017.09</h2><p>在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：<code>Command</code> + <code>Option</code> + <code>C</code></p>
<hr>
<p>以KB，MB，GB方式显示文件大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lh</div></pre></td></tr></table></figure></p>
<hr>
<p>删除超大文本文件的特定行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'10000,50000d'</span> xxx.txt &gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt</div></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<p>切分超大文本文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split -b 2G <span class="_">-d</span> <span class="_">-a</span> 2 deletelines.txt  da  //把超大文件切分为多个文件，每个文件2GB，前缀为da，后缀为2位数字</div></pre></td></tr></table></figure>
<hr>
<p>修改Linux当前用户密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd</div></pre></td></tr></table></figure>
<hr>
<p>使用Python打开一个未知编码的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">"your_file"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</div><div class="line">    file_data = fp.read()</div><div class="line">    result = chardet.detect(file_data)</div><div class="line">    file_content = file_data.decode(encoding=result[<span class="string">'encoding'</span>])</div></pre></td></tr></table></figure></p>
<h2 id="2017-08"><a href="#2017-08" class="headerlink" title="2017.08"></a>2017.08</h2><p>在SSH + Tmux中，如果想复制，按住<code>Alt</code>或者<code>Option</code>键再选择就可以复制了。</p>
<hr>
<p>关闭requests的SSL警告<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">requests.packages.urllib3.disable_warnings()</div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM中，<code>Crtl</code> + <code>V</code> <code>Ctrl</code> + <code>A</code>可以输出特殊符合<code>^A</code>，把A改为可以得到<code>^M</code></p>
<h2 id="2017-07"><a href="#2017-07" class="headerlink" title="2017.07"></a>2017.07</h2><p>在Python中，pymongo的find方法返回的是一个生成器，只有在迭代的时候才会执行里面的具体代码去读MongoDB。但是在Golang的Mgo包中，如果想让Find返回一个迭代器而不是直接把所有结果全部返回，就需要手动指定：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> xInfo <span class="keyword">struct</span> &#123;</div><div class="line">	ID <span class="keyword">int</span> <span class="string">`bson:"mt_poi_id"`</span></div><div class="line">	Count <span class="keyword">int</span> <span class="string">`bson:"count"`</span></div><div class="line">&#125;</div><div class="line">resultIter = m.handler.Find(<span class="literal">nil</span>).Select(bson.M&#123;<span class="string">"_id"</span>: <span class="number">0</span>, <span class="string">"mt_poi_id"</span>: <span class="number">1</span>, <span class="string">"count"</span>: <span class="number">1</span>&#125;).Iter()</div><div class="line"><span class="keyword">var</span> x xInfo</div><div class="line"><span class="keyword">for</span> resultIter.Next(&amp;xInfo) &#123;</div><div class="line">    fmt.Println(xInfo.Id)</div><div class="line">    fmt.Println(xInfo.Count)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2017-06"><a href="#2017-06" class="headerlink" title="2017.06"></a>2017.06</h2><p>在Golang中，使用MySQL的事务：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// paraArray为一个channel，里面是更新所需要的参数</span></div><div class="line">tx, _ := db.Begin()</div><div class="line">    <span class="keyword">for</span> _, para := <span class="keyword">range</span> paraArray&#123;</div><div class="line">        tx.Exec(<span class="string">"update....."</span>, para) </div><div class="line">    &#125;</div><div class="line">    tx.Commit()</div></pre></td></tr></table></figure></p>
<hr>
<p>由于更新MySQL会锁表，因此使用多个goroutine来更新MySQL，效果可能还不如直接在主线程中更新来的高。</p>
<hr>
<p>在Golang中，使用goroutine太多反而会导致性能下降。</p>
<h2 id="2017-05"><a href="#2017-05" class="headerlink" title="2017.05"></a>2017.05</h2><p>在Python中，可以使用<code>&gt;</code>或者<code>&gt;=</code>来判断一个集合是不是另一个集合的子集。只有是子集才会返回<code>True</code><br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-05-04-09-58-18.png" alt=""></p>
<h2 id="2017-04"><a href="#2017-04" class="headerlink" title="2017.04"></a>2017.04</h2><p>在MongoDB中，通过_id来更新数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line">conn = pymongo.MongoClient().XX.YY</div><div class="line">conn.update(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'adf84a8fafasf3213'</span>), &#123;<span class="string">'$set'</span>: &#123;<span class="string">'name'</span>: <span class="string">'aaa'</span>&#125;&#125;&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p>在Python 3中，计算两个日期相隔了多少秒：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"></div><div class="line">start = <span class="string">'2017-03-21 17:21:30'</span></div><div class="line">end = <span class="string">'2017-03-21 18:10:13'</span></div><div class="line"></div><div class="line">start_datetime = datetime.datetime.strptime(start, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">end_datetime = datetime.datetime.strptime(end, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"></div><div class="line">total_seconds = (end_datetime - start_datetime).total_seconds()</div></pre></td></tr></table></figure></p>
<hr>
<p>Scrapy中，通过覆写items.py中，每个item的__repr__方法，可以减少打印出来的Log信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXItem</span><span class="params">(Item)</span>:</span></div><div class="line">    name = Field()</div><div class="line">    age = Field()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'======data has been stored.======='</span></div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM粘贴Python代码的时候，缩进会一不小心爆炸。为了避免这个问题，应该先在normal模式输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set paste</div></pre></td></tr></table></figure></p>
<p>回车，再按i，再粘贴。这样Python的缩进就不会乱掉了。</p>
<hr>
<p>Selenium的Debug级的Log有时候打得太多了，为了去掉Selenium的Debug Log又不影响其他部份的Debug Log，可以使用如下命令完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">from</span> selenium.webdriver.remote.remote_connection <span class="keyword">import</span> LOGGER</div><div class="line">LOGGER.setLevel(logging.WARNING)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017-09&quot;&gt;&lt;a href=&quot;#2017-09&quot; class=&quot;headerlink&quot; title=&quot;2017.09&quot;&gt;&lt;/a&gt;2017.09&lt;/h2&gt;&lt;p&gt;在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：&lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;Option&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以KB，MB，GB方式显示文件大小&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ls -lh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;删除超大文本文件的特定行数&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed &lt;span class=&quot;_&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;10000,50000d&#39;&lt;/span&gt; xxx.txt &amp;gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://www.kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="Craft" scheme="https://www.kingname.info/tags/Craft/"/>
    
  </entry>
  
  <entry>
    <title>Tenacity——Exception Retry 从此无比简单</title>
    <link href="https://www.kingname.info/2017/06/18/easy-retry/"/>
    <id>https://www.kingname.info/2017/06/18/easy-retry/</id>
    <published>2017-06-17T16:17:47.000Z</published>
    <updated>2018-09-25T13:33:27.398Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://kingname.info/2017/04/17/decorate-for-method/" target="_blank" rel="external">Python 装饰器装饰类中的方法</a>这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。</p>
<p>在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。</p>
<a id="more"></a>
<p>以爬虫开发为例，由于网页返回的源代码有各种不同的情况，因此捕获异常并重试是很常见的要求。下面这几段代码是我多年以前，在刚开始学习爬虫的时候，由于捕获异常并重试导致代码混乱化过程。</p>
<p>代码一开始的逻辑非常简单，获取网页后台API返回的JSON字符串，转化成字典，提取出里面<code>data</code>的数据，然后传递给<code>save()</code>函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>代码运行一段时间，发现有时候JSON会随机出现解析错误。于是添加捕获异常并重试的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        extract(url)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>后来又发现，有部份的URL会导致递归深度超过最大值。这是因为有一些URL返回的是数据始终是错误的，而有些URL，重试几次又能返回正常的JSON数据，于是限制只重试3次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">            <span class="keyword">if</span> extract(url):</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>后来又发现，不能立刻重试，重试要有时间间隔，并且时间间隔逐次增大……</p>
<p>从上面的例子中可以看到，对于异常的捕获和处理，一不小心就让整个代码变得很难看很难维护。为了解决这个问题，就需要通过装饰器来完成处理异常并重试的功能。</p>
<p>Python 有一个第三方库，叫做<a href="http://tenacity.readthedocs.io/en/latest/" target="_blank" rel="external">Tenacity</a>，它实现了一种优雅的重试功能。</p>
<p>以上面爬虫最初的无限重试版本为例，如果想实现遇到异常就重试。只需要添加两行代码，爬虫的主体函数完全不需要做修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry</div><div class="line"></div><div class="line"><span class="meta">@retry</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在要限制重试次数为3次，代码总行数不需要新增一行就能实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</div><div class="line"></div><div class="line"><span class="meta">@retry(stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在想每5秒钟重试一次，代码行数也不需要增加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_fixed</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_fixed(5))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>甚至重试的时间间隔想指数级递增，代码行数也不需要增加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_exponential</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_exponential(multiplier=1, max=10)) # 重试时间间隔满足：2^n * multiplier, n为重试次数，但最多间隔10秒</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure></p>
<p>重试不仅可以限制次数和间隔时间，还可以针对特定的异常进行重试。在爬虫主体中，其实有三个地方可能出现异常: </p>
<ul>
<li>requests获取网页出错</li>
<li>解析JSON出错</li>
<li>info_dict字典里面没有<code>data</code>这个key</li>
</ul>
<p>如果只需要在JSON解析错误时重试，由于异常类型为<code>json.decoder.JSONDecodeError</code>，所以就可以通过参数来进行限制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>当然，这些特性都可以进行组合，例如只对<code>JSONDecodeError</code> 进行重试，每次间隔5秒，重试三次，那就写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type, wait_fixed, stop_after_attempt</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>自始至终，爬虫主体的代码完全不需要做任何修改。</p>
<p>Tenacity是我见过的，最 Pythonic ，最优雅的第三方库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://kingname.info/2017/04/17/decorate-for-method/&quot;&gt;Python 装饰器装饰类中的方法&lt;/a&gt;这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Exception" scheme="https://www.kingname.info/tags/Exception/"/>
    
      <category term="Tenacity" scheme="https://www.kingname.info/tags/Tenacity/"/>
    
  </entry>
  
  <entry>
    <title>记住变量类型的三种方式</title>
    <link href="https://www.kingname.info/2017/06/11/type-hints-in-python3/"/>
    <id>https://www.kingname.info/2017/06/11/type-hints-in-python3/</id>
    <published>2017-06-11T07:25:03.000Z</published>
    <updated>2018-09-25T13:33:27.428Z</updated>
    
    <content type="html"><![CDATA[<p>Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。</p>
<a id="more"></a>
<p>假设有一个变量<code>is_request_finished</code>，从名字上来看，这个变量的值应该为<code>True</code>或者<code>False</code>，在写代码的时候，最初也确实是这样定义的。但是可能由于某些原因，在某一次赋值的时候，<code>is_request_finished = &#39;True&#39;</code>。此时，如果代码的单元测试不够完善，那么<code>if is_request_finished</code>在 <code>is_request_finished = True</code> 和 <code>is_request_finished = &#39;True&#39;</code>的时候都成立，问题被隐藏了。但是当<code>is_request_finished = &#39;False&#39;</code>的时候，由于<code>&#39;False&#39;</code>作为一个非空字符串，就会使得<code>if is_request_finished</code> 依然成立，从而使程序的行为发现异常。</p>
<p>单个变量的类型异常也许还容易发现，但是如果变量是放在字典或者列表里面，那就比较麻烦了。假设需要保存一段个人信息，于是创建了下面这样一个列表套字典的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">person_list = [&#123;</div><div class="line">        &apos;name&apos;: &apos;kingname&apos;,</div><div class="line">        &apos;age&apos;: 23,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;xxx&apos;,</div><div class="line">                    &apos;work&apos;: &apos;engineer&apos;,</div><div class="line">                    &apos;salary&apos;: 100000</div><div class="line">            &#125;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">        &apos;name&apos;: &apos;xiaoming&apos;,</div><div class="line">        &apos;age&apos;: 65,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;yyy&apos;,</div><div class="line">                    &apos;work&apos;: &apos;pm&apos;,</div><div class="line">                    &apos;salary&apos;: 0.5</div><div class="line">            &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>这种方式开发起来非常的快速而方便，但是其他人甚至是开发者自己在一段时间以后读代码，都会有一种想抽死自己的冲动。因为根本不知道这个变量里面保存的是什么东西。</p>
<p>针对以上问题，常见的解决办法有三种。</p>
<h2 id="Type-Hints-与-Variable-Annotations"><a href="#Type-Hints-与-Variable-Annotations" class="headerlink" title="Type Hints 与 Variable Annotations"></a>Type Hints 与 Variable Annotations</h2><p>在<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="external">PEP 484</a>中，引入了Type Hints，在<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">PEP 526</a>中引入了Variable Annotations。它使得Python 3.6及以后的Python 代码拥有了“声明”变量类型的能力。这里的“声明”之所以会打引号，是因为这个声明是给IDE和人看的。这个声明对 Python 的解释器无效。</p>
<h3 id="Type-Hints"><a href="#Type-Hints" class="headerlink" title="Type Hints"></a>Type Hints</h3><p>PyCharm现在已经可以比较好地支持Type Hints了。例如下面这一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url)</span>:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>模拟一段上传文件的函数，上传成功以后返回True。接收一个参数<code>url</code>。在正常情况下，这个<code>url</code>应该是一个字符串。于是，使用Type Hints，代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url: str)</span> -&gt; bool:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如果直接运行，其运行效果如下图所示：<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-23-11.png" alt=""></p>
<p>现在假设传递一个不是字符串的变量给<code>upload</code>函数，此时PyCharm就会提示类型有问题，如下图所示：<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-24-35.png" alt=""><br>但提示归提示，强行运行也是没有问题的。这就说明Type Hints主要是给IDE和人用的，解释器并不会关心类型正不正确。</p>
<p>如果修改这个函数的返回值，让它不返回<code>True</code> 或者<code>False</code>，PyCharm 也会发出警告：<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-27-49.png" alt=""></p>
<p>Type Hints的官方文档，可以参阅：<a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="external">typing — Support for type hints</a></p>
<h3 id="Variable-Annotations"><a href="#Variable-Annotations" class="headerlink" title="Variable Annotations"></a>Variable Annotations</h3><p>对于Variable Annotations，如下图所示，虽然目前PyCharm还不能很好地提示变量类型不对，但是人在读代码的时候，还是会起到一定的帮助。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-32-23.png" alt=""></p>
<p>除了这种写法外，Variable Annotations还支持把类型写在注释中，如下图所示：<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-35-15.png" alt=""></p>
<p>虽然PyCharm不能起到很好的提示作用，但是可以使用一个第三方库<code>mypy</code>来对代码做静态检查，其运行效果如下图所示，可以发现赋值的类型与声明的类型不一致(expression has type “str”, variable has type “bool”, 表达式的类型为“str”，变量的类型是“bool”)。<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-41-12.png" alt=""></p>
<p>关于Variable Annotations的更多用法，可以参阅：<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">Syntax for Variable Annotations</a><br>关于Mypy，可以参阅它的官方文档：<a href="http://mypy.readthedocs.io/en/stable/index.html" target="_blank" rel="external">Mypy documentation</a></p>
<h2 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h2><p>在docstring来标注变量的类型，如下图所示：<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2017-06-11-16-48-18.png" alt=""><br>这种写法可以用来提示一个函数，或者一个类它里面的各个变量的情况。但是详细程度需要看开发者有没有耐心把这个注释写清楚。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>这种方法来自与Java Bean的思想，它主要用来解决列表套字典，字典套字典，字典套列表，列表套列表这种深层的嵌套关系。关于这个方法，请参阅另一篇文章：<a href="http://kingname.info/2016/06/19/bean-in-python/" target="_blank" rel="external">可爱的豆子——使用Beans思想让Python代码更易维护</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
</feed>
