<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2020-01-01T11:08:53.318Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNE v0.1 正式发布： 4 行代码开发新闻网站通用爬虫</title>
    <link href="https://www.kingname.info/2020/01/01/gne-release/"/>
    <id>https://www.kingname.info/2020/01/01/gne-release/</id>
    <published>2020-01-01T11:07:33.000Z</published>
    <updated>2020-01-01T11:08:53.318Z</updated>
    
    <content type="html"><![CDATA[<p>GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。</p>
<a id="more"></a>
<p>使用方式非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">html = <span class="string">'网站源代码'</span></div><div class="line">result = extractor.extract(html)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>GNE 的输入是<code>经过 js 渲染以后的</code> HTML 代码，所以 GNE 可以配合Selenium 或者 Pyppeteer 使用。</p>
<p>下图是 GNE 配合 Selenium 实现的一个 Demo：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-51-47.png" alt=""></p>
<p>对应的代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</div><div class="line"></div><div class="line"></div><div class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</div><div class="line">driver.get(<span class="string">'https://www.toutiao.com/a6766986211736158727/'</span>)</div><div class="line">time.sleep(<span class="number">3</span>)</div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(driver.page_source)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>下图是 GNE 配合 Pyppeteer 实现的 Demo：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-07-14.png" alt=""></p>
<p>对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    browser = <span class="keyword">await</span> launch(executablePath=<span class="string">'/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'</span>)</div><div class="line">    page = <span class="keyword">await</span> browser.newPage()</div><div class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://news.163.com/20/0101/17/F1QS286R000187R2.html'</span>)</div><div class="line">    extractor = GeneralNewsExtractor()</div><div class="line">    result = extractor.extract(<span class="keyword">await</span> page.content())</div><div class="line">    print(result)</div><div class="line">    input(<span class="string">'检查完成以后回到这里按下任意键'</span>)</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
<h2 id="如何安装-GNE"><a href="#如何安装-GNE" class="headerlink" title="如何安装 GNE"></a>如何安装 GNE</h2><p>现在你可以直接使用 pip 安装 GNE 了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install gne</div></pre></td></tr></table></figure>
<p>如果访问pypi 官方源太慢，你也可以使用网易源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install gne -i https://mirrors.163.com/pypi/simple/</div></pre></td></tr></table></figure>
<p>安装过程如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-34-36.png" alt=""></p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><h3 id="获取正文源代码"><a href="#获取正文源代码" class="headerlink" title="获取正文源代码"></a>获取正文源代码</h3><p>在<code>extract()</code>方法只传入网页源代码，不添加任何额外参数时，GNE 返回如下字段：</p>
<ul>
<li>title：新闻标题</li>
<li>publish_time：新闻发布时间</li>
<li>author：新闻作者</li>
<li>content：新闻正文</li>
<li>images: 正文中的图片（相对路径或者绝对路径）</li>
</ul>
<p>可能有些朋友希望获取新闻正文所在标签的源代码，此时可以给<code>extract()</code>方法传入<code>with_body_html</code>参数，设置为 True：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, with_body_html=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>返回数据中将会增加一个字段<code>body_html</code>，它的值就是正文对应的 HTML 源代码。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-16-25.png" alt=""></p>
<h3 id="总是返回图片的绝对路径"><a href="#总是返回图片的绝对路径" class="headerlink" title="总是返回图片的绝对路径"></a>总是返回图片的绝对路径</h3><p>默认情况下，如果新闻中的图片使用的是相对路径，那么 GNE 返回的<code>images</code>字段对应的值也是图片相对路径的列表。</p>
<p>如果你想始终让 GNE 返回绝对路径，那么你可以给<code>extract()</code>方法增加<code>host</code>参数，这个参数的值是图片的域名，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, host=<span class="string">'https://www.kingname.info'</span>)</div></pre></td></tr></table></figure>
<p>这样，如果新闻中的图片是<code>/images/pic.png</code>，那么 GNE 返回时会自动把它变为<code>https://www.kingname.info/images/pic.png</code>。</p>
<h3 id="指定新闻标题所在的-XPath"><a href="#指定新闻标题所在的-XPath" class="headerlink" title="指定新闻标题所在的 XPath"></a>指定新闻标题所在的 XPath</h3><p>GNE 预定义了一组 XPath 和正则表达式用于提取新闻的标题。但某些特殊的新闻网站可能无法提取标题，此时，你可以给<code>extract()</code>方法指定<code>title_xpath</code>参数，用于提取新闻标题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, title_xpath=<span class="string">'//title/text()'</span>)</div></pre></td></tr></table></figure>
<h3 id="提前移除噪声标签"><a href="#提前移除噪声标签" class="headerlink" title="提前移除噪声标签"></a>提前移除噪声标签</h3><p>某些新闻下面可能会存在长篇大论的评论，这些评论看起来比新闻正文“更像”正文，为了防止他们干扰新闻的提取，可以通过给<code>extract()</code>方法传入<code>noise_node_list</code>参数，提前把这些噪声节点移除。<code>noise_node_list</code>的值是一个列表，里面是一个或多个 XPath：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, noise_node_list=[<span class="string">'//div[@class="comment-list"]'</span>, <span class="string">'//*[@style="display:none"]'</span>])</div></pre></td></tr></table></figure>
<h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>API 中的参数 <code>title_xpath</code>、 <code>host</code>、 <code>noise_node_list</code>、 <code>with_body_html</code>除了直接写到 <code>extract()</code> 方法中外，还可以通过一个配置文件来设置。</p>
<p>请在项目的根目录创建一个文件 <code>.gne</code>，配置文件可以用 YAML 格式，也可以使用 JSON 格式。</p>
<ul>
<li>YAML 格式配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span></div><div class="line"><span class="attr">   xpath:</span> //title/text()</div><div class="line"><span class="attr">host:</span> https://www.xxx.com</div><div class="line"><span class="attr">noise_node_list:</span></div><div class="line"><span class="bullet">   -</span> //div[@class=\<span class="string">"comment-list\"]</span></div><div class="line">   - //*[@style=\"display:none\"]</div><div class="line">with_body_html: true</div></pre></td></tr></table></figure>
<ul>
<li>JSON 格式配置文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"title"</span>: &#123;</div><div class="line">       <span class="attr">"xpath"</span>: <span class="string">"//title/text()"</span></div><div class="line">   &#125;,</div><div class="line">   <span class="attr">"host"</span>: <span class="string">"https://www.xxx.com"</span>,</div><div class="line">   <span class="attr">"noise_node_list"</span>: [<span class="string">"//div[@class=\"comment-list\"]"</span>,</div><div class="line">                       <span class="string">"//*[@style=\"display:none\"]"</span>],</div><div class="line">   <span class="attr">"with_body_html"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种写法是完全等价的。</p>
<p>配置文件与 <code>extract()</code> 方法的参数一样，并不是所有字段都需要提供。你可以组合填写你需要的字段。</p>
<p>如果一个参数，既在 <code>extract()</code> 方法中，又在 <code>.gne</code> 配置文件中，但值不一样，那么 <code>extract()</code> 方法中的这个参数的优先级更高。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="GeneralNewsExtractor-以下简称GNE-是爬虫吗？"><a href="#GeneralNewsExtractor-以下简称GNE-是爬虫吗？" class="headerlink" title="GeneralNewsExtractor(以下简称GNE)是爬虫吗？"></a>GeneralNewsExtractor(以下简称GNE)是爬虫吗？</h3><p>GNE不是爬虫，它的项目名称General News Extractor表示通用新闻抽取器。它的输入是HTML，输出是一个包含新闻标题，新闻正文，作者，发布时间的字典。你需要自行设法获取目标网页的HTML。</p>
<p>GNE 现在不会，将来也不会提供请求网页的功能。</p>
<h3 id="GNE支持翻页吗？"><a href="#GNE支持翻页吗？" class="headerlink" title="GNE支持翻页吗？"></a>GNE支持翻页吗？</h3><p>GNE不支持翻页。因为GNE不会提供网页请求的功能，所以你需要自行获取每一页的HTML，并分别传递给GNE。</p>
<h3 id="GNE支持哪些版本的Python？"><a href="#GNE支持哪些版本的Python？" class="headerlink" title="GNE支持哪些版本的Python？"></a>GNE支持哪些版本的Python？</h3><p>不小于Python 3.6.0</p>
<h3 id="我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？"><a href="#我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？" class="headerlink" title="我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？"></a>我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？</h3><p>GNE是基于HTML来提取正文的，所以传入的HTML一定要是经过JavaScript渲染以后的HTML。而requests和Scrapy获取的只是JavaScript渲染之前的源代码，所以无法正确提取。</p>
<p>另外，有一些网页，例如今日头条，它的新闻正文实际上是以JSON格式直接写在网页源代码的，当页面在浏览器上面打开的时候，JavaScript把源代码里面的正文解析为HTML。这种情况下，你在Chrome上面就看不到Ajax请求。</p>
<p>所以建议你使用Puppeteer/Pyppeteer/Selenium之类的工具获取经过渲染的HTML再传入GNE。</p>
<h3 id="GNE-支持非新闻类网站吗（例如博客、论坛……）"><a href="#GNE-支持非新闻类网站吗（例如博客、论坛……）" class="headerlink" title="GNE 支持非新闻类网站吗（例如博客、论坛……）"></a>GNE 支持非新闻类网站吗（例如博客、论坛……）</h3><p>不支持。</p>
<h2 id="关于-GNE"><a href="#关于-GNE" class="headerlink" title="关于 GNE"></a>关于 GNE</h2><p>GNE 官方文档：<a href="https://generalnewsextractor.readthedocs.io/" target="_blank" rel="external">https://generalnewsextractor.readthedocs.io/</a></p>
<p>GNE 的项目源代码在：<a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="external">https://github.com/kingname/GeneralNewsExtractor</a>。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>如果您觉得GNE对您的日常开发或公司有帮助，请加作者微信 mxqiuchen（或扫描下方二维码） 并注明”GNE”，作者会将你拉入群。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_3729_2.JPG" alt=""></p>
<p>验证消息：<code>GNE</code></p>
<p>我的公众号：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么每一个爬虫工程师都应该学习 Kafka</title>
    <link href="https://www.kingname.info/2019/12/14/use-kakfa-in-spider/"/>
    <id>https://www.kingname.info/2019/12/14/use-kakfa-in-spider/</id>
    <published>2019-12-14T00:36:02.000Z</published>
    <updated>2019-12-14T00:38:53.112Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。</p>
<a id="more"></a>
<h2 id="一个简单的需求"><a href="#一个简单的需求" class="headerlink" title="一个简单的需求"></a>一个简单的需求</h2><p>假设我们需要写一个微博爬虫，老板给的需求如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-35-25.png" alt=""></p>
<p>开发爬虫对你来说非常简单，于是三下五除二你就把爬虫开发好了：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-39-18.png" alt=""></p>
<p>接下来开始做报警功能，逻辑也非常简单：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-52-50.png" alt=""></p>
<p>再来看看统计关键词的功能，这个功能背后有一个网页，会实时显示抓取数据量的变化情况，可以显示每分钟、每小时的某个关键词的抓取量。</p>
<p>这个功能对你来说也挺简单，于是你实现了如下逻辑：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-16-03.png" alt=""></p>
<p>最后一个需求，对微博数据进行情感分析。情感分析的模块有别的部门同事开发，你要做的就是每个小时拉取一批数据，发送到接口，获取返回，然后存入后端需要的数据库：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-12-52.png" alt=""></p>
<p>任务完成，于是你高兴地回家睡觉了。</p>
<h2 id="困难接踵而至"><a href="#困难接踵而至" class="headerlink" title="困难接踵而至"></a>困难接踵而至</h2><h3 id="爬虫变慢了"><a href="#爬虫变慢了" class="headerlink" title="爬虫变慢了"></a>爬虫变慢了</h3><p>随着老板逐渐增加新的关键词，你发现每一次完整抓取的时间越来越长，一开始是2分钟抓取一轮，后来变成10分钟一轮，然后变成30分钟一轮，接下来变成1小时才能抓取一轮。随着延迟越来越高，你的报警越来越不准确，微博都发出来一小时了，你的报警还没有发出来，因为那一条微博还没有来得及入库。</p>
<p>你的爬虫技术非常好，能绕过所有反爬虫机制，你有无限个代理 IP，于是你轻轻松松就把爬虫提高到了每秒一百万并发。现在只需要1分钟你就能完成全部数据的抓取。这下没问题了吧。</p>
<p>可是报警还是没有发出来。这是怎么回事？</p>
<h3 id="数据库撑不住了"><a href="#数据库撑不住了" class="headerlink" title="数据库撑不住了"></a>数据库撑不住了</h3><p>经过排查，你发现了问题。数据抓取量上来了，但是 MongoDB 却无法同时接收那么多的数据写入。数据写入速度远远小于爬取数据，大量的数据堆积在内存中。于是你的服务器爆炸了。</p>
<p>你紧急搭建了100个数据库并编号0-99，对于抓取到的微博，先把每一条微博的 ID对100求余数，然后把数据存入余数对应的 MongoDB 中。每一台 MongoDB 的压力下降到了原来的1%。数据终于可以即时存进数据库里面了。</p>
<p>可是报警还是没有发出来，不仅如此，现在实时抓取量统计功能也不能用了，还有什么问题？</p>
<h3 id="查询来不及了"><a href="#查询来不及了" class="headerlink" title="查询来不及了"></a>查询来不及了</h3><p>现在报警程序要遍历100个数据库最近5分钟里面的每一条数据，确认是否有需要报警的内容。但是这个遍历过程就远远超过5分钟。</p>
<h3 id="时间错开了"><a href="#时间错开了" class="headerlink" title="时间错开了"></a>时间错开了</h3><p>由于微博的综合搜索功能不是按照时间排序的，那么就会出现这样一种情况，早上10:01发的微博，你在12:02的时候才抓到。</p>
<p>不论你是在报警的时候筛选数据，还是筛选数据推送给 NLP 分析接口，如果你是以微博的发布时间来搜索，那么这一条都会被你直接漏掉——当你在10:05的时候检索10:00-10:05这5分钟发表的微博，由于这一条微博没有抓到，你自然搜索不到。</p>
<p>当你12:05开始检索12:00-12:05的数据时，你搜索的是发布时间为12:00-12:05的数据，于是10:01这条数据虽然是在12:02抓到的，但你也无法筛选出来。</p>
<p>那么是不是可以用抓取时间来搜索呢？例如10:05开始检索在10:00-10:05抓取到的数据，无论它的发布时间是多少，都检索出来。</p>
<p>这样做确实可以保证不漏掉数据，但这样做的代价是你必需保存、检索非常非常多的数据。例如每次抓取，只要发布时间是最近10小时的，都要保存下来。于是报警程序在检索数据时，就需要检索这5分钟入库的，实际上发布时间在10小时内的全部数据。</p>
<p>什么，你说每次保存之前检查一下这条微博是否已经存在，如果存在就不保存？别忘了批量写入时间都不够了，你还准备分一些时间去查询？</p>
<h3 id="脏数据来了"><a href="#脏数据来了" class="headerlink" title="脏数据来了"></a>脏数据来了</h3><p>老板突然来跟你说，关键词“篮球”里面有大量的关于 蔡徐坤的内容，所以要你把所有包含蔡徐坤的数据全部删掉。</p>
<p>那么，这个过滤逻辑放在哪里？放在爬虫的 pipelines.py 里面吗？那你要重新部署所有爬虫。今天是过滤蔡徐坤，明天是过滤范层层，后天是过滤王一博，每天增加关键词，你每天都得重新部署爬虫？</p>
<p>那你把关键词放在 Redis 或者 MongoDB 里面，每次插入数据前，读取所有关键词，看微博里面不包含再存。</p>
<p>还是那个问题，插入时间本来就不够了，你还要查数据库？</p>
<p>好，关键词过滤不放在爬虫里面了。你写了一个脚本，每分钟检查一次MongoDB新增的数据，如果发现包含 不需要的关键词，就把他删除。</p>
<p>现在问题来了，删除数据的程序每分钟检查一次，报警程序每5分钟检查一次。中间必定存在某些数据，还没有来得及删除，报警程序就报警了，老板收到报警来看数据，而你的删除程序又在这时把这个脏数据删了。</p>
<p>这下好了，天天报假警，狼来了的故事重演了。</p>
<h2 id="5个问题1个救星"><a href="#5个问题1个救星" class="headerlink" title="5个问题1个救星"></a>5个问题1个救星</h2><p>如果你在爬虫开发的过程中遇到过上面的诸多问题，那么，你就应该试一试使用 Kafka。一次性解决上面的所有问题。</p>
<p>把 Kafka 加入到你的爬虫流程中，那么你的爬虫架构变成了下面这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-34-55.png" alt=""></p>
<p>这看起来似乎和数据直接写进 MongoDB 里面，然后各个程序读取 MongoDB 没什么区别啊？那 Kafka 能解决什么问题？</p>
<p>我们来看看，在这个爬虫架构里面，我们将会用到的 Kafka 的特性：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-39-28.png" alt=""></p>
<p>与其说 Kafka 在这个爬虫架构中像 MongoDB，不如说更像 Redis 的列表。</p>
<p>现在来简化一下我们的模型，如果现在爬虫只有一个需求，就是搜索，然后报警。那么我们可以这样设计：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-46-23.png" alt=""></p>
<p>爬虫爬下来的数据，直接塞进 Redis 的列表右侧。报警程序从 Redis 列表左侧一条一条读取。读取一条检视一条，如果包含报警关键词，就报警。然后读取下一条。</p>
<p>这样做有什么好处？</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-50-27.png" alt=""></p>
<p>因为报警程序直接从 Redis 里面一条一条读取，不存在按时间搜索数据的过程，所以不会有数据延迟的问题。由于 Redis 是单线程数据库，所以可以同时启动很多个报警程序。由于 lpop 读取一条就删除一条，如果报警程序因为某种原因崩溃了，再把它启动起来即可，它会接着工作，不会重复报警。</p>
<p>但使用 Redis 列表的优势也是劣势：列表中的信息只能消费1次，被弹出了就没有了。</p>
<p>所以如果既需要报警，还需要把数据存入 MongoDB 备份，那么只有一个办法，就是报警程序检查完数据以后，把数据存入 MongoDB。</p>
<blockquote>
<p>可我只是一个哨兵，为什么要让我做后勤兵的工作？</p>
</blockquote>
<p>一个报警程序，让它做报警的事情就好了，它不应该做储存数据的事情。</p>
<p>而使用 Kafka，它有 Redis 列表的这些好处，但又没有 Redis 列表的弊端！</p>
<p>我们完全可以分别实现4个程序，不同程序之间消费数据的快慢互不影响。但同一个程序，无论是关闭再打开，还是同时运行多次，都不会重复消费。</p>
<h3 id="程序1：报警"><a href="#程序1：报警" class="headerlink" title="程序1：报警"></a>程序1：报警</h3><p>从 Kafka 中一条一条读取数据，做报警相关的工作。程序1可以同时启动多个。关了再重新打开也不会重复消费。</p>
<h3 id="程序2：储存原始数据"><a href="#程序2：储存原始数据" class="headerlink" title="程序2：储存原始数据"></a>程序2：储存原始数据</h3><p>这个程序从 Kafka 中一条一条读取数据，每凑够1000条就批量写入到 MongoDB 中。这个程序不要求实时储存数据，有延迟也没关系。 存入MongoDB中也只是原始数据存档。一般情况下不会再从 MongoDB 里面读取出来。</p>
<h3 id="程序3：统计"><a href="#程序3：统计" class="headerlink" title="程序3：统计"></a>程序3：统计</h3><p>从 Kafka 中读取数据，记录关键词、发布时间。按小时和分钟分别对每个关键词的微博计数。最后把计数结果保存下来。</p>
<h3 id="程序4：情感分析"><a href="#程序4：情感分析" class="headerlink" title="程序4：情感分析"></a>程序4：情感分析</h3><p>从 Kafka 中读取每一条数据，凑够一批发送给 NLP 分析接口。拿到结果存入后端数据库中。</p>
<h3 id="如果要清洗数据怎么办"><a href="#如果要清洗数据怎么办" class="headerlink" title="如果要清洗数据怎么办"></a>如果要清洗数据怎么办</h3><p>4个需求都解决了，那么如果还是需要你首先移除脏数据，再分析怎么办呢？实际上非常简单，你加一个 Kafka（Topic） 就好了！</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-11-27.png" alt=""></p>
<h2 id="大批量通用爬虫"><a href="#大批量通用爬虫" class="headerlink" title="大批量通用爬虫"></a>大批量通用爬虫</h2><p>除了上面的微博例子以外，我们再来看看在开发通用爬虫的时候，如何应用 Kafka。</p>
<p>在任何时候，无论是 XPath 提取数据还是解析网站返回的 JSON，都不是爬虫开发的主要工作。爬虫开发的主要工作一直是爬虫的调度和反爬虫的开发。</p>
<p>我们现在写 Scrapy 的时候，处理反爬虫的逻辑和提取数据的逻辑都是写在一个爬虫项目中的，那么在开发的时候实际上很难实现多人协作。</p>
<p>现在我们把网站内容的爬虫和数据提取分开，实现下面这样一个爬虫架构：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-22-51.png" alt=""></p>
<p>爬虫开发技术好的同学，负责实现绕过反爬虫，获取网站的内容，无论是 HTML 源代码还是接口返回的JSON。拿到以后，直接塞进 Kafka。</p>
<p>爬虫技术相对一般的同学、实习生，需要做的只是从 Kafka 里面获取数据，不需要关心这个数据是来自于 Scrapy 还是 Selenium。他们要做的只是把这些HTML 或者JSON 按照产品要求解析成格式化的数据，然后塞进 Kafka，供后续数据分析的同学继续读取并使用。</p>
<p>如此一来，一个数据小组的工作就分开了，每个人做各自负责的事情，约定好格式，同步开发，互不影响。</p>
<h2 id="为什么是-Kafka-而不是其他"><a href="#为什么是-Kafka-而不是其他" class="headerlink" title="为什么是 Kafka 而不是其他"></a>为什么是 Kafka 而不是其他</h2><p>上面描述的功能，实际上有不少 MQ 都能实现。但为什么是 Kafka 而不是其他呢？因为Kafka 集群的性能非常高，在垃圾电脑上搭建的集群能抗住每秒10万并发的数据写入量。而如果选择性能好一些的服务器，每秒100万的数据写入也能轻松应对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章通过两个例子介绍了 Kafka 在爬虫开发中的作用。作为一个爬虫工程师，作为我的读者。请一定要掌握 Kafka。</p>
<p>下一篇文章，我们来讲讲如何使用 Kafka。比你在网上看到的教程会更简单，更容易懂。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt=""></p>
<p>关注本公众号，回复“爬虫与Kafka”获取本文对应的思维导图原图。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中实现函数重载</title>
    <link href="https://www.kingname.info/2019/12/11/singledispatch/"/>
    <id>https://www.kingname.info/2019/12/11/singledispatch/</id>
    <published>2019-12-11T15:01:25.000Z</published>
    <updated>2019-12-11T15:01:58.828Z</updated>
    
    <content type="html"><![CDATA[<p>假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</div><div class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</div></pre></td></tr></table></figure>
<p>你想在代码里面兼容这两种写法，于是你可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(address, str):</div><div class="line">        ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    <span class="keyword">elif</span> isinstance(address, tuple):</div><div class="line">        ip, port = address</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'地址格式不正确'</span>)</div></pre></td></tr></table></figure>
<p>这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 <code>if-elif-elif-...-else</code>。代码看起来就非常不美观。</p>
<p>学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。</p>
<p>在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 <code>if-else</code>外，我们还可以使用<code>functools</code>模块里面的<code>singledispatch</code>装饰器实现函数重载。</p>
<a id="more"></a>
<p>我们来写一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</div><div class="line"></div><div class="line"><span class="meta">@singledispatch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    print(f<span class="string">' 传输参数类型为：&#123;type(address)&#125;，不是有效类型'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: str)</span>:</span></div><div class="line">    ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    print(f<span class="string">'参数为字符串，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: tuple)</span>:</span></div><div class="line">    ip, port = address</div><div class="line">    print(f<span class="string">'参数为元组，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</div><div class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</div><div class="line">connect(<span class="number">123</span>)</div></pre></td></tr></table></figure>
<p>我们运行一下这段代码，大家看看根据参数的不同，有什么样的不同效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-11-21-55-13.png" alt=""></p>
<p>可以看到，我们调用的函数，始终都是<code>connect</code>，但是由于传入参数的类型不同，它运行的结果也不一样。</p>
<p>我们使用<code>singledispatch</code>装饰一个函数，那么这个函数就是我们将会调用的函数。</p>
<p>这个函数在传入参数不同时的具体实现，通过下面注册的函数来实现。注册的时候使用<code>@我们定义的函数名.register</code>来注册。被注册的函数名叫什么无关紧要，所以这里我都直接使用下划线代替。</p>
<p>被注册的函数的第一个参数，通过类型标注来确定它应该使用什么类型。当我们调用我们定义的函数是，如果参数类型符合某个被注册的函数，那么就会执行这个被注册的函数。如果参数类型不满足任何一个被注册的函数，那么就会执行我们的原函数。</p>
<p>使用类型标注来指定参数类型是从 Python 3.7才引入的新特性。在 Python 3.6或之前的版本，我们需要通过<code>@我们定义的函数名.register(类型)</code>来指定类型，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</div><div class="line"></div><div class="line"><span class="meta">@singledispatch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    print(f<span class="string">' 传输参数类型为：&#123;type(address)&#125;，不是有效类型'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register(str)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></div><div class="line">    ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    print(f<span class="string">'参数为字符串，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register(tuple)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></div><div class="line">    ip, port = address</div><div class="line">    print(f<span class="string">'参数为元组，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div></pre></td></tr></table></figure>
<p>同时，还有一个需要注意的点，就是只有第一个参数的不同类型会被重载。后面的参数的类型变化会被自动忽略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;connect(&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18:8080&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connect((&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你想在代码里面兼容这两种写法，于是你可能会这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(address)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isinstance(address, str):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ip, port = address.split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; isinstance(address, tuple):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ip, port = address&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;地址格式不正确&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 &lt;code&gt;if-elif-elif-...-else&lt;/code&gt;。代码看起来就非常不美观。&lt;/p&gt;
&lt;p&gt;学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。&lt;/p&gt;
&lt;p&gt;在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 &lt;code&gt;if-else&lt;/code&gt;外，我们还可以使用&lt;code&gt;functools&lt;/code&gt;模块里面的&lt;code&gt;singledispatch&lt;/code&gt;装饰器实现函数重载。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何统计一个数字的二进制值里面有多少个1</title>
    <link href="https://www.kingname.info/2019/12/11/count-1-in-bin/"/>
    <id>https://www.kingname.info/2019/12/11/count-1-in-bin/</id>
    <published>2019-12-11T14:51:01.000Z</published>
    <updated>2019-12-11T14:53:43.423Z</updated>
    
    <content type="html"><![CDATA[<p>任意给出一个正整数，例如<code>4523</code>，如何快速统计它的二进制值里面有几个<code>1</code>？</p>
<a id="more"></a>
<p>我们知道，在 Python 里面，查看一个数字的二进制函数为：<code>bin</code>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">4523</span>)</div><div class="line"><span class="string">'0b1000110101011'</span></div></pre></td></tr></table></figure>
<p>所以我们很快就能想到一个统计方案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">one_num = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin(<span class="number">4523</span>)[<span class="number">2</span>:]:</div><div class="line">    <span class="keyword">if</span> i == <span class="string">'1'</span>:</div><div class="line">        count += <span class="number">1</span></div><div class="line">print(f<span class="string">'数字4523的二进制值里面，一共有&#123;count&#125;个1'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-24-21-29-12.png" alt=""></p>
<p>如果使用这个方法，由于4523的二进制值有13位，所以 for 循环需要执行13次才能完成统计。更一般的结论，一个正整数 <code>n</code>，它的二进制值有$log_2{n} + 1$位，所以这种解法的时间复杂度始终为<code>O(logn)</code>，那么我们有没有什么办法优化这个算法呢？</p>
<p>这个时候，我们观察一个现象：</p>
<p>给出一个二进制的值<code>1000110101011</code>与这个值减1的值<code>1000110101010</code>，他们做与运算，结果为：<code>1000110101010</code>。可以看到，最右侧的1变成了0.</p>
<p>现在我们再对<code>1000110101010</code>与它减1的值做与运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1000110101010</span> &amp; <span class="number">1000110101001</span> = <span class="number">1000110101000</span></div></pre></td></tr></table></figure>
<p>此时，最右侧的1又变成了0.</p>
<p>我们可以证明，假设有一个二进制数 <code>n</code>与<code>n-1</code>做与运算，它的效果相当于把这个二进制数最右侧的1变成0.</p>
<p>于是，给定一个正整数<code>x</code>，只需要统计移除多少位的最右侧的1以后，这个数字变成了0，就能知道它里面有多少个1.于是我们可以写出如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">count = <span class="number">0</span></div><div class="line">n = <span class="number">4523</span></div><div class="line"><span class="keyword">while</span> n:</div><div class="line">    n = n &amp; (n - <span class="number">1</span>)</div><div class="line">    count += <span class="number">1</span></div><div class="line">print(count)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-24-21-42-25.png" alt=""></p>
<p>使用这种算法，最坏情况下，只有在数字 n 对应的二进制全部都是1的情况下(3, 7, 15, 31, 63….)，会执行$log_2n+1$次循环。而一般情况下，如果只有1个1，那么只需要循环1次，如果有2个1，只需要循环2次。大大提高了运算效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任意给出一个正整数，例如&lt;code&gt;4523&lt;/code&gt;，如何快速统计它的二进制值里面有几个&lt;code&gt;1&lt;/code&gt;？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="算法" scheme="https://www.kingname.info/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>闲聊：语言决定思维方法</title>
    <link href="https://www.kingname.info/2019/12/10/languate-define-your-brain/"/>
    <id>https://www.kingname.info/2019/12/10/languate-define-your-brain/</id>
    <published>2019-12-10T15:00:27.000Z</published>
    <updated>2019-12-11T15:01:09.315Z</updated>
    
    <content type="html"><![CDATA[<p>在知乎上有这样一个问题：《如果当年汉字真的拼音化了会怎么样？》，下面有一个高赞回答写道：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-40-42.png" alt=""></p>
<p>这个答主的逻辑非常简单，因为《施氏食狮史》这个小故事，全篇只有<code>shi</code>与<code>si</code>两种发音，如果用汉语拼音，那么完全无法读懂。只有通过不同的中文汉字，才能正确读懂故事的意思。因此中文汉字比汉语拼音强，信息量比汉语拼音大。</p>
<p>然而这个答主忽略了一个问题，这个小故事实际上只有生活在汉字环境中的人才能想出来。对于完全生活在拼音环境中的人来说，他们的思维方式决定了根本不可能有这个故事产生。</p>
<a id="more"></a>
<p>类似的例子还有英文句子：Can you can a can as a caner can can a can.</p>
<p>这个句子只有英文语境下面的人能想出来，中文语境下面的人，在思维方式上就想不到这样的句子。难道这就能说明英文比中文好？</p>
<p>如果当年真的推行了拼音而完全放弃了汉字，那么基于拼音自然会产生它对应的文化、思维方式和表达方式。而绝不是现在这些人所嘲笑和想当然的样子。</p>
<p>还有下面这种非常扯淡的文章：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-53-43.png" alt=""></p>
<p>如果计算机是中国人发明的，那么编程语言绝对不会是他这样的写法。他这个写法仅仅是把英文编程语言里面的关键词换成了中文而已。但里面的行文逻辑与思维方式，完全还是英语编程语言的思维方式。在纯粹中文原生的编程语言，绝对不会这样表达。</p>
<p>他的这种逻辑，就像是以为仅仅把五线谱里面的蝌蚪音符转化为宫商角徵羽，就变成了中国古代乐谱。然而中国古代的乐谱长下面这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-56-30.png" alt=""></p>
<p>语言塑造了你的思维。当你只会一门语言时，你几乎无法跳脱这门语言所创造出来的思考方式。不是你不愿意从更多的角度来思考问题，而是在你的意识里面，根本不知道还能有更多的思考角度。</p>
<p>所以无论是现实中交流的语言，还是编程语言，多学几门，你的见识就不一样了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在知乎上有这样一个问题：《如果当年汉字真的拼音化了会怎么样？》，下面有一个高赞回答写道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-40-42.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个答主的逻辑非常简单，因为《施氏食狮史》这个小故事，全篇只有&lt;code&gt;shi&lt;/code&gt;与&lt;code&gt;si&lt;/code&gt;两种发音，如果用汉语拼音，那么完全无法读懂。只有通过不同的中文汉字，才能正确读懂故事的意思。因此中文汉字比汉语拼音强，信息量比汉语拼音大。&lt;/p&gt;
&lt;p&gt;然而这个答主忽略了一个问题，这个小故事实际上只有生活在汉字环境中的人才能想出来。对于完全生活在拼音环境中的人来说，他们的思维方式决定了根本不可能有这个故事产生。&lt;/p&gt;
    
    </summary>
    
      <category term="思维方式" scheme="https://www.kingname.info/categories/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="思维" scheme="https://www.kingname.info/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>如何从 Redis 的列表中一次性 pop 多条数据？</title>
    <link href="https://www.kingname.info/2019/12/04/batch-pop-in-redis/"/>
    <id>https://www.kingname.info/2019/12/04/batch-pop-in-redis/</id>
    <published>2019-12-04T14:58:33.000Z</published>
    <updated>2019-12-11T14:59:55.144Z</updated>
    
    <content type="html"><![CDATA[<p>当我们想从 Redis 的列表里面持续弹出数据的时候，我们一般使用<code>lpop</code>或者<code>rpop</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data = client.lpop(<span class="string">'key'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(f<span class="string">'弹出一条数据：&#123;data.decode()&#125;'</span>)</div></pre></td></tr></table></figure>
<p>但这种写法有一个问题，就是每弹出1条数据都要连接一次 Redis 服务器，当你要把1000万条数据从列表里面弹出来的时候，实际上超过一半的时间都消耗在了网络请求上面。</p>
<a id="more"></a>
<p>但是<code>lpop</code>与<code>rpop</code>都只接收一个参数，就是<code>key</code><br>。因此没有办法通过传入参数的方式让它一次弹出多条数据。</p>
<p>要获取多条数据，我们还有另一种方案，就是<code>lrange</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = client.lrange(<span class="string">'key'</span>, <span class="number">0</span>, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>这一行的意思是从列表中，获取前5001条数据（包含首尾）。但<code>lrange</code>只能获取数据，却不能删除数据。这就会导致在多个进程获取到重复的数据。</p>
<p>我们还知道Redis 的<code>ltrim</code>来删除数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.ltrim(<span class="string">'key'</span>, <span class="number">5000</span>, <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>这样就能删除前5000条数据了。这里第三个参数之所以要用负数，是因为<code>ltrim(key, start, end)</code>的意思是说，保留列表 Key 的第start项到第end 项，其它项删除。那么如果 end为负数，表示倒数第几项，例如-1表示倒数第1项，-2表示倒数第2项。假设列表里面有10000项，那么 start 为5000，end 为-1，表示删除前5000条数据（0-4999），保留后面的。</p>
<p>于是有人问，能不能这样写代码呢：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line">data = client.lrange(<span class="string">'key'</span>, <span class="number">0</span>, <span class="number">4999</span>)</div><div class="line">client.ltrim(<span class="string">'key'</span>, <span class="number">5000</span>, <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>这样不就看起来像是弹出了5000条数据吗？</p>
<p>想法很好，但是由于获取数据与删除数据是两条命令，中间有时间差。这就导致在多个线程或者进程同时执行这两条代码的时候，出现竞争。也就是进程1刚刚获取了前5000条数据，然后进程2同样获取这5000条数据，然后进程1删除前5000条数据，然后进程2再删除5000条数据。</p>
<p>这样一来，两个进程获取了相同的5000条数据，但是却删了10000条数据。</p>
<p>为了解决这个问题，必需让获取数据与删除数据这两个操作变成一个“原子操作”。所谓的原子操作就是只一个最小的操作单位，它不会被中途打断。</p>
<p>要解决这个问题，我们就需要使用 Redis 的<code>pipeline</code>功能。它可以把多条命令放在一个网络请求中发送到服务器，并默认在一个事务中执行这些命令。一个事务是不会被打断的，从事务开始然后执行里面的多个命令到结束的整个过程，可以看做一个原子操作。</p>
<p><code>pipeline</code>的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_lpop</span><span class="params">(key, n)</span>:</span></div><div class="line">    p = client.pipeline()</div><div class="line">    p.lrange(key, <span class="number">0</span>, n - <span class="number">1</span>)</div><div class="line">    p.ltrim(key, n, <span class="number">-1</span>)</div><div class="line">    data = p.execute()</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line">batch_lpop(<span class="string">'test_pipeline'</span>, <span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>当代码执行到<code>p.execute()</code>的时候，它才会真正去连接服务器，然后把待执行的命令在一个事务中一次性执行完成。并返回一个列表。返回的列表有两项，第0项是包含结果的列表，第1项为ltrim 的返回结果。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-04-22-42-04.png" alt=""></p>
<p>我们只需要使用第0项的结果即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们想从 Redis 的列表里面持续弹出数据的时候，我们一般使用&lt;code&gt;lpop&lt;/code&gt;或者&lt;code&gt;rpop&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; redis&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;client = redis.Redis()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data = client.lpop(&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; data:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(f&lt;span class=&quot;string&quot;&gt;&#39;弹出一条数据：&amp;#123;data.decode()&amp;#125;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但这种写法有一个问题，就是每弹出1条数据都要连接一次 Redis 服务器，当你要把1000万条数据从列表里面弹出来的时候，实际上超过一半的时间都消耗在了网络请求上面。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 正则表达式模块中逃跑（escape</title>
    <link href="https://www.kingname.info/2019/12/02/escape-in-python/"/>
    <id>https://www.kingname.info/2019/12/02/escape-in-python/</id>
    <published>2019-12-02T14:57:34.000Z</published>
    <updated>2019-12-11T14:58:09.202Z</updated>
    
    <content type="html"><![CDATA[<p>在编程语言中，有常见的符号被赋予了特殊的意义，例如小数点<code>.</code>，在正则表达式里面表示任意一个非换行符的字符；小于号<code>&lt;</code>在 html 中表示标签。</p>
<p>但有时候，我们只想让这些符号表示它本来的意思，不想让它的特殊意义表露出来，应该怎么办？</p>
<a id="more"></a>
<p>我们知道，在正则表达式中可以使用反斜杠来让一个特殊符号变成普通符号，例如<code>\.</code>表示普通的小数点，<code>\$</code>表示普通的美元符号。</p>
<p>现在我有一个列表<code>keywords_list</code>，里面是100个字符串，我想判断是否有任意一个字符串在某个给定的句子中。如果用 for 循环一个一个去检查，效率非常低。于是可以考虑使用正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">'|'</span>.join(keywords_list))</div><div class="line"></div><div class="line"><span class="keyword">if</span> pattern.search(<span class="string">'目标句子'</span>):</div><div class="line">    print(<span class="string">'目标句子中包含某个关键词'</span>)</div></pre></td></tr></table></figure>
<p>但假设 <code>keywords_list</code>列表中有如下的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keywords_list = [<span class="string">'4.5'</span>, <span class="string">'+&#123;d'</span>, <span class="string">'***'</span>]</div></pre></td></tr></table></figure>
<p>那么我们使用正则表达式就会导致报错，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-02-22-11-20.png" alt=""></p>
<p>这是因为这些字符串里面存在特殊的符号，这些符号在正则表达式里面有特殊的意义，有使用的规范，不能随意使用。</p>
<p>但是，<code>keywords_list</code>里面有各种各样的特殊符号，难道要一个一个取出来，逐一<code>x.replace(&#39;+&#39;, &#39;\+&#39;).replace(&#39;.&#39;, &#39;\.&#39;).replace(&#39;*&#39;, &#39;\*&#39;)...</code>?</p>
<p>当然不用，Python 的正则表达式模块已经帮你想好了解决办法，使用<code>re.escape</code>就能自动处理所有的特殊符号了！</p>
<p>它的用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>keywords_list = [<span class="string">'4.5'</span>, <span class="string">'+&#123;d'</span>, <span class="string">'***'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pattern_str = <span class="string">'|'</span>.join(keywords_list)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>safe_pattern_str = re.escape(pattern_str)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(safe_pattern_str)</div><div class="line"><span class="number">4</span>\<span class="number">.5</span>\|\+\&#123;d\|\*\*\*</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.compile(safe_pattern_str)</div><div class="line">re.compile(<span class="string">'4\\.5\\|\\+\\&#123;d\\|\\*\\*\\*'</span>)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-02-22-16-08.png" alt=""></p>
<p>解决问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程语言中，有常见的符号被赋予了特殊的意义，例如小数点&lt;code&gt;.&lt;/code&gt;，在正则表达式里面表示任意一个非换行符的字符；小于号&lt;code&gt;&amp;lt;&lt;/code&gt;在 html 中表示标签。&lt;/p&gt;
&lt;p&gt;但有时候，我们只想让这些符号表示它本来的意思，不想让它的特殊意义表露出来，应该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>让你的字典读取不报错</title>
    <link href="https://www.kingname.info/2019/11/30/quite-dict/"/>
    <id>https://www.kingname.info/2019/11/30/quite-dict/</id>
    <published>2019-11-30T14:56:25.000Z</published>
    <updated>2019-12-11T14:57:05.250Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，读取 Python 字典时，如果某个 Key 不存在，Python 就会报错，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-42-39.png" alt=""></p>
<p>为了防止它报错，我们可以使用<code>.get()</code>方法：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-43-26.png" alt=""></p>
<p>但每次都要写<code>.get()</code>稍显麻烦。于是我们可以通过自己实现一个自定义的字典对象，来解决这个问题。</p>
<a id="more"></a>
<p>我们自定义一个类，继承<code>dict</code>，然后实现它的<code>__missing__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OurDict</span><span class="params">(dict)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">a = OurDict(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</div><div class="line">print(a[<span class="string">'x'</span>])</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-46-13.png" alt=""></p>
<p>只要这个 Key 不存在，就会返回 <code>None</code>。</p>
<p>在 Python 的<code>collections</code>工具模块中，有一个<code>defaultdict</code>实现了类似的事情。我们看它的使用方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">a = defaultdict(str)</div><div class="line">a[<span class="string">'a'</span>] = <span class="number">1</span></div><div class="line">a[<span class="string">'b'</span>] = <span class="number">2</span></div><div class="line">print(a)</div><div class="line">print(a[<span class="string">'x'</span>])</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-54-45.png" alt=""></p>
<p><code>a = defaultdict(str)</code>接收一个函数，让<code>a</code>变量成为一个<code>defaultdict</code>类型的对象，它可以像普通字典一样被赋值和读取。</p>
<p>但是当你读取一个不存在的 key 时，它会自动生成一个默认值，并把默认值和这个 key 插入到字典中。这个默认值取决于你在<code>defaultdict</code>传入的参数。如果传入的是<code>str</code>那么默认值就是空字符串，如果是<code>int</code>那么默认值就是0.当然你也可以传入自定义的一个函数，从而控制这个默认值。例如我自定义一个函数，用于返回当前的时间，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-59-25.png" alt=""></p>
<p>当插入的 key 不存在时，就自动以当前时间作为默认值，并存入到字典中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，读取 Python 字典时，如果某个 Key 不存在，Python 就会报错，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-42-39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了防止它报错，我们可以使用&lt;code&gt;.get()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-43-26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但每次都要写&lt;code&gt;.get()&lt;/code&gt;稍显麻烦。于是我们可以通过自己实现一个自定义的字典对象，来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中编写抽象类</title>
    <link href="https://www.kingname.info/2019/11/26/abstract-class-in-python/"/>
    <id>https://www.kingname.info/2019/11/26/abstract-class-in-python/</id>
    <published>2019-11-26T14:55:20.000Z</published>
    <updated>2019-12-11T14:55:59.869Z</updated>
    
    <content type="html"><![CDATA[<p>在极客时间某设计模式相关的课程中，某老师说 Python 不支持抽象类和接口。</p>
<p>但实际上，Python 支持抽象类。</p>
<a id="more"></a>
<p>Python 自带的<code>abc</code>模块用于实现抽象类相关的定义和操作。</p>
<p>我们通过一个简单的例子来说明，如何在 Python 中实现抽象类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(ABC)</span>:</span></div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'我正在跳舞'</span>)</div></pre></td></tr></table></figure>
<p>从<code>abc</code>模块导入<code>ABC</code>类，和<code>abstractmethod</code>抽象方法装饰器。基于<code>ABC</code>类可以实现一个抽象类。通过<code>@abstractmethod</code>装饰一个方法，让它成为一个抽象方法。抽象方法在子类中必需被实现。</p>
<p>抽象类不能被实例化，所以我们实例化一下，可以看到这里报错了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-43-11.png" alt=""></p>
<p>我们再看一下，如果继承抽象类，但是没有实现其中的某个抽象方法，也会导致报错。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-47-41.png" alt=""></p>
<p>当我们把所有抽象方法都实现了以后，子类就能够正常初始化了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-49-23.png" alt=""></p>
<p>抽象类<code>People</code>中的<code>dance</code>不是抽象方法，所以子类不需要覆盖。</p>
<p>抽象类是软件开发中一个非常重要的概念，通过定义抽象类，我们可以约定子类必需实现的方法。当我们一个类有几十上百个方法时，用抽象方法来防止子类漏掉某些方法是非常方便的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在极客时间某设计模式相关的课程中，某老师说 Python 不支持抽象类和接口。&lt;/p&gt;
&lt;p&gt;但实际上，Python 支持抽象类。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GNE v0.04版更新，支持提取正文图片与源代码</title>
    <link href="https://www.kingname.info/2019/11/25/gne-0-4/"/>
    <id>https://www.kingname.info/2019/11/25/gne-0-4/</id>
    <published>2019-11-25T14:54:01.000Z</published>
    <updated>2019-12-11T14:54:53.559Z</updated>
    
    <content type="html"><![CDATA[<p><code>GeneralNewsExtractor</code>以下简称<code>GNE</code>是一个新闻网页通用抽取器，能够在不指定任何抽取规则的情况下，把新闻网站的正文提取出来。</p>
<p>我们来看一下它的基本使用方法。</p>
<a id="more"></a>
<h2 id="安装-GNE"><a href="#安装-GNE" class="headerlink" title="安装 GNE"></a>安装 GNE</h2><p>使用 pip 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install --upgrade git+https://github.com/kingname/GeneralNewsExtractor.git</div></pre></td></tr></table></figure>
<p>当然你也可以使用<code>pipenv</code>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install git+https://github.com/kingname/GeneralNewsExtractor.git<span class="comment">#egg=gne</span></div></pre></td></tr></table></figure>
<h2 id="获取新闻网页源代码"><a href="#获取新闻网页源代码" class="headerlink" title="获取新闻网页源代码"></a>获取新闻网页源代码</h2><p>GNE 现在不会，将来也不会提供网页请求的功能，所以你需要自行想办法获取<code>经过渲染以后的</code>网页源代码。你可以使用<code>Selenium</code>或者<code>Pyppeteer</code>或者直接从浏览器上复制。</p>
<p>这里演示如何直接从浏览器中复制网页的源代码：</p>
<ol>
<li>在 Chrome 浏览器中打开对应页面，然后开启开发者工具，如下图所示：</li>
</ol>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-21-06.png" alt=""></p>
<ol>
<li>在Elements标签页定位到<html>标签，并右键，选择Copy-Copy OuterHTML，如下图所示</html></li>
</ol>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-22-12.png" alt=""></p>
<ol>
<li>把源代码保存为1.html</li>
</ol>
<h2 id="提取正文信息"><a href="#提取正文信息" class="headerlink" title="提取正文信息"></a>提取正文信息</h2><p>编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'1.html'</span>) <span class="keyword">as</span> f:</div><div class="line">    html = f.read()</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(html)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-41-02.png" alt=""></p>
<h2 id="这次更新了什么"><a href="#这次更新了什么" class="headerlink" title="这次更新了什么"></a>这次更新了什么</h2><p>在最新更新的 v0.04版本中，开放了正文图片提取功能，与返回正文源代码功能。其中返回图片 URL 的功能在上面已经演示了，结果中的<code>images</code>字段就是正文中的图片。</p>
<p>那么怎么返回正文源代码呢？只需要增加一个参数<code>with_body_html=True</code>即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'1.html'</span>) <span class="keyword">as</span> f:</div><div class="line">    html = f.read()</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(html, with_body_html=<span class="keyword">True</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-42-45.png" alt=""></p>
<p>返回结果中的<code>body_html</code>就是正文的 html 源代码。</p>
<p>关于 GNE 的深入使用，可以访问GNE 的Github: <a href="https://github.com/kingname/GeneralNewsExtractor。" target="_blank" rel="external">https://github.com/kingname/GeneralNewsExtractor。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GeneralNewsExtractor&lt;/code&gt;以下简称&lt;code&gt;GNE&lt;/code&gt;是一个新闻网页通用抽取器，能够在不指定任何抽取规则的情况下，把新闻网站的正文提取出来。&lt;/p&gt;
&lt;p&gt;我们来看一下它的基本使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Flupy 构建数据处理管道</title>
    <link href="https://www.kingname.info/2019/11/23/flupy/"/>
    <id>https://www.kingname.info/2019/11/23/flupy/</id>
    <published>2019-11-23T14:49:18.000Z</published>
    <updated>2019-12-11T14:50:40.623Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用 Linux 的同学，肯定对<code>|</code>这个符号不陌生，这个符号是 Linux 的管道符号，可以把左边的数据传递给右边。</p>
<a id="more"></a>
<p>例如我有一个<code>spider.log</code>文件，我想查看里面包含”ERROR”关键词，同时时间为<code>2019-11-23</code>的数据，那么我可以这样写命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat spider.log | grep ERROR | grep <span class="string">"2019-11-23"</span></div></pre></td></tr></table></figure>
<p>但是，如果你想执行更复杂的操作，例如提取关键词<code>fail on: https://xxx.com</code>后面的这个网址，然后对所有获得的网址进行去重，那么虽然 shell 命令也能办到，但写起来却稍显麻烦。</p>
<p>这个时候，你就可以使用 Flupy来实现你的需求。首先我们使用 Python 3.6以上的版本安装<code>Flupy</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 -m pip install flupy</div></pre></td></tr></table></figure>
<p>然后开始写代码，看看这几步操作有多简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> flupy <span class="keyword">import</span> flu</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'spider.log'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">    error_url = (flu(f).filter(<span class="keyword">lambda</span> x: <span class="string">'ERROR'</span> <span class="keyword">in</span> x)</div><div class="line">                      .map(<span class="keyword">lambda</span> x: re.search(<span class="string">'fail on: (.*?),'</span>, x))</div><div class="line">                      .filter(<span class="keyword">lambda</span> x: x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)</div><div class="line">                      .map(<span class="keyword">lambda</span> x: x.group(<span class="number">1</span>))</div><div class="line">                      .unique())</div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> error_url:</div><div class="line">        print(url)</div></pre></td></tr></table></figure>
<p>首先<code>flu</code>接收一个可迭代对象，无论是列表还是生成器都可以。然后对里面的每一条数据应用后面的规则。这个过程都是基于生成器实现的，所以不会有内存不足的问题，对于 PB 级别的数据也不在话下。</p>
<p>在上面的例子中，<code>Flupy</code>获取日志文件的每一行内容，首先使用<code>filter</code>进行过滤，只保留包含<code>ERROR</code>字符串的行。然后对这些行通过<code>map</code>方法执行正则表达式，搜索满足<code>fail on: (.*?)\n</code>的内容。由于有些行有，有些行没有，所以这一步返回的数据有些是 None，有些是正则表达式对象，所以进一步再使用<code>filter</code>关键字，把所有返回<code>None</code>的都过滤掉。然后继续使用<code>map</code>关键字，对每一个正则表达式对象获取<code>.group(1)</code>。并把结果输出。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-23-20-49-04.png" alt=""></p>
<p>实现了数据的提取和去重。并且整个过程通过 Python 实现，代码也比 Shell 简单直观。</p>
<p>由于<code>Flupy</code>可以接收任何可迭代对象，所以传入数据库游标也是没有问题的，例如从 MongoDB 中读取数据并进行处理的一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"><span class="keyword">from</span> flupy <span class="keyword">import</span> flu</div><div class="line"></div><div class="line"></div><div class="line">handler = pymongo.MongoClient().db.col</div><div class="line"></div><div class="line">cursor = handler.find()</div><div class="line">data = flu(cursor).filter(<span class="keyword">lambda</span> x: x[<span class="string">'date'</span>] &gt;= <span class="string">'2019-11-10'</span>).map(<span class="keyword">lambda</span> x: x[<span class="string">'text'</span>]).take_while(<span class="keyword">lambda</span> x: <span class="string">'kingname'</span> <span class="keyword">in</span> x)</div></pre></td></tr></table></figure>
<p>这一段代码的意思是说，从数据库中一行一行检查数据，如果<code>date</code>字段大于<code>2019-11-10</code>就获取<code>text</code>字段的数据，满足一条就获取一条，直到某条数据包含<code>kingname</code>为止。</p>
<p>使用<code>Flupy</code>不仅可以通过写<code>.py</code>文件实现，还可以直接在命令行中执行，例如上面读取<code>spider.log</code>的代码，可以转换为终端命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flu -f spider.log <span class="string">"_.filter(lambda x: 'ERROR' in x).map(lambda x: re.search('fail on: (.*?),', x)).filter(lambda x: x is not None).map(lambda x: x.group(1)).unique()"</span> -i re</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-23-21-00-44.png" alt=""></p>
<p>通过<code>-i</code> 参数导入不同的库，无论是系统自带的库或者第三方库都可以。</p>
<p>Flupy 的更多使用参数，可以参阅它的<a href="https://flupy.readthedocs.io/en/latest/welcome.html" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用 Linux 的同学，肯定对&lt;code&gt;|&lt;/code&gt;这个符号不陌生，这个符号是 Linux 的管道符号，可以把左边的数据传递给右边。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中小括号的另类用法</title>
    <link href="https://www.kingname.info/2019/11/21/brack-in-python/"/>
    <id>https://www.kingname.info/2019/11/21/brack-in-python/</id>
    <published>2019-11-21T14:46:59.000Z</published>
    <updated>2019-12-11T14:47:51.935Z</updated>
    
    <content type="html"><![CDATA[<p>在写 Python 代码时，小括号必定是天天跟我们打交道的符号。无论是函数还是类或是运算优先级都会涉及到大量的小括号。</p>
<p>今天我们来讲讲小括号不为人知的另外两种用法。</p>
<a id="more"></a>
<h3 id="优化单行字符串的显示"><a href="#优化单行字符串的显示" class="headerlink" title="优化单行字符串的显示"></a>优化单行字符串的显示</h3><p>我有一行非常长的单行字符串，如果放在一行，看起来非常不方便，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-16-22.png" alt=""></p>
<p>但是，如果我使用三引号分行显示，那么就会引入不必要的换行符，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-18-19.png" alt=""></p>
<p>当然我们可以使用单引号加上反斜杠实现相同的效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-20-11.png" alt=""></p>
<p>但引入这么多的反斜杠，一是非常难看，而是很容易引入空格，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-21-20.png" alt=""></p>
<p>实际上，我们只需要使用小括号把多个字符串包在一起，他们自动就会组合成一个整体：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-24-08.png" alt=""></p>
<p>这样代码的可读性就大大提高了。</p>
<h3 id="if-条件语句的换行"><a href="#if-条件语句的换行" class="headerlink" title="if 条件语句的换行"></a>if 条件语句的换行</h3><p>Python 的 if 条件语句是 Python 的基本语法，我们在日常使用中可能会出现这样的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> <span class="keyword">and</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> <span class="keyword">and</span> <span class="number">4</span> + <span class="number">4</span> == <span class="number">8</span>:</div><div class="line">    print(<span class="string">'正确'</span>)</div></pre></td></tr></table></figure>
<p>一个 if 语句里面可能会出现多个表达式，他们使用<code>and</code>或者<code>or</code>进行连接。这就会导致有时候一个 if 语句变得非常长。</p>
<p>遇到这种情况，你可能会想到使用反斜杠进行分行，例如：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-25-12.png" alt=""></p>
<p>但反斜杠看起来非常碍眼，此时，我们也可以通过小括号来实现换行：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-25-53.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 Python 代码时，小括号必定是天天跟我们打交道的符号。无论是函数还是类或是运算优先级都会涉及到大量的小括号。&lt;/p&gt;
&lt;p&gt;今天我们来讲讲小括号不为人知的另外两种用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中像字典一样持久化数据</title>
    <link href="https://www.kingname.info/2019/11/16/persist-data-like-dict/"/>
    <id>https://www.kingname.info/2019/11/16/persist-data-like-dict/</id>
    <published>2019-11-16T14:44:10.000Z</published>
    <updated>2019-12-11T14:45:55.876Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如果我们在 Python 中想把一段数据持久化到硬盘上，最简单的办法就是写文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(<span class="string">'username：1234567\n'</span>)</div><div class="line">    f.write(<span class="string">'password: 9876543\n'</span>)</div></pre></td></tr></table></figure>
<p>但这样做有一个弊端，就是在读取数据的时候，我们把整个数据读入内存以后，还需要单独写一段代码，用来区分哪里是<code>username</code>对应的值，哪些是<code>password</code>对应的值。</p>
<a id="more"></a>
<p>实际上，在 Python 中，我们可以使用<code>shelve</code>模块，像读写字典一样持久化存储数据。例如，在 <code>write.py</code>文件中，我们写如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> shelve</div><div class="line"></div><div class="line"><span class="keyword">with</span> shelve.open(<span class="string">'data'</span>) <span class="keyword">as</span> db:</div><div class="line">    db[<span class="string">'username'</span>] = <span class="number">12345678</span></div><div class="line">    db[<span class="string">'password'</span>] = <span class="number">98765432</span></div></pre></td></tr></table></figure>
<p>运行完成以后，会在<code>write.py</code>所在的文件夹下面生成一个<code>data.db</code>文件，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-16-22-07-33.png" alt=""></p>
<p>现在，我们再写一个<code>read.py</code>，其内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> shelve</div><div class="line"></div><div class="line"><span class="keyword">with</span> shelve.open(<span class="string">'data'</span>) <span class="keyword">as</span> db:</div><div class="line">    username = db[<span class="string">'username'</span>]</div><div class="line">    password = db[<span class="string">'password'</span>]</div><div class="line"></div><div class="line">print(f<span class="string">'账号为：&#123;username&#125;'</span>)</div><div class="line">print(f<span class="string">'密码为：&#123;password&#125;'</span>)</div></pre></td></tr></table></figure>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-16-22-09-20.png" alt=""></p>
<p>不需要我们单独做额外的解析，就能像读取字典一样读取持久化到硬盘中的数据。</p>
<p>并且，原来写文本文件的时候，如果我们的数据是字典或者列表，直接写入还会报错，必需先转成 JSON 字符串才能写入。</p>
<p>但<code>shelve</code>模块没有这个限制，所有能被 <code>pickle</code>的对象，都可以存入，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> shelve</div><div class="line"></div><div class="line"><span class="keyword">with</span> shelve.open(<span class="string">'data'</span>) <span class="keyword">as</span> db:</div><div class="line">    db[<span class="string">'complex_data'</span>] = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, <span class="number">2</span>, <span class="string">'a'</span>]</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>shelve</code>模块底层基于<code>pickle</code>模块，所以当别人传给你一个 <code>shelve</code>生成的文件时，不能贸然打开，否则可能会执行危险的代码。</p>
<p>另外，<code>shelve</code>模块只支持多线程同时读取。不支持多线程写入，也不支持同时读写。</p>
<p>关于<code>shelve</code>的更多参数，可以参阅它的<a href="https://docs.python.org/3.8/library/shelve.html" target="_blank" rel="external">官方文档</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，如果我们在 Python 中想把一段数据持久化到硬盘上，最简单的办法就是写文件：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;data.txt&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;, encoding=&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    f.write(&lt;span class=&quot;string&quot;&gt;&#39;username：1234567\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    f.write(&lt;span class=&quot;string&quot;&gt;&#39;password: 9876543\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但这样做有一个弊端，就是在读取数据的时候，我们把整个数据读入内存以后，还需要单独写一段代码，用来区分哪里是&lt;code&gt;username&lt;/code&gt;对应的值，哪些是&lt;code&gt;password&lt;/code&gt;对应的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 下面最简单的单例模式写法</title>
    <link href="https://www.kingname.info/2019/11/13/most-simple-singletom/"/>
    <id>https://www.kingname.info/2019/11/13/most-simple-singletom/</id>
    <published>2019-11-13T14:42:17.000Z</published>
    <updated>2019-12-11T14:43:27.917Z</updated>
    
    <content type="html"><![CDATA[<p>二十几种设计模式中，单例模式是最简单最常用的一种。在其他语言里面实现单例模式要写不少代码，但是在 Python 里面，有一种非常简单的单例模式写法。</p>
<a id="more"></a>
<p>为了演示这种简单的写法，我们首先创建一个文件，<code>DBUtil.py</code>文件，用来模拟数据库操作类。这个文件里面的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.conn = self.connect()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'创建数据库连接'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="string">'connect'</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        print(f<span class="string">'写入数据：&#123;data&#125;'</span>)</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'从数据库中读取数据'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">123</span></div></pre></td></tr></table></figure>
<p>现在我们创建两个文件：<code>a.py</code>和<code>b.py</code>，用来模拟在一个工程里面的两个不同地方同时调用数据库操作类并初始化的过程。</p>
<p><code>a.py</code>内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> DBUtil <span class="keyword">import</span> DBUtil</div><div class="line"><span class="keyword">from</span> b <span class="keyword">import</span> run</div><div class="line"></div><div class="line">data = run()</div><div class="line">db_util = DBUtil()</div><div class="line">db_util.write(data)</div></pre></td></tr></table></figure>
<p><code>b.py</code>的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> DBUtil <span class="keyword">import</span> DBUtil</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></div><div class="line">    db_util = DBUtil()</div><div class="line">    data = db_util.read()</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-12-22-52-47.png" alt=""></p>
<p>可以看到，<code>创建数据库连接</code>被打印了两次，说明<code>DBUtil</code>类被实例化了两次。对应到真实的项目中，就是创建了多个到数据库的链接。这样是很浪费资源的。</p>
<p>当然，你可以在 <code>a.py</code>中初始化<code>DBUtil</code>，然后把这个对象作为参数传入<code>run</code>函数里面，再<code>run</code>函数里面调用这个对象的<code>read()</code>方法。</p>
<p>但是在实际项目中，往往会出现很多层的调用，如果要把一个对象一层一层传下去，不仅让参数列表显得杂乱，还容易漏掉或者搞错顺序。</p>
<p>所以，使用单例模式就能避免通过参数传递对象，但又不会创建多个数据库连接。</p>
<p>网上关于单例模式的代码有很多。本文将会介绍最简单的一种，利用 Python 的<code>import</code>机制。在 Python 里面，一个模块只会被导入1次，如果多次使用<code>import xxx</code>导入同一个模块，后面的导入语句会被自动忽略。你用这个机制，我们就能很容易实现单例模式。</p>
<p>修改<code>DBUtil.py</code>，在它的最下面加上一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.conn = self.connect()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'创建数据库连接'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="string">'connect'</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        print(f<span class="string">'写入数据：&#123;data&#125;'</span>)</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'从数据库中读取数据'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">123</span></div><div class="line"></div><div class="line">db_util = DBUtil()</div></pre></td></tr></table></figure>
<p>修改<code>a.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> DBUtil <span class="keyword">import</span> db_util</div><div class="line"><span class="keyword">from</span> b <span class="keyword">import</span> run</div><div class="line"></div><div class="line">data = run()</div><div class="line">db_util.write(data)</div></pre></td></tr></table></figure>
<p>修改<code>b.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> DBUtil <span class="keyword">import</span> db_util</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></div><div class="line">    data = db_util.read()</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<p>运行以后的效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-12-23-02-25.png" alt=""></p>
<p>可以看到，<code>创建数据库连接</code>只打印了1次，说明单例模式成功。</p>
<p>这种单例模式非常简单，但是有一个弊端，就是无法实现懒加载。程序刚刚开始运行，<code>DBUtil</code>类就会被实例化，无法做到等到需要的时候才实例化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二十几种设计模式中，单例模式是最简单最常用的一种。在其他语言里面实现单例模式要写不少代码，但是在 Python 里面，有一种非常简单的单例模式写法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="设计模式" scheme="https://www.kingname.info/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>禁止通行——如何让 itertools.tee 线程安全</title>
    <link href="https://www.kingname.info/2019/11/06/thread-safe-in-tee/"/>
    <id>https://www.kingname.info/2019/11/06/thread-safe-in-tee/</id>
    <published>2019-11-06T14:39:31.000Z</published>
    <updated>2019-12-11T14:40:34.880Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们说到了，<code>itertools.tee</code>不是线程安全的，并给出了一个例子，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-22-04-16.png" alt=""></p>
<p>在两个线程里面同时运行分裂出来的生成器对象，就会导致报错。</p>
<a id="more"></a>
<p>现在，你想看看<code>itertools.tee</code>的源代码，但是你会发现，在 PyCharm 里面，它的源代码如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-21-55-40.png" alt=""></p>
<p>这是因为，在 CPython 中，<code>itertools.tee</code>底层是通过C 语言实现的，所以你不能在 PyCharm 中看到它的源代码。但是你可以通过阅读 <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c" target="_blank" rel="external">Python 的源代码中的Modules/itertoolsmodule.c文件</a>，找到它的实现算法。</p>
<p>导致问题的核心部分在如下图所示的两段代码中：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-03-11.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-05-19.png" alt=""></p>
<p>大家看不懂也没有关系，根据我上一篇文章中使用 Python 实现的简化版本就足够帮助理解了。</p>
<p>我们使用简化版本来解释其中线程不安全的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="keyword">yield</span> f<span class="string">'我是你第&#123;i&#125;个爷爷'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></div><div class="line">    value_list_1 = []</div><div class="line">    value_list_2 = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(queue)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    value = next(g)</div><div class="line">                <span class="keyword">except</span> StopIteration:</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                value_list_1.append(value)</div><div class="line">                value_list_2.append(value)</div><div class="line">            <span class="keyword">yield</span> queue.pop(<span class="number">0</span>)</div><div class="line">    g_1 = wrap(value_list_1)</div><div class="line">    g_2 = wrap(value_list_2)</div><div class="line">    <span class="keyword">return</span> g_1, g_2</div><div class="line"></div><div class="line">g = generator()</div><div class="line">g_1, g_2 = split(g)</div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</div><div class="line">    print(value)</div><div class="line"></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_2:</div><div class="line">    print(value)</div></pre></td></tr></table></figure>
<p>当两个线程同时运行到<code>if not queue</code>时，发现当前各自的队列都是空的，于是进入<code>value = next(g)</code>获取下一个值。其中，线程 A 先进入那么几毫秒。然后线程 B 进入<code>value = next(g)</code>。但由于此时线程 A 中的<code>next(g)</code>正在运行，尚未结束，线程 B 又跑来运行，于是就导致了报错的发生。Python 中，生成器不是线程安全的。</p>
<p>那么如何让<code>itertools.tee</code>分裂出来的多个生成器可以在多线程中运行呢？其关键因素就是让<code>value = next(g)</code>这一行一次只能让一个线程运行。所以我们可以通过加锁来实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KingnameTee</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tee_obj, lock)</span>:</span></div><div class="line">        self.tee_obj = tee_obj</div><div class="line">        self.lock = lock</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            <span class="keyword">return</span> next(self.tee_obj)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__copy__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> KingnameTee(self.tee_obj.__copy__(), self.lock)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_tee</span><span class="params">(iterable, n=<span class="number">2</span>)</span>:</span></div><div class="line">    <span class="string">"""tuple of n independent thread-safe iterators"""</span></div><div class="line">    lock = Lock()</div><div class="line">    <span class="keyword">return</span> tuple(KingnameTee(tee_obj, lock) <span class="keyword">for</span> tee_obj <span class="keyword">in</span> itertools.tee(iterable, n))</div></pre></td></tr></table></figure>
<p>我们来看看运行效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-21-01.png" alt=""></p>
<p>多线程完美运行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，我们说到了，&lt;code&gt;itertools.tee&lt;/code&gt;不是线程安全的，并给出了一个例子，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-22-04-16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在两个线程里面同时运行分裂出来的生成器对象，就会导致报错。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="生成器" scheme="https://www.kingname.info/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
      <category term="多线程" scheme="https://www.kingname.info/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>炸掉你的内存—— itertools.tee 的弊端</title>
    <link href="https://www.kingname.info/2019/11/05/your-memory-boom/"/>
    <id>https://www.kingname.info/2019/11/05/your-memory-boom/</id>
    <published>2019-11-05T14:38:15.000Z</published>
    <updated>2019-12-11T14:39:10.816Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们讲到了，使用<code>itertools.tee</code>可以让一个生成器被多次完整遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools </div><div class="line"></div><div class="line">g = generator()</div><div class="line">g_1, g_2, g_3 = itertools.tee(g, <span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_1:</div><div class="line">    print(row)</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_2:</div><div class="line">    print(row)</div><div class="line">    </div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_3:</div><div class="line">    print(row)</div></pre></td></tr></table></figure>
<p>但是，我们说到<code>itertools.tee</code>有两个弊端，其一，如果分裂出来的多个生成器是按顺序执行的，其中一个完整遍历了再遍历第二个，那么就会导致内存中堆积大量的数据。</p>
<p>要解释这个问题的原因，我们就要理解<code>itertools.tee</code>背后的原理。</p>
<a id="more"></a>
<p>我们知道，一个生成器只能被完整遍历一次。那么如果我想强行让他被遍历两次怎么办呢？最简单的办法是搞个列表出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">g = generator()</div><div class="line">value_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> g]</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> value_list:</div><div class="line">    print(row)</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> value_list:</div><div class="line">    print(row)</div></pre></td></tr></table></figure>
<p>转换为列表以后，你想完整遍历几次，就能完整遍历几次。但这样做，就背离了使用生成器节省内存的目的。所有的数据，全都在列表里面，如果数据量非常非常多，那么内存可能就会爆炸。</p>
<p>所以我们需要一边迭代生成器，一边消费数据。为了实现这个目的，我们先来看看，如何一条一条地取出生成器里面的数据——<code>next</code> 函数。</p>
<p>当我们每次执行<code>next(g)</code>的时候，生成器被迭代1次，并返回1条数据，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-25-21.png" alt=""></p>
<p>当生成器的所有数据都被遍历完成以后，再次执行<code>next(g)</code>就会抛出<code>StopIteration</code>异常。所以当我们捕获到这个异常的时候，就说明生成器里面的所有数据都遍历完成了。</p>
<p>现在，我们把生成器<code>分裂出来</code>，但是取极端情况，只分裂1个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        <span class="keyword">yield</span> f<span class="string">'我是你第&#123;i&#125;个爷爷'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></div><div class="line">    value_list = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value_list:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                value = next(g)</div><div class="line">            <span class="keyword">except</span> StopIteration:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            value_list.append(value)</div><div class="line">        <span class="keyword">yield</span> value_list.pop()</div><div class="line"></div><div class="line">g = generator()</div><div class="line">g_1 = split(g)</div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</div><div class="line">    print(value)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-31-28.png" alt=""></p>
<p><code>split</code>生成器函数，写了一大堆代码，似乎做了无用功——如果<code>value_list</code>为空，那么就从原始生成器里面取一个数据，然后放入 <code>value_list</code> 列表，然后又把这个数从 <code>value_list</code>取出来，再抛给上层。</p>
<p>这样写有什么意义呢？</p>
<p>现在，我们修改代码，让 split 能够分裂出两个生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        <span class="keyword">yield</span> f<span class="string">'我是你第&#123;i&#125;个爷爷'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></div><div class="line">    value_list_1 = []</div><div class="line">    value_list_2 = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(queue)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    value = next(g)</div><div class="line">                <span class="keyword">except</span> StopIteration:</div><div class="line">                    <span class="keyword">return</span></div><div class="line">                value_list_1.append(value)</div><div class="line">                value_list_2.append(value)</div><div class="line">            <span class="keyword">yield</span> queue.pop(<span class="number">0</span>)</div><div class="line">    g_1 = wrap(value_list_1)</div><div class="line">    g_2 = wrap(value_list_2)</div><div class="line">    <span class="keyword">return</span> g_1, g_2</div><div class="line"></div><div class="line">g = generator()</div><div class="line">g_1, g_2 = split(g)</div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</div><div class="line">    print(value)</div><div class="line"></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_2:</div><div class="line">    print(value)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-42-29.png" alt=""></p>
<p>现在， <code>split</code>是一个会返回两个生成器的函数。首先创建两个列表<code>value_list_1</code>和<code>value_list_2</code>，然后定义一个闭包生成器函数<code>wrap</code>。它接收一个参数<code>queue</code>。这个参数是一个列表。</p>
<p>如果<code>queue</code>不为空，那么取它的第0个元素，并抛出给上层。如果<code>queue</code>为空，迭代一次原始生成器，获得的值同时放进<code>value_list_1</code>和<code>value_list_2</code>这两个列表中。此时，由于<code>queue</code>列表必定是<code>value_list_1</code>或者<code>value_list_2</code>的其中一个，所以此时<code>queue</code>必定不为空，因此可以取它下标为0的元素，抛出给上层。</p>
<p>由于<code>.pop</code>在取出数据以后，会把这个数据从列表里面删除。所以<code>queue</code>对应的列表又会变成空。</p>
<p>但大家有没有发现，此时，另外一个列表的数据，是留在列表里面的，没有被消费。</p>
<p>所以，如果我始终迭代<code>g_1</code>这个分裂后的生成器，那么<code>wrap</code>的参数始终是<code>value_list_1</code>，此时，<code>value_list_2</code>始终没有被消费，于是数据就会越堆越多，最后撑爆内存。</p>
<p>所以，<code>itertools.tee</code>分裂以后的多个生成器，应该尽量间隔着迭代，或者“同时迭代”，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        value = next(g_1)</div><div class="line">        parse(value)</div><div class="line">        value = next(g_2)</div><div class="line">        parse(value)</div><div class="line">    <span class="keyword">except</span> StopIteration:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>这样调用，就能始终保证两个列表最多只有1条数据，就不会出现堆积的问题。</p>
<p>但是在实际项目中，很难这样写，所以你可能会想，是不是可以把分裂后的多个生成器，放进多个线程里面同步运行。这样虽然列表里面的数据会超过1条，但也不会堆积太多。</p>
<p>然而这是不行的，<code>itertools.tee</code>分裂出来的多个生成器不是线程安全的，不能在多线程里面运行，否则会导致报错。这里给出一个报错的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</div><div class="line">        <span class="keyword">yield</span> i</div><div class="line"></div><div class="line">g = generator()</div><div class="line">g_1, g_2 = itertools.tee(g, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [g_1, g_2]:</div><div class="line">    threading.Thread(target=sum, args=(x, )).start()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-22-04-16.png" alt=""></p>
<p>在下一篇文章中，我们将会说明，为什么分裂以后的生成器不是线程安全的，以及如何让它线程安全。</p>
<p>P.S.:本文介绍 <code>itertools.tee</code>的代码经过简化和修改，用于表示这个函数的核心逻辑。但真正的源代码比这个简化版本要复杂得多。并且源代码中队列是使用<code>dequeue</code>而不是列表。因为<code>dequeue</code>是基于双向链表实现的，在两头增加删除数据，时间复杂度都是 O(1)，但是从列表的头部删除数据，时间复杂度为 O(n)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，我们讲到了，使用&lt;code&gt;itertools.tee&lt;/code&gt;可以让一个生成器被多次完整遍历：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; itertools &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;g = generator()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;g_1, g_2, g_3 = itertools.tee(g, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; g_1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(row)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; g_2:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(row)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; g_3:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(row)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，我们说到&lt;code&gt;itertools.tee&lt;/code&gt;有两个弊端，其一，如果分裂出来的多个生成器是按顺序执行的，其中一个完整遍历了再遍历第二个，那么就会导致内存中堆积大量的数据。&lt;/p&gt;
&lt;p&gt;要解释这个问题的原因，我们就要理解&lt;code&gt;itertools.tee&lt;/code&gt;背后的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="生成器" scheme="https://www.kingname.info/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>一个生成器如何当两个用？</title>
    <link href="https://www.kingname.info/2019/11/05/one-generator-to-two/"/>
    <id>https://www.kingname.info/2019/11/05/one-generator-to-two/</id>
    <published>2019-11-05T14:37:00.000Z</published>
    <updated>2019-12-11T14:37:54.433Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，Python 里面的生成器只能被消费一次，例如如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">'产品经理'</span>, <span class="string">'kingname'</span>]:</div><div class="line">        <span class="keyword">yield</span> name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(g)</span>:</span></div><div class="line">    print(<span class="string">'hello 函数开始运行'</span>)</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> g:</div><div class="line">        print(<span class="string">'hello'</span>, name)</div><div class="line">    print(<span class="string">'hello 函数运行完成'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(g)</span>:</span></div><div class="line">    print(<span class="string">'hi函数开始运行'</span>)</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> g:</div><div class="line">        print(<span class="string">'hi'</span>, name)</div><div class="line">    print(<span class="string">'hi函数运行完成'</span>)</div><div class="line"></div><div class="line">names = name_generator()</div><div class="line">say_hello(names)</div><div class="line">say_hi(names)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-04-23-13-54.png" alt=""></p>
<p>在 <code>say_hello</code>函数里面，生成器已经被完整遍历了一次，那么在<code>say_hi</code>里面，就什么数据都拿不到了。</p>
<p>但如果我们用的是列表，就可以多次遍历，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-04-23-15-26.png" alt=""></p>
<p>大家注意观察区别。</p>
<p>那么有什么办法，能让生成器被多次完整迭代呢？这个时候就要使用<code>itertools.tee</code>这个函数了。它通过<code>dequeue</code>实现了让生成器多次消费的办法。</p>
<a id="more"></a>
<p><code>itertools.tee</code>的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">生成器<span class="number">1</span>, 生成器<span class="number">2</span>, 生成器<span class="number">3</span> = itertools.tee(原始生成器, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p><code>itertools.tee</code>的第一个参数是原始生成器，第二个参数是你希望让它返回多少个可以复用的生成器。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">'产品经理'</span>, <span class="string">'kingname'</span>]:</div><div class="line">        <span class="keyword">yield</span> name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(g)</span>:</span></div><div class="line">    print(<span class="string">'hello 函数开始运行'</span>)</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> g:</div><div class="line">        print(<span class="string">'hello'</span>, name)</div><div class="line">    print(<span class="string">'hello 函数运行完成'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(g)</span>:</span></div><div class="line">    print(<span class="string">'hi函数开始运行'</span>)</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> g:</div><div class="line">        print(<span class="string">'hi'</span>, name)</div><div class="line">    print(<span class="string">'hi函数运行完成'</span>)</div><div class="line"></div><div class="line">names = name_generator()</div><div class="line">names_1, names_2 = itertools.tee(names, <span class="number">2</span>)</div><div class="line">say_hello(names_1)</div><div class="line">say_hi(names_2)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-04-23-19-45.png" alt=""></p>
<p>但是，<code>itertools.tee</code>有两个缺陷：</p>
<p>其一是如果原始生成器能循环非常多次，产生的数据量非常大，并且你在消费的时候，是先迭代第一个分裂后的生成器，完整迭代完以后再迭代第二个分裂后的生成器，那么这将会浪费大量内存。所以，应该让两个生成器能间隔着迭代，或者“同时”迭代。</p>
<p>其二，多个生成器同时迭代也有问题，分裂出来的多个生成器不是线程安全的，在多线程里面同时运行会导致报错。</p>
<p>在接下来的两篇文章中，我会讲到<code>itertools.tee</code>是如何做到让生成器多次迭代的，然后讲到如何让分裂以后的生成器线程安全。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，Python 里面的生成器只能被消费一次，例如如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;name_generator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&#39;产品经理&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;kingname&#39;&lt;/span&gt;]:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;say_hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(g)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;hello 函数开始运行&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; g:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;, name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;hello 函数运行完成&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;say_hi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(g)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;hi函数开始运行&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; g:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;hi&#39;&lt;/span&gt;, name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;hi函数运行完成&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;names = name_generator()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;say_hello(names)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;say_hi(names)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-04-23-13-54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;say_hello&lt;/code&gt;函数里面，生成器已经被完整遍历了一次，那么在&lt;code&gt;say_hi&lt;/code&gt;里面，就什么数据都拿不到了。&lt;/p&gt;
&lt;p&gt;但如果我们用的是列表，就可以多次遍历，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-04-23-15-26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家注意观察区别。&lt;/p&gt;
&lt;p&gt;那么有什么办法，能让生成器被多次完整迭代呢？这个时候就要使用&lt;code&gt;itertools.tee&lt;/code&gt;这个函数了。它通过&lt;code&gt;dequeue&lt;/code&gt;实现了让生成器多次消费的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="生成器" scheme="https://www.kingname.info/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>产品经理的故事：产品经理拿错了别人的外卖</title>
    <link href="https://www.kingname.info/2019/11/04/pm-get-others-thing/"/>
    <id>https://www.kingname.info/2019/11/04/pm-get-others-thing/</id>
    <published>2019-11-04T14:35:18.000Z</published>
    <updated>2019-12-11T14:36:29.895Z</updated>
    
    <content type="html"><![CDATA[<p>产品经理中午没有赶上食堂的午饭，于是纠集了一批人一起点外卖。然而正当她要下单时，老板找她有开会，于是她让开发小哥随便帮忙点一份。</p>
<p>产品经理开完会回来以后，发现还剩三份外卖没有人拿，分别是鲱鱼汤、螺蛳粉和大肠刺身。此时开发小哥碰巧不在，产品经理一时不知道哪一份才是自己的。</p>
<a id="more"></a>
<p>产品经理想随便选一份，于是选了鲱鱼汤。正当她抱起鲱鱼汤准备走时，开发小哥风风火火跑过来，拿着螺蛳粉又跑了，产品经理甚至来不及询问哪一个才是自己的。</p>
<p>产品经理一想，虽然自己是文科生，但是现在只剩两个外卖，选哪一个都是二分之一的概率。所以直接拿走了鲱鱼汤。</p>
<p>3分钟以后，研究员小哥咆哮一声：谁拿走了我的鲱鱼汤？</p>
<p>产品经理赶紧喝完了汤，若无其事地把鲱鱼汤的包装扔进了垃圾桶。</p>
<p>躲在暗处的开发小哥注视着刚才发生的一切，用中指推了推眼镜，镜片上一道光芒闪过，转身走向了厕所。</p>
<p>其实，开发小哥在不久之前才教会了产品经理使用 Python，如果产品经理写几行代码验证一下概率，就会发现事情并不简单。</p>
<p>我们假设：</p>
<ol>
<li>这三个外卖里面，有且只有一份是产品经理的</li>
<li>开发小哥跑过来，不会抢产品经理手上拿着的外卖</li>
<li>开发小哥拿走的，一定不是属于产品经理的外卖</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">options = &#123;<span class="string">'鲱鱼汤'</span>, <span class="string">'螺蛳粉'</span>, <span class="string">'大肠刺身'</span>&#125;</div><div class="line">pm = random.choice(list(options))  <span class="comment"># 开发小哥给产品经理点的外卖</span></div><div class="line">right = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">    guess = random.choice(list(options)) <span class="comment"># 产品经理随机选的外卖</span></div><div class="line">    </div><div class="line">    <span class="comment"># 开发小哥会从剩下的两个外卖中，拿走不属于产品经理的一个</span></div><div class="line">    exclude_options = options - &#123;guess, pm&#125;  </div><div class="line">    exclude = random.choice(list(exclude_options))</div><div class="line"></div><div class="line">    <span class="comment"># 如果产品经理此时更换了选项</span></div><div class="line">    new_guess_option = options - &#123;exclude, guess&#125;</div><div class="line">    new_guess = random.choice(list(new_guess_option))</div><div class="line">    <span class="keyword">if</span> new_guess == pm:</div><div class="line">        right += <span class="number">1</span></div><div class="line">print(right / <span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-03-15-06-51.png" alt=""></p>
<p>如果产品经理在看到开发小哥拿走了外卖以后，更换自己的选择，那么选对的概率是2/3.如果不更换自己的选择，选中的概率为1/3.</p>
<p>相信很多人都会跟产品经理一样，觉得选对的概率是1/2.对代码的计算结果感到惊讶，这非常违反直觉。</p>
<p>其实，整个问题的关键在于，开发小哥不是随机从剩下的两个外卖中拿走一个。开发小哥拿走的一定是不属于产品经理的外卖。</p>
<p>相信很多人不想看概率公式，所以我们今天不用概率来解释。我另外举一个例子：</p>
<p>我现在有三个盒子，其中一个盒子里面放手机。但你不知道手机在哪个盒子里面。</p>
<ol>
<li>你选一个盒子放在你的包里面，另外两个盒子放在我的包里面，我问你换不换包，你会换吗？我包里面有两个盒子，所以我的<code>包</code>里面有手机的概率是2/3，你显然要换。</li>
<li>你选一个盒子放在你的包里面，另外两个盒子放在我的包里面，然后我从我包里面丢掉一个空盒子，再问你换不换包。此时，我丢掉空盒子并不会影响我包里面有手机的概率为2/3.你显然要换。</li>
<li>现在去掉<code>包</code>这个可有可无的东西——你选一个盒子，我从剩下两个盒子里面扔掉一个空盒子，问你要不要更换选择？你说换不换？</li>
</ol>
<p>最后我们再从概率上来定量解释一下这个问题。如果产品经理始终选择要更换，那么：</p>
<ol>
<li>第一次就选中了她的外卖，此时更换以后，选对的概率为1/3 * 0</li>
<li>第一次选中了别人的外卖1，开发小哥必定拿走别人的外卖2，此时产品经理选对的概率为：1/3 * 1 = 1/3</li>
<li>第一次选中了别人的外卖2，开发小哥必定拿走别人的外卖1，此时产品经理选对的概率为：1/3 * 1 = 1/3</li>
</ol>
<p>所以如果选择要换，产品经理选对的概率为<code>0 + 1/3 + 1/3 = 2/3</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产品经理中午没有赶上食堂的午饭，于是纠集了一批人一起点外卖。然而正当她要下单时，老板找她有开会，于是她让开发小哥随便帮忙点一份。&lt;/p&gt;
&lt;p&gt;产品经理开完会回来以后，发现还剩三份外卖没有人拿，分别是鲱鱼汤、螺蛳粉和大肠刺身。此时开发小哥碰巧不在，产品经理一时不知道哪一份才是自己的。&lt;/p&gt;
    
    </summary>
    
      <category term="博弈论" scheme="https://www.kingname.info/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="博弈论" scheme="https://www.kingname.info/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>为什么我能一天更新13篇博客？</title>
    <link href="https://www.kingname.info/2019/11/03/follow-my-wechat-platform/"/>
    <id>https://www.kingname.info/2019/11/03/follow-my-wechat-platform/</id>
    <published>2019-11-03T02:46:00.000Z</published>
    <updated>2019-11-03T02:49:40.009Z</updated>
    
    <content type="html"><![CDATA[<p>不是因为我高产似那啥。而是因为这些文章是我每天一篇发布在微信公众号上的，然后每隔一段时间整体搬运到博客上面来。</p>
<p>所以还没有关注我微信公众号的同学，请扫描下面的二维码，关注我的公众号，每天一篇原创文章，每天都有新技能 Get。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不是因为我高产似那啥。而是因为这些文章是我每天一篇发布在微信公众号上的，然后每隔一段时间整体搬运到博客上面来。&lt;/p&gt;
&lt;p&gt;所以还没有关注我微信公众号的同学，请扫描下面的二维码，关注我的公众号，每天一篇原创文章，每天都有新技能 Get。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
    
    </summary>
    
      <category term="杂谈" scheme="https://www.kingname.info/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="公众号" scheme="https://www.kingname.info/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用 yield 压平多层字典列表混合嵌套数据</title>
    <link href="https://www.kingname.info/2019/11/03/flat-dict-with-list/"/>
    <id>https://www.kingname.info/2019/11/03/flat-dict-with-list/</id>
    <published>2019-11-03T02:08:53.000Z</published>
    <updated>2019-11-03T02:10:08.035Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章里面，我们讲到了如何使用Python的<code>yield</code>关键字简化代码，压平多层嵌套字典的。</p>
<p>那么如果我们的数据不仅仅有字典，还有列表，是一个字典列表多层嵌套的数据怎么办呢？例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nest_dict = &#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b'</span>: &#123;</div><div class="line">        <span class="string">'c'</span>: <span class="number">2</span>,</div><div class="line">        <span class="string">'d'</span>: <span class="number">3</span>,</div><div class="line">        <span class="string">'e'</span>: &#123;<span class="string">'f'</span>: <span class="number">4</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'g'</span>: &#123;<span class="string">'h'</span>: <span class="number">5</span>&#125;,</div><div class="line">    <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line">    <span class="string">'j'</span>: &#123;<span class="string">'k'</span>: &#123;<span class="string">'l'</span>: &#123;<span class="string">'m'</span>: <span class="number">8</span>&#125;&#125;&#125;,</div><div class="line">    <span class="string">'n'</span>: [<span class="number">1</span>, &#123;<span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'p'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  <span class="string">'q'</span>: &#123;<span class="string">'r'</span>: &#123;<span class="string">'s'</span>: <span class="number">100</span>&#125;&#125;&#125;, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">5</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，请停下来，敲一敲代码，想想如何把处理列表的逻辑添加进去。</p>
<p>首先，我们来看一下最终被压平以后的数据长什么样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'b_c'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'b_d'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'b_e_f'</span>: <span class="number">4</span>,</div><div class="line"> <span class="string">'g_h'</span>: <span class="number">5</span>,</div><div class="line"> <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line"> <span class="string">'j_k_l_m'</span>: <span class="number">8</span>,</div><div class="line"> <span class="string">'n_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_o'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_p_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_p_1'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'n_1_p_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_1_q_r_s'</span>: <span class="number">100</span>,</div><div class="line"> <span class="string">'n_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_3_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_3_1'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'n_3_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_4'</span>: <span class="number">5</span>&#125;</div></pre></td></tr></table></figure>
<p>对于<code>&#39;n&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>这种形式的数据，我们把它转换为： <code>{&#39;n_0&#39;: &#39;a&#39;, &#39;n_1&#39;: &#39;b&#39;, &#39;n_2&#39;: &#39;c&#39;}</code></p>
<a id="more"></a>
<p>我们原来的核心代码是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">if</span> isinstance(value, dict):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>你的第一反应，是不是这样修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">if</span> isinstance(value, dict):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">elif</span> isinstance(value, list):</div><div class="line">            <span class="string">"一大堆处理列表的代码"</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>如果你使用<code>return</code>和递归，你可能确实需要这样写。</p>
<p>但如果你使用<code>yield</code>关键字，那么，你虽然也要修改代码，可是修改的地方却不是这里。我们要修改的地方在<code>for key, value in x.items()</code>。</p>
<p>因为<code>.items()</code>这个方法是字典的方法，列表没有这个方法。所以我们需要写一个通用的迭代生成器，支持字典和列表，所以我们增加一个函数：<code>iter_x</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_x</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(x, dict):</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">            <span class="keyword">yield</span> (key, value)</div><div class="line">    <span class="keyword">elif</span> isinstance(x, list):</div><div class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(x):</div><div class="line">            <span class="keyword">yield</span> (index, value)</div></pre></td></tr></table></figure>
<p>现在，我们在原来的代码中调用这段个新的生成器函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> iter_x(x):</div><div class="line">        <span class="keyword">if</span> isinstance(value, (dict, list)):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>其中，<code>isinstance(value, (dict, list))</code>，相当于<code>isinstance(value, dict) or isinstance(value, list)</code>。</p>
<p>我们来看一下运行效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-02-22-25-08.png" alt=""></p>
<p>掌握<code>yield</code>关键字，你的编程思路和想问题的方式会发生一个重大的转变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章里面，我们讲到了如何使用Python的&lt;code&gt;yield&lt;/code&gt;关键字简化代码，压平多层嵌套字典的。&lt;/p&gt;
&lt;p&gt;那么如果我们的数据不仅仅有字典，还有列表，是一个字典列表多层嵌套的数据怎么办呢？例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;nest_dict = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;g&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;j&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;k&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;l&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;n&#39;&lt;/span&gt;: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],  &lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，请停下来，敲一敲代码，想想如何把处理列表的逻辑添加进去。&lt;/p&gt;
&lt;p&gt;首先，我们来看一下最终被压平以后的数据长什么样：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_e_f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;g_h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;j_k_l_m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_o&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_1&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_q_r_s&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_1&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_4&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于&lt;code&gt;&amp;#39;n&amp;#39;: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]&lt;/code&gt;这种形式的数据，我们把它转换为： &lt;code&gt;{&amp;#39;n_0&amp;#39;: &amp;#39;a&amp;#39;, &amp;#39;n_1&amp;#39;: &amp;#39;b&amp;#39;, &amp;#39;n_2&amp;#39;: &amp;#39;c&amp;#39;}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="yield" scheme="https://www.kingname.info/tags/yield/"/>
    
  </entry>
  
</feed>
