<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2020-03-23T15:41:11.370Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你经常看到却经常忽视的__init__.py有什么用？</title>
    <link href="https://www.kingname.info/2020/03/23/init-in-python/"/>
    <id>https://www.kingname.info/2020/03/23/init-in-python/</id>
    <published>2020-03-23T15:40:46.000Z</published>
    <updated>2020-03-23T15:41:11.370Z</updated>
    
    <content type="html"><![CDATA[<p>Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做<code>__init__.py</code>的文件。下图为著名的第三方库<code>requests</code>的源代码：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png" alt=""></p>
<p>那么<code>__init__.py</code>有什么用呢？本文介绍它的两个用途。</p>
<a id="more"></a>
<h2 id="精简导入路径"><a href="#精简导入路径" class="headerlink" title="精简导入路径"></a>精简导入路径</h2><p>假设我们有两个文件<code>main.py</code>与<code>writer.py</code>，他们所在的文件结构如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-48-36.png" alt=""></p>
<p><code>main.py</code>在<code>DocParser</code>文件夹下面；<code>writer.py</code>在<code>DocParser/microsoft/docx/</code>文件夹下面。<code>writer.py</code>文件中有一个函数<code>write</code>。其内容如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-48.png" alt=""></p>
<p>现在我想在<code>main.py</code>文件夹调用这个函数，那么我有3种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> microsoft.word.docx.writer <span class="keyword">import</span> write</div><div class="line"></div><div class="line">write()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-50-32.png" alt=""></p>
<p>或者这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> microsoft.word.docx <span class="keyword">import</span> writer</div><div class="line"></div><div class="line">writer.write()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-51-21.png" alt=""></p>
<p>或者这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> microsoft.word.docx.writer</div><div class="line"></div><div class="line">microsoft.word.docx.writer.write()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-52-02.png" alt=""></p>
<p>但无论那种方法，都要写长长的路径，甚为不便。这个时候，我们可以在<code>microsoft</code>文件夹下面创建一个<code>__init__.py</code>文件，并在里面填写如下内容：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt=""></p>
<p>此时，在 <code>main.py</code>，我们导入<code>write</code>函数，就像是从<code>microsoft.py</code> 文件中导入一样。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-54-39.png" alt=""></p>
<p>注意上面我说的是就像从<code>microsoft.py 文件</code>中导入一样，这里是用的<code>文件</code>而不是<code>文件夹</code>。</p>
<p>这是因为，当一个文件夹里面有<code>__init__.py</code>以后，这个文件夹就会被 Python 作为一个<code>包(package)</code>来处理。此时，对于这个包里面层级比较深的函数、常量、类，我们可以先把它们导入到<code>__init__.py</code>中。这样以来，包外面再想导入这些内容时，就可以用<code>from 包名 import 函数名</code>来导入了。</p>
<h2 id="无视工作区的相对引用"><a href="#无视工作区的相对引用" class="headerlink" title="无视工作区的相对引用"></a>无视工作区的相对引用</h2><p>为什么会有<code>包</code>这个东西呢？这是因为，当有一些代码会在很多地方被使用时，我们可以把这些代码打包起来，作为一个公共的部分提供给其他模块调用。</p>
<p>由于调用包的其他模块所在的绝对路径是千变万化的，所以在包的内部调用自身其他文件中的函数、常量、类，就应该使用相对路径，而是绝对路径。</p>
<p>例如，现在我在<code>microsoft</code>文件夹下面再创建一个<code>parse.py</code>文件，它需要导入<code>microsoft/word/docx/writer.py</code>中的<code>write</code>函数，那么代码可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> .word.docx.writer <span class="keyword">import</span> write</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_doc</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'现在在 parse.py 中调用 write 函数'</span>)</div><div class="line">    write()</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-08-34.png" alt=""></p>
<p>可以看到，此时<code>from .word.docx.writer</code>中的<code>.</code>表示当前包，所以<code>.word.docx.writer</code>表示当前包下面的word 文件夹下面的 docx 文件夹下面的 writer.py 文件。</p>
<p>然后我们修改<code>__init__.py</code>，把<code>parse_doc</code>函数导入进去，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-25.png" alt=""></p>
<p>最后，在<code>main.py</code>中调用这个<code>parse_doc</code>函数，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-10-59.png" alt=""></p>
<p>可以看到，在包里面的一个文件调用这个包里面的另一个文件，只需要知道另一个文件的相对位置就可以了，不用关心这个包被放在哪里。</p>
<p>并且，上面<code>parse.py</code>中导入<code>write</code>函数的代码还可以进一步简化，由于<code>write</code>函数已经被导入到了<code>__init__.py</code>中，所以我们可以直接从<code>.</code>里面导入<code>write</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> write</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-20-13-05.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当一个文件夹里面包含<code>__init__.py</code>时，这个文件夹会被 Python 认为是一个<code>包(package)</code>，此时，包内部的文件之间互相导入可以使用相对导入，并且通过提前把函数、常量、类导入到<code>__init__.py</code>中再在其他文件中导入，可以精简代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 初学者在阅读一些 Python 开源项目时，常常会看到一个叫做&lt;code&gt;__init__.py&lt;/code&gt;的文件。下图为著名的第三方库&lt;code&gt;requests&lt;/code&gt;的源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-29-19-43-20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;__init__.py&lt;/code&gt;有什么用呢？本文介绍它的两个用途。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Python 中的 import 与 from import</title>
    <link href="https://www.kingname.info/2020/03/23/know-import/"/>
    <id>https://www.kingname.info/2020/03/23/know-import/</id>
    <published>2020-03-23T15:40:01.000Z</published>
    <updated>2020-03-23T15:40:29.703Z</updated>
    
    <content type="html"><![CDATA[<p>对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用<code>import xxx</code>？什么时候用<code>from xxx import yyy</code>？什么时候用<code>from xxx.yyy import zzz</code>？什么时候用<code>from xxx import *</code>？</p>
<p>这篇文章，我们来彻底搞懂这个问题。</p>
<a id="more"></a>
<h2 id="系统自带的模块"><a href="#系统自带的模块" class="headerlink" title="系统自带的模块"></a>系统自带的模块</h2><p>以正则表达式模块为例，我们经常这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">target = <span class="string">'abc1234xyz'</span></div><div class="line">re.search(<span class="string">'(\d+)'</span>, target)</div></pre></td></tr></table></figure>
<p>但有时候，你可能会看到某些人这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> re <span class="keyword">import</span> search</div><div class="line">target = <span class="string">'abc1234xyz'</span></div><div class="line">search(<span class="string">'(\d+)'</span>, target)</div></pre></td></tr></table></figure>
<p>那么这两种导入方式有什么区别呢？</p>
<p>我们分别使用<code>type</code>函数来看看他们的类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re</div><div class="line">&gt;&gt;&gt; type(re)</div><div class="line">&lt;class 'module'&gt;</div><div class="line">&gt;&gt;&gt; from re import search</div><div class="line">&gt;&gt;&gt; type(search)</div><div class="line">&lt;class 'function'&gt;</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-30-59.png" alt=""></p>
<p>可以看到，直接使用<code>import re</code>导入的<code>re</code>它是一个<code>module</code>类，也就是模块。我们把它成为<code>正则表达式模块</code>。而当我们<code>from re import search</code>时，这个<code>search</code>是一个<code>function</code>类，我们称呼它为<code>search 函数</code>。</p>
<p>一个模块里面可以包含多个函数。</p>
<p>如果在你的代码里面，你已经确定只使用<code>search</code>函数，不会再使用正则表达式里面的其他函数了，那么你使用两种方法都可以，没什么区别。</p>
<p>但是，如果你要使用正则表达式下面的多个函数，或者是一些常量，那么用第一种方案会更加简洁清晰。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re.search(<span class="string">'c(.*?)x'</span>, flags=re.S)</div><div class="line">re.sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=re.I)</div></pre></td></tr></table></figure>
<p>在这个例子中，你分别使用了<code>re.search</code>，<code>re.sub</code>，<code>re.S</code>和<code>re.I</code>。后两者是常量，用于忽略换行符和大小写。</p>
<p>但是，如果你使用<code>from re import search, sub, S, I</code>来写代码，那么代码就会变成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">search(<span class="string">'c(.*?)x'</span>, flags=S)</div><div class="line">sub(<span class="string">'[a-zA-Z0-9]'</span>, <span class="string">'***'</span>, target, flags=I)</div></pre></td></tr></table></figure>
<p>看起来虽然简洁了，但是，一旦你的代码行数多了以后，你很容易忘记<code>S</code>和<code>I</code>这两个变量是什么东西。而且我们自己定义的函数，也很有可能取名为<code>sub</code>或者<code>search</code>，从而覆盖正则表达式模块下面的这两个同名函数。这就会导致很多难以觉察的潜在 bug。</p>
<p>再举一个例子。Python 的 <code>datetime</code>模块，我们可以直接<code>import datetime</code>，此时我们导入的是一个<code>datetime</code>模块，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-43-21.png" alt=""></p>
<p>但是如果你写为<code>from datetime import datetime</code>，那么你导入的<code>datetime</code>是一个<code>type</code>类：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-45-07.png" alt=""></p>
<p>因为这种方式导入的<code>datetime</code>，它就是Python 中的一种类型，用于表示包含日期和时间的数据。</p>
<p>这两种导入方式导入的<code>datetime</code>，虽然名字一样，但是他们的意义完全不一样，请大家观察下面两种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">now = datetime.datetime.now()</div><div class="line">one_hour_ago = now - datetime.timedelta(hours=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</div><div class="line">now = datetime.now()</div><div class="line">one_hour_ago = now - timedelta(hours=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>第二种写法看似简单，但实则改动起来却更为麻烦。例如我还需要增加一个变量<code>today</code>用于记录今日的日期。</p>
<p>对于第一段代码，我们只需要增加一行即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">today = datetime.date.today()</div></pre></td></tr></table></figure>
<p>但对于第二行来说，我们需要首先修改导入部分的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, date</div></pre></td></tr></table></figure>
<p>然后才能改代码：<code>today = date.today()</code></p>
<p>这样一来你就要修改两个地方，反倒增加了负担。</p>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>在使用某些第三方库的代码里面，我们会看到类似这样的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</div><div class="line"></div><div class="line">selector = fromstring(HTML)</div></pre></td></tr></table></figure>
<p>但是我们还可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</div><div class="line"></div><div class="line">selector = html.fromstring(HTML)</div></pre></td></tr></table></figure>
<p>但是，下面这种写法会导致报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> lxml</div><div class="line">selector = lxml.html.fromstring(HTML)</div></pre></td></tr></table></figure>
<p>那么这里的<code>lxml.html</code>又是什么东西呢？</p>
<p>这种情况多常见于一些特别大型的第三方库中，这种库能处理多种类型的数据。例如<code>lxml</code>它既能处理<code>xml</code>的数据，又能处理<code>html</code>的数据，于是这种库会划分子模块，<code>lxml.html</code>模块专门负责<code>html</code>相关的数据。</p>
<h2 id="自己来实现多种导入方法"><a href="#自己来实现多种导入方法" class="headerlink" title="自己来实现多种导入方法"></a>自己来实现多种导入方法</h2><p>我们现在自己来写代码，实现这多种导入方法。</p>
<p>我们创建一个文件夹<code>DocParser</code>，在里面分别创建两个文件<code>main.py</code>和<code>util.py</code>，他们的内容如下：</p>
<p><code>util.py</code>文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'write 函数被调用！'</span>)</div></pre></td></tr></table></figure>
<p><code>main.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> util</div><div class="line"></div><div class="line">util.write()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-06-29.png" alt=""></p>
<p>现在我们把<code>main.py</code>的导入方式修改一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> util <span class="keyword">import</span> write</div><div class="line"></div><div class="line">write()</div></pre></td></tr></table></figure>
<p>依然正常运行，如下图所示</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-07-21.png" alt=""></p>
<blockquote>
<p>当两个文件在同一个文件夹下面，并且该文件夹里面没有<strong>init</strong>.py 文件时，两种导入方式等价。</p>
</blockquote>
<p>现在，我们来创建一个文件夹<code>microsoft</code>，里面再添加一个文件<code>parse.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'我是 microsoft 文件夹下面的 parse.py 中的 read函数'</span>)</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-11-17.png" alt=""></p>
<p>此时我们在 <code>main.py</code>中对它进行调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> parse</div><div class="line"></div><div class="line">parse.read()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-12-17.png" alt=""></p>
<p>我们也可以用另一种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> microsoft.parse <span class="keyword">import</span> read</div><div class="line"></div><div class="line">read()</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-13-17.png" alt=""></p>
<p>但是，你不能直接导入<code>microsoft</code>，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-15-35.png" alt=""></p>
<blockquote>
<p>你只能导入一个模块或者导入一个函数或者类，你不能导入一个文件夹</p>
</blockquote>
<p>无论你使用的是<code>import xxx</code>还是<code>from xxx.yyy.zzz.www import qqq</code>，你导入进来的东西，要不就是一个模块(对应到.py 文件的文件名)，或者是某个.py 文件中的函数名、类名、变量名。</p>
<p>无论是<code>import xxx</code>还是<code>from xxx import yyy</code>，你导入进来的都不能是一个文件夹的名字。</p>
<p>可能有这样一种情况，就是某个函数名与文件的名字相同，例如：</p>
<p>在 <code>microsoft</code>文件夹里面有一个<code>microsoft.py</code>文件，这个文件里面有一个函数叫做<code>microsoft</code>，那么你的代码可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> microsoft`</div><div class="line">microsoft.microsoft()</div></pre></td></tr></table></figure>
<p>但请注意分辨，这里你导入的还是模块，只不过<code>microsoft.py</code>文件名与它所在的文件夹名恰好相同而已。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是使用<code>import</code>还是<code>from import</code>，第一个要求是代码能够正常运行，其次，根据代码维护性，团队编码风格来确定选择哪一种方案。</p>
<p>如果我们只会使用到某个模块下面的一个函数（或者常量、类）并且名字不会产生混淆，可识别性高，那么<code>from 模块名 import 函数名</code>这没有什么问题。</p>
<p>如果我们会用到一个模块下面的多个函数，或者是我们将要使用的函数名、常量名、类名可能会让人产生混淆（例如 re.S、re.I），那么这种情况下，<code>import 模块名</code>然后再 <code>模块名.xxx</code>来调用会让代码更加清晰，更好维护。</p>
<p>但无论什么情况下，都禁止使用<code>from xxx import *</code>这种写法，它会给你带来无穷无尽的噩梦。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>在明天的文章中，我们来讲讲还有一种写法<code>from . import xxx</code>，以及当文件夹中存在<code>__init__.py</code>时，导入方式又有什么变化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对不少 Python 初学者来说，Python 导入其他模块的方式让他们很难理解。什么时候用&lt;code&gt;import xxx&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import yyy&lt;/code&gt;？什么时候用&lt;code&gt;from xxx.yyy import zzz&lt;/code&gt;？什么时候用&lt;code&gt;from xxx import *&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;这篇文章，我们来彻底搞懂这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：推特时间的格式化方案</title>
    <link href="https://www.kingname.info/2020/03/23/twitter-time-format/"/>
    <id>https://www.kingname.info/2020/03/23/twitter-time-format/</id>
    <published>2020-03-23T15:39:12.000Z</published>
    <updated>2020-03-23T15:39:39.967Z</updated>
    
    <content type="html"><![CDATA[<p>在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="string">"created_at"</span>: <span class="string">"Tue Dec 24 10:51:15 +0000 2019"</span>,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我想把它转换为<code>2019-12-24 18:51:15</code>的形式，应该如何操作呢？</p>
<a id="more"></a>
<p>可能有同学会按照下面这个逻辑来处理：</p>
<ol>
<li>首先，使用空格把这个时间字符串切分开变成<code>[&#39;Tue&#39;, &#39;Dec&#39;, &#39;24&#39;, &#39;10:51:15&#39;, &#39;+0000&#39;, &#39;2019&#39;]</code></li>
<li>第0项是星期，不需要，直接丢弃</li>
<li>第1项是月份，通过一个英文月份简称到月份数字的字典，把<code>Dec</code>映射为<code>12</code></li>
<li>第2项是日期，不做修改</li>
<li>第3项是时分秒，不做修改</li>
<li>第4项是时区，说明这个时间是采用的0时区，比北京时间晚8小时</li>
<li>第5项是年份，不做修改</li>
<li>把修改过的第1项、第2项、第3项、第5项调整顺序，拼接成一个符合要求的时间：<code>2019-12-24 10:51:15</code>。把使用<code>datetime.datetime.strptime</code>转成<code>datetime.datetime</code>对象。</li>
<li>把这个<code>datetime.datetime</code>对象加上<code>datetime.timedelta(hours=8)</code></li>
<li>使用<code>strftime</code>方法再把<code>datetime.datetime</code>对象转回字符串</li>
</ol>
<p>整个过程看起来非常麻烦。</p>
<p>实际上，我们有更简单的办法来处理。<code>Tue Dec 24 10:51:15 +0000 2019</code>对应的时间格式为<code>%a %b %d %H:%M:%S %z %Y</code>；对于一个<code>datetime.datetime</code>对象，我们可以调用它的<code>astimezone</code>方法把时区移除，移除以后就会变成当地时间。</p>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = <span class="string">'Wed Dec 25 09:09:25 +0000 2019'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj = datetime.datetime.strptime(dt, <span class="string">'%a %b %d %H:%M:%S %z %Y'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt_obj.astimezone(tz=<span class="keyword">None</span>).strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"><span class="string">'2019-12-25 17:09:25'</span></div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-25-21-38-09.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用推特开放API获取推文的时候，会发现推文的发布时间是下面这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;created_at&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Tue Dec 24 10:51:15 +0000 2019&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我想把它转换为&lt;code&gt;2019-12-24 18:51:15&lt;/code&gt;的形式，应该如何操作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>逆向操作，把被压平的字典还原成嵌套字典</title>
    <link href="https://www.kingname.info/2020/03/23/reverse-flat/"/>
    <id>https://www.kingname.info/2020/03/23/reverse-flat/</id>
    <published>2020-03-23T15:38:04.000Z</published>
    <updated>2020-03-23T15:38:33.913Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;mid=2648977876&amp;idx=1&amp;sn=76c6f8d0a8dabaefe3aa3f666893c991&amp;chksm=f2506c34c527e522478a1c0e07d52075d05c2436bd326662746c1fd854ee922244dcae23b1dd&amp;token=821834861&amp;lang=zh_CN#rd" target="_blank" rel="external">使用 yield 压平嵌套字典有多简单？</a>这篇文章中，我们讲到，要把一个多层嵌套的字典压平，可以使用<code>yield</code>关键字来实现。</p>
<p>今天，我们倒过来，把一个已经被压平的字典还原成嵌套字典。</p>
<a id="more"></a>
<p>目标字典为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">'a_b_h'</span>:<span class="number">1</span>,</div><div class="line">    <span class="string">'a_b_i'</span>:<span class="number">2</span>,</div><div class="line">    <span class="string">'a_c_j'</span>:<span class="number">3</span>,</div><div class="line">    <span class="string">'a_d'</span>:<span class="number">4</span>,</div><div class="line">    <span class="string">'a_c_k'</span>:<span class="number">5</span>,</div><div class="line">    <span class="string">'a_e'</span>:<span class="number">6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们要把它还原为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"a"</span>: &#123;</div><div class="line">    <span class="string">"b"</span>: &#123;</div><div class="line">      <span class="string">"h"</span>: <span class="number">1</span>,</div><div class="line">      <span class="string">"i"</span>: <span class="number">2</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"c"</span>: &#123;</div><div class="line">      <span class="string">"j"</span>: <span class="number">3</span>,</div><div class="line">      <span class="string">"k"</span>: <span class="number">5</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"d"</span>: <span class="number">4</span>,</div><div class="line">    <span class="string">"e"</span>: <span class="number">6</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现这个需求，我们分成两个主要的步骤。</p>
<h2 id="还原每一个嵌套字典"><a href="#还原每一个嵌套字典" class="headerlink" title="还原每一个嵌套字典"></a>还原每一个嵌套字典</h2><p>对于<code>{&#39;a_b_h&#39;:1}</code>，它实际上被还原以后应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'a'</span>: &#123;<span class="string">'b'</span>: &#123;<span class="string">'h'</span>: <span class="number">1</span>&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<p>现在，写一个函数<code>unpack</code>，这个函数的作用是传入两个参数<code>[&#39;a&#39;, &#39;b&#39;, &#39;h&#39;]</code>和<code>1</code>输出<code>{&#39;a&#39;: {&#39;b&#39;: {&#39;h&#39;: 1}}}</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpack</span><span class="params">(key, value)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(key) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> &#123;key[<span class="number">0</span>]: value&#125;</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        prefix = key.pop(<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> &#123;prefix: unpack(key, value)&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>unpack</code>函数的第一个参数是一个列表，形如：<code>[&#39;a&#39;, &#39;b&#39;, &#39;h&#39;]</code>。运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-20-29-10.png" alt=""></p>
<p>这个函数使用递归，把第一个参数列表一项一项拿出来，作为字典的 key，并把剩下的项作为子字典的 key。当列表只剩一个值的时候，说明已经到了最里面了，把这个值作为最里面字典的 key，第二个参数作为 value。</p>
<p>接下来，我们实现第二个函数<code>deflat</code>，它把目标字典分成<code>key, value</code>对，并把 key 转换为列表以后传给<code>unpack</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deflat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">yield</span> unpack(key.split(<span class="string">'_'</span>), value)</div></pre></td></tr></table></figure>
<p>在 <code>deflat</code>函数中，我们传入目标字典。目标字典的每一对 <code>key, value</code>被取出来，传入<code>unpack</code>函数构造每一个小的嵌套字典。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-20-43-03.png" alt=""></p>
<h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>有了每一个嵌套字典以后，我们要做的就是把他们合并起来。</p>
<p>假设我们有两个字典：dst 和 src，把 src 的内容合并到 dst 字典中，有如下几种情况。</p>
<h3 id="dst中没有-src-的-key"><a href="#dst中没有-src-的-key" class="headerlink" title="dst中没有 src 的 key"></a>dst中没有 src 的 key</h3><p>假设<code>dst = {&#39;a&#39;: 1}</code>，<code>src = {&#39;b&#39;: 1}</code>，那么合并以后，<code>dst</code>变成<code>{&#39;a&#39;: 1, &#39;b&#39;: 1}</code>。</p>
<p>对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dst:</div><div class="line">            dst[key] = value</div></pre></td></tr></table></figure>
<h3 id="dst-中有-src-的-key且值都是字典"><a href="#dst-中有-src-的-key且值都是字典" class="headerlink" title="dst 中有 src 的 key且值都是字典"></a>dst 中有 src 的 key且值都是字典</h3><p>假设<code>dst = {&#39;a&#39;: {&#39;b&#39;: 1}}</code>， <code>src = {&#39;a&#39;: {&#39;c&#39;: 1}}</code>，那么由于<code>dst</code>与<code>src</code>都有<code>&#39;a&#39;</code>这个 key，所以问题转换为合并<code>{&#39;b&#39;: 1}</code>和<code>{&#39;c&#39;: 1}</code>，变成第一种情况。</p>
<p>对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> dst:</div><div class="line">            merge(dst[key], value)</div></pre></td></tr></table></figure>
<h3 id="dst-中有-src-的-key-且值相同"><a href="#dst-中有-src-的-key-且值相同" class="headerlink" title="dst 中有 src 的 key 且值相同"></a>dst 中有 src 的 key 且值相同</h3><p>在本题中，这种情况不存在，因为这会导致目标字典有相同的 key。但是字典是不能重复的。</p>
<h3 id="dst中有-src-的-key-且值的类型不同"><a href="#dst中有-src-的-key-且值的类型不同" class="headerlink" title="dst中有 src 的 key 且值的类型不同"></a>dst中有 src 的 key 且值的类型不同</h3><p>这种情况下说明目标字典有问题，无法合并。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="string">'a_b_c'</span>: <span class="number">1</span></div><div class="line"> <span class="string">'a'</span>: <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种字典不存在嵌套写法，因为<code>{&#39;a&#39;: 3}</code>与<code>{&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 1}}}</code>只能互相覆盖，不能合并。</p>
<h3 id="完整写法"><a href="#完整写法" class="headerlink" title="完整写法"></a>完整写法</h3><p><code>merge</code>函数的完整写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(dst, src)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> src.items():</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dst:</div><div class="line">            dst[key] = value</div><div class="line">        <span class="keyword">elif</span> isinstance(dst[key], dict) <span class="keyword">and</span> isinstance(value, dict):</div><div class="line">            merge(dst[key], value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> Exception(<span class="string">'数据格式有误，不能转换为嵌套字典'</span>)</div></pre></td></tr></table></figure>
<h2 id="解答问题"><a href="#解答问题" class="headerlink" title="解答问题"></a>解答问题</h2><p>最后我们来解答这个问题，把三个函数结合起来。运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-21-00-23.png" alt=""></p>
<p>当传入不能被转换的目标字典时，也会正常报错</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-20-21-01-43.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;amp;mid=2648977876&amp;amp;idx=1&amp;amp;sn=76c6f8d0a8dabaefe3aa3f666893c991&amp;amp;chksm=f2506c34c527e522478a1c0e07d52075d05c2436bd326662746c1fd854ee922244dcae23b1dd&amp;amp;token=821834861&amp;amp;lang=zh_CN#rd&quot;&gt;使用 yield 压平嵌套字典有多简单？&lt;/a&gt;这篇文章中，我们讲到，要把一个多层嵌套的字典压平，可以使用&lt;code&gt;yield&lt;/code&gt;关键字来实现。&lt;/p&gt;
&lt;p&gt;今天，我们倒过来，把一个已经被压平的字典还原成嵌套字典。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>剖析灵魂，为什么aiohttp默认的写法那么慢？</title>
    <link href="https://www.kingname.info/2020/03/23/why-default-aiohttp-slow/"/>
    <id>https://www.kingname.info/2020/03/23/why-default-aiohttp-slow/</id>
    <published>2020-03-23T15:36:58.000Z</published>
    <updated>2020-03-23T15:37:41.416Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们提到了aiohttp官方文档中的默认写法速度与requests单线程请求没有什么区别，需要通过使用<code>asyncio.wait</code>来加速aiohttp的请求。今天我们来探讨一下这背后的原因。</p>
<a id="more"></a>
<p>我们使用一个可以通过URL设定返回延迟的网站来进行测试，网址为：<code>http://httpbin.org/delay/5</code>。当<code>delay</code>后面的数字为5时，表示请求这个网址以后，要等5秒才会收到返回；当<code>delay</code>后面的数字为3时，表示请求这个网址以后，要等3秒才会收到返回。大家可以在浏览器上面输入这个网址测试看看。</p>
<p>现在我们写一段简单的aiohttp代码来进行测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</div><div class="line">        start = time.time()</div><div class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/3'</span>)</div><div class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/5'</span>)</div><div class="line">        end = time.time()</div><div class="line">        print(f<span class="string">'总共耗时：&#123;end - start&#125;'</span>)</div><div class="line"></div><div class="line"></div><div class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></div><div class="line"></div><div class="line"><span class="comment"># Python 3.6或以下需要注释掉上面一行，并为下面两行解除注释</span></div><div class="line"><span class="comment">#loop = asyncio.get_event_loop()</span></div><div class="line"><span class="comment">#loop.run_until_complete(main())</span></div></pre></td></tr></table></figure>
<p>注意，如果你的Python 版本大于等于3.7，那么你可以直接使用<code>asyncio.run</code>来运行一个协程，而不需要像昨天那样先创建一个事件循环再运行。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-28-34.png" alt=""></p>
<p>可以看到，运行时间大于8秒钟，也就是说，这段代码，是先请求第一个3秒的网址，等它运行完成以后，再请求第二个5秒的网址，他们根本就没有并行！</p>
<p>按照我们之前的认识，协程在网络 IO 等待的时候，可以交出控制权，当 aiohttp 请求第一个3秒网址，等待返回的时候，应该就可以立刻请求第二个5秒的网址。在等待5秒网址返回的过程中，又去检查第一个3秒请求是否结束了。直到3秒请求已经返回了结果，再等待5秒的请求。</p>
<p>那为什么上面这段代码，并没有按这段逻辑来走？</p>
<p>这是因为，协程虽然可以充分利用网络 IO 的等待时间，但它并不会自动这么做。而是需要你把它加入到调度器里面。</p>
<p>能被 <code>await</code>的对象有3种：协程、Task对象、future 对象。</p>
<p>当你<code>await 协程</code>对象时，它并没有被加入到调度器中，所以它依然是串行执行的。</p>
<p>但 Task 对象会被自动加入到调度器中，所以 Task 对象能够并发执行。</p>
<p>要创建一个 Task 对象非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">asyncio.create_task(协程) <span class="comment">#python 3.7或以上版本的写法</span></div><div class="line">asyncio.ensure_future(协程)  <span class="comment"># python 3.6或以下的写法</span></div></pre></td></tr></table></figure>
<p>所以我们来稍稍修改一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</div><div class="line">        start = time.time()</div><div class="line">        task1 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/3'</span>))</div><div class="line">        task2 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/5'</span>))</div><div class="line">        <span class="keyword">await</span> task1</div><div class="line">        <span class="keyword">await</span> task2</div><div class="line">        end = time.time()</div><div class="line">        print(f<span class="string">'总共耗时：&#123;end - start&#125;'</span>)</div><div class="line"></div><div class="line"></div><div class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-37-55.png" alt=""></p>
<p>可以看到，现在请求两个网址的时间加到一起，只比5秒多一点，说明确实已经实现了并发请求的效果。至于这多出来的一点点时间，是因为协程之间切换控制权导致的。</p>
<p>那么为什么我们把很多协程放进一个 列表里面，然后把列表放进 <code>asyncio.wait</code>里面，也能实现并行呢？这是因为，<code>asyncio.wait</code>帮我们做了创建 Task 的任务。这一点我们可以在Python 的<a href="https://docs.python.org/3/library/asyncio-task.html#waiting-primitives" target="_blank" rel="external">官方文档</a>中看到原话：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-43-35.png" alt=""></p>
<p>同理，当你把协程传入<code>asyncio.gather</code>时，这些协程也会被当做Task 来调度：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-45-34.png" alt=""></p>
<p>回到我们昨天的问题，我们不用<code>asyncio.wait</code>也不用<code>asyncio.Queue</code>让爬虫并发起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"></div><div class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, page)</span>:</span></div><div class="line">    url = template.format(page=page)</div><div class="line">    resp = <span class="keyword">await</span> session.get(url)</div><div class="line">    print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</div><div class="line">        tasks = []</div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">            task = asyncio.create_task(get(session, page))</div><div class="line">            tasks.append(task)</div><div class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">            <span class="keyword">await</span> task</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/new-fast.2019-12-19 12_56_10.gif" alt=""></p>
<p>但你需要注意一点，创建 Task 与<code>await Task</code>是分开执行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tasks = []</div><div class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">    task = asyncio.create_task(get(session, page))</div><div class="line">    tasks.append(task)</div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    <span class="keyword">await</span> task</div></pre></td></tr></table></figure>
<p>你不能写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">    task = asyncio.create_task(get(session, page))</div><div class="line">    <span class="keyword">await</span> task</div></pre></td></tr></table></figure>
<p>这是因为，创建Task 的时候会自动把它加入到调度队列里面，然后<code>await Task</code>的时候执行调度。上面这样写，会导致每一个 Task 被分批调度，一个 Task 在等待网络 IO 的时候，没有办法切换到第二个 Task，所以最终又会降级成串行请求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，我们提到了aiohttp官方文档中的默认写法速度与requests单线程请求没有什么区别，需要通过使用&lt;code&gt;asyncio.wait&lt;/code&gt;来加速aiohttp的请求。今天我们来探讨一下这背后的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="aiohttp" scheme="https://www.kingname.info/tags/aiohttp/"/>
    
  </entry>
  
  <entry>
    <title>为 aiohttp 爬虫注入灵魂</title>
    <link href="https://www.kingname.info/2020/03/23/insert-sprit/"/>
    <id>https://www.kingname.info/2020/03/23/insert-sprit/</id>
    <published>2020-03-23T15:35:14.000Z</published>
    <updated>2020-03-23T15:36:17.499Z</updated>
    
    <content type="html"><![CDATA[<p>听说过异步爬虫的同学，应该或多或少听说过<code>aiohttp</code>这个库。它通过 Python 自带的<code>async/await</code>实现了异步爬虫。</p>
<p>使用 aiohttp，我们可以通过 requests 的api写出并发量匹敌 Scrapy 的爬虫。</p>
<a id="more"></a>
<p>我们在 aiohttp 的官方文档上面，可以看到它给出了一个代码示例，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-18-21-55-56.png" alt=""></p>
<p>我们现在稍稍修改一下，来看看这样写爬虫，运行效率如何。</p>
<p>修改以后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"></div><div class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, page)</span>:</span></div><div class="line">    url = template.format(page=page)</div><div class="line">    resp = <span class="keyword">await</span> session.get(url)</div><div class="line">    print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">            <span class="keyword">await</span> get(session, page)</div><div class="line"></div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div></pre></td></tr></table></figure>
<p>这段代码访问我的爬虫练习站100次，获取100页的内容。</p>
<p>大家可以通过下面这个视频看看它的运行效率：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/slow.2019-12-18 22_51_37.gif" alt=""></p>
<p>可以说，目前这个运行速度，跟 requests 写的单线程爬虫几乎没有区别，代码还多了那么多。</p>
<p>那么，应该如何正确释放 aiohttp 的超能力呢？</p>
<p>我们现在把代码做一下修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> aiohttp</div><div class="line"></div><div class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/&#123;page&#125;'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, queue)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            page = queue.get_nowait()</div><div class="line">        <span class="keyword">except</span> asyncio.QueueEmpty:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        url = template.format(page=page)</div><div class="line">        resp = <span class="keyword">await</span> session.get(url)</div><div class="line">        print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</div><div class="line">        queue = asyncio.Queue()</div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">            queue.put_nowait(page)</div><div class="line">        tasks = []</div><div class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">            task = get(session, queue)</div><div class="line">            tasks.append(task)</div><div class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line"></div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div></pre></td></tr></table></figure>
<p>在修改以后的代码里面，我让这个爬虫爬1000页的内容，我们来看看下面这个视频。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/fast.2019-12-18 22_49_49.gif" alt=""></p>
<p>可以看到，目前这个速度已经可以跟 Scrapy 比一比了。并且大家需要知道，这个爬虫只有1个进程1个线程，它是通过异步的方式达到这个速度的。</p>
<p>那么，修改以后的代码，为什么速度能快那么多呢？</p>
<p>关键的代码，就在：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tasks = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">    task = get(session, queue)</div><div class="line">    tasks.append(task)</div><div class="line"><span class="keyword">await</span> asyncio.wait(tasks)</div></pre></td></tr></table></figure>
<p>在慢速版本里面，我们只有1个协程在运行。而在现在这个快速版本里面，我们创建了100个协程，并把它提交给<code>asyncio.wait</code>来统一调度。<code>asyncio.wait</code>会在所有协程全部结束的时候才返回。</p>
<p>我们把1000个 URL 放在<code>asyncio.Queue</code>生成的一个异步队列里面，每一个协程都通过 while True 不停从这个异步队列里面取 URL 并进行访问，直到异步队列为空，退出。</p>
<p>当程序运行时，Python 会自动调度这100个协程，当一个协程在等待网络 IO 返回时，切换到第二个协程并发起请求，在这个协程等待返回时，继续切换到第三个协程并发起请求……。程序充分利用了网络 IO 的等待时间，从而大大提高了运行速度。</p>
<p>最后，感谢实习生小河给出的这种加速方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听说过异步爬虫的同学，应该或多或少听说过&lt;code&gt;aiohttp&lt;/code&gt;这个库。它通过 Python 自带的&lt;code&gt;async/await&lt;/code&gt;实现了异步爬虫。&lt;/p&gt;
&lt;p&gt;使用 aiohttp，我们可以通过 requests 的api写出并发量匹敌 Scrapy 的爬虫。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="aiohttp" scheme="https://www.kingname.info/tags/aiohttp/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Python读写Kafka？</title>
    <link href="https://www.kingname.info/2020/03/23/operate-kafka-by-python/"/>
    <id>https://www.kingname.info/2020/03/23/operate-kafka-by-python/</id>
    <published>2020-03-23T15:34:07.000Z</published>
    <updated>2020-03-23T15:36:25.136Z</updated>
    
    <content type="html"><![CDATA[<p>关于Kafka的第三篇文章，我们来讲讲如何使用Python读写Kafka。这一篇文章里面，我们要使用的一个第三方库叫做<code>kafka-python</code>。大家可以使用<code>pip</code>或者<code>pipenv</code>安装它。下面两种安装方案，任选其一即可。</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python3 -m pip install kafka-python</div><div class="line">pipenv install kafka-python</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-07-03.png" alt=""></p>
<p>这篇文章，我们将会使用最短的代码来实现一个读、写Kafka的示例。</p>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>由于生产者和消费者都需要连接Kafka，所以我单独写了一个配置文件<code>config.py</code>用来保存连接Kafka所需要的各个参数，而不是直接把这些参数Hard Code写在代码里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># config.py</span></div><div class="line">SERVER = <span class="string">'123.45.32.11:1234'</span></div><div class="line">USERNAME = <span class="string">'kingname'</span></div><div class="line">PASSWORD = <span class="string">'kingnameisgod'</span></div><div class="line">TOPIC = <span class="string">'howtousekafka'</span></div></pre></td></tr></table></figure>
<p>本文演示所用的Kafka由我司平台组的同事搭建，需要账号密码才能连接，所以我在配置文件中加上了<code>USERNAME</code>和<code>PASSWORD</code>两项。你使用的Kafka如果没有账号和密码，那么你只需要<code>SERVER</code>和<code>TOPIC</code>即可。</p>
<h2 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h2><p>代码简单到甚至不需要解释。首先使用<code>KafkaProducer</code>类连接 Kafka，获得一个生产者对象，然后往里面写数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> config</div><div class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</div><div class="line"></div><div class="line"></div><div class="line">producer = KafkaProducer(bootstrap_servers=config.SERVER,</div><div class="line">                         value_serializer=<span class="keyword">lambda</span> m: json.dumps(m).encode())</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">    data = &#123;<span class="string">'num'</span>: i, <span class="string">'ts'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</div><div class="line">    producer.send(config.TOPIC, data)</div><div class="line">    time.sleep(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>参数<code>bootstrap_servers</code>用于指定 Kafka 的服务器连接地址。</p>
<p>参数<code>value_serializer</code>用来指定序列化的方式。这里我使用 json 来序列化数据，从而实现我向 Kafka 传入一个字典，Kafka 自动把它转成 JSON 字符串的效果。</p>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-40-18.png" alt=""></p>
<p>注意，上图中，我多写了4个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">security_protocol=<span class="string">"SASL_PLAINTEXT"</span></div><div class="line">sasl_mechanism=<span class="string">"PLAIN"</span></div><div class="line">sasl_plain_username=config.USERNAME</div><div class="line">sasl_plain_password=config.PASSWORD</div></pre></td></tr></table></figure>
<p>这四个参数是因为我这里需要通过密码连接 Kafka 而加上的，如果你的 Kafka 没有账号密码，就不需要这四个参数。</p>
<h2 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h2><p>Kafka 消费者也需要连接 Kafka，首先使用<code>KafkaConsumer</code>类初始化一个消费者对象，然后循环读取数据。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> config</div><div class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</div><div class="line"></div><div class="line"></div><div class="line">consumer = KafkaConsumer(config.TOPIC,</div><div class="line">                         bootstrap_servers=config.SERVER,</div><div class="line">                         group_id=<span class="string">'test'</span>,</div><div class="line">                         auto_offset_reset=<span class="string">'earliest'</span>)</div><div class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</div><div class="line">    print(msg.value)</div></pre></td></tr></table></figure>
<p>KafkaConsumer 的第一个参数用于指定 Topic。你可以把这个 Topic 理解成 Redis 的 Key。</p>
<p>bootstrap_servers用于指定 Kafka 服务器连接地址。</p>
<p>group_id这个参数后面的字符串可以任意填写。如果两个程序的<code>Topic</code>与<code>group_id</code>相同，那么他们读取的数据不会重复，两个程序的<code>Topic</code>相同，但是<code>group_id</code>不同，那么他们各自消费全部数据，互不影响。</p>
<p>auto_offset_rest 这个参数有两个值，<code>earliest</code>和<code>latest</code>，如果省略这个参数，那么默认就是<code>latest</code>。这个参数会单独介绍。这里先略过。</p>
<p>连接好 Kafka 以后，直接对消费者对象使用 for 循环迭代，就能持续不断获取里面的数据了。</p>
<h2 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h2><p>运行两个消费者程序和一个生产者程序，效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-44-26.png" alt=""></p>
<p>我们可以看到，两个消费者程序读取数据不重复，不遗漏。</p>
<p>当所有数据都消费完成以后，如果你把两个消费者程序关闭，再运行其中一个，你会发现已经没有数据会被打印出来了。</p>
<p>但如果你修改一下 group_id，程序又能正常从头开始消费了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-17-20-48-55.png" alt=""></p>
<h2 id="很多人都会搞混的几个地方"><a href="#很多人都会搞混的几个地方" class="headerlink" title="很多人都会搞混的几个地方"></a>很多人都会搞混的几个地方</h2><h3 id="earliest-与-latest"><a href="#earliest-与-latest" class="headerlink" title="earliest 与 latest"></a>earliest 与 latest</h3><p>在我们创建消费者对象的时候，有一个参数叫做<code>auto_offset_reset=&#39;earliest&#39;</code>。有人看到<code>earliest</code>与<code>latest</code>，想当然地认为设置为<code>earliest</code>，就是从 Topic 的头往后读，设置为<code>latest</code>就是忽略之前的数据，从程序运行以后，新来的数据开始读。</p>
<p>这种看法是不正确的。</p>
<p><code>auto_offset_reset</code>这个参数，只有在一个<code>group</code>第一次运行的时候才有作用，从第二次运行开始，这个参数就失效了。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test2</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test3</code>。<code>auto_offset_reset</code>设置为 <code>latest</code>。那么当你的消费者运行的时候，Kafka 不会给你返回任何数据，消费者看起来就像卡住了一样，但是 Kafka 会直接强制把前100条数据的状态设置为已经被你消费的状态。所以当前你的 offset 就直接是99了。直到生产者插入了一条新的数据，此时消费者才能读取到。这条新的数据对应的 offset 就变成了100。</p>
<p>假设现在你的 Topic 里面有100个数据，你设置了一个全新的 group_id 为<code>test4</code>。<code>auto_offset_reset</code>设置为 <code>earliest</code>。那么当你的消费者运行的时候，Kafka 会先把你的 offset 设置为0，然后让你从头开始消费的。等消费到第50条数据时，你把消费者程序关了，把<code>auto_offset_reset</code>设置为<code>latest</code>，再重新运行。此时消费者依然会接着从第51条数据开始读取。不会跳过剩下的50条数据。</p>
<p>所以，auto_offset_reset的作用，是在你的 group 第一次运行，还没有 offset 的时候，给你设定初始的 offset。而一旦你这个 group 已经有 offset 了，那么auto_offset_reset这个参数就不会再起作用了。</p>
<h3 id="partition-是如何分配的？"><a href="#partition-是如何分配的？" class="headerlink" title="partition 是如何分配的？"></a>partition 是如何分配的？</h3><p>对于同一个 Topic 的同一个 Group：</p>
<p>假设你的 Topic 有10个  Partition，一开始你只启动了1个消费者。那么这个消费者会轮换着从这10个Partition 中读取数据。</p>
<p>当你启动第二个消费者时，Kafka 会从第一个消费者手上抢走5个Partition，分给第二个消费者。于是两个消费者各自读5个 Partition。互不影响。</p>
<p>当第三个消费者又出现时，Kafka 从第一个消费者手上再抢走1个 Partition，从第二个消费者手上抢走2个 Partition 给第三个消费者。于是，消费者1有4个 Partition，消费者2有3个 Partition，消费者3有3个 Partiton，互不影响。</p>
<p>当你有10个消费者一起消费时，每个消费者读取一个 Partition，互不影响。</p>
<p>当第11个消费者出现时，它由于分配不到 Partition，所以它什么都读不到。</p>
<p>所以在上一篇文章中，我说，在同一个 Topic，同一个 Group 中，你有多少个 Partiton，就能起多少个进程同时消费。</p>
<h3 id="Kafka-是不是完全不重复不遗漏？"><a href="#Kafka-是不是完全不重复不遗漏？" class="headerlink" title="Kafka 是不是完全不重复不遗漏？"></a>Kafka 是不是完全不重复不遗漏？</h3><p>在极端情况下，Kafka 会重复，也会遗漏，但是这种极端情况并不常见。如果你的 Kafka 频繁漏数据，或者总是出现重复数据，那么肯定是你环境没有搭建正确，或者代码有问题。</p>
<h3 id="忠告"><a href="#忠告" class="headerlink" title="忠告"></a>忠告</h3><p>再次提醒：专业的人做专业的事情，不要轻易自建Kafka 集群。让专门的同事复制搭建和维护，你只管使用。这才是最高效省事的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Kafka的第三篇文章，我们来讲讲如何使用Python读写Kafka。这一篇文章里面，我们要使用的一个第三方库叫做&lt;code&gt;kafka-python&lt;/code&gt;。大家可以使用&lt;code&gt;pip&lt;/code&gt;或者&lt;code&gt;pipenv&lt;/code&gt;安装它。下面两种安装方案，任选其一即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="https://www.kingname.info/categories/Kafka/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 里面的信息是如何被消费的？</title>
    <link href="https://www.kingname.info/2020/03/23/how-kafka-consume/"/>
    <id>https://www.kingname.info/2020/03/23/how-kafka-consume/</id>
    <published>2020-03-23T15:32:45.000Z</published>
    <updated>2020-03-23T15:36:36.199Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就可以m’ys’q作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就何读取就可以可了。</p>
<blockquote>
<p>请谨记：使用 Kafka 很容易，但对 Kafka 集群进行搭建、维护与调优很麻烦。Kafka 集群需要有专人来维护，不要以为你能轻易胜任这个工作。</p>
</blockquote>
<a id="more"></a>
<p>本文，以及接下来的几篇针对 Kafka 的文章，我们面向的对象都是爬虫工程师或者仅仅需要使用 Kafka 的读者。关于 Kafka 更深入的底层细节与核心原理，不在我们的讨论范围中。为了解释方便，文章中对 Kafka 的一些术语会使用一些不太准确但能表明意思的类比。如果你需要在面试中解释这些术语，还请阅读Kafka 的官方文档。</p>
<p>今天我们要讨论的一个话题是，Kafka 是如何做到，对单个程序的多个进程而言，能持续消费，断点续传和并行消费；对多个程序而言又互不影响，各自独立。</p>
<p>一个 Kafka 可以有多个不同的队列，我们把这个队列叫做<code>Topic</code>，假设其中一个队列如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-14-00.png" alt=""></p>
<p>信息从右边进去，从左边出来。如果这是Redis 的列表，那么它弹出一条信息以后，队列会变成下面这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-15-28.png" alt=""></p>
<p>最左边的<code>信息1</code>不见了。所以即使程序在消费了<code>信息1</code>后立刻关闭，再重新打开，程序也会接着从<code>信息2</code>开始消费，不会把<code>信息1</code>重复消费两次。</p>
<p>但我如果有两个程序呢？程序1读取每一条数据，再转存到数据库。程序2读取每一条数据，再检查是否有关键词。这种情况下，<code>信息1</code>应该能被程序1消费，也能被程序2消费。但上面这种方案显然是不行的。当程序1消费了<code>信息1</code>，程序2就再也拿不到它了。</p>
<p>所以，在 Kafka 里面，信息会停留在队列里面，但对每一个程序来说，有一个单独的记号，来记录当前消费到了哪一条数据，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-15-22-23-41.png" alt=""></p>
<p>当程序1要读取 Kafka 里面下一条数据时，Kafka 先把当前位置的标记向右移动一位，把新的这个值返回出来。标记移动与返回这两个操作合在一起算是一个原子操作，不会出现重复读取的问题。</p>
<p>程序1与程序2使用的是不同的标记，所以各自的标记指向哪个值，是互不影响的。</p>
<p>当增加一个程序3的时候，只需要再加一个标记即可。新的这个标记也不受前两个标记的影响。</p>
<p>这就实现了在多个不同的程序读取  Kafka 时，各自互不影响。</p>
<p>现在如果你觉得程序1消费太慢了，把程序1同时运行了3次，那么由于标记和移位是原子操作，即使你看起来程序是同时去读取 Kafka，但在内部 Kafka 也会对他们进行“排队”，从而使得他们返回的结果不重复，不遗漏。</p>
<p>如果你在网上看 Kafka 的教程，你会发现他们提到了一个叫做 <code>Offset</code> 的东西，实际上就是本文所说的各个程序里面指向当前数据的<code>标记</code>。</p>
<p>你还会看到一个关键词叫做<code>Group</code>，实际上对应到本文的<code>程序1</code>，<code>程序2</code>和<code>程序3</code>。</p>
<p>对同一个队列，如果多个程序使用不同的<code>Group</code>消费，那么他们读取的数据就互不干扰。</p>
<p>对同一个队列，相同 Group 的多个进程在消费数据时，看起来就像是在对 Redis 进行 lpop 操作一样。</p>
<p>最后，你在网上关于 Kafka 的文章里面，一定会看到一个词叫做<code>Paritition</code>或者中文<code>分片</code>。而且你会发现你无法理解这个东西。</p>
<p>没关系，忘记它吧。你只需要知道，一个 Topic 有多少个 Partition，那么你最多能启动多少个进程读取同一个 Group。——如果一个Topic有3个Partition，那么你只能最多开3个进程同时读相同的 Group。 Topic如果有5个Partition，那么你只能最多开5个进程读同一个 Group。</p>
<p>下一篇文章，我们用 Python 来读写一下 Kafka。只需要几行代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就可以m’ys’q作为一个爬虫工程师，Kafka 对你而言就是一个消息队列，你只需要掌握如何向里面写入数据，以及如何读取数据就何读取就可以可了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请谨记：使用 Kafka 很容易，但对 Kafka 集群进行搭建、维护与调优很麻烦。Kafka 集群需要有专人来维护，不要以为你能轻易胜任这个工作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kafka" scheme="https://www.kingname.info/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>GNE v0.1 正式发布： 4 行代码开发新闻网站通用爬虫</title>
    <link href="https://www.kingname.info/2020/01/01/gne-release/"/>
    <id>https://www.kingname.info/2020/01/01/gne-release/</id>
    <published>2020-01-01T11:07:33.000Z</published>
    <updated>2020-03-23T15:34:45.069Z</updated>
    
    <content type="html"><![CDATA[<p>GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。</p>
<a id="more"></a>
<p>使用方式非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">html = <span class="string">'网站源代码'</span></div><div class="line">result = extractor.extract(html)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>GNE 的输入是<code>经过 js 渲染以后的</code> HTML 代码，所以 GNE 可以配合Selenium 或者 Pyppeteer 使用。</p>
<p>下图是 GNE 配合 Selenium 实现的一个 Demo：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-51-47.png" alt=""></p>
<p>对应的代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</div><div class="line"></div><div class="line"></div><div class="line">driver = Chrome(<span class="string">'./chromedriver'</span>)</div><div class="line">driver.get(<span class="string">'https://www.toutiao.com/a6766986211736158727/'</span>)</div><div class="line">time.sleep(<span class="number">3</span>)</div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(driver.page_source)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>下图是 GNE 配合 Pyppeteer 实现的 Demo：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-07-14.png" alt=""></p>
<p>对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    browser = <span class="keyword">await</span> launch(executablePath=<span class="string">'/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'</span>)</div><div class="line">    page = <span class="keyword">await</span> browser.newPage()</div><div class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://news.163.com/20/0101/17/F1QS286R000187R2.html'</span>)</div><div class="line">    extractor = GeneralNewsExtractor()</div><div class="line">    result = extractor.extract(<span class="keyword">await</span> page.content())</div><div class="line">    print(result)</div><div class="line">    input(<span class="string">'检查完成以后回到这里按下任意键'</span>)</div><div class="line"></div><div class="line">asyncio.run(main())</div></pre></td></tr></table></figure>
<h2 id="如何安装-GNE"><a href="#如何安装-GNE" class="headerlink" title="如何安装 GNE"></a>如何安装 GNE</h2><p>现在你可以直接使用 pip 安装 GNE 了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install gne</div></pre></td></tr></table></figure>
<p>如果访问pypi 官方源太慢，你也可以使用网易源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install gne -i https://mirrors.163.com/pypi/simple/</div></pre></td></tr></table></figure>
<p>安装过程如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-17-34-36.png" alt=""></p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><h3 id="获取正文源代码"><a href="#获取正文源代码" class="headerlink" title="获取正文源代码"></a>获取正文源代码</h3><p>在<code>extract()</code>方法只传入网页源代码，不添加任何额外参数时，GNE 返回如下字段：</p>
<ul>
<li>title：新闻标题</li>
<li>publish_time：新闻发布时间</li>
<li>author：新闻作者</li>
<li>content：新闻正文</li>
<li>images: 正文中的图片（相对路径或者绝对路径）</li>
</ul>
<p>可能有些朋友希望获取新闻正文所在标签的源代码，此时可以给<code>extract()</code>方法传入<code>with_body_html</code>参数，设置为 True：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, with_body_html=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>返回数据中将会增加一个字段<code>body_html</code>，它的值就是正文对应的 HTML 源代码。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2020-01-01-18-16-25.png" alt=""></p>
<h3 id="总是返回图片的绝对路径"><a href="#总是返回图片的绝对路径" class="headerlink" title="总是返回图片的绝对路径"></a>总是返回图片的绝对路径</h3><p>默认情况下，如果新闻中的图片使用的是相对路径，那么 GNE 返回的<code>images</code>字段对应的值也是图片相对路径的列表。</p>
<p>如果你想始终让 GNE 返回绝对路径，那么你可以给<code>extract()</code>方法增加<code>host</code>参数，这个参数的值是图片的域名，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, host=<span class="string">'https://www.kingname.info'</span>)</div></pre></td></tr></table></figure>
<p>这样，如果新闻中的图片是<code>/images/pic.png</code>，那么 GNE 返回时会自动把它变为<code>https://www.kingname.info/images/pic.png</code>。</p>
<h3 id="指定新闻标题所在的-XPath"><a href="#指定新闻标题所在的-XPath" class="headerlink" title="指定新闻标题所在的 XPath"></a>指定新闻标题所在的 XPath</h3><p>GNE 预定义了一组 XPath 和正则表达式用于提取新闻的标题。但某些特殊的新闻网站可能无法提取标题，此时，你可以给<code>extract()</code>方法指定<code>title_xpath</code>参数，用于提取新闻标题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, title_xpath=<span class="string">'//title/text()'</span>)</div></pre></td></tr></table></figure>
<h3 id="提前移除噪声标签"><a href="#提前移除噪声标签" class="headerlink" title="提前移除噪声标签"></a>提前移除噪声标签</h3><p>某些新闻下面可能会存在长篇大论的评论，这些评论看起来比新闻正文“更像”正文，为了防止他们干扰新闻的提取，可以通过给<code>extract()</code>方法传入<code>noise_node_list</code>参数，提前把这些噪声节点移除。<code>noise_node_list</code>的值是一个列表，里面是一个或多个 XPath：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">extractor.extract(html, noise_node_list=[<span class="string">'//div[@class="comment-list"]'</span>, <span class="string">'//*[@style="display:none"]'</span>])</div></pre></td></tr></table></figure>
<h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>API 中的参数 <code>title_xpath</code>、 <code>host</code>、 <code>noise_node_list</code>、 <code>with_body_html</code>除了直接写到 <code>extract()</code> 方法中外，还可以通过一个配置文件来设置。</p>
<p>请在项目的根目录创建一个文件 <code>.gne</code>，配置文件可以用 YAML 格式，也可以使用 JSON 格式。</p>
<ul>
<li>YAML 格式配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span></div><div class="line"><span class="attr">   xpath:</span> //title/text()</div><div class="line"><span class="attr">host:</span> https://www.xxx.com</div><div class="line"><span class="attr">noise_node_list:</span></div><div class="line"><span class="bullet">   -</span> //div[@class=\<span class="string">"comment-list\"]</span></div><div class="line">   - //*[@style=\"display:none\"]</div><div class="line">with_body_html: true</div></pre></td></tr></table></figure>
<ul>
<li>JSON 格式配置文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"title"</span>: &#123;</div><div class="line">       <span class="attr">"xpath"</span>: <span class="string">"//title/text()"</span></div><div class="line">   &#125;,</div><div class="line">   <span class="attr">"host"</span>: <span class="string">"https://www.xxx.com"</span>,</div><div class="line">   <span class="attr">"noise_node_list"</span>: [<span class="string">"//div[@class=\"comment-list\"]"</span>,</div><div class="line">                       <span class="string">"//*[@style=\"display:none\"]"</span>],</div><div class="line">   <span class="attr">"with_body_html"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种写法是完全等价的。</p>
<p>配置文件与 <code>extract()</code> 方法的参数一样，并不是所有字段都需要提供。你可以组合填写你需要的字段。</p>
<p>如果一个参数，既在 <code>extract()</code> 方法中，又在 <code>.gne</code> 配置文件中，但值不一样，那么 <code>extract()</code> 方法中的这个参数的优先级更高。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="GeneralNewsExtractor-以下简称GNE-是爬虫吗？"><a href="#GeneralNewsExtractor-以下简称GNE-是爬虫吗？" class="headerlink" title="GeneralNewsExtractor(以下简称GNE)是爬虫吗？"></a>GeneralNewsExtractor(以下简称GNE)是爬虫吗？</h3><p>GNE不是爬虫，它的项目名称General News Extractor表示通用新闻抽取器。它的输入是HTML，输出是一个包含新闻标题，新闻正文，作者，发布时间的字典。你需要自行设法获取目标网页的HTML。</p>
<p>GNE 现在不会，将来也不会提供请求网页的功能。</p>
<h3 id="GNE支持翻页吗？"><a href="#GNE支持翻页吗？" class="headerlink" title="GNE支持翻页吗？"></a>GNE支持翻页吗？</h3><p>GNE不支持翻页。因为GNE不会提供网页请求的功能，所以你需要自行获取每一页的HTML，并分别传递给GNE。</p>
<h3 id="GNE支持哪些版本的Python？"><a href="#GNE支持哪些版本的Python？" class="headerlink" title="GNE支持哪些版本的Python？"></a>GNE支持哪些版本的Python？</h3><p>不小于Python 3.6.0</p>
<h3 id="我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？"><a href="#我用requests-Scrapy获取的HTML传入GNE，为什么不能提取正文？" class="headerlink" title="我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？"></a>我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？</h3><p>GNE是基于HTML来提取正文的，所以传入的HTML一定要是经过JavaScript渲染以后的HTML。而requests和Scrapy获取的只是JavaScript渲染之前的源代码，所以无法正确提取。</p>
<p>另外，有一些网页，例如今日头条，它的新闻正文实际上是以JSON格式直接写在网页源代码的，当页面在浏览器上面打开的时候，JavaScript把源代码里面的正文解析为HTML。这种情况下，你在Chrome上面就看不到Ajax请求。</p>
<p>所以建议你使用Puppeteer/Pyppeteer/Selenium之类的工具获取经过渲染的HTML再传入GNE。</p>
<h3 id="GNE-支持非新闻类网站吗（例如博客、论坛……）"><a href="#GNE-支持非新闻类网站吗（例如博客、论坛……）" class="headerlink" title="GNE 支持非新闻类网站吗（例如博客、论坛……）"></a>GNE 支持非新闻类网站吗（例如博客、论坛……）</h3><p>不支持。</p>
<h2 id="关于-GNE"><a href="#关于-GNE" class="headerlink" title="关于 GNE"></a>关于 GNE</h2><p>GNE 官方文档：<a href="https://generalnewsextractor.readthedocs.io/" target="_blank" rel="external">https://generalnewsextractor.readthedocs.io/</a></p>
<p>GNE 的项目源代码在：<a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="external">https://github.com/kingname/GeneralNewsExtractor</a>。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>如果您觉得GNE对您的日常开发或公司有帮助，请加作者微信 mxqiuchen（或扫描下方二维码） 并注明”GNE”，作者会将你拉入群。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_3729_2.JPG" alt=""></p>
<p>验证消息：<code>GNE</code></p>
<p>我的公众号：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么每一个爬虫工程师都应该学习 Kafka</title>
    <link href="https://www.kingname.info/2019/12/14/use-kakfa-in-spider/"/>
    <id>https://www.kingname.info/2019/12/14/use-kakfa-in-spider/</id>
    <published>2019-12-14T00:36:02.000Z</published>
    <updated>2019-12-14T00:38:53.112Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。</p>
<a id="more"></a>
<h2 id="一个简单的需求"><a href="#一个简单的需求" class="headerlink" title="一个简单的需求"></a>一个简单的需求</h2><p>假设我们需要写一个微博爬虫，老板给的需求如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-35-25.png" alt=""></p>
<p>开发爬虫对你来说非常简单，于是三下五除二你就把爬虫开发好了：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-39-18.png" alt=""></p>
<p>接下来开始做报警功能，逻辑也非常简单：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-16-52-50.png" alt=""></p>
<p>再来看看统计关键词的功能，这个功能背后有一个网页，会实时显示抓取数据量的变化情况，可以显示每分钟、每小时的某个关键词的抓取量。</p>
<p>这个功能对你来说也挺简单，于是你实现了如下逻辑：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-16-03.png" alt=""></p>
<p>最后一个需求，对微博数据进行情感分析。情感分析的模块有别的部门同事开发，你要做的就是每个小时拉取一批数据，发送到接口，获取返回，然后存入后端需要的数据库：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-17-12-52.png" alt=""></p>
<p>任务完成，于是你高兴地回家睡觉了。</p>
<h2 id="困难接踵而至"><a href="#困难接踵而至" class="headerlink" title="困难接踵而至"></a>困难接踵而至</h2><h3 id="爬虫变慢了"><a href="#爬虫变慢了" class="headerlink" title="爬虫变慢了"></a>爬虫变慢了</h3><p>随着老板逐渐增加新的关键词，你发现每一次完整抓取的时间越来越长，一开始是2分钟抓取一轮，后来变成10分钟一轮，然后变成30分钟一轮，接下来变成1小时才能抓取一轮。随着延迟越来越高，你的报警越来越不准确，微博都发出来一小时了，你的报警还没有发出来，因为那一条微博还没有来得及入库。</p>
<p>你的爬虫技术非常好，能绕过所有反爬虫机制，你有无限个代理 IP，于是你轻轻松松就把爬虫提高到了每秒一百万并发。现在只需要1分钟你就能完成全部数据的抓取。这下没问题了吧。</p>
<p>可是报警还是没有发出来。这是怎么回事？</p>
<h3 id="数据库撑不住了"><a href="#数据库撑不住了" class="headerlink" title="数据库撑不住了"></a>数据库撑不住了</h3><p>经过排查，你发现了问题。数据抓取量上来了，但是 MongoDB 却无法同时接收那么多的数据写入。数据写入速度远远小于爬取数据，大量的数据堆积在内存中。于是你的服务器爆炸了。</p>
<p>你紧急搭建了100个数据库并编号0-99，对于抓取到的微博，先把每一条微博的 ID对100求余数，然后把数据存入余数对应的 MongoDB 中。每一台 MongoDB 的压力下降到了原来的1%。数据终于可以即时存进数据库里面了。</p>
<p>可是报警还是没有发出来，不仅如此，现在实时抓取量统计功能也不能用了，还有什么问题？</p>
<h3 id="查询来不及了"><a href="#查询来不及了" class="headerlink" title="查询来不及了"></a>查询来不及了</h3><p>现在报警程序要遍历100个数据库最近5分钟里面的每一条数据，确认是否有需要报警的内容。但是这个遍历过程就远远超过5分钟。</p>
<h3 id="时间错开了"><a href="#时间错开了" class="headerlink" title="时间错开了"></a>时间错开了</h3><p>由于微博的综合搜索功能不是按照时间排序的，那么就会出现这样一种情况，早上10:01发的微博，你在12:02的时候才抓到。</p>
<p>不论你是在报警的时候筛选数据，还是筛选数据推送给 NLP 分析接口，如果你是以微博的发布时间来搜索，那么这一条都会被你直接漏掉——当你在10:05的时候检索10:00-10:05这5分钟发表的微博，由于这一条微博没有抓到，你自然搜索不到。</p>
<p>当你12:05开始检索12:00-12:05的数据时，你搜索的是发布时间为12:00-12:05的数据，于是10:01这条数据虽然是在12:02抓到的，但你也无法筛选出来。</p>
<p>那么是不是可以用抓取时间来搜索呢？例如10:05开始检索在10:00-10:05抓取到的数据，无论它的发布时间是多少，都检索出来。</p>
<p>这样做确实可以保证不漏掉数据，但这样做的代价是你必需保存、检索非常非常多的数据。例如每次抓取，只要发布时间是最近10小时的，都要保存下来。于是报警程序在检索数据时，就需要检索这5分钟入库的，实际上发布时间在10小时内的全部数据。</p>
<p>什么，你说每次保存之前检查一下这条微博是否已经存在，如果存在就不保存？别忘了批量写入时间都不够了，你还准备分一些时间去查询？</p>
<h3 id="脏数据来了"><a href="#脏数据来了" class="headerlink" title="脏数据来了"></a>脏数据来了</h3><p>老板突然来跟你说，关键词“篮球”里面有大量的关于 蔡徐坤的内容，所以要你把所有包含蔡徐坤的数据全部删掉。</p>
<p>那么，这个过滤逻辑放在哪里？放在爬虫的 pipelines.py 里面吗？那你要重新部署所有爬虫。今天是过滤蔡徐坤，明天是过滤范层层，后天是过滤王一博，每天增加关键词，你每天都得重新部署爬虫？</p>
<p>那你把关键词放在 Redis 或者 MongoDB 里面，每次插入数据前，读取所有关键词，看微博里面不包含再存。</p>
<p>还是那个问题，插入时间本来就不够了，你还要查数据库？</p>
<p>好，关键词过滤不放在爬虫里面了。你写了一个脚本，每分钟检查一次MongoDB新增的数据，如果发现包含 不需要的关键词，就把他删除。</p>
<p>现在问题来了，删除数据的程序每分钟检查一次，报警程序每5分钟检查一次。中间必定存在某些数据，还没有来得及删除，报警程序就报警了，老板收到报警来看数据，而你的删除程序又在这时把这个脏数据删了。</p>
<p>这下好了，天天报假警，狼来了的故事重演了。</p>
<h2 id="5个问题1个救星"><a href="#5个问题1个救星" class="headerlink" title="5个问题1个救星"></a>5个问题1个救星</h2><p>如果你在爬虫开发的过程中遇到过上面的诸多问题，那么，你就应该试一试使用 Kafka。一次性解决上面的所有问题。</p>
<p>把 Kafka 加入到你的爬虫流程中，那么你的爬虫架构变成了下面这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-34-55.png" alt=""></p>
<p>这看起来似乎和数据直接写进 MongoDB 里面，然后各个程序读取 MongoDB 没什么区别啊？那 Kafka 能解决什么问题？</p>
<p>我们来看看，在这个爬虫架构里面，我们将会用到的 Kafka 的特性：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-39-28.png" alt=""></p>
<p>与其说 Kafka 在这个爬虫架构中像 MongoDB，不如说更像 Redis 的列表。</p>
<p>现在来简化一下我们的模型，如果现在爬虫只有一个需求，就是搜索，然后报警。那么我们可以这样设计：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-46-23.png" alt=""></p>
<p>爬虫爬下来的数据，直接塞进 Redis 的列表右侧。报警程序从 Redis 列表左侧一条一条读取。读取一条检视一条，如果包含报警关键词，就报警。然后读取下一条。</p>
<p>这样做有什么好处？</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-20-50-27.png" alt=""></p>
<p>因为报警程序直接从 Redis 里面一条一条读取，不存在按时间搜索数据的过程，所以不会有数据延迟的问题。由于 Redis 是单线程数据库，所以可以同时启动很多个报警程序。由于 lpop 读取一条就删除一条，如果报警程序因为某种原因崩溃了，再把它启动起来即可，它会接着工作，不会重复报警。</p>
<p>但使用 Redis 列表的优势也是劣势：列表中的信息只能消费1次，被弹出了就没有了。</p>
<p>所以如果既需要报警，还需要把数据存入 MongoDB 备份，那么只有一个办法，就是报警程序检查完数据以后，把数据存入 MongoDB。</p>
<blockquote>
<p>可我只是一个哨兵，为什么要让我做后勤兵的工作？</p>
</blockquote>
<p>一个报警程序，让它做报警的事情就好了，它不应该做储存数据的事情。</p>
<p>而使用 Kafka，它有 Redis 列表的这些好处，但又没有 Redis 列表的弊端！</p>
<p>我们完全可以分别实现4个程序，不同程序之间消费数据的快慢互不影响。但同一个程序，无论是关闭再打开，还是同时运行多次，都不会重复消费。</p>
<h3 id="程序1：报警"><a href="#程序1：报警" class="headerlink" title="程序1：报警"></a>程序1：报警</h3><p>从 Kafka 中一条一条读取数据，做报警相关的工作。程序1可以同时启动多个。关了再重新打开也不会重复消费。</p>
<h3 id="程序2：储存原始数据"><a href="#程序2：储存原始数据" class="headerlink" title="程序2：储存原始数据"></a>程序2：储存原始数据</h3><p>这个程序从 Kafka 中一条一条读取数据，每凑够1000条就批量写入到 MongoDB 中。这个程序不要求实时储存数据，有延迟也没关系。 存入MongoDB中也只是原始数据存档。一般情况下不会再从 MongoDB 里面读取出来。</p>
<h3 id="程序3：统计"><a href="#程序3：统计" class="headerlink" title="程序3：统计"></a>程序3：统计</h3><p>从 Kafka 中读取数据，记录关键词、发布时间。按小时和分钟分别对每个关键词的微博计数。最后把计数结果保存下来。</p>
<h3 id="程序4：情感分析"><a href="#程序4：情感分析" class="headerlink" title="程序4：情感分析"></a>程序4：情感分析</h3><p>从 Kafka 中读取每一条数据，凑够一批发送给 NLP 分析接口。拿到结果存入后端数据库中。</p>
<h3 id="如果要清洗数据怎么办"><a href="#如果要清洗数据怎么办" class="headerlink" title="如果要清洗数据怎么办"></a>如果要清洗数据怎么办</h3><p>4个需求都解决了，那么如果还是需要你首先移除脏数据，再分析怎么办呢？实际上非常简单，你加一个 Kafka（Topic） 就好了！</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-11-27.png" alt=""></p>
<h2 id="大批量通用爬虫"><a href="#大批量通用爬虫" class="headerlink" title="大批量通用爬虫"></a>大批量通用爬虫</h2><p>除了上面的微博例子以外，我们再来看看在开发通用爬虫的时候，如何应用 Kafka。</p>
<p>在任何时候，无论是 XPath 提取数据还是解析网站返回的 JSON，都不是爬虫开发的主要工作。爬虫开发的主要工作一直是爬虫的调度和反爬虫的开发。</p>
<p>我们现在写 Scrapy 的时候，处理反爬虫的逻辑和提取数据的逻辑都是写在一个爬虫项目中的，那么在开发的时候实际上很难实现多人协作。</p>
<p>现在我们把网站内容的爬虫和数据提取分开，实现下面这样一个爬虫架构：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-13-21-22-51.png" alt=""></p>
<p>爬虫开发技术好的同学，负责实现绕过反爬虫，获取网站的内容，无论是 HTML 源代码还是接口返回的JSON。拿到以后，直接塞进 Kafka。</p>
<p>爬虫技术相对一般的同学、实习生，需要做的只是从 Kafka 里面获取数据，不需要关心这个数据是来自于 Scrapy 还是 Selenium。他们要做的只是把这些HTML 或者JSON 按照产品要求解析成格式化的数据，然后塞进 Kafka，供后续数据分析的同学继续读取并使用。</p>
<p>如此一来，一个数据小组的工作就分开了，每个人做各自负责的事情，约定好格式，同步开发，互不影响。</p>
<h2 id="为什么是-Kafka-而不是其他"><a href="#为什么是-Kafka-而不是其他" class="headerlink" title="为什么是 Kafka 而不是其他"></a>为什么是 Kafka 而不是其他</h2><p>上面描述的功能，实际上有不少 MQ 都能实现。但为什么是 Kafka 而不是其他呢？因为Kafka 集群的性能非常高，在垃圾电脑上搭建的集群能抗住每秒10万并发的数据写入量。而如果选择性能好一些的服务器，每秒100万的数据写入也能轻松应对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章通过两个例子介绍了 Kafka 在爬虫开发中的作用。作为一个爬虫工程师，作为我的读者。请一定要掌握 Kafka。</p>
<p>下一篇文章，我们来讲讲如何使用 Kafka。比你在网上看到的教程会更简单，更容易懂。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt=""></p>
<p>关注本公众号，回复“爬虫与Kafka”获取本文对应的思维导图原图。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章不会涉及到Kafka 的具体操作，而是告诉你 Kafka 是什么，以及它能在爬虫开发中扮演什么重要角色。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Kafka" scheme="https://www.kingname.info/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中实现函数重载</title>
    <link href="https://www.kingname.info/2019/12/11/singledispatch/"/>
    <id>https://www.kingname.info/2019/12/11/singledispatch/</id>
    <published>2019-12-11T15:01:25.000Z</published>
    <updated>2019-12-11T15:01:58.828Z</updated>
    
    <content type="html"><![CDATA[<p>假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</div><div class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</div></pre></td></tr></table></figure>
<p>你想在代码里面兼容这两种写法，于是你可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(address, str):</div><div class="line">        ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    <span class="keyword">elif</span> isinstance(address, tuple):</div><div class="line">        ip, port = address</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'地址格式不正确'</span>)</div></pre></td></tr></table></figure>
<p>这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 <code>if-elif-elif-...-else</code>。代码看起来就非常不美观。</p>
<p>学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。</p>
<p>在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 <code>if-else</code>外，我们还可以使用<code>functools</code>模块里面的<code>singledispatch</code>装饰器实现函数重载。</p>
<a id="more"></a>
<p>我们来写一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</div><div class="line"></div><div class="line"><span class="meta">@singledispatch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    print(f<span class="string">' 传输参数类型为：&#123;type(address)&#125;，不是有效类型'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: str)</span>:</span></div><div class="line">    ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    print(f<span class="string">'参数为字符串，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address: tuple)</span>:</span></div><div class="line">    ip, port = address</div><div class="line">    print(f<span class="string">'参数为元组，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line">connect(<span class="string">'123.45.32.18:8080'</span>)</div><div class="line">connect((<span class="string">'123.45.32.18'</span>, <span class="number">8080</span>))</div><div class="line">connect(<span class="number">123</span>)</div></pre></td></tr></table></figure>
<p>我们运行一下这段代码，大家看看根据参数的不同，有什么样的不同效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-11-21-55-13.png" alt=""></p>
<p>可以看到，我们调用的函数，始终都是<code>connect</code>，但是由于传入参数的类型不同，它运行的结果也不一样。</p>
<p>我们使用<code>singledispatch</code>装饰一个函数，那么这个函数就是我们将会调用的函数。</p>
<p>这个函数在传入参数不同时的具体实现，通过下面注册的函数来实现。注册的时候使用<code>@我们定义的函数名.register</code>来注册。被注册的函数名叫什么无关紧要，所以这里我都直接使用下划线代替。</p>
<p>被注册的函数的第一个参数，通过类型标注来确定它应该使用什么类型。当我们调用我们定义的函数是，如果参数类型符合某个被注册的函数，那么就会执行这个被注册的函数。如果参数类型不满足任何一个被注册的函数，那么就会执行我们的原函数。</p>
<p>使用类型标注来指定参数类型是从 Python 3.7才引入的新特性。在 Python 3.6或之前的版本，我们需要通过<code>@我们定义的函数名.register(类型)</code>来指定类型，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</div><div class="line"></div><div class="line"><span class="meta">@singledispatch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(address)</span>:</span></div><div class="line">    print(f<span class="string">' 传输参数类型为：&#123;type(address)&#125;，不是有效类型'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register(str)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></div><div class="line">    ip, port = address.split(<span class="string">':'</span>)</div><div class="line">    print(f<span class="string">'参数为字符串，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div><div class="line"></div><div class="line"><span class="meta">@connect.register(tuple)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(address)</span>:</span></div><div class="line">    ip, port = address</div><div class="line">    print(f<span class="string">'参数为元组，IP是：&#123;ip&#125;, 端口是：&#123;port&#125;'</span>)</div></pre></td></tr></table></figure>
<p>同时，还有一个需要注意的点，就是只有第一个参数的不同类型会被重载。后面的参数的类型变化会被自动忽略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你有一个函数connect，它有一个参数address，这个参数可能是一个字符串，也可能是一个元组。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;connect(&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18:8080&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connect((&lt;span class=&quot;string&quot;&gt;&#39;123.45.32.18&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你想在代码里面兼容这两种写法，于是你可能会这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(address)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isinstance(address, str):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ip, port = address.split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; isinstance(address, tuple):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ip, port = address&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;地址格式不正确&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法简单直接，但是如果参数的类型更多，那么你就需要写很长的 &lt;code&gt;if-elif-elif-...-else&lt;/code&gt;。代码看起来就非常不美观。&lt;/p&gt;
&lt;p&gt;学习过 Java 的同学，应该对函数重载比较熟悉，可以定义几个名字相同的函数，但是他们的参数类型或者数量不同，从而实现不同的代码逻辑。&lt;/p&gt;
&lt;p&gt;在 Python 里面，参数的数量不同可以使用默认参数来解决，不需要定义多个函数。那如果参数类型不同就实现不同的逻辑，除了上面的 &lt;code&gt;if-else&lt;/code&gt;外，我们还可以使用&lt;code&gt;functools&lt;/code&gt;模块里面的&lt;code&gt;singledispatch&lt;/code&gt;装饰器实现函数重载。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何统计一个数字的二进制值里面有多少个1</title>
    <link href="https://www.kingname.info/2019/12/11/count-1-in-bin/"/>
    <id>https://www.kingname.info/2019/12/11/count-1-in-bin/</id>
    <published>2019-12-11T14:51:01.000Z</published>
    <updated>2019-12-11T14:53:43.423Z</updated>
    
    <content type="html"><![CDATA[<p>任意给出一个正整数，例如<code>4523</code>，如何快速统计它的二进制值里面有几个<code>1</code>？</p>
<a id="more"></a>
<p>我们知道，在 Python 里面，查看一个数字的二进制函数为：<code>bin</code>，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">4523</span>)</div><div class="line"><span class="string">'0b1000110101011'</span></div></pre></td></tr></table></figure>
<p>所以我们很快就能想到一个统计方案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">one_num = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bin(<span class="number">4523</span>)[<span class="number">2</span>:]:</div><div class="line">    <span class="keyword">if</span> i == <span class="string">'1'</span>:</div><div class="line">        count += <span class="number">1</span></div><div class="line">print(f<span class="string">'数字4523的二进制值里面，一共有&#123;count&#125;个1'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-24-21-29-12.png" alt=""></p>
<p>如果使用这个方法，由于4523的二进制值有13位，所以 for 循环需要执行13次才能完成统计。更一般的结论，一个正整数 <code>n</code>，它的二进制值有$log_2{n} + 1$位，所以这种解法的时间复杂度始终为<code>O(logn)</code>，那么我们有没有什么办法优化这个算法呢？</p>
<p>这个时候，我们观察一个现象：</p>
<p>给出一个二进制的值<code>1000110101011</code>与这个值减1的值<code>1000110101010</code>，他们做与运算，结果为：<code>1000110101010</code>。可以看到，最右侧的1变成了0.</p>
<p>现在我们再对<code>1000110101010</code>与它减1的值做与运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1000110101010</span> &amp; <span class="number">1000110101001</span> = <span class="number">1000110101000</span></div></pre></td></tr></table></figure>
<p>此时，最右侧的1又变成了0.</p>
<p>我们可以证明，假设有一个二进制数 <code>n</code>与<code>n-1</code>做与运算，它的效果相当于把这个二进制数最右侧的1变成0.</p>
<p>于是，给定一个正整数<code>x</code>，只需要统计移除多少位的最右侧的1以后，这个数字变成了0，就能知道它里面有多少个1.于是我们可以写出如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">count = <span class="number">0</span></div><div class="line">n = <span class="number">4523</span></div><div class="line"><span class="keyword">while</span> n:</div><div class="line">    n = n &amp; (n - <span class="number">1</span>)</div><div class="line">    count += <span class="number">1</span></div><div class="line">print(count)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-24-21-42-25.png" alt=""></p>
<p>使用这种算法，最坏情况下，只有在数字 n 对应的二进制全部都是1的情况下(3, 7, 15, 31, 63….)，会执行$log_2n+1$次循环。而一般情况下，如果只有1个1，那么只需要循环1次，如果有2个1，只需要循环2次。大大提高了运算效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任意给出一个正整数，例如&lt;code&gt;4523&lt;/code&gt;，如何快速统计它的二进制值里面有几个&lt;code&gt;1&lt;/code&gt;？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="算法" scheme="https://www.kingname.info/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>闲聊：语言决定思维方法</title>
    <link href="https://www.kingname.info/2019/12/10/languate-define-your-brain/"/>
    <id>https://www.kingname.info/2019/12/10/languate-define-your-brain/</id>
    <published>2019-12-10T15:00:27.000Z</published>
    <updated>2019-12-11T15:01:09.315Z</updated>
    
    <content type="html"><![CDATA[<p>在知乎上有这样一个问题：《如果当年汉字真的拼音化了会怎么样？》，下面有一个高赞回答写道：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-40-42.png" alt=""></p>
<p>这个答主的逻辑非常简单，因为《施氏食狮史》这个小故事，全篇只有<code>shi</code>与<code>si</code>两种发音，如果用汉语拼音，那么完全无法读懂。只有通过不同的中文汉字，才能正确读懂故事的意思。因此中文汉字比汉语拼音强，信息量比汉语拼音大。</p>
<p>然而这个答主忽略了一个问题，这个小故事实际上只有生活在汉字环境中的人才能想出来。对于完全生活在拼音环境中的人来说，他们的思维方式决定了根本不可能有这个故事产生。</p>
<a id="more"></a>
<p>类似的例子还有英文句子：Can you can a can as a caner can can a can.</p>
<p>这个句子只有英文语境下面的人能想出来，中文语境下面的人，在思维方式上就想不到这样的句子。难道这就能说明英文比中文好？</p>
<p>如果当年真的推行了拼音而完全放弃了汉字，那么基于拼音自然会产生它对应的文化、思维方式和表达方式。而绝不是现在这些人所嘲笑和想当然的样子。</p>
<p>还有下面这种非常扯淡的文章：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-53-43.png" alt=""></p>
<p>如果计算机是中国人发明的，那么编程语言绝对不会是他这样的写法。他这个写法仅仅是把英文编程语言里面的关键词换成了中文而已。但里面的行文逻辑与思维方式，完全还是英语编程语言的思维方式。在纯粹中文原生的编程语言，绝对不会这样表达。</p>
<p>他的这种逻辑，就像是以为仅仅把五线谱里面的蝌蚪音符转化为宫商角徵羽，就变成了中国古代乐谱。然而中国古代的乐谱长下面这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-56-30.png" alt=""></p>
<p>语言塑造了你的思维。当你只会一门语言时，你几乎无法跳脱这门语言所创造出来的思考方式。不是你不愿意从更多的角度来思考问题，而是在你的意识里面，根本不知道还能有更多的思考角度。</p>
<p>所以无论是现实中交流的语言，还是编程语言，多学几门，你的见识就不一样了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在知乎上有这样一个问题：《如果当年汉字真的拼音化了会怎么样？》，下面有一个高赞回答写道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-10-22-40-42.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个答主的逻辑非常简单，因为《施氏食狮史》这个小故事，全篇只有&lt;code&gt;shi&lt;/code&gt;与&lt;code&gt;si&lt;/code&gt;两种发音，如果用汉语拼音，那么完全无法读懂。只有通过不同的中文汉字，才能正确读懂故事的意思。因此中文汉字比汉语拼音强，信息量比汉语拼音大。&lt;/p&gt;
&lt;p&gt;然而这个答主忽略了一个问题，这个小故事实际上只有生活在汉字环境中的人才能想出来。对于完全生活在拼音环境中的人来说，他们的思维方式决定了根本不可能有这个故事产生。&lt;/p&gt;
    
    </summary>
    
      <category term="思维方式" scheme="https://www.kingname.info/categories/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="思维" scheme="https://www.kingname.info/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>如何从 Redis 的列表中一次性 pop 多条数据？</title>
    <link href="https://www.kingname.info/2019/12/04/batch-pop-in-redis/"/>
    <id>https://www.kingname.info/2019/12/04/batch-pop-in-redis/</id>
    <published>2019-12-04T14:58:33.000Z</published>
    <updated>2019-12-11T14:59:55.144Z</updated>
    
    <content type="html"><![CDATA[<p>当我们想从 Redis 的列表里面持续弹出数据的时候，我们一般使用<code>lpop</code>或者<code>rpop</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data = client.lpop(<span class="string">'key'</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(f<span class="string">'弹出一条数据：&#123;data.decode()&#125;'</span>)</div></pre></td></tr></table></figure>
<p>但这种写法有一个问题，就是每弹出1条数据都要连接一次 Redis 服务器，当你要把1000万条数据从列表里面弹出来的时候，实际上超过一半的时间都消耗在了网络请求上面。</p>
<a id="more"></a>
<p>但是<code>lpop</code>与<code>rpop</code>都只接收一个参数，就是<code>key</code><br>。因此没有办法通过传入参数的方式让它一次弹出多条数据。</p>
<p>要获取多条数据，我们还有另一种方案，就是<code>lrange</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client = client.lrange(<span class="string">'key'</span>, <span class="number">0</span>, <span class="number">5000</span>)</div></pre></td></tr></table></figure>
<p>这一行的意思是从列表中，获取前5001条数据（包含首尾）。但<code>lrange</code>只能获取数据，却不能删除数据。这就会导致在多个进程获取到重复的数据。</p>
<p>我们还知道Redis 的<code>ltrim</code>来删除数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.ltrim(<span class="string">'key'</span>, <span class="number">5000</span>, <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>这样就能删除前5000条数据了。这里第三个参数之所以要用负数，是因为<code>ltrim(key, start, end)</code>的意思是说，保留列表 Key 的第start项到第end 项，其它项删除。那么如果 end为负数，表示倒数第几项，例如-1表示倒数第1项，-2表示倒数第2项。假设列表里面有10000项，那么 start 为5000，end 为-1，表示删除前5000条数据（0-4999），保留后面的。</p>
<p>于是有人问，能不能这样写代码呢：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line">data = client.lrange(<span class="string">'key'</span>, <span class="number">0</span>, <span class="number">4999</span>)</div><div class="line">client.ltrim(<span class="string">'key'</span>, <span class="number">5000</span>, <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>这样不就看起来像是弹出了5000条数据吗？</p>
<p>想法很好，但是由于获取数据与删除数据是两条命令，中间有时间差。这就导致在多个线程或者进程同时执行这两条代码的时候，出现竞争。也就是进程1刚刚获取了前5000条数据，然后进程2同样获取这5000条数据，然后进程1删除前5000条数据，然后进程2再删除5000条数据。</p>
<p>这样一来，两个进程获取了相同的5000条数据，但是却删了10000条数据。</p>
<p>为了解决这个问题，必需让获取数据与删除数据这两个操作变成一个“原子操作”。所谓的原子操作就是只一个最小的操作单位，它不会被中途打断。</p>
<p>要解决这个问题，我们就需要使用 Redis 的<code>pipeline</code>功能。它可以把多条命令放在一个网络请求中发送到服务器，并默认在一个事务中执行这些命令。一个事务是不会被打断的，从事务开始然后执行里面的多个命令到结束的整个过程，可以看做一个原子操作。</p>
<p><code>pipeline</code>的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_lpop</span><span class="params">(key, n)</span>:</span></div><div class="line">    p = client.pipeline()</div><div class="line">    p.lrange(key, <span class="number">0</span>, n - <span class="number">1</span>)</div><div class="line">    p.ltrim(key, n, <span class="number">-1</span>)</div><div class="line">    data = p.execute()</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line">batch_lpop(<span class="string">'test_pipeline'</span>, <span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>当代码执行到<code>p.execute()</code>的时候，它才会真正去连接服务器，然后把待执行的命令在一个事务中一次性执行完成。并返回一个列表。返回的列表有两项，第0项是包含结果的列表，第1项为ltrim 的返回结果。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-04-22-42-04.png" alt=""></p>
<p>我们只需要使用第0项的结果即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们想从 Redis 的列表里面持续弹出数据的时候，我们一般使用&lt;code&gt;lpop&lt;/code&gt;或者&lt;code&gt;rpop&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; redis&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;client = redis.Redis()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data = client.lpop(&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; data:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(f&lt;span class=&quot;string&quot;&gt;&#39;弹出一条数据：&amp;#123;data.decode()&amp;#125;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但这种写法有一个问题，就是每弹出1条数据都要连接一次 Redis 服务器，当你要把1000万条数据从列表里面弹出来的时候，实际上超过一半的时间都消耗在了网络请求上面。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 正则表达式模块中逃跑（escape</title>
    <link href="https://www.kingname.info/2019/12/02/escape-in-python/"/>
    <id>https://www.kingname.info/2019/12/02/escape-in-python/</id>
    <published>2019-12-02T14:57:34.000Z</published>
    <updated>2019-12-11T14:58:09.202Z</updated>
    
    <content type="html"><![CDATA[<p>在编程语言中，有常见的符号被赋予了特殊的意义，例如小数点<code>.</code>，在正则表达式里面表示任意一个非换行符的字符；小于号<code>&lt;</code>在 html 中表示标签。</p>
<p>但有时候，我们只想让这些符号表示它本来的意思，不想让它的特殊意义表露出来，应该怎么办？</p>
<a id="more"></a>
<p>我们知道，在正则表达式中可以使用反斜杠来让一个特殊符号变成普通符号，例如<code>\.</code>表示普通的小数点，<code>\$</code>表示普通的美元符号。</p>
<p>现在我有一个列表<code>keywords_list</code>，里面是100个字符串，我想判断是否有任意一个字符串在某个给定的句子中。如果用 for 循环一个一个去检查，效率非常低。于是可以考虑使用正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">'|'</span>.join(keywords_list))</div><div class="line"></div><div class="line"><span class="keyword">if</span> pattern.search(<span class="string">'目标句子'</span>):</div><div class="line">    print(<span class="string">'目标句子中包含某个关键词'</span>)</div></pre></td></tr></table></figure>
<p>但假设 <code>keywords_list</code>列表中有如下的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keywords_list = [<span class="string">'4.5'</span>, <span class="string">'+&#123;d'</span>, <span class="string">'***'</span>]</div></pre></td></tr></table></figure>
<p>那么我们使用正则表达式就会导致报错，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-02-22-11-20.png" alt=""></p>
<p>这是因为这些字符串里面存在特殊的符号，这些符号在正则表达式里面有特殊的意义，有使用的规范，不能随意使用。</p>
<p>但是，<code>keywords_list</code>里面有各种各样的特殊符号，难道要一个一个取出来，逐一<code>x.replace(&#39;+&#39;, &#39;\+&#39;).replace(&#39;.&#39;, &#39;\.&#39;).replace(&#39;*&#39;, &#39;\*&#39;)...</code>?</p>
<p>当然不用，Python 的正则表达式模块已经帮你想好了解决办法，使用<code>re.escape</code>就能自动处理所有的特殊符号了！</p>
<p>它的用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>keywords_list = [<span class="string">'4.5'</span>, <span class="string">'+&#123;d'</span>, <span class="string">'***'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pattern_str = <span class="string">'|'</span>.join(keywords_list)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>safe_pattern_str = re.escape(pattern_str)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(safe_pattern_str)</div><div class="line"><span class="number">4</span>\<span class="number">.5</span>\|\+\&#123;d\|\*\*\*</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.compile(safe_pattern_str)</div><div class="line">re.compile(<span class="string">'4\\.5\\|\\+\\&#123;d\\|\\*\\*\\*'</span>)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-02-22-16-08.png" alt=""></p>
<p>解决问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程语言中，有常见的符号被赋予了特殊的意义，例如小数点&lt;code&gt;.&lt;/code&gt;，在正则表达式里面表示任意一个非换行符的字符；小于号&lt;code&gt;&amp;lt;&lt;/code&gt;在 html 中表示标签。&lt;/p&gt;
&lt;p&gt;但有时候，我们只想让这些符号表示它本来的意思，不想让它的特殊意义表露出来，应该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>让你的字典读取不报错</title>
    <link href="https://www.kingname.info/2019/11/30/quite-dict/"/>
    <id>https://www.kingname.info/2019/11/30/quite-dict/</id>
    <published>2019-11-30T14:56:25.000Z</published>
    <updated>2019-12-11T14:57:05.250Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，读取 Python 字典时，如果某个 Key 不存在，Python 就会报错，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-42-39.png" alt=""></p>
<p>为了防止它报错，我们可以使用<code>.get()</code>方法：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-43-26.png" alt=""></p>
<p>但每次都要写<code>.get()</code>稍显麻烦。于是我们可以通过自己实现一个自定义的字典对象，来解决这个问题。</p>
<a id="more"></a>
<p>我们自定义一个类，继承<code>dict</code>，然后实现它的<code>__missing__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OurDict</span><span class="params">(dict)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">a = OurDict(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</div><div class="line">print(a[<span class="string">'x'</span>])</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-46-13.png" alt=""></p>
<p>只要这个 Key 不存在，就会返回 <code>None</code>。</p>
<p>在 Python 的<code>collections</code>工具模块中，有一个<code>defaultdict</code>实现了类似的事情。我们看它的使用方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">a = defaultdict(str)</div><div class="line">a[<span class="string">'a'</span>] = <span class="number">1</span></div><div class="line">a[<span class="string">'b'</span>] = <span class="number">2</span></div><div class="line">print(a)</div><div class="line">print(a[<span class="string">'x'</span>])</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-54-45.png" alt=""></p>
<p><code>a = defaultdict(str)</code>接收一个函数，让<code>a</code>变量成为一个<code>defaultdict</code>类型的对象，它可以像普通字典一样被赋值和读取。</p>
<p>但是当你读取一个不存在的 key 时，它会自动生成一个默认值，并把默认值和这个 key 插入到字典中。这个默认值取决于你在<code>defaultdict</code>传入的参数。如果传入的是<code>str</code>那么默认值就是空字符串，如果是<code>int</code>那么默认值就是0.当然你也可以传入自定义的一个函数，从而控制这个默认值。例如我自定义一个函数，用于返回当前的时间，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-59-25.png" alt=""></p>
<p>当插入的 key 不存在时，就自动以当前时间作为默认值，并存入到字典中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，读取 Python 字典时，如果某个 Key 不存在，Python 就会报错，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-42-39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了防止它报错，我们可以使用&lt;code&gt;.get()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-30-22-43-26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但每次都要写&lt;code&gt;.get()&lt;/code&gt;稍显麻烦。于是我们可以通过自己实现一个自定义的字典对象，来解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中编写抽象类</title>
    <link href="https://www.kingname.info/2019/11/26/abstract-class-in-python/"/>
    <id>https://www.kingname.info/2019/11/26/abstract-class-in-python/</id>
    <published>2019-11-26T14:55:20.000Z</published>
    <updated>2019-12-11T14:55:59.869Z</updated>
    
    <content type="html"><![CDATA[<p>在极客时间某设计模式相关的课程中，某老师说 Python 不支持抽象类和接口。</p>
<p>但实际上，Python 支持抽象类。</p>
<a id="more"></a>
<p>Python 自带的<code>abc</code>模块用于实现抽象类相关的定义和操作。</p>
<p>我们通过一个简单的例子来说明，如何在 Python 中实现抽象类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(ABC)</span>:</span></div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'我正在跳舞'</span>)</div></pre></td></tr></table></figure>
<p>从<code>abc</code>模块导入<code>ABC</code>类，和<code>abstractmethod</code>抽象方法装饰器。基于<code>ABC</code>类可以实现一个抽象类。通过<code>@abstractmethod</code>装饰一个方法，让它成为一个抽象方法。抽象方法在子类中必需被实现。</p>
<p>抽象类不能被实例化，所以我们实例化一下，可以看到这里报错了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-43-11.png" alt=""></p>
<p>我们再看一下，如果继承抽象类，但是没有实现其中的某个抽象方法，也会导致报错。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-47-41.png" alt=""></p>
<p>当我们把所有抽象方法都实现了以后，子类就能够正常初始化了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-26-19-49-23.png" alt=""></p>
<p>抽象类<code>People</code>中的<code>dance</code>不是抽象方法，所以子类不需要覆盖。</p>
<p>抽象类是软件开发中一个非常重要的概念，通过定义抽象类，我们可以约定子类必需实现的方法。当我们一个类有几十上百个方法时，用抽象方法来防止子类漏掉某些方法是非常方便的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在极客时间某设计模式相关的课程中，某老师说 Python 不支持抽象类和接口。&lt;/p&gt;
&lt;p&gt;但实际上，Python 支持抽象类。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GNE v0.04版更新，支持提取正文图片与源代码</title>
    <link href="https://www.kingname.info/2019/11/25/gne-0-4/"/>
    <id>https://www.kingname.info/2019/11/25/gne-0-4/</id>
    <published>2019-11-25T14:54:01.000Z</published>
    <updated>2019-12-11T14:54:53.559Z</updated>
    
    <content type="html"><![CDATA[<p><code>GeneralNewsExtractor</code>以下简称<code>GNE</code>是一个新闻网页通用抽取器，能够在不指定任何抽取规则的情况下，把新闻网站的正文提取出来。</p>
<p>我们来看一下它的基本使用方法。</p>
<a id="more"></a>
<h2 id="安装-GNE"><a href="#安装-GNE" class="headerlink" title="安装 GNE"></a>安装 GNE</h2><p>使用 pip 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install --upgrade git+https://github.com/kingname/GeneralNewsExtractor.git</div></pre></td></tr></table></figure>
<p>当然你也可以使用<code>pipenv</code>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install git+https://github.com/kingname/GeneralNewsExtractor.git<span class="comment">#egg=gne</span></div></pre></td></tr></table></figure>
<h2 id="获取新闻网页源代码"><a href="#获取新闻网页源代码" class="headerlink" title="获取新闻网页源代码"></a>获取新闻网页源代码</h2><p>GNE 现在不会，将来也不会提供网页请求的功能，所以你需要自行想办法获取<code>经过渲染以后的</code>网页源代码。你可以使用<code>Selenium</code>或者<code>Pyppeteer</code>或者直接从浏览器上复制。</p>
<p>这里演示如何直接从浏览器中复制网页的源代码：</p>
<ol>
<li>在 Chrome 浏览器中打开对应页面，然后开启开发者工具，如下图所示：</li>
</ol>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-21-06.png" alt=""></p>
<ol>
<li>在Elements标签页定位到<html>标签，并右键，选择Copy-Copy OuterHTML，如下图所示</html></li>
</ol>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-22-12.png" alt=""></p>
<ol>
<li>把源代码保存为1.html</li>
</ol>
<h2 id="提取正文信息"><a href="#提取正文信息" class="headerlink" title="提取正文信息"></a>提取正文信息</h2><p>编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'1.html'</span>) <span class="keyword">as</span> f:</div><div class="line">    html = f.read()</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(html)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-41-02.png" alt=""></p>
<h2 id="这次更新了什么"><a href="#这次更新了什么" class="headerlink" title="这次更新了什么"></a>这次更新了什么</h2><p>在最新更新的 v0.04版本中，开放了正文图片提取功能，与返回正文源代码功能。其中返回图片 URL 的功能在上面已经演示了，结果中的<code>images</code>字段就是正文中的图片。</p>
<p>那么怎么返回正文源代码呢？只需要增加一个参数<code>with_body_html=True</code>即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gne <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'1.html'</span>) <span class="keyword">as</span> f:</div><div class="line">    html = f.read()</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">result = extractor.extract(html, with_body_html=<span class="keyword">True</span>)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-25-22-42-45.png" alt=""></p>
<p>返回结果中的<code>body_html</code>就是正文的 html 源代码。</p>
<p>关于 GNE 的深入使用，可以访问GNE 的Github: <a href="https://github.com/kingname/GeneralNewsExtractor。" target="_blank" rel="external">https://github.com/kingname/GeneralNewsExtractor。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;GeneralNewsExtractor&lt;/code&gt;以下简称&lt;code&gt;GNE&lt;/code&gt;是一个新闻网页通用抽取器，能够在不指定任何抽取规则的情况下，把新闻网站的正文提取出来。&lt;/p&gt;
&lt;p&gt;我们来看一下它的基本使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Flupy 构建数据处理管道</title>
    <link href="https://www.kingname.info/2019/11/23/flupy/"/>
    <id>https://www.kingname.info/2019/11/23/flupy/</id>
    <published>2019-11-23T14:49:18.000Z</published>
    <updated>2019-12-11T14:50:40.623Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用 Linux 的同学，肯定对<code>|</code>这个符号不陌生，这个符号是 Linux 的管道符号，可以把左边的数据传递给右边。</p>
<a id="more"></a>
<p>例如我有一个<code>spider.log</code>文件，我想查看里面包含”ERROR”关键词，同时时间为<code>2019-11-23</code>的数据，那么我可以这样写命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat spider.log | grep ERROR | grep <span class="string">"2019-11-23"</span></div></pre></td></tr></table></figure>
<p>但是，如果你想执行更复杂的操作，例如提取关键词<code>fail on: https://xxx.com</code>后面的这个网址，然后对所有获得的网址进行去重，那么虽然 shell 命令也能办到，但写起来却稍显麻烦。</p>
<p>这个时候，你就可以使用 Flupy来实现你的需求。首先我们使用 Python 3.6以上的版本安装<code>Flupy</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 -m pip install flupy</div></pre></td></tr></table></figure>
<p>然后开始写代码，看看这几步操作有多简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> flupy <span class="keyword">import</span> flu</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'spider.log'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">    error_url = (flu(f).filter(<span class="keyword">lambda</span> x: <span class="string">'ERROR'</span> <span class="keyword">in</span> x)</div><div class="line">                      .map(<span class="keyword">lambda</span> x: re.search(<span class="string">'fail on: (.*?),'</span>, x))</div><div class="line">                      .filter(<span class="keyword">lambda</span> x: x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)</div><div class="line">                      .map(<span class="keyword">lambda</span> x: x.group(<span class="number">1</span>))</div><div class="line">                      .unique())</div><div class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> error_url:</div><div class="line">        print(url)</div></pre></td></tr></table></figure>
<p>首先<code>flu</code>接收一个可迭代对象，无论是列表还是生成器都可以。然后对里面的每一条数据应用后面的规则。这个过程都是基于生成器实现的，所以不会有内存不足的问题，对于 PB 级别的数据也不在话下。</p>
<p>在上面的例子中，<code>Flupy</code>获取日志文件的每一行内容，首先使用<code>filter</code>进行过滤，只保留包含<code>ERROR</code>字符串的行。然后对这些行通过<code>map</code>方法执行正则表达式，搜索满足<code>fail on: (.*?)\n</code>的内容。由于有些行有，有些行没有，所以这一步返回的数据有些是 None，有些是正则表达式对象，所以进一步再使用<code>filter</code>关键字，把所有返回<code>None</code>的都过滤掉。然后继续使用<code>map</code>关键字，对每一个正则表达式对象获取<code>.group(1)</code>。并把结果输出。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-23-20-49-04.png" alt=""></p>
<p>实现了数据的提取和去重。并且整个过程通过 Python 实现，代码也比 Shell 简单直观。</p>
<p>由于<code>Flupy</code>可以接收任何可迭代对象，所以传入数据库游标也是没有问题的，例如从 MongoDB 中读取数据并进行处理的一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"><span class="keyword">from</span> flupy <span class="keyword">import</span> flu</div><div class="line"></div><div class="line"></div><div class="line">handler = pymongo.MongoClient().db.col</div><div class="line"></div><div class="line">cursor = handler.find()</div><div class="line">data = flu(cursor).filter(<span class="keyword">lambda</span> x: x[<span class="string">'date'</span>] &gt;= <span class="string">'2019-11-10'</span>).map(<span class="keyword">lambda</span> x: x[<span class="string">'text'</span>]).take_while(<span class="keyword">lambda</span> x: <span class="string">'kingname'</span> <span class="keyword">in</span> x)</div></pre></td></tr></table></figure>
<p>这一段代码的意思是说，从数据库中一行一行检查数据，如果<code>date</code>字段大于<code>2019-11-10</code>就获取<code>text</code>字段的数据，满足一条就获取一条，直到某条数据包含<code>kingname</code>为止。</p>
<p>使用<code>Flupy</code>不仅可以通过写<code>.py</code>文件实现，还可以直接在命令行中执行，例如上面读取<code>spider.log</code>的代码，可以转换为终端命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flu -f spider.log <span class="string">"_.filter(lambda x: 'ERROR' in x).map(lambda x: re.search('fail on: (.*?),', x)).filter(lambda x: x is not None).map(lambda x: x.group(1)).unique()"</span> -i re</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-23-21-00-44.png" alt=""></p>
<p>通过<code>-i</code> 参数导入不同的库，无论是系统自带的库或者第三方库都可以。</p>
<p>Flupy 的更多使用参数，可以参阅它的<a href="https://flupy.readthedocs.io/en/latest/welcome.html" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用 Linux 的同学，肯定对&lt;code&gt;|&lt;/code&gt;这个符号不陌生，这个符号是 Linux 的管道符号，可以把左边的数据传递给右边。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中小括号的另类用法</title>
    <link href="https://www.kingname.info/2019/11/21/brack-in-python/"/>
    <id>https://www.kingname.info/2019/11/21/brack-in-python/</id>
    <published>2019-11-21T14:46:59.000Z</published>
    <updated>2019-12-11T14:47:51.935Z</updated>
    
    <content type="html"><![CDATA[<p>在写 Python 代码时，小括号必定是天天跟我们打交道的符号。无论是函数还是类或是运算优先级都会涉及到大量的小括号。</p>
<p>今天我们来讲讲小括号不为人知的另外两种用法。</p>
<a id="more"></a>
<h3 id="优化单行字符串的显示"><a href="#优化单行字符串的显示" class="headerlink" title="优化单行字符串的显示"></a>优化单行字符串的显示</h3><p>我有一行非常长的单行字符串，如果放在一行，看起来非常不方便，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-16-22.png" alt=""></p>
<p>但是，如果我使用三引号分行显示，那么就会引入不必要的换行符，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-18-19.png" alt=""></p>
<p>当然我们可以使用单引号加上反斜杠实现相同的效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-20-11.png" alt=""></p>
<p>但引入这么多的反斜杠，一是非常难看，而是很容易引入空格，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-21-20.png" alt=""></p>
<p>实际上，我们只需要使用小括号把多个字符串包在一起，他们自动就会组合成一个整体：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-24-08.png" alt=""></p>
<p>这样代码的可读性就大大提高了。</p>
<h3 id="if-条件语句的换行"><a href="#if-条件语句的换行" class="headerlink" title="if 条件语句的换行"></a>if 条件语句的换行</h3><p>Python 的 if 条件语句是 Python 的基本语法，我们在日常使用中可能会出现这样的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> <span class="keyword">and</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> <span class="keyword">and</span> <span class="number">4</span> + <span class="number">4</span> == <span class="number">8</span>:</div><div class="line">    print(<span class="string">'正确'</span>)</div></pre></td></tr></table></figure>
<p>一个 if 语句里面可能会出现多个表达式，他们使用<code>and</code>或者<code>or</code>进行连接。这就会导致有时候一个 if 语句变得非常长。</p>
<p>遇到这种情况，你可能会想到使用反斜杠进行分行，例如：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-25-12.png" alt=""></p>
<p>但反斜杠看起来非常碍眼，此时，我们也可以通过小括号来实现换行：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-21-22-25-53.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 Python 代码时，小括号必定是天天跟我们打交道的符号。无论是函数还是类或是运算优先级都会涉及到大量的小括号。&lt;/p&gt;
&lt;p&gt;今天我们来讲讲小括号不为人知的另外两种用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
</feed>
