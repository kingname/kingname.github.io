<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kingname.info/"/>
  <updated>2017-10-04T09:13:35.000Z</updated>
  <id>https://kingname.info/</id>
  
  <author>
    <name>Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TeamFlowy——结合Teambition与Workflowy</title>
    <link href="https://kingname.info/2017/10/03/teamflowy/"/>
    <id>https://kingname.info/2017/10/03/teamflowy/</id>
    <published>2017-10-03T15:29:05.000Z</published>
    <updated>2017-10-04T09:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png" alt=""></p>
<p>Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png" alt=""></p>
<p>面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。</p>
<p>当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png" alt=""></p>
<p>但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。</p>
<a id="more"></a>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>TeamFlowy是一个Python脚本，运行以后，它会登录Workflowy账号，读取上面所有的条目。名为[Teambition]的条目是任务开始的标记，这个条目下面的一级条目会作为任务被添加到Teambition中。如果任务下面还有二级条目，这些二级条目会作为子任务被添加到任务中。由于Teambition是按照项目-Stage-任务-子任务的形式组织一个工程（其中Stage对应了Teambition中工程下面的面板，例如：“待处理”，“进行中”，“完成”。）不会存在子任务的子任务，所以Workflowy中[Teambition]这个条目下面最多出现二级缩进。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-28-13.png" alt=""></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="Workflowy"><a href="#Workflowy" class="headerlink" title="Workflowy"></a>Workflowy</h3><p>获取Workflowy上面的条目，需要进行三步操作：</p>
<ol>
<li>登录Workflowy</li>
<li>获取所有条目对应的JSON字符串</li>
<li>提取需要添加到Teambition中的条目</li>
</ol>
<h4 id="登录Workflowy"><a href="#登录Workflowy" class="headerlink" title="登录Workflowy"></a>登录Workflowy</h4><p>打开Chrome监控登录Wokrflowy的过程，可以看到登录Workflowy需要访问的接口为：<code>https://workflowy.com/accounts/login/</code>。使用HTTP <code>POST</code>方式发送请求，提交的数据包括<code>username</code>，<code>password</code>和一个不知道用途的<code>next</code>。如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-47-51.png" alt=""></p>
<p>使用Python的第三方网络模块<code>requests</code>向这个模块发送<code>POST</code>请求，提交用户名和密码即可实现登录。其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">login_url = <span class="string">'https://workflowy.com/accounts/login/'</span></div><div class="line">session = requests.Session()</div><div class="line">session.post(login_url,</div><div class="line">             data=&#123;<span class="string">'username'</span>: <span class="string">'12345@qq.com'</span>,</div><div class="line">                   <span class="string">'password'</span>: <span class="string">'8888888'</span>,</div><div class="line">                   <span class="string">'next'</span>: <span class="string">''</span>&#125;)</div></pre></td></tr></table></figure>
<h4 id="获取所有条目"><a href="#获取所有条目" class="headerlink" title="获取所有条目"></a>获取所有条目</h4><p>使用<code>requests</code>的<code>session</code>登录Workflowy以后，Cookies会被自动保存到<code>session</code>这个对象里面。于是使用<code>session</code>继续访问Workfowy就可以以登录后的身份查看自己的各个条目。</p>
<p>通过Chrome可以看到获取所有条目的接口为<code>https://workflowy.com/get_initialization_data?client_version=18</code>，接口返回的数据是一个包含所有条目的超大型JSON字符串，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-10-55-40.png" alt=""></p>
<p>使用Python的json模块可以解析这个JSON字符串为字典，并获取所有条目，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">outline_url = <span class="string">'https://workflowy.com/get_initialization_data?client_version=18'</span></div><div class="line">outlines_json = session.get(outline_url).text</div><div class="line">outlines_dict = json.loads(outlines_json)</div><div class="line">project_list = outlines_dict.get(<span class="string">'projectTreeData'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'mainProjectTreeInfo'</span>, &#123;&#125;)\</div><div class="line">    .get(<span class="string">'rootProjectChildren'</span>, [])</div></pre></td></tr></table></figure>
<h4 id="提取任务与子任务"><a href="#提取任务与子任务" class="headerlink" title="提取任务与子任务"></a>提取任务与子任务</h4><p>所有的条目层层嵌套在列表-字典结构中，其基本的形态如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"ch"</span>: [子条目], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">308496</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"957996b9-67ce-51c7-a796-bfbee44e3d3f"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"AutoEmo"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>nm</code>为这个条目的名字。如果一个条目有子条目，那么<code>ch</code>列表中就会有很多个字典，每个字典的都是这个结构，如果一个条目没有子条目，那么就没有<code>ch</code>这个key。这样一层一层嵌套下去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> &#123;</div><div class="line">    <span class="string">"ch"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"5117e20b-25ba-ba91-59e1-790c0636f78e"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"准备并熟背一段自我介绍，在任何需要自我介绍的场合都有用"</span></div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">            <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fb315fc4e6f"</span>, </div><div class="line">            <span class="string">"nm"</span>: <span class="string">"姓名，来自哪里，什么工作"</span>,</div><div class="line">            <span class="string">"ch"</span>: [</div><div class="line">                &#123;<span class="string">"lm"</span>: <span class="number">5435246</span>, </div><div class="line">                 <span class="string">"id"</span>: <span class="string">"4894b23e-6f47-8028-a26a-5fbadfasdc4e6f"</span>, </div><div class="line">                 <span class="string">"nm"</span>: <span class="string">"工作经验"</span>&#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ], </div><div class="line">    <span class="string">"lm"</span>: <span class="number">558612</span>, </div><div class="line">    <span class="string">"id"</span>: <span class="string">"ea282a1c-94f3-1a44-c5b3-7907792e9e6e"</span>, </div><div class="line">    <span class="string">"nm"</span>: <span class="string">"自我介绍"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于条目和子条目的结构是一样的，那么就可以使用递归来解析每一个条目。由于需要添加到Teambition的任务，从名为[Teambition]的条目开始，于是可以使用下面这样一个函数来解析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">task_dict = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_task</span><span class="params">(sections, task_dict, target_section=False)</span>:</span></div><div class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> sections:</div><div class="line">        name = section[<span class="string">'nm'</span>]</div><div class="line">        <span class="keyword">if</span> target_section:</div><div class="line">            task_dict[name] = [x[<span class="string">'nm'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> section.get(<span class="string">'ch'</span>, [])]</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'[Teambition]'</span>:</div><div class="line">            target_section = <span class="keyword">True</span></div><div class="line">        sub_sections = section.get(<span class="string">'ch'</span>, [])</div><div class="line">        extract_task(sub_sections, task_dict, target_section=target_section)</div></pre></td></tr></table></figure>
<p>下图所示为一段需要添加到Teambition中的条目，运行这段函数以后，得到的结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'登录Workflowy'</span>: [], <span class="string">'获取需要添加到Teambition的内容'</span>: [<span class="string">'获取任务'</span>, <span class="string">'获取子任务'</span>], <span class="string">'调试Teambition API'</span>: [], <span class="string">'添加任务到Teambition'</span>: []&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-09-03.png" alt=""></p>
<h2 id="Teambition"><a href="#Teambition" class="headerlink" title="Teambition"></a>Teambition</h2><p>将任务添加到Teambition，需要使用Teambition的Python SDK登录Teambition并调用API添加任务。Teambition的Python SDK在使用<code>OAuth2</code>获取<code>access_token</code>的时候有一个坑，需要特别注意。</p>
<h3 id="登录Teambition"><a href="#登录Teambition" class="headerlink" title="登录Teambition"></a>登录Teambition</h3><h4 id="设置Teambition应用"><a href="#设置Teambition应用" class="headerlink" title="设置Teambition应用"></a>设置Teambition应用</h4><p>Teambition 是使用<code>OAuth2</code>来进行权限验证的，所以需要获取<code>access_token</code>。</p>
<p>首先打开Teambition的<a href="https://developer.teambition.com/dashboard" target="_blank" rel="external">开发者中心</a>并单击<code>新建应用</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-14-38.png" alt=""></p>
<p>应用名称可以随便写。创建好应用以后，可以看到应用的信息，需要记录<code>Client ID</code>和<code>Client Secret</code>，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-18-20.png" alt=""></p>
<p>点击左侧的<code>OAuth2</code>配置，填写回调URL，如下图所示。这里的这个URL其实使用任何一个可以访问的网站的域名都可以，这里以我的博客地址为例。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-20-49.png" alt=""></p>
<h4 id="使用Python获取access-token"><a href="#使用Python获取access-token" class="headerlink" title="使用Python获取access_token"></a>使用Python获取access_token</h4><p>首先在Python中安装Teambition的SDK：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install teambition</div></pre></td></tr></table></figure>
<p>接下来，在Python中获取授权URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> teambition <span class="keyword">import</span> Teambition</div><div class="line"></div><div class="line">tb_client_id = <span class="string">'7bfae080-a8dc-11e7-b543-77a936726657'</span></div><div class="line">tb_client_secret = <span class="string">'9830fc8c-81b3-45ed-b3c0-e039ab8f2d8b'</span></div><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret)</div><div class="line">authorize_url = tb.oauth.get_authorize_url(<span class="string">'https://kingname.info'</span>)</div><div class="line">print(authorize_url)</div></pre></td></tr></table></figure>
<p>代码运行以后，会得到一段形如下面这段URL的授权URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://account.teambition.com/oauth2/authorize?client_id=7bfae080-a8dc-11e7-b543-77a936726657&amp;redirect_uri=https://kingname.info&amp;state=&amp;lang=zh</div></pre></td></tr></table></figure>
<p>在电脑浏览器中<strong>人工</strong>访问这个URL，会出现下面这样的页面。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-31-25.png" alt=""></p>
<p>单击<code>授权并登录</code>，可以看到浏览器上面的网址变为形如：<code>https://kingname.info/?code=Pn7ebs4sZh3NYOz2FvVJQ4uu</code>，此时，需要记录<code>code=</code>后面的这一串字符串<code>Pn7ebs4sZh3NYOz2FvVJQ4uu</code>。</p>
<p>接下来就是Teambition的SDK的坑点了，根据Teambition官方文档的说法，要获取access_token，只需要如下两段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">tb.oauth.fetch_access_token(code)</div><div class="line"><span class="comment"># 上面的代码完成授权，接下来直接使用tb.xxxx就可以操作任务了。</span></div></pre></td></tr></table></figure>
<p>但实际上，上面这一段代码一定会报错。提示<code>grant invaild</code>。要解决这个问题，就必需使用Teambition的HTTP 接口来人工获取access_token。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">code = <span class="string">'Pn7ebs4sZh3NYOz2FvVJQ4uu'</span> <span class="comment">#前面浏览器中的字符串</span></div><div class="line">fetch_result_dict = session.post(<span class="string">'https://account.teambition.com/oauth2/access_token'</span>,</div><div class="line">                  data=&#123;<span class="string">'client_id'</span>: tb_client_id,</div><div class="line">                        <span class="string">'client_secret'</span>: tb_client_secret,</div><div class="line">                        <span class="string">'code'</span>: code,</div><div class="line">                        <span class="string">'grant_type'</span>: <span class="string">'code'</span>&#125;).json()</div><div class="line">tb_access_token = fetch_result_dict.get(<span class="string">'access_token'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p>此时得到的access_token是一段非常长的字符串。接下来，重新初始化tb变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tb = Teambition(tb_client_id,</div><div class="line">                tb_client_secret,</div><div class="line">                access_token=tb_access_token)</div></pre></td></tr></table></figure>
<p>初始化以后，使用tb这个变量，就可以对工程和任务进行各种操作了。</p>
<h4 id="Teambition的简单使用"><a href="#Teambition的简单使用" class="headerlink" title="Teambition的简单使用"></a>Teambition的简单使用</h4><p>要在某个工程里面创建任务，就需要知道工程的ID。首先在Teambition中手动创建一个工程，在浏览器中打开工程，URL中可以看到工程的ID，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-45-51.png" alt=""></p>
<p>有了工程ID以后，就可以使用下面的代码创建任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_task</span><span class="params">(task_name, sub_task_list)</span>:</span></div><div class="line">    tasklist = tb.tasklists.get(project_id=<span class="string">'59d396ee1013d919f3348675'</span>)[<span class="number">0</span>]</div><div class="line">    tasklist_id = tasklist[<span class="string">'_id'</span>]</div><div class="line">    todo_stage_id = tasklist[<span class="string">'stageIds'</span>][<span class="number">0</span>]</div><div class="line">    task_info = tb.tasks.create(task_name, tasklist_id=tasklist_id, stage_id=todo_stage_id)</div><div class="line">    <span class="keyword">if</span> sub_task_list:</div><div class="line">        task_id = task_info[<span class="string">'_id'</span>]</div><div class="line">        <span class="keyword">for</span> sub_task_name <span class="keyword">in</span> sub_task_list:</div><div class="line">            tb.subtasks.create(sub_task_name, task_id=task_id)</div><div class="line">    print(f<span class="string">'task: &#123;task_name&#125; with sub tasks: &#123;sub_task_list&#125; added.'</span>)</div></pre></td></tr></table></figure>
<p>这段代码首先使用<code>tb.tasklists.get()</code>根据工程ID获得任务组的ID和<code>待处理</code>这个面板的ID，接下来调用<code>tb.tasks.create()</code>接口添加任务。从添加任务返回的信息里面拿到任务的ID，再根据任务ID，调用<code>tb.subtasks.create()</code>添加子任务ID。</p>
<h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>上面的代码实现了TeamFlowy的基本逻辑。运行TeamFlowy脚本以后，[Teambition]这个条目下面的任务被成功的添加到了Teambition中，如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-16-55-34.png" alt=""></p>
<p>将代码组合起来并进行完善，让代码更容易使用，完整的代码可以查看<a href="https://github.com/kingname/TeamFlowy" target="_blank" rel="external">https://github.com/kingname/TeamFlowy</a>。完整的代码运行效果如下图所示。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-04-17-01-11.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Teambition是一个跨平台的团队协作和项目管理工具，相当于国外的Trello。使用Teambition可以像使用白板与便签纸一样来管理项目进度，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-45-13.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Teambition虽然便于管理项目，但是如果直接在Teambition上面创建一个项目对应的任务，却容易陷入面对茫茫白板，不知道如何拆分任务的尴尬境地。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-47-38.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;面对这个空荡荡的窗口，应该添加哪些任务进去？直接用脑子现想，恐怕容易出现顾此失彼或者干脆漏掉了任务的情况。&lt;/p&gt;
&lt;p&gt;当我要开始一个项目的时候，我一般不会直接打开Teambition就写任务，而是使用一个大纲工具——Workflowy来梳理思路，切分任务。等任务已经切分好了，在誊写到Teambition中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2017-10-03-23-53-06.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但这样就出现了一个问题：首先在Workflowy上面把需要做的任务写好。然后再打开Teambition，把这些任务又誊写到Teambition中。为了减少“誊写”这一步重复劳动，于是就有了TeamFlowy这个小工具。它的作用是自动誊写Workflowy中的特定条目到Teambition中。&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Teambition" scheme="https://kingname.info/tags/Teambition/"/>
    
      <category term="Workflowy" scheme="https://kingname.info/tags/Workflowy/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1709</title>
    <link href="https://kingname.info/2017/09/22/tweet-201709/"/>
    <id>https://kingname.info/2017/09/22/tweet-201709/</id>
    <published>2017-09-22T14:34:01.000Z</published>
    <updated>2017-09-22T14:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-09"><a href="#2017-09" class="headerlink" title="2017.09"></a>2017.09</h2><p>在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：<code>Command</code> + <code>Option</code> + <code>C</code></p>
<hr>
<p>以KB，MB，GB方式显示文件大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lh</div></pre></td></tr></table></figure></p>
<hr>
<p>删除超大文本文件的特定行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'10000,50000d'</span> xxx.txt &gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt</div></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<p>切分超大文本文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split -b 2G <span class="_">-d</span> <span class="_">-a</span> 2 deletelines.txt  da  //把超大文件切分为多个文件，每个文件2GB，前缀为da，后缀为2位数字</div></pre></td></tr></table></figure>
<hr>
<p>修改Linux当前用户密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd</div></pre></td></tr></table></figure>
<hr>
<p>使用Python打开一个未知编码的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">"your_file"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</div><div class="line">    file_data = fp.read()</div><div class="line">    result = chardet.detect(file_data)</div><div class="line">    file_content = file_data.decode(encoding=result[<span class="string">'encoding'</span>])</div></pre></td></tr></table></figure></p>
<h2 id="2017-08"><a href="#2017-08" class="headerlink" title="2017.08"></a>2017.08</h2><p>在SSH + Tmux中，如果想复制，按住<code>Alt</code>或者<code>Option</code>键再选择就可以复制了。</p>
<hr>
<p>关闭requests的SSL警告<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">requests.packages.urllib3.disable_warnings()</div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM中，<code>Crtl</code> + <code>V</code> <code>Ctrl</code> + <code>A</code>可以输出特殊符合<code>^A</code>，把A改为可以得到<code>^M</code></p>
<h2 id="2017-07"><a href="#2017-07" class="headerlink" title="2017.07"></a>2017.07</h2><p>在Python中，pymongo的find方法返回的是一个生成器，只有在迭代的时候才会执行里面的具体代码去读MongoDB。但是在Golang的Mgo包中，如果想让Find返回一个迭代器而不是直接把所有结果全部返回，就需要手动指定：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> xInfo <span class="keyword">struct</span> &#123;</div><div class="line">	ID <span class="keyword">int</span> <span class="string">`bson:"mt_poi_id"`</span></div><div class="line">	Count <span class="keyword">int</span> <span class="string">`bson:"count"`</span></div><div class="line">&#125;</div><div class="line">resultIter = m.handler.Find(<span class="literal">nil</span>).Select(bson.M&#123;<span class="string">"_id"</span>: <span class="number">0</span>, <span class="string">"mt_poi_id"</span>: <span class="number">1</span>, <span class="string">"count"</span>: <span class="number">1</span>&#125;).Iter()</div><div class="line"><span class="keyword">var</span> x xInfo</div><div class="line"><span class="keyword">for</span> resultIter.Next(&amp;xInfo) &#123;</div><div class="line">    fmt.Println(xInfo.Id)</div><div class="line">    fmt.Println(xInfo.Count)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2017-06"><a href="#2017-06" class="headerlink" title="2017.06"></a>2017.06</h2><p>在Golang中，使用MySQL的事务：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// paraArray为一个channel，里面是更新所需要的参数</span></div><div class="line">tx, _ := db.Begin()</div><div class="line">    <span class="keyword">for</span> _, para := <span class="keyword">range</span> paraArray&#123;</div><div class="line">        tx.Exec(<span class="string">"update....."</span>, para) </div><div class="line">    &#125;</div><div class="line">    tx.Commit()</div></pre></td></tr></table></figure></p>
<hr>
<p>由于更新MySQL会锁表，因此使用多个goroutine来更新MySQL，效果可能还不如直接在主线程中更新来的高。</p>
<hr>
<p>在Golang中，使用goroutine太多反而会导致性能下降。</p>
<h2 id="2017-05"><a href="#2017-05" class="headerlink" title="2017.05"></a>2017.05</h2><p>在Python中，可以使用<code>&gt;</code>或者<code>&gt;=</code>来判断一个集合是不是另一个集合的子集。只有是子集才会返回<code>True</code><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-05-04-09-58-18.png" alt=""></p>
<h2 id="2017-04"><a href="#2017-04" class="headerlink" title="2017.04"></a>2017.04</h2><p>在MongoDB中，通过_id来更新数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line">conn = pymongo.MongoClient().XX.YY</div><div class="line">conn.update(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'adf84a8fafasf3213'</span>), &#123;<span class="string">'$set'</span>: &#123;<span class="string">'name'</span>: <span class="string">'aaa'</span>&#125;&#125;&#125;)</div></pre></td></tr></table></figure></p>
<hr>
<p>在Python 3中，计算两个日期相隔了多少秒：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"></div><div class="line">start = <span class="string">'2017-03-21 17:21:30'</span></div><div class="line">end = <span class="string">'2017-03-21 18:10:13'</span></div><div class="line"></div><div class="line">start_datetime = datetime.datetime.strptime(start, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">end_datetime = datetime.datetime.strptime(end, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"></div><div class="line">total_seconds = (end_datetime - start_datetime).total_seconds()</div></pre></td></tr></table></figure></p>
<hr>
<p>Scrapy中，通过覆写items.py中，每个item的__repr__方法，可以减少打印出来的Log信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXItem</span><span class="params">(Item)</span>:</span></div><div class="line">    name = Field()</div><div class="line">    age = Field()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'======data has been stored.======='</span></div></pre></td></tr></table></figure></p>
<hr>
<p>在VIM粘贴Python代码的时候，缩进会一不小心爆炸。为了避免这个问题，应该先在normal模式输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set paste</div></pre></td></tr></table></figure></p>
<p>回车，再按i，再粘贴。这样Python的缩进就不会乱掉了。</p>
<hr>
<p>Selenium的Debug级的Log有时候打得太多了，为了去掉Selenium的Debug Log又不影响其他部份的Debug Log，可以使用如下命令完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">from</span> selenium.webdriver.remote.remote_connection <span class="keyword">import</span> LOGGER</div><div class="line">LOGGER.setLevel(logging.WARNING)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017-09&quot;&gt;&lt;a href=&quot;#2017-09&quot; class=&quot;headerlink&quot; title=&quot;2017.09&quot;&gt;&lt;/a&gt;2017.09&lt;/h2&gt;&lt;p&gt;在macOS中直接复制文件路径，在Finder中选中文件，按下快捷键：&lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;Option&lt;/code&gt; + &lt;code&gt;C&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以KB，MB，GB方式显示文件大小&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ls -lh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;删除超大文本文件的特定行数&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed &lt;span class=&quot;_&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;10000,50000d&#39;&lt;/span&gt; xxx.txt &amp;gt; new_xxx.txt  //删除xxx.txt的第10000行到50000行的所有内容,并将结果保存到new_xxx.txt&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://kingname.info/tags/Golang/"/>
    
      <category term="Linux" scheme="https://kingname.info/tags/Linux/"/>
    
      <category term="Craft" scheme="https://kingname.info/tags/Craft/"/>
    
  </entry>
  
  <entry>
    <title>Tenacity——Exception Retry 从此无比简单</title>
    <link href="https://kingname.info/2017/06/18/easy-retry/"/>
    <id>https://kingname.info/2017/06/18/easy-retry/</id>
    <published>2017-06-17T16:17:47.000Z</published>
    <updated>2017-07-21T13:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://kingname.info/2017/04/17/decorate-for-method/">Python 装饰器装饰类中的方法</a>这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。</p>
<p>在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。</p>
<a id="more"></a>
<p>以爬虫开发为例，由于网页返回的源代码有各种不同的情况，因此捕获异常并重试是很常见的要求。下面这几段代码是我多年以前，在刚开始学习爬虫的时候，由于捕获异常并重试导致代码混乱化过程。</p>
<p>代码一开始的逻辑非常简单，获取网页后台API返回的JSON字符串，转化成字典，提取出里面<code>data</code>的数据，然后传递给<code>save()</code>函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>代码运行一段时间，发现有时候JSON会随机出现解析错误。于是添加捕获异常并重试的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        extract(url)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>后来又发现，有部份的URL会导致递归深度超过最大值。这是因为有一些URL返回的是数据始终是错误的，而有些URL，重试几次又能返回正常的JSON数据，于是限制只重试3次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).text</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        info_dict = json.loads(info_json)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        print(<span class="string">'网页返回的不是有效的JSON格式字符串，重试！'</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">            <span class="keyword">if</span> extract(url):</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>后来又发现，不能立刻重试，重试要有时间间隔，并且时间间隔逐次增大……</p>
<p>从上面的例子中可以看到，对于异常的捕获和处理，一不小心就让整个代码变得很难看很难维护。为了解决这个问题，就需要通过装饰器来完成处理异常并重试的功能。</p>
<p>Python 有一个第三方库，叫做<a href="http://tenacity.readthedocs.io/en/latest/" target="_blank" rel="external">Tenacity</a>，它实现了一种优雅的重试功能。</p>
<p>以上面爬虫最初的无限重试版本为例，如果想实现遇到异常就重试。只需要添加两行代码，爬虫的主体函数完全不需要做修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry</div><div class="line"></div><div class="line"><span class="meta">@retry</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在要限制重试次数为3次，代码总行数不需要新增一行就能实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</div><div class="line"></div><div class="line"><span class="meta">@retry(stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>现在想每5秒钟重试一次，代码行数也不需要增加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_fixed</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_fixed(5))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>甚至重试的时间间隔想指数级递增，代码行数也不需要增加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, wait_exponential</div><div class="line"></div><div class="line"><span class="meta">@retry(wait=wait_exponential(multiplier=1, max=10)) # 重试时间间隔满足：2^n * multiplier, n为重试次数，但最多间隔10秒</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure></p>
<p>重试不仅可以限制次数和间隔时间，还可以针对特定的异常进行重试。在爬虫主体中，其实有三个地方可能出现异常: </p>
<ul>
<li>requests获取网页出错</li>
<li>解析JSON出错</li>
<li>info_dict字典里面没有<code>data</code>这个key</li>
</ul>
<p>如果只需要在JSON解析错误时重试，由于异常类型为<code>json.decoder.JSONDecodeError</code>，所以就可以通过参数来进行限制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>当然，这些特性都可以进行组合，例如只对<code>JSONDecodeError</code> 进行重试，每次间隔5秒，重试三次，那就写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, retry_if_exception_type, wait_fixed, stop_after_attempt</div><div class="line"><span class="keyword">from</span> json.decoder <span class="keyword">import</span> JSONDecodeError</div><div class="line"></div><div class="line"><span class="meta">@retry(retry=retry_if_exception_type(JSONDecodeError), wait=wait_fixed(5), stop=stop_after_attempt(3))</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(url)</span>:</span></div><div class="line">    info_json = requests.get(url).content.decode()</div><div class="line">    info_dict = json.loads(info_json)</div><div class="line">    data = info_dict[<span class="string">'data'</span>]</div><div class="line">    save(data)</div></pre></td></tr></table></figure>
<p>自始至终，爬虫主体的代码完全不需要做任何修改。</p>
<p>Tenacity是我见过的，最 Pythonic ，最优雅的第三方库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://kingname.info/2017/04/17/decorate-for-method/&quot;&gt;Python 装饰器装饰类中的方法&lt;/a&gt;这篇文章，使用了装饰器来捕获代码异常。这种方式可以让代码变得更加简洁和Pythonic。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，处理异常并重试是一个非常常见的需求。但是如何把捕获异常并重试写得简洁高效，这就是一个技术活了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Exception" scheme="https://kingname.info/tags/Exception/"/>
    
      <category term="Tenacity" scheme="https://kingname.info/tags/Tenacity/"/>
    
  </entry>
  
  <entry>
    <title>记住变量类型的三种方式</title>
    <link href="https://kingname.info/2017/06/11/type-hints-in-python3/"/>
    <id>https://kingname.info/2017/06/11/type-hints-in-python3/</id>
    <published>2017-06-11T07:25:03.000Z</published>
    <updated>2017-06-11T08:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。</p>
<a id="more"></a>
<p>假设有一个变量<code>is_request_finished</code>，从名字上来看，这个变量的值应该为<code>True</code>或者<code>False</code>，在写代码的时候，最初也确实是这样定义的。但是可能由于某些原因，在某一次赋值的时候，<code>is_request_finished = &#39;True&#39;</code>。此时，如果代码的单元测试不够完善，那么<code>if is_request_finished</code>在 <code>is_request_finished = True</code> 和 <code>is_request_finished = &#39;True&#39;</code>的时候都成立，问题被隐藏了。但是当<code>is_request_finished = &#39;False&#39;</code>的时候，由于<code>&#39;False&#39;</code>作为一个非空字符串，就会使得<code>if is_request_finished</code> 依然成立，从而使程序的行为发现异常。</p>
<p>单个变量的类型异常也许还容易发现，但是如果变量是放在字典或者列表里面，那就比较麻烦了。假设需要保存一段个人信息，于是创建了下面这样一个列表套字典的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">person_list = [&#123;</div><div class="line">        &apos;name&apos;: &apos;kingname&apos;,</div><div class="line">        &apos;age&apos;: 23,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;xxx&apos;,</div><div class="line">                    &apos;work&apos;: &apos;engineer&apos;,</div><div class="line">                    &apos;salary&apos;: 100000</div><div class="line">            &#125;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">        &apos;name&apos;: &apos;xiaoming&apos;,</div><div class="line">        &apos;age&apos;: 65,</div><div class="line">        &apos;sex&apos;: &apos;male&apos;</div><div class="line">        &apos;detail&apos;: &#123;</div><div class="line">                    &apos;address&apos;: &apos;yyy&apos;,</div><div class="line">                    &apos;work&apos;: &apos;pm&apos;,</div><div class="line">                    &apos;salary&apos;: 0.5</div><div class="line">            &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>这种方式开发起来非常的快速而方便，但是其他人甚至是开发者自己在一段时间以后读代码，都会有一种想抽死自己的冲动。因为根本不知道这个变量里面保存的是什么东西。</p>
<p>针对以上问题，常见的解决办法有三种。</p>
<h2 id="Type-Hints-与-Variable-Annotations"><a href="#Type-Hints-与-Variable-Annotations" class="headerlink" title="Type Hints 与 Variable Annotations"></a>Type Hints 与 Variable Annotations</h2><p>在<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="external">PEP 484</a>中，引入了Type Hints，在<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">PEP 526</a>中引入了Variable Annotations。它使得Python 3.6及以后的Python 代码拥有了“声明”变量类型的能力。这里的“声明”之所以会打引号，是因为这个声明是给IDE和人看的。这个声明对 Python 的解释器无效。</p>
<h3 id="Type-Hints"><a href="#Type-Hints" class="headerlink" title="Type Hints"></a>Type Hints</h3><p>PyCharm现在已经可以比较好地支持Type Hints了。例如下面这一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url)</span>:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>模拟一段上传文件的函数，上传成功以后返回True。接收一个参数<code>url</code>。在正常情况下，这个<code>url</code>应该是一个字符串。于是，使用Type Hints，代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(url: str)</span> -&gt; bool:</span></div><div class="line">    print(f<span class="string">'now upload a file to &#123;url&#125;'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如果直接运行，其运行效果如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-23-11.png" alt=""></p>
<p>现在假设传递一个不是字符串的变量给<code>upload</code>函数，此时PyCharm就会提示类型有问题，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-24-35.png" alt=""><br>但提示归提示，强行运行也是没有问题的。这就说明Type Hints主要是给IDE和人用的，解释器并不会关心类型正不正确。</p>
<p>如果修改这个函数的返回值，让它不返回<code>True</code> 或者<code>False</code>，PyCharm 也会发出警告：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-27-49.png" alt=""></p>
<p>Type Hints的官方文档，可以参阅：<a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="external">typing — Support for type hints</a></p>
<h3 id="Variable-Annotations"><a href="#Variable-Annotations" class="headerlink" title="Variable Annotations"></a>Variable Annotations</h3><p>对于Variable Annotations，如下图所示，虽然目前PyCharm还不能很好地提示变量类型不对，但是人在读代码的时候，还是会起到一定的帮助。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-32-23.png" alt=""></p>
<p>除了这种写法外，Variable Annotations还支持把类型写在注释中，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-35-15.png" alt=""></p>
<p>虽然PyCharm不能起到很好的提示作用，但是可以使用一个第三方库<code>mypy</code>来对代码做静态检查，其运行效果如下图所示，可以发现赋值的类型与声明的类型不一致(expression has type “str”, variable has type “bool”, 表达式的类型为“str”，变量的类型是“bool”)。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-41-12.png" alt=""></p>
<p>关于Variable Annotations的更多用法，可以参阅：<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="external">Syntax for Variable Annotations</a><br>关于Mypy，可以参阅它的官方文档：<a href="http://mypy.readthedocs.io/en/stable/index.html" target="_blank" rel="external">Mypy documentation</a></p>
<h2 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h2><p>在docstring来标注变量的类型，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-06-11-16-48-18.png" alt=""><br>这种写法可以用来提示一个函数，或者一个类它里面的各个变量的情况。但是详细程度需要看开发者有没有耐心把这个注释写清楚。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p>这种方法来自与Java Bean的思想，它主要用来解决列表套字典，字典套字典，字典套列表，列表套列表这种深层的嵌套关系。关于这个方法，请参阅另一篇文章：<a href="http://kingname.info/2016/06/19/bean-in-python/">可爱的豆子——使用Beans思想让Python代码更易维护</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python作为一门动态语言，其变量的类型可以自由变化。这个特性提高了代码的开发效率，却也增加了阅读代码和维护代码的难度。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 装饰器装饰类中的方法</title>
    <link href="https://kingname.info/2017/04/17/decorate-for-method/"/>
    <id>https://kingname.info/2017/04/17/decorate-for-method/</id>
    <published>2017-04-17T12:44:31.000Z</published>
    <updated>2017-04-17T13:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前在中文网上能搜索到的绝大部分关于装饰器的教程，都在讲如何装饰一个普通的函数。本文介绍如何使用Python的装饰器装饰一个类的方法，同时在装饰器函数中调用类里面的其他方法。本文以捕获一个方法的异常为例来进行说明。</p>
<a id="more"></a>
<p>有一个类Test, 它的结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure>
<p>在类中有一个方法<code>read_value()</code>，这个方法在多个地方被调用。由于某些原因，方法<code>read_value</code>有可能随机抛出Exception导致程序崩溃。所以需要对整个方法做<code>try ... except</code>处理。最丑陋的做法如下面的代码所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            print(<span class="string">'here I will do something.'</span>)</div><div class="line">            <span class="comment"># do something.</span></div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            print(f<span class="string">'exception &#123;e&#125; raised, parse exception.'</span>)</div><div class="line">            <span class="comment"># do other thing.</span></div><div class="line">            self.revive()</div></pre></td></tr></table></figure>
<p>这样写虽然可以解决问题，但是代码不Pythonic。</p>
<p>使用装饰器来解决这个问题，装饰器函数应该写在类里面还是类外面呢？答案是，写在类外面。那么既然写在类外面，如何调用这个类的其他方法呢？</p>
<p>首先写出一个最常见的处理异常的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_exception</span><span class="params">(origin_func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            u = origin_func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> u</div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            <span class="keyword">return</span> <span class="string">'an Exception raised.'</span></div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line"><span class="meta">    @catch_exception</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure>
<p>这种写法，确实可以捕获到<code>origin_func()</code>的异常，但是如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，这又应该怎么办？答案是给wrapper增加一个参数：self.</p>
<p>代码变为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">catch_exception</span><span class="params">(origin_func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            u = origin_func(self, *args, **kwargs)</div><div class="line">            <span class="keyword">return</span> u</div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            self.revive() <span class="comment">#不用顾虑，直接调用原来的类的方法</span></div><div class="line">            <span class="keyword">return</span> <span class="string">'an Exception raised.'</span></div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">revive</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'revive from exception.'</span>)</div><div class="line">        <span class="comment"># do something to restore</span></div><div class="line"></div><div class="line"><span class="meta">    @catch_exception</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_value</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'here I will do something.'</span>)</div><div class="line">        <span class="comment"># do something.</span></div></pre></td></tr></table></figure></p>
<p>只需要修改装饰器<strong>定义</strong>的部分，使用装饰器的地方完全不需要做修改。</p>
<p>下图为正常运行时的运行结果：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-04-17-21-19-25.png" alt="正常运行"></p>
<p>下图为发生异常以后捕获并处理异常：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-04-17-21-20-59.png" alt="发生异常"></p>
<p>通过添加一个self参数，类外面的装饰器就可以直接使用类里面的各种方法，也可以直接使用类的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前在中文网上能搜索到的绝大部分关于装饰器的教程，都在讲如何装饰一个普通的函数。本文介绍如何使用Python的装饰器装饰一个类的方法，同时在装饰器函数中调用类里面的其他方法。本文以捕获一个方法的异常为例来进行说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Decorate" scheme="https://kingname.info/tags/Decorate/"/>
    
  </entry>
  
  <entry>
    <title>技巧收集-M1701</title>
    <link href="https://kingname.info/2017/02/05/tweet/"/>
    <id>https://kingname.info/2017/02/05/tweet/</id>
    <published>2017-02-05T15:56:31.000Z</published>
    <updated>2017-02-05T15:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-02"><a href="#2017-02" class="headerlink" title="2017.02"></a>2017.02</h2><p>To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, <em>always</em> remember that the <code>route()</code> decorator is the outermost.</p>
<a id="more"></a>
<h2 id="2017-01"><a href="#2017-01" class="headerlink" title="2017.01"></a>2017.01</h2><p>HTML的<code>&lt;select&gt;&lt;/select&gt;</code>标签可以实现下拉选择框。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span> <span class="attr">selected</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>viewer<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span>guest<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>运行效果如下：</p>
<p><select class="form-control"><br>    <option value="admin" selected>admin</option><br>    <option value="admin">viewer</option><br>    <option value="admin">guest</option><br></select></p>
<hr>
<p>通过二进制的位操作，可以简化很多问题的分析。</p>
<p>例如现在有四个角色，分别为：读者，作者，编辑和管理员。有四个不同的权限使用四位的二进制数表示：</p>
<ul>
<li>阅读权限：0001</li>
<li>写入权限：0010</li>
<li>修改权限：0100</li>
<li>删除权限：1000</li>
</ul>
<p>每个角色的权限如下：</p>
<ul>
<li>读者只能读，所以权限是0001</li>
<li>作者能读也能写，所以是0011</li>
<li>编辑能读能写能修改，所以是0111</li>
<li>管理员能读能写能修改能删除，所以是1111</li>
</ul>
<p>要判断一个角色有哪些权限，人眼可以直接看对应的位置上面是0还是1，是0就是没有权限，是1就是有权限。在程序里面可以通过和对应权限的四位二进制数取位与操作。例如，0111编辑是否有写权限？因为0111 &amp; 0010 = 0010 所以有写权限。只要角色的四位二进制数和权限的四位二进制数取位与，得到的结果还是权限的四位二进制数，那么就有这个权限。</p>
<hr>
<p>正常情况下人有十根手指，所以一共可以计数1023个，但是一般在计数到第4个数的时候你就会挨打。明白二进制的自然知道我说的是什么意思。不明白二进制的，请看下面的动图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/count.gif" alt="手指使用二进制计数"></p>
<hr>
<p>Markdown在写作方面有非常好的优势，可以让写作的人不用关心格式，从而专注于要写的内容。但是Markdown不能进行缩进，这导致在一些大纲类的文本信息的显示上不太友好。<a href="https://workflowy.com/invite/4b7e29eb.lnx" target="_blank" rel="external">Workflowy</a>的出现可以解决这个问题。Workflowy只支持文本，界面极其简洁：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-28-16-59-48.png" alt=""><br>通过它来创建一个大纲，有助于理清思路。</p>
<hr>
<p>在HTML的<code>&lt;form&gt;&lt;/form&gt;</code>表单中，有一个属性叫做<code>action</code>,它的值是空或者是一个URL的相对路径或绝对路径。如果为空，表单将会被提交到现在这个页面的URL；如果不为空，表单将会被提交到action的值对应的页面来处理。</p>
<p>理解这一点，那些喜欢在Flask中，把GET和POST写到一个Route，同时又要为GET带参数的人，需要特别注意。因为当你POST的时候，如果action不为空，参数可能会被丢失。</p>
<hr>
<p>如果你想在局域网中共享一个文件，你可以通过Python 3快速完成：</p>
<ol>
<li>打开终端或者CMD</li>
<li><code>cd</code> 进入你需要分享的文件所在的文件夹</li>
<li>输入<code>python3 -m http.server</code>回车</li>
<li>在另一台电脑上打开浏览器，输入上一台电脑的<code>ip地址:8000</code>例如：<code>192.168.2.13:8000</code></li>
<li>下载文件</li>
</ol>
<hr>
<p>在Python中，使用<code>yield</code>实现生成器。生成器的性质是只有在被迭代的时候才运行其内部的代码。这样可以大大降低内存的占用。除此之外，<code>yield</code>还可以接收参数供生成器内部使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(top)</span>:</span></div><div class="line">       index = <span class="number">0</span></div><div class="line">       <span class="keyword">while</span> index &lt;= top:</div><div class="line">              value_from_out = <span class="keyword">yield</span> index ** <span class="number">2</span></div><div class="line">              print(<span class="string">'来自外面的值为：&#123;&#125;'</span>.format(value_from_out))</div><div class="line">              index += <span class="number">1</span></div><div class="line"></div><div class="line">power_2 = generator(<span class="number">10</span>)</div><div class="line">print(next(power_2))</div><div class="line">print(next(power_2))</div><div class="line">print(power_2.send(<span class="string">"next(power_2) 相当于power_2.send(None)"</span>))</div><div class="line">print(next(power_2))</div><div class="line">print(power_2.send(<span class="string">'代码在函数和这里来回跳。'</span>))</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">来自外面的值为：None</div><div class="line">1</div><div class="line">来自外面的值为：next(power_2) 相当于power_2.send(None)</div><div class="line">4</div><div class="line">来自外面的值为：None</div><div class="line">9</div><div class="line">来自外面的值为：代码在函数和这里来回跳。</div><div class="line">16</div></pre></td></tr></table></figure></p>
<p>以上的运行方式，和协程非常的相似。</p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="external">逆波兰式</a>通过栈来实现对表达式的运算。例如：</p>
<blockquote>
<p>中缀表达式: 5 + ((1 + 2) <em> 4) − 3<br>逆波兰式：5 1 2 + 4 </em> + 3 −</p>
</blockquote>
<hr>
<p>使用<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95" target="_blank" rel="external">调度场算法</a>可以将中缀表达式转换为逆波兰式。调度场算法是通过栈来实现的。操作数直接输出，符号需要判断优先级来判断应该直接压栈还是直接输出或者应该先将栈顶元素输出再压栈。</p>
<blockquote>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/170122.png" alt="调度场算法示意图"></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2017-02&quot;&gt;&lt;a href=&quot;#2017-02&quot; class=&quot;headerlink&quot; title=&quot;2017.02&quot;&gt;&lt;/a&gt;2017.02&lt;/h2&gt;&lt;p&gt;To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, &lt;em&gt;always&lt;/em&gt; remember that the &lt;code&gt;route()&lt;/code&gt; decorator is the outermost.&lt;/p&gt;
    
    </summary>
    
      <category term="Craft" scheme="https://kingname.info/categories/Craft/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Craft" scheme="https://kingname.info/tags/Craft/"/>
    
  </entry>
  
  <entry>
    <title>30秒找到藏在家里的手机</title>
    <link href="https://kingname.info/2017/01/07/findmyphone/"/>
    <id>https://kingname.info/2017/01/07/findmyphone/</id>
    <published>2017-01-07T06:02:02.000Z</published>
    <updated>2017-01-07T07:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们都有这样的生活体验</p>
<blockquote>
<p>我清清楚楚的记得半个小时前还用手机打了电话，怎么现在手机找不到了？这半个小时我一直在房间里，难道手机还会长翅膀飞走了吗？</p>
</blockquote>
<p>如果你有两个手机而且你的手机没有静音，那可以用另一个手机给不见的手机打一个电话。可是如果你的手机静音了呢？有人说可以等到晚上打电话，看家里哪里在发光。那么如果你的手机不仅静音，还屏幕朝下呢？</p>
<p>看了这篇文章以后，只要你的手机在家里，只要手机开机，只要手机可以上网，那么你就可以在30秒以内找到它，不论它是否静音。</p>
<a id="more"></a>
<p>根本原理还是让手机播放音乐，我们通过音乐来找到手机。但是在放音乐之前，需要让手机自动解除静音，并将音量调到最大声。</p>
<p>和<a href="http://kingname.info/2016/11/07/autoalarmclock/">《如果我提前起床，闹钟你就别响》</a>一样，这一次的任务依然是借助Python语言+ Flask框架 + 安卓上面的自动化程序：Automate来完成。不过，这一次我会把这个工具提供给大家一起使用。</p>
<h2 id="四个网址"><a href="#四个网址" class="headerlink" title="四个网址"></a>四个网址</h2><p>本文将会涉及到四个网址：</p>
<ul>
<li>注册你的账号&gt;<a href="http://automatic.kingname.info:8888/账号/register" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/register</a></li>
<li>获取当前状态&gt;<a href="http://automatic.kingname.info:8888/kingname" target="_blank" rel="external">http://automatic.kingname.info:8888/账号</a></li>
<li>让手机在30秒以后放音乐&gt;<a href="http://automatic.kingname.info:8888/kingname/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a></li>
<li>停止寻找手机&gt;<a href="http://automatic.kingname.info:8888/kingname/cancel" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/cancel</a></li>
</ul>
<h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>为了让每个人都能使用这个服务，我开放了账号注册的功能。注册只需要提供用户名即可，不需要密码，不需要邮箱，不需要手机号。注册账号只需要访问<a href="http://automatic.kingname.info:8888/账号/register" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/register</a> 其中，账号只能使用大小写字母或者数字或者下划线。如果你的账号可以使用，你将会看到如下画面：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-40-02.png" alt=""><br>就是这么简单。你的账号已经注册成功了，接下来就可以使用服务了。</p>
<p>当然，如果你的账号不巧被别人注册过了，你将会看到如下的提示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-41-25.png" alt=""><br>这个时候你需要换一个账号注册。</p>
<h3 id="获得状态"><a href="#获得状态" class="headerlink" title="获得状态"></a>获得状态</h3><p>注册完成以后，访问<a href="http://automatic.kingname.info:8888/账号" target="_blank" rel="external">http://automatic.kingname.info:8888/账号</a>, 你可以看到当前的状态，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-27-38.png" alt=""><br>这句话表示，现在不需要让手机自己叫起来。这个网址是给手机上面的Automate使用的，一般情况下不需要手动输入。</p>
<h3 id="呼叫手机"><a href="#呼叫手机" class="headerlink" title="呼叫手机"></a>呼叫手机</h3><p>突然，你发现你的手机不见了。这个时候，赶紧访问<a href="http://automatic.kingname.info:8888/账号/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a>, 如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-14-50-03.png" alt=""><br>当你访问了这个页面以后，在30秒内，你的手机就会欢快的播放音乐了。各位需要把这个网址保存为书签，方便以后直接使用。</p>
<h3 id="停止呼叫"><a href="#停止呼叫" class="headerlink" title="停止呼叫"></a>停止呼叫</h3><p>当你找到了手机，你就需要这个网址：<a href="http://automatic.kingname.info:8888/账号/cancel" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/cancel</a> 这个网址一般情况下是给Automate使用的，大家不需要手动输入。</p>
<h2 id="Automate"><a href="#Automate" class="headerlink" title="Automate"></a>Automate</h2><p>现在再来看看安卓上面的Automate应该如何配置流程。我已经将文件放在了：<a href="https://github.com/kingname/Automatic/blob/master/BackEnd/automate/Find%20my%20phone.flo" target="_blank" rel="external">Github</a>上面。点击Download按钮即可下载，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-04-56.png" alt=""></p>
<p>下载完成以后，将这个文件放在手机中，打开手机上的Automate，点击右上角的三个竖着的点，选择<code>Import</code>，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-08-49.png" alt=""></p>
<p>再点击<code>SD card</code>,如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-08-24.png" alt=""></p>
<p>选中刚刚下载的文件，即可导入成功。导入完成以后，打开这个flow, 点击右上角铅笔的图标，可以打开整个流程图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-16-49.png" alt=""><br>你需要修改的，只有我画红框的三个方块。</p>
<p>对于这两个HTTP Request，你只需要在<code>REQUEST URL</code>中，把网址里面的账号修改成你自己的账号。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-19-27.png" alt=""></p>
<p>对于Sound Play这个方块，因为我手机上面的音乐不一定在你手机上也有同样的，所以一定要修改音乐：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2017-01-07-15-20-50.png" alt=""><br>点<code>SOUND URI</code>，选择你一个你喜欢的音乐。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Flow设置完成，点击右上角✓保存，然后点击<code>Start</code>启动这个Flow。在电脑或者手机浏览器中访问：<a href="http://automatic.kingname.info:8888/账号/find" target="_blank" rel="external">http://automatic.kingname.info:8888/账号/find</a> 坐等30秒，听一下你的手机相应你的呼唤吧。然后再试一试把手机调成静音，看看它是不是依然可以大声的叫出来~</p>
<p>本文设计到的网页源代码，请访问：<a href="https://github.com/kingname/Automatic" target="_blank" rel="external">https://github.com/kingname/Automatic</a>获取。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都有这样的生活体验&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我清清楚楚的记得半个小时前还用手机打了电话，怎么现在手机找不到了？这半个小时我一直在房间里，难道手机还会长翅膀飞走了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有两个手机而且你的手机没有静音，那可以用另一个手机给不见的手机打一个电话。可是如果你的手机静音了呢？有人说可以等到晚上打电话，看家里哪里在发光。那么如果你的手机不仅静音，还屏幕朝下呢？&lt;/p&gt;
&lt;p&gt;看了这篇文章以后，只要你的手机在家里，只要手机开机，只要手机可以上网，那么你就可以在30秒以内找到它，不论它是否静音。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Workflow" scheme="https://kingname.info/tags/Workflow/"/>
    
      <category term="Automatic" scheme="https://kingname.info/tags/Automatic/"/>
    
  </entry>
  
  <entry>
    <title>用图像识别来自动确认网页加载成功</title>
    <link href="https://kingname.info/2016/12/04/how-to-know-webpage-loaded/"/>
    <id>https://kingname.info/2016/12/04/how-to-know-webpage-loaded/</id>
    <published>2016-12-04T10:10:33.000Z</published>
    <updated>2016-12-04T13:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在对安卓手机设计自动化测试用例的时候，判断一个测试场景是否可以自动化的依据在于其是否需要人的参与。对于wifi能否自动打开关闭，短信能否自动收发这样的场景，不需要人参与就可以通过程序来判断，因此对Wifi与短信这样的测试，可以通过程序来实现自动化测试。但是另外还有一些测试场景，需要人的眼睛来看，这种场景要实现自动化就比较困难。<br><a id="more"></a></p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>使用安卓的浏览器访问一个网站，如何判断网站已经加载成功？目标网站确实已经收到了请求，也返回了HTML数据，手机也收到了网站返回的数据，但是不知道什么原因，在某些时候，浏览器上面却什么都没有显示，而浏览器输出的Log却完全看不出异样。对于这样的场景，为了减少人力开销，如何让测试程序自动发现网页没有加载成功，并通知开发者？</p>
<p>这个需求可以使用计算机图像识别来实现自动化。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>由于这个需求只需要判断网页是否加载成功，因此并不需要非常高深的图像识别的理论。对一个网页来说，所谓的加载成功就是指它里面的内容能够正常地在浏览器中显示出来。因此，可以设计一个特别的网页，网页要足够简单，但是又要足够特别，从而方便图像识别。</p>
<p>这篇文章将会使用一个纯绿色的网页来进行测试。网页加载完成以后，手机屏幕上绝大多数的区域是绿色的。这个时候，截取屏幕，并使用程序来识别这张截图。如果发现截图中有大面积的绿色区域，那就证明网页已经加载完成了。</p>
<h2 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h2><h3 id="纯绿色的网页"><a href="#纯绿色的网页" class="headerlink" title="纯绿色的网页"></a>纯绿色的网页</h3><p>创建一个“greenpage.html”，它的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Green Page&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body bgcolor=&quot;green&quot;&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>网站加载成功以后，页面是全绿色的，如下图所示。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-18-49-20.png" alt=""></p>
<p>在局域网中搭建一个Web Server，并让局域网的设备可以链接。打开终端，进入到这个html文件所在的文件夹，并通过Python 3在局域网中搭建一个简单地WebServer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/Project/IdentifyWebpage</div><div class="line">python -m http.server</div></pre></td></tr></table></figure></p>
<p>使用手机访问“电脑IP:8000/greenpage.html”，效果如下图所示。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-19-01-42.png" alt=""></p>
<h3 id="识别绿色截图"><a href="#识别绿色截图" class="headerlink" title="识别绿色截图"></a>识别绿色截图</h3><p>这个Demo使用Pillow图像处理库来做图像颜色的识别，通过pip安装Pillow：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pillow</div></pre></td></tr></table></figure></p>
<p>安装完成以后，在Python程序中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from PIL import Image</div></pre></td></tr></table></figure></p>
<p>导入它图像模块。</p>
<p>程序使用Image模块载入截图，并从截图中读取某一点颜色RGB值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img = Image.open(&apos;snapshot.png&apos;)</div><div class="line">color = img.getpixel((700, 800))</div><div class="line">print(color)</div></pre></td></tr></table></figure></p>
<p>代码中的（700, 800）是截图中的某一点的座标。第一个参数为横座标，第二个参数为纵座标。截图左上角为(0, 0)，越往下，纵座标越大；越往右，横座标越大。</p>
<p>为了谨慎起见，在截图中取9个点，分别获取他们的RGB值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">points = [(200, 300), (455, 678), (333, 1200),</div><div class="line">          (300, 500), (888, 678), (900, 800),</div><div class="line">          (400, 600), (245, 365), (799, 777)]</div><div class="line">img = Image.open(&apos;snapshot.png&apos;)</div><div class="line">for point in self.points:</div><div class="line">    color = img.getpixel(point)</div><div class="line">    print(color)</div></pre></td></tr></table></figure></p>
<p>运行以后的结果如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-12-04-19-44-55.png" alt=""><br>从图中可以看到，9个点的RGB值全部是(0, 128, 0)，这个值正是绿色的RGB值。到这里，可以认为这个图片大部分的地方确实是绿色的。如果你觉得9个点还是不够全面，那你可以使用代码生成几百个点来计算。</p>
<h3 id="获取屏幕截图"><a href="#获取屏幕截图" class="headerlink" title="获取屏幕截图"></a>获取屏幕截图</h3><p>adb（Android Debug Bridge）是安卓的调试工具，可以通过adb的命令来控制手机。要对手机截图，只需要使用下面两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell /system/bin/screencap -p /sdcard/screenshot.png</div><div class="line">adb pull /sdcard/screenshot.png ~/Project/IndenfyWebpage/screenshot.png</div></pre></td></tr></table></figure></p>
<p>第一条命令生成截图，并将截图保存到手机内置存储中。虽然这里写的是“sdcard”，但是对于现在没有SD卡的手机，这条命令依然可以使用。</p>
<p>第二条命令将手机内置存储中的截图文件取出来，并保存到电脑中。如果你的电脑为Windows系统，可以将第二条命令修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/screenshot.png D:/Project/IndenfyWebpage/screenshot.png</div></pre></td></tr></table></figure></p>
<p>保存到D盘下面。注意这里使用的是从右上到左下的斜杠（/）。</p>
<p>完整的程序请访问-&gt; <a href="https://github.com/kingname/Automatic" target="_blank" rel="external">https://github.com/kingname/Automatic</a></p>
<h2 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h2><p>虽然这个Demo只是针对网页来进行测试。但是这个方法除了网页还可以验证很多其他的测试场景。例如验证视频能否正常播放，做一个特殊的视频，视频中是几个不同的纯色画面不停的切换。每一个画面停留一定的时间，程序定时获取截图并分析此时是否为纯色画面，且纯色画面是否在更换。</p>
<p>理论上讲，任何需要在屏幕上显示信息的测试案例，都可以使用这个方法来实现自动化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对安卓手机设计自动化测试用例的时候，判断一个测试场景是否可以自动化的依据在于其是否需要人的参与。对于wifi能否自动打开关闭，短信能否自动收发这样的场景，不需要人参与就可以通过程序来判断，因此对Wifi与短信这样的测试，可以通过程序来实现自动化测试。但是另外还有一些测试场景，需要人的眼睛来看，这种场景要实现自动化就比较困难。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="PIL" scheme="https://kingname.info/tags/PIL/"/>
    
      <category term="Android" scheme="https://kingname.info/tags/Android/"/>
    
      <category term="自动化测试" scheme="https://kingname.info/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如果我提前起床，闹钟你就别响</title>
    <link href="https://kingname.info/2016/11/07/autoalarmclock/"/>
    <id>https://kingname.info/2016/11/07/autoalarmclock/</id>
    <published>2016-11-07T14:56:21.000Z</published>
    <updated>2016-12-04T12:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>闹钟已经成了我们生活中必不可少的东西。如果全球每个国家的当地时间明天早上，所有的闹钟突然都不响了，不知道会发生什么样的混乱。</p>
<p>然而我们要讨论另外一种情况，闹钟每天定时响起来，真的是最好的情况吗？你有过醒来以后等闹钟的经历吗？如果你有时候在闹钟响之前就起来了，那么你会不会希望闹钟能知道你已经起来了？如果你提前醒了，那么闹钟就不响，只有你一直睡着的时候，闹钟才会按时响起来。<br><a id="more"></a></p>
<p>这个项目基于 Andorid 上面的自动化 workflow 程序 Automate 和 Python 制作。总代码量非常小。</p>
<p>做这个东西目的，是因为我现在早上有时候会在 7 点起床写东西，然后再去上班。但有时候可能会直接睡到 7 点 45 ，让闹钟把我闹醒。提前起床可能会忘记关闹钟，但是我不希望在我早上写作的时候被闹钟打扰。</p>
<p>如果我早上提前起床使用电脑，那么 Automate 可以得到信息，并关闭闹钟。如果 Automate 发现我 7 点 45 都还没有碰电脑，就会把我闹醒。整个过程，我不需要和闹钟有任何的交互。</p>
<p>这就是AutoAlarmClock这个项目存在的意义。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>AutoAlarmClock分为三个部分，安卓手机上的Automate，VPS上面的Web Server和Mac OS上面的一行命令。</p>
<p>每天早上7点40，手机上的Automate会访问一个URL A：<a href="http://autoemo.kingname.info:745/alarm_clock" target="_blank" rel="external">http://autoemo.kingname.info:745/alarm_clock</a>，只要没有得到返回信息“No”，无论是网络问题，还是因为服务器返回的是其他信息，都会设定一个闹钟，在7点45分响起来。只有访问URL以后，服务器返回“No”，那么就不设闹钟。</p>
<p>对于电脑来说，每天早上7点30分，如果电脑是开着的，说明我正在工作。这个时候电脑就会自动访问一个URL B：<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>.只有这个URL被访问过，之前给Automate访问的URL A才会返回“No”。</p>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>Web Server是手机和电脑之间的桥梁。它是使用Python的Flask框架写成的。代码已经放在了Github上：<a href="https://github.com/kingname/Automatic.git" target="_blank" rel="external">AutoAlarmClock</a>. 包括空行总共只有32行代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'please visit my blog at http://kingname.info'</span></div><div class="line"></div><div class="line"><span class="meta">@app.route("/alarm_clock")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">alarm_clock</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'alarmclock.txt'</span>):</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'alarmclock.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">            date_in_txt = f.read()</div><div class="line">            today = str(date.today())</div><div class="line">            <span class="keyword">if</span> date_in_txt == today:</div><div class="line">                <span class="keyword">return</span> <span class="string">'No'</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Yes'</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/set_alarm')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_alarm</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'alarmclock.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">        f.write(str(date.today()))</div><div class="line">    <span class="keyword">return</span> <span class="string">'OK'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">745</span>)</div></pre></td></tr></table></figure>
<p>由于这个Web Server每天只访问两次，所以没有必要使用数据库或者做线程安全的设置。数据只需要使用一个文本文件作为中转即可。一旦<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>这个链接被访问，就会在当前目录创建一个alarmclock.txt文件，里面存放的是今天的日期。当<a href="http://autoemo.kingname.info:745/alarm_clock" target="_blank" rel="external">http://autoemo.kingname.info:745/alarm_clock</a>被访问的时候，它会去检查alarmclock.txt，如果这个文件不存在，或者里面的日期不是今天的日期，那么它就会返回“Yes”。只有当alarmclock.txt存在，并且里面的内容为今天的日期，它才会返回“No”。</p>
<h3 id="电脑端"><a href="#电脑端" class="headerlink" title="电脑端"></a>电脑端</h3><p>电脑只需要访问<a href="http://autoemo.kingname.info:745/set_alarm" target="_blank" rel="external">http://autoemo.kingname.info:745/set_alarm</a>.由于Mac Book Pro只休眠，不关机，无法使用开机启动的方法来触发这个URL的访问。所以我使用了Crontab这个定时任务。因为在电脑休眠的时候，Crontab的定时任务是不会执行的，只有我在电脑上工作的时候，电脑开着才会访问这个URL，并让它生成记录今天日期的文本文件。</p>
<p>通过下面的命令设定Crontab定时任务，编辑器我选择的是VIM：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">env EDITOR=vim crontab -e</div></pre></td></tr></table></figure>
<p>定时任务设定为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 07 * * * curl -G http://autoemo.kingname.info:745/set_alarm</div></pre></td></tr></table></figure></p>
<p>表示每天的7点30分使用curl访问后面的链接。</p>
<p>Crontab在Linux下面也可以正常使用。</p>
<p>如果你的电脑为Windows，因为Windows电脑一般在晚上睡觉时会关机，所以访问URL的工作可以设定开机启动来完成。</p>
<p>首先创建一个EnableAlarmClock.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">requests.get(&apos;http://autoemo.kingname.info:745/set_alarm&apos;)</div></pre></td></tr></table></figure></p>
<p>这个文件用到了Python的requests库，如果你没有的话，请使用pip安装。</p>
<p>再创建一个EnableAlarmClock.bat文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python EnableAlarmClock.py</div></pre></td></tr></table></figure></p>
<p>打开Windows的 <strong>任务计划</strong> ，触发器选择“当前用户登录时”，操作选择“启动程序”，并填写EnableAlarmClock.bat的路径，如下图所示：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/task.png" alt=""></p>
<p>这样，每次开机登录桌面的时候，程序自动就会访问设定闹钟的页面了。</p>
<h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>Automate是安卓上面的一个强大的自动化工具，类似于IFTTT和iOS上面的Workflow。</p>
<p>在Automate中创建一个Flow，如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161108-074321.png" alt=""><br>其中涉及到了”Time await”, “HTTP request”, “Expression true?”, “Alarm add”这几个组件。</p>
<ul>
<li><p>“Time await”的设置如下图所示：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224111.png" alt=""></p>
</li>
<li><p>“HTTP request”的设置为下面两张图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224136.png" alt=""><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224142.png" alt=""></p>
</li>
<li><p>“Alarm add”的设置为下图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/Screenshot_20161107-224155.png" alt=""><br>这里由于没有设置“REPEAT WEEKDAYS”这一项，所以闹钟都是一次性的，关了以后，第二天需要再根据实际情况来让Automate来决定是否需要创建。</p>
</li>
</ul>
<p>设置并启动这个Flow以后，每天早上的闹钟就可以根据你是否在电脑前面工作而决定要不要闹响了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闹钟已经成了我们生活中必不可少的东西。如果全球每个国家的当地时间明天早上，所有的闹钟突然都不响了，不知道会发生什么样的混乱。&lt;/p&gt;
&lt;p&gt;然而我们要讨论另外一种情况，闹钟每天定时响起来，真的是最好的情况吗？你有过醒来以后等闹钟的经历吗？如果你有时候在闹钟响之前就起来了，那么你会不会希望闹钟能知道你已经起来了？如果你提前醒了，那么闹钟就不响，只有你一直睡着的时候，闹钟才会按时响起来。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Automate" scheme="https://kingname.info/tags/Automate/"/>
    
      <category term="Workflow" scheme="https://kingname.info/tags/Workflow/"/>
    
  </entry>
  
  <entry>
    <title>alias导致virtualenv异常的分析和解法</title>
    <link href="https://kingname.info/2016/06/27/alias-vs-virtualenv/"/>
    <id>https://kingname.info/2016/06/27/alias-vs-virtualenv/</id>
    <published>2016-06-27T15:40:56.000Z</published>
    <updated>2016-11-30T13:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>virtualenv 可以虚拟出一个独立的Python环境，在这个环境中安装的第三方库不会对系统中的Python产生影响。作为一个系统洁癖，我的系统中的Python环境只安装最主要的第三方库，我在开发Python项目的时候一般使用virtualenv生成的独立环境来安装项目需要的第三方库。但是如果同时使用了zsh的alias 和virtualenv，有可能就会导致virtualenv下面的python不能使用第三方库。</p>
<h2 id="Python的运行方式"><a href="#Python的运行方式" class="headerlink" title="Python的运行方式"></a>Python的运行方式</h2><p>一般我们会使用以下两种方式之一来运行Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python xxx.py</div></pre></td></tr></table></figure>
<p>或者在代码的第一行加上python的路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/local/bin/python</span></div></pre></td></tr></table></figure>
<p>这两种方式，使用的是系统中的Python来解释代码。</p>
<h2 id="问题的复现"><a href="#问题的复现" class="headerlink" title="问题的复现"></a>问题的复现</h2><p>如果电脑上安装了Python2 和Python3， 那么想运行Python3写的代码的时候，我们可以使用以下方法来运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python3 xxx.py</div></pre></td></tr></table></figure>
<p>但是由于有人不想写数字3， 于是就使用了zsh的alias功能，在<code>~/.zshrc</code>文件中，添加了一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>在这种情况下，使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python xxx.py</div></pre></td></tr></table></figure>
<p>就可以通过Python3来解析代码了。这种方式使用系统中的Python没有问题，但是如果在virtualenv下面可就惨了。</p>
<p>我们创建一个虚拟环境并激活，安装Python的requests库，再启动python并导入requests库, 并其代码流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ virtualenv --python=python3 venv</div><div class="line">$ . venv/bin/activate</div><div class="line">$ pip install requests</div><div class="line">$ python</div><div class="line">&gt;&gt;&gt;import requests</div></pre></td></tr></table></figure>
<p>如果我们设置了上面的alias，那么你一定会得到下面的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ImportError: No module named requests</div></pre></td></tr></table></figure>
<p>于是你打开<code>venv/lib/python3.5/site-packages</code>却发现requests安安静静的躺在里面。于是你百思不得其解，明明pip 是把requests安装在虚拟环境下面的，为什么Python不能正常导入呢？于是你再执行以下代码查看环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">print(sys.path)</div></pre></td></tr></table></figure>
<p>你看到的可能是下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[&apos;&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python35.zip&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/plat-darwin&apos;,</div><div class="line">&apos;/usr/local/Cellar/python3/3.5.1/Frameworks/Python.framework/Versions/3.5/lib/python3.5/lib-dynload&apos;,</div><div class="line">&apos;/usr/local/lib/python3.5/site-packages&apos;]</div></pre></td></tr></table></figure>
<p>全部是系统下面Python的路径，和你的virtualenv 没有一点点的关系。</p>
<p>然后你退出Python，在虚拟环境下面打印PATH，你却发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo $PATH</div><div class="line">/Users/kingname/jikexueyuan/class_spider_basic/program/mongodb/venv/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</div></pre></td></tr></table></figure>
<p>你的virtualenv环境好好的躺在你的环境变量的最前面。于是你快要疯掉了，到底是什么鬼，怎么会发生如此灵异的事件？系统不应该是首先找环境变量第一个位置下面的Python吗？怎么会跳过虚拟环境，去打开了系统中的Python呢？应该直接打开虚拟环境下面的Python才对啊！</p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>问题的根源就在你的alias上面。</p>
<p>zsh 的alias的优先级是非常高的，它会首先替换为等号后面的内容，然后再执行。那么即使在虚拟环境下，在终端输入<code>python</code>并回车以后，实际执行的代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>你使用了绝对路径打开了系统中的Python3。</p>
<p>而由于你没有对pip 设定alias, 因此你使用pip 安装requests的时候，它调用的是虚拟环境下面的pip,所以requests会正确安装在虚拟环境下面。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决办法有两个:</p>
<ol>
<li>在<code>~/.zshrc</code>中删除下面的代码，并重启终端：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<ol>
<li>将<code>~/.zshrc</code>中的：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias python=python3</div></pre></td></tr></table></figure>
<p>本文首发地址： <a href="http://kingname.info/2016/06/27/alias-vs-virtualenv/">http://kingname.info/2016/06/27/alias-vs-virtualenv/</a>转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;virtualenv 可以虚拟出一个独立的Python环境，在这个环境中安装的第三方库不会对系统中的Python产生影响。作为一个系统洁癖，我的系统中的Python环境只安装最主要的第三方库，我在开发Python项目的时候一般使用virtualenv生成的独立环境来安装项目
    
    </summary>
    
      <category term="OS X" scheme="https://kingname.info/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="https://kingname.info/tags/OS-X/"/>
    
      <category term="ZSH" scheme="https://kingname.info/tags/ZSH/"/>
    
      <category term="alias" scheme="https://kingname.info/tags/alias/"/>
    
      <category term="virtualenv" scheme="https://kingname.info/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>可爱的豆子——使用Beans思想让Python代码更易维护</title>
    <link href="https://kingname.info/2016/06/19/bean-in-python/"/>
    <id>https://kingname.info/2016/06/19/bean-in-python/</id>
    <published>2016-06-19T13:43:33.000Z</published>
    <updated>2016-11-30T13:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经是一个对Java非常反感的人，因为Java的语法非常啰嗦。而用惯了动态类型的Python再使用静态类型的Java就会觉得多出了很多的工作量。</p>
<p>因为工作的关系，我开始使用Java来做项目。在这个过程中，我发现Java在某些方面确实和Python不一样。</p>
<p>有一句话说的好：</p>
<blockquote>
<p>语言决定了世界观。</p>
</blockquote>
<p>当我Java用的越来越多的时候，我渐渐发现我不是那么讨厌它了。</p>
<p>今天我要讲的，是我从Java里面学到的，一个被称为JavaBeans的东西。</p>
<blockquote>
<p>In computing based on the Java Platform, JavaBeans are classes that encapsulate many objects into a single object (the bean). They are serializable, have a zero-argument constructor, and allow access to properties using getter and setter methods. </p>
</blockquote>
<p>一句话概括起来： <strong>当一些信息需要使用类似于字典套字典套列表这种很深的结构来储存的时候，请改用类来储存。</strong></p>
<p>在Python里面，我以前会写这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">person_list = [&#123;</div><div class="line">        <span class="string">'name'</span>: <span class="string">'kingname'</span>,</div><div class="line">        <span class="string">'age'</span>: <span class="number">23</span>,</div><div class="line">        <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">        <span class="string">'detail'</span>: &#123;</div><div class="line">                    <span class="string">'address'</span>: <span class="string">'xxx'</span>,</div><div class="line">                    <span class="string">'work'</span>: <span class="string">'engineer'</span>,</div><div class="line">                    <span class="string">'salary'</span>: <span class="number">100000</span></div><div class="line">            &#125;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">        <span class="string">'name'</span>: <span class="string">'xiaoming'</span>,</div><div class="line">        <span class="string">'age'</span>: <span class="number">65</span>,</div><div class="line">        <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">        <span class="string">'detail'</span>: &#123;</div><div class="line">                    <span class="string">'address'</span>: <span class="string">'yyy'</span>,</div><div class="line">                    <span class="string">'work'</span>: <span class="string">'pm'</span>,</div><div class="line">                    <span class="string">'salary'</span>: <span class="number">0.5</span></div><div class="line">            &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>由于Python动态类型的特点，字典里面的value经常是包含了各种类型，有时候，字典里面包含了字典，里面的字典里面还有列表，这个内部字典里面的列表里面又包含了字典……</p>
<p>当我刚刚开始写Java代码的时候，也会保留了这个坏习惯，于是我定义的一个变量类似于这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Map&lt;String, Map&lt;String, Object&gt;&gt;&gt;&gt; info = .....</div></pre></td></tr></table></figure>
<p>并且由于Java是静态类型语言，有时候Map里面的Value类型还不一致，需要使用Object来代替，等要使用的时候再做类型转换。</p>
<p>对于这样的写法，真可谓是写代码一时爽，调试代码火葬场。我过几天读自己的代码，自己都不知道这个字典里面有哪些内容，也不知道它们有哪些类型，必须到定义的地方去看。</p>
<p>我的Mentor看了我的Java代码以后，让我去用一下JavaBeans，于是我的世界瞬间就简洁多了。后来我将JavaBeans的思想用到Python中，果然Python代码也变得好看多了。</p>
<p>使用上面person_list这个复杂的结构为例，我用JavaBeans的思想，在Python里面重构它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=<span class="string">''</span>, age=<span class="number">0</span>, sex=<span class="string">''</span>, detail=None)</span>:</span></div><div class="line">        self._name = name</div><div class="line">        self._age = age</div><div class="line">        self._sex = sex</div><div class="line">        self._detail = detail</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line">    </div><div class="line"><span class="meta">    @name.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, new_name)</span>:</span></div><div class="line">        self._name = new_name</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._age</div><div class="line">    </div><div class="line"><span class="meta">    @age.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, new_age)</span>:</span></div><div class="line">        self._age = new_age</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sex</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._sex</div><div class="line">    </div><div class="line"><span class="meta">    @sex.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sex</span><span class="params">(self, new_sex)</span>:</span></div><div class="line">        self._sex = new_sex</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._detail</div><div class="line">    </div><div class="line"><span class="meta">    @detail.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self, new_detail)</span>:</span></div><div class="line">        self._detail = new_detail</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detail</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address=<span class="string">''</span>, work=<span class="string">''</span>, salary=<span class="number">0</span>)</span>:</span></div><div class="line">        self._address = address</div><div class="line">        self._work = work</div><div class="line">        self._salary = salary</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">address</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._address</div><div class="line">    </div><div class="line"><span class="meta">    @address.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">address</span><span class="params">(self, new_address)</span>:</span></div><div class="line">        self._address = new_address</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._work</div><div class="line">    </div><div class="line"><span class="meta">    @work.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self, new_work)</span>:</span></div><div class="line">        self._work = new_work</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._salary</div><div class="line">    </div><div class="line"><span class="meta">    @salary.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">salary</span><span class="params">(self, new_salary)</span>:</span></div><div class="line">        self._salary = new_salary</div></pre></td></tr></table></figure>
<p>从这里可以看到，我把字典变成了类。于是，当我想保存我自己的信息和小明的时候，我就可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">detail_kingname = Detail(address=<span class="string">'xxx'</span>, work=<span class="string">'engineer'</span>, salary=<span class="number">10000</span>),</div><div class="line">kingname = Person(name=<span class="string">'kingname'</span>, age=<span class="number">23</span>, sex=<span class="string">'male'</span>, detail=detail_kingname)</div><div class="line"></div><div class="line">detail_xiaoming = Detail(address=<span class="string">'yyy'</span>, work=<span class="string">'pm'</span>, salary=<span class="number">0.5</span>),</div><div class="line">xiaoming = Person(name=<span class="string">'xiaoming'</span>, age=<span class="number">65</span>, sex=<span class="string">'male'</span>, detail=detail_xiaoming)</div><div class="line"></div><div class="line">person_list = [kingname, xiaoming]</div></pre></td></tr></table></figure>
<p>这样写，虽然说代码量确实翻了不止一倍，但是当我们后期维护的时候或者遇到问题来调试代码，我们就能发现这样写的好处。</p>
<p>举一个很简单的例子，在写了代码一年以后，我已经对这段代码没有多少印象了，现在我得到了变量<code>person_list</code>, 我想查看每个人的工资。首先，由于<code>Person</code>和<code>Detail</code>这两个类是已经定义好的，分别放在<code>Person.py</code>和<code>Detail.py</code>两个文件中，于是我点开它们，就知道，原来工资是保存在<code>Detail</code>这个类中的，关键词是<code>salary</code>, 而<code>Detail</code>又是保存在<code>Person</code>中的，关键词是<code>detail</code>。</p>
<p>所以要查看每个人的工资，我可以这样写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> person <span class="keyword">in</span> person_list:</div><div class="line">    detail = person.detail</div><div class="line">    salary = detail.salary</div><div class="line">    print(salary)</div></pre></td></tr></table></figure>
<p>但是如果我使用的是最上面字典的那种方式，那么情况就没有这么简单了。因为我不知道工资是在这个字典的什么地方。于是我首先要找到<code>person_list</code>是在哪里初始化的，然后看它里面有什么。在这个例子中，我是一次性把整个列表字典初始化完成的，直接找到列表初始化的地方就知道，原来这个<code>person_list</code>下面有很多个字典，字典有一个key 叫<code>detail</code>,这个<code>detail</code>的value本身又是一个字典，它下面的key<code>salary</code>保存了工资的信息。这似乎还比较方便。但是如果字典里面的信息不是一次性初始化完成的呢？万一<code>detail</code>这一个key是后面再加的呢？于是又要去找<code>detail</code>初始化的地方……</p>
<p>第二个好处，使用Beans的时候，每个关键字是定义好的，<code>salary</code>就只能叫做<code>salary</code>，如果写成了<code>salarv</code>, 集成开发环境会立刻告诉你，<code>Detail</code>没有<code>salarv</code>这个属性。但是如果使用字典的方式，我在给字典赋值的时候，一不小心:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detail[<span class="string">'salarv'</span>] = <span class="number">0.5</span></div></pre></td></tr></table></figure>
<p>由于这里的<code>salarv</code>是字符串，所以集成开发环境是不会报错的，只有等你运行的时候,尝试读取<code>detail[&#39;salary&#39;]</code>里面的值，Python会告诉你:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;xxx.py&quot;, line 1, in &lt;module&gt;</div><div class="line">KeyError: &apos;salary&apos;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将JavaBeans的思想用在Python中，避免字典套字典这种深层嵌套的情况，对于一些需要反复使用的字典，使用类来表示。这样做，别人读代码的时候会更加的容易，自己开发的时候，也会避免出现问题。</p>
<p>本文首发于：<a href="http://kingname.info/2016/06/19/bean-in-python/">http://kingname.info/2016/06/19/bean-in-python/</a> 转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经是一个对Java非常反感的人，因为Java的语法非常啰嗦。而用惯了动态类型的Python再使用静态类型的Java就会觉得多出了很多的工作量。&lt;/p&gt;
&lt;p&gt;因为工作的关系，我开始使用Java来做项目。在这个过程中，我发现Java在某些方面确实和Python不一样。&lt;/
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Java" scheme="https://kingname.info/tags/Java/"/>
    
      <category term="经验" scheme="https://kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>MarkdownPicPicker - Markdown 图片上传助手</title>
    <link href="https://kingname.info/2016/06/04/markdownPicPicker/"/>
    <id>https://kingname.info/2016/06/04/markdownPicPicker/</id>
    <published>2016-06-04T08:40:06.000Z</published>
    <updated>2016-11-30T13:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>MarkdownPicPicker 是基于Python3 的Markdown写作辅助工具， 作者是我。它能将剪贴板中的图片上传到网络图床中，并将markdown格式的图片链接(![](&lt;图片地址&gt;))复制到剪贴板中。</p>
<p>项目地址：<a href="https://github.com/kingname/MarkdownPicPicker" target="_blank" rel="external">https://github.com/kingname/MarkdownPicPicker</a></p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>第0.2版有以下功能：</p>
<ol>
<li>使用七牛云作为图床。</li>
<li>将图片保存在本地</li>
<li>图片上传成功后将Markdown格式的图片地址保存到剪贴板中</li>
<li>全局监听键盘(默认不开启)</li>
<li>独立配置文件</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件保存在<code>config.ini</code>文件中，其意义分别如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="section">[basic]</span></div><div class="line"><span class="attr">run_method</span> = bat # 设定程序的运行方式，bat为使用bat文件触发，global_listen为全局键盘监听方式</div><div class="line"><span class="attr">picture_folder</span> = pic #设定程序的运行方式，bat为使用bat文件触发，pyHook为全局键盘监听方式</div><div class="line"><span class="attr">picture_suffix</span> = png #截图的保存格式，可以选择bmp或者png</div><div class="line"><span class="comment"># now support qiniu only</span></div><div class="line"><span class="attr">picture_bed</span> = qiniu</div><div class="line"><span class="section"></span></div><div class="line">[global_listen]</div><div class="line"><span class="attr">short_key_one</span> = Lwin #快捷键第一个按键</div><div class="line"><span class="attr">short_key_two</span> = C #快捷键第二个按键</div><div class="line"><span class="section"></span></div><div class="line">[qiniu]</div><div class="line"><span class="comment">#七牛云的相关配置</span></div><div class="line"><span class="attr">access_key</span> = Q6sS422O05AwYD5aVqM3FqCcCpF36tqvyQ75Zvzw</div><div class="line"><span class="attr">secret_key</span> = <span class="number">6</span>QtAqqTxoSxZP-<span class="number">2</span>uoXROehxPLX2CCmoOaB2aLObM</div><div class="line"><span class="attr">container_name</span> = picturebed  #七牛云的图片储存位置</div><div class="line"><span class="attr">url</span> = http://<span class="number">7</span>sbpmp.com1.z0.glb.clouddn.com/&#123;&#125; #七牛云分配的默认域名</div></pre></td></tr></table></figure></p>
<p>其中<code>access_key</code> 和 <code>secret_key</code> 可以在七牛云的控制面板中看到，如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/20160605083025.png" alt=""><br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-20-22-43.png" alt=""> </p>
<p><code>container_name</code> 为下图所示内容：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-20-24-40.png" alt=""> </p>
<p><code>short_key_one</code> 和 <code>short_key_two</code> 为快捷键的两个按键，默认为左侧windows徽标键(<code>Lwin</code>) 和 字母 <code>C</code>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将程序配置好以后运行，创建一个批处理文件markdownpicpicker.bat, 其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">cmd /k &quot;G:\github\MarkdownPicPicker\venv\Scripts\activate &amp; cd /d G:\github\MarkdownPicPicker &amp; python MarkdownPicPicker.py &amp; deactivate &amp; exit&quot;</div></pre></td></tr></table></figure></p>
<p>路径请根据实际情况修改。</p>
<p>由于我使用了virtualenv, 所以需要在批处理中进入virtualenv的环境才能正常运行程序。对于将requirements.txt里面包含的库直接安装在全局的情况，bat 可以简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">cmd /k &quot;cd /d &lt;MarkdownPicPicker.py脚本所在文件夹路径&gt; &amp; python MarkdownPicPicker.py &amp; exit&quot;</div></pre></td></tr></table></figure>
<p>不论哪种方式，均不要在任何相关的路径上出现中文，否则会导致不可预知的问题。</p>
<p>然后右键选择批处理，发送到桌面快捷方式。接着右键快捷方式，属性，在“快捷键” 这一栏按下字母Q，它将自动填充为 <code>Ctrl + Alt + Q</code>, 确定。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-05-00-45-03.png" alt=""> </p>
<p>只需要首先使用QQ截图或者其他截图工具将图片保存到剪贴板中，然后按下设定好的快捷键即可。Markdown格式的图片链接就已经保存到剪贴板中了。在需要使用的地方直接粘贴。</p>
<p>不过这样设定的快捷键，按下以后会有大概一秒钟的延迟。推荐大家使用AutoHotKey来触发这个bat文件。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="Pillow-bug修正"><a href="#Pillow-bug修正" class="headerlink" title="Pillow bug修正"></a>Pillow bug修正</h3><p>本程序使用了Pillow库中的 <code>ImageGrab.grabclipboard()</code> 方法来获取剪贴板中的数据，但是由于这个方法有一个bug, 导致可能会爆以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unsupported BMP bitfields layout</div></pre></td></tr></table></figure></p>
<p>这个问题从Pillow 2.8.0开始，一直到3.2.0都没有被官方解决。目前有一个间接的解决办法。<br>请打开Python安装目录下的\Lib\site-packages\PIL\BmpImagePlugin.py文件，将以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if file_info[&apos;bits&apos;] in SUPPORTED:</div><div class="line">    if file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgba_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgba_mask&apos;])]</div><div class="line">        self.mode = &quot;RGBA&quot; if raw_mode in (&quot;BGRA&quot;,) else self.mode</div><div class="line">    elif file_info[&apos;bits&apos;] in (24, 16) and file_info[&apos;rgb_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgb_mask&apos;])]</div><div class="line">    else:</div><div class="line">        raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div><div class="line">else:</div><div class="line">    raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div></pre></td></tr></table></figure>
<p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if file_info[&apos;bits&apos;] in SUPPORTED:</div><div class="line">    if file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgba_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgba_mask&apos;])]</div><div class="line">        self.mode = &quot;RGBA&quot; if raw_mode in (&quot;BGRA&quot;,) else self.mode</div><div class="line">    elif file_info[&apos;bits&apos;] in (24, 16) and file_info[&apos;rgb_mask&apos;] in SUPPORTED[file_info[&apos;bits&apos;]]:</div><div class="line">        raw_mode = MASK_MODES[(file_info[&apos;bits&apos;], file_info[&apos;rgb_mask&apos;])]</div><div class="line">    &apos;&apos;&apos;新增内容开始&apos;&apos;&apos;</div><div class="line">    elif file_info[&apos;bits&apos;] == 32 and file_info[&apos;rgb_mask&apos;] == (0xff0000, 0xff00, 0xff):</div><div class="line">        pass</div><div class="line">    &apos;&apos;&apos;新增内容结束&apos;&apos;&apos;</div><div class="line">    else:</div><div class="line">        raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div><div class="line">else:</div><div class="line">    raise IOError(&quot;Unsupported BMP bitfields layout&quot;)</div></pre></td></tr></table></figure></p>
<p>就能解决本问题。</p>
<h3 id="全局键盘监听"><a href="#全局键盘监听" class="headerlink" title="全局键盘监听"></a>全局键盘监听</h3><p>本程序还有一个功能是全局监听键盘，通过特殊的快捷键组合就可以直接触发读取图片上传图片的操作。但是由于这个功能使用到了pyHook这个库。但是这个库在设计上存在缺陷，如果当前窗体的标题包含Unicode字符时，会导致Python崩溃。因此这个功能默认不启动。</p>
<h3 id="获取键盘按键"><a href="#获取键盘按键" class="headerlink" title="获取键盘按键"></a>获取键盘按键</h3><p>如果不清楚某个键盘按键对应的字符串是什么样子的，可以运行QueryKey.py这个文件，运行以后按下某个键，控制台上就会显示相应的信息。其中<code>Key</code>就是可以设置到<code>SHORT_KEY_ONE</code>和<code>SHORT_KEY_TWO</code>的内容。如图为按下键盘左Shift键以后显示的信息。<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/2016-06-04-23-14-30.png" alt=""> </p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>支持更多的截图方式</li>
<li>支持更多的图床</li>
<li>窗口隐藏</li>
<li>解决pyHook的问题</li>
<li>适配Linux 和 Mac OS</li>
</ul>
<p><strong>本文首发地址-&gt; <a href="http://kingname.info/2016/06/04/markdownPicPicker/">http://kingname.info/2016/06/04/markdownPicPicker/</a> 转载请注明出处</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h2&gt;&lt;p&gt;MarkdownPicPicker 是基于Python3 的Markdown写作辅助工具， 作者是我。它能将剪贴板中的图片上
    
    </summary>
    
      <category term="Markdown" scheme="https://kingname.info/categories/Markdown/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Markdown" scheme="https://kingname.info/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>搭建持续集成环境(一)</title>
    <link href="https://kingname.info/2016/05/29/raspberryCI-1/"/>
    <id>https://kingname.info/2016/05/29/raspberryCI-1/</id>
    <published>2016-05-29T06:04:49.000Z</published>
    <updated>2016-11-30T13:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开题说明"><a href="#开题说明" class="headerlink" title="开题说明"></a>开题说明</h2><p>软件开发的过程是一个从简单到复杂的过程。我们在开发的时候，会首先写出具有核心的功能的原型，满足基本的需求。但是这个原型使用非常的麻烦，有无数的配置，数据的格式也需要严格的规定，稍微一个不合法的输入输出就有可能导致程序的崩溃。</p>
<p>接下来，在这个基本的原型上，我们逐渐进行完善，逐渐提高了程序的鲁棒性，用户体验逐渐的提高。新的需求出现了，于是又添加新的功能来满足新的需求。</p>
<p>在这样一个逐渐搭建（迭代）起来的过程中，我们要进行不间断的测试来保证修改没有破坏代码的已有功能，也要防止引入新的bug.如果是团队开发，要保持代码风格的一致。如果多个人同时开发，又要防止代码修改的地方出现冲突。一个版本的代码开发完成了，测试也没有问题了，同时部署到几百台服务器上，完成新功能的上线。</p>
<p>这样一个流程，如果手动来完成是相当痛苦的。于是，就需要持续集成来帮助我们完成这些琐碎的工作。开发者开发好了程序，本地测试没有问题了。使用Git提交到代码仓库，然后触发一系列的检查流程，如果出问题就给提交者发邮件提示问题，如果一切正常就开始代码审核(code review)，审核完成，合并代码。合并完成以后，会自动做好部署前面的集成测试，然后等待下一次部署周期到达以后自动将代码部署到各个服务器。</p>
<p>持续集成这个系列的文章，就是要完成以上各个环节的搭建工作，从而让开发者把精力放在开发上，而不是一些无谓的体力劳动上。</p>
<p>我会使用树莓派2 来搭建持续集成的环境，树莓派的系统为ArchLinux.</p>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Jenkins是一个用Java编写的开源的持续集成工具。它是持续集成的核心部分，扮演了一个总管的角色，统筹联系各个部分。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -S jenkins</div></pre></td></tr></table></figure>
<p>由于jenkins是Java写的，所以这个时候如果你的系统中没有Java的运行环境，他就会让你选择安装jre7-openjdk 或者是jre8-openjdk, 我选择的是安装jre8-openjdk. 这个时候我没有意识到，隐患已经埋下来了。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在ArchLinux中，什么东西都喜欢使用systemd来启动，所以执行以下命令来启动Jenkins：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start jenkins.service</div></pre></td></tr></table></figure></p>
<p>理论上这样就能使用了。但是当我在浏览器打开<code>http://192.168.2.107:8090</code>的时候却发现网页无法打开。于是检查它的log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">journalctl -u jenkins</div></pre></td></tr></table></figure></p>
<p>发现原来报错了。如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/openjdkerror.png" alt=""></p>
<p>难道说Java环境有问题？于是我是用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>来检查Java环境，果然, 连查看Java 的版本都报错了，如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/javaversion.png" alt=""></p>
<h3 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h3><p>对于这种情况，看起来不能使用openJDK了，于是去安装Oracle的JDK。</p>
<p>首先要卸载openJdk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -Rdd jre8-openjdk</div></pre></td></tr></table></figure>
<p>这里使用<code>-Rdd</code> 而不是<code>-R</code>就是为了忽略依赖性。如果直接使用<code>-R</code>的话，会报错，无法卸载。</p>
<p>如何判断卸载是否完成呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<p>提示找不到Java的时候，就说明卸载完成了。如果此时依然会爆出上面的core dumpd的错误, 就说明openJDK没有卸载干净。输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pacman -Rdd jre</div></pre></td></tr></table></figure></p>
<p>然后按键盘上面的Tab键，让自动完成功能来探测到底是哪个部分还没有卸载。</p>
<p>完全卸载干净openJDK以后，就可以安装Oracle的JDK了。</p>
<p>由于Oracle的JDK不能直接使用pacman来安装，所以需要使用AUR。树莓派的CPU是ARM架构，所以使用使用<a href="https://aur.archlinux.org/packages/jdk-arm/" target="_blank" rel="external">arm版的JDK</a>。如果有朋友是在X86的电脑上面安装的话，可以使用<a href="https://aur.archlinux.org/packages/jdk" target="_blank" rel="external">x86版的JDK</a>。</p>
<p>对于安装AUR的文件，首先从左侧<a href="https://aur.archlinux.org/cgit/aur.git/snapshot/jdk-arm.tar.gz" target="_blank" rel="external">Download snapshot</a>下载pkg文件，然后使用以下命令来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -xvf jdk-arm.tar.gz</div><div class="line">cd jdk-arm</div><div class="line">makepkg -sri</div></pre></td></tr></table></figure>
<p>然后就等待下载安装文件然后完成安装。如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/aurinstall.png" alt=""></p>
<p>完成以后，我们再执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure></p>
<p>就可以正常看到Java的版本信息了。</p>
<h3 id="再启动"><a href="#再启动" class="headerlink" title="再启动"></a>再启动</h3><p>再一次启动Jenkins:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start jenkins.service</div></pre></td></tr></table></figure></p>
<p>也可以正常启动了。（输入命令以后等待1分钟左右，让服务完全启动起来。）如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/jenkins.png" alt=""></p>
<p>根据它的提示读取密码，并填写到网页上，于是Jenkins就算是安装成功了。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>插件是Jenkins的精华，在第一次进入的时候，Jenkins就会让你选择插件。这里我选择<br><code>Select plugins to install</code>.<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/plugin.png" alt=""></p>
<p>它默认已经勾选了一些插件，我增加了以下的插件：</p>
<ul>
<li>Source Code Management 下面的Github plugin</li>
<li>Notifications and Publishing下面的 SSH plugin</li>
<li>Pipelines and Continuous Delivery 下面的 Parameterized Trigger plugin</li>
</ul>
<p>选择好以后点击 install就可以等待它安装了。如果发现漏选了或者多选了也没有关系，因为之后还可以手动管理这些插件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇讲到了如何在树莓派上面搭建Jenkins并安装插件。下一篇将会讲到Jenkins Job的创建和配置和使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开题说明&quot;&gt;&lt;a href=&quot;#开题说明&quot; class=&quot;headerlink&quot; title=&quot;开题说明&quot;&gt;&lt;/a&gt;开题说明&lt;/h2&gt;&lt;p&gt;软件开发的过程是一个从简单到复杂的过程。我们在开发的时候，会首先写出具有核心的功能的原型，满足基本的需求。但是这个原型使用非
    
    </summary>
    
      <category term="持续集成" scheme="https://kingname.info/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Jenkins" scheme="https://kingname.info/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="https://kingname.info/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>使用Python保存截图</title>
    <link href="https://kingname.info/2016/05/19/screenshot/"/>
    <id>https://kingname.info/2016/05/19/screenshot/</id>
    <published>2016-05-19T14:47:29.000Z</published>
    <updated>2016-11-30T13:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在<a href="http://jikexueyuan.com" target="_blank" rel="external">极客学院</a>讲授《使用Python编写远程控制程序》的课程中，涉及到查看被控制电脑屏幕截图的功能。</p>
<p>如果使用PIL，这个需求只需要三行代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</div><div class="line">pic = ImageGrab.grab()</div><div class="line">pic.save(<span class="string">'1.jpg'</span>)</div></pre></td></tr></table></figure></p>
<p>但是考虑到被控端应该尽量的精简，对其他模块尽量少的依赖，这样才能比较方便的部署，因此我考虑能否有一种方法，不依赖PIL来实现截图的功能。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于被控端使用了win32api, 因此有一个方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32api.keybd_event</div></pre></td></tr></table></figure></p>
<p>这个方法可以模拟键盘的按键动作。因此，解决方法就比较的明显了：</p>
<ol>
<li>模拟键盘上面的“Print Screen” 键按下</li>
<li>从剪贴板中读取出截图</li>
<li>将截图保存到本地 </li>
</ol>
<p>第一步非常的简单，实用win32api 和 win32con，两行代码就能实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import win32api</div><div class="line">import win32con</div><div class="line">win32api.keybd_event(win32con.VK_SNAPSHOT, 0)</div></pre></td></tr></table></figure></p>
<p>其中win32con这个库里面包含了很多定义好的和Windows相关的常量，而VK_SNAPSHOT就是Print Screen键的键位码。后面的数字0表示截取整个屏幕。如果改成数字1，表示截取当前窗口。</p>
<p>那么现在问题来了，在不实用PIL的情况下，如何将剪贴板你们的图片保存到本地？</p>
<p>win32api有一个模块 win32clipboard 是负责剪贴板相关的操作。它有一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32clipboard.GetClipboardData(formats)</div></pre></td></tr></table></figure></p>
<p>这个方法可以从剪贴板里面读取数据。但是需要指定数据的格式。从<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff729168\(v=vs.85\" target="_blank" rel="external">这里</a>.aspx)可以查看到更多的标准剪贴板格式(<em>Standard Clipboard Formats</em>).</p>
<p>一开始我使用的formats是<strong>CF_BITMAP</strong>，程序返回的是一串整数，怀疑应该是一个内存地址。这也和这个format的描述：</p>
<blockquote>
<p>A handle to a bitmap (<strong>HBITMAP</strong>).</p>
</blockquote>
<p>是一致的，它是一个handle。</p>
<p>我也尝试过CF_TIFF, 不过程序直接报错了，可见我使用Print Screen截图以后，剪贴板里面的图片格式并不是TIFF。</p>
<p>经过查阅其他资料，我最后确定使用了CF_DIB。</p>
<blockquote>
<p>A memory object containing a BITMAPINFO structure followed by the bitmap bits.</p>
</blockquote>
<p>这个描述说明，CF_DIB返回的是一个内存对象，包含了BIT格式图片的信息。经过测试使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win32clipboard.GetClipboardData(win32con.CF_DIB)</div></pre></td></tr></table></figure></p>
<p>以后，可以得到一个很大的字符串。显然这个字符串就是图片的内容了。但是当我把这个字符串写入到bmp格式的文件后，却发现图片无法打开。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在StackOverflow上，我遇到了一个非常好的老先生： <a href="http://stackoverflow.com/users/355230/martineau" target="_blank" rel="external">Mr. martineau</a>他为了解答了问题，并给我提供了解决办法。以下内容翻译自martineau先生的回答，原文请戳-&gt;<a href="http://stackoverflow.com/a/35885108/3922976" target="_blank" rel="external">http://stackoverflow.com/a/35885108/3922976</a></p>
<blockquote>
<p>你的方法的主要问题在于，你写入文件的字符串缺少了.bmp 文件头，这个文件头是<code>BITMAPFILEHEADER</code>结构。</p>
<p>为了创建这个文件头，使用<code>GetClipboardData()</code>返回的字符串必须要进行解码(<em>decoded</em>)。对于<code>CF_DIB</code>格式来说，返回的字符串的前面一部分就是<code>BOTMAPINFOHEADER</code>。</p>
<p>对于各种各样有不同种类压缩的<code>DIB</code>来说，这种文件头结构是非常的普遍的。不过幸好对截图来说，只需要简单的无压缩的RGBA像素。</p>
<p>由于<code>BOTMAPFILEHEADER</code>被放在了bf0ffBits的区域里，所以事情就变得很容易了。而其他的情况，例如大尺度的颜色表跟在<code>BITMAPINFOHEADER</code> 和像素数组的开头。</p>
<p>（这一段我看不太懂，还请如果有能正确解释这段话的朋友指正。原文是：</p>
<blockquote>
<p>That fact makes things much easier because otherwise determining the value to put in the bfOffBits field of the BITMAPFILEHEADER would be complicated by the fact that in most other cases there’s also a variably-sized color table following the BITMAPINFOHEADER and the start of the pixel array.）</p>
</blockquote>
<p>下面的代码是一个简单的例子（仅仅针对这个需求）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">import ctypes</div><div class="line">from ctypes.wintypes import *</div><div class="line">import win32clipboard</div><div class="line">from win32con import *</div><div class="line">import sys</div><div class="line"></div><div class="line">class BITMAPFILEHEADER(ctypes.Structure):</div><div class="line">    _pack_ = 1  # structure field byte alignment</div><div class="line">    _fields_ = [</div><div class="line">        (&apos;bfType&apos;, WORD),  # file type (&quot;BM&quot;)</div><div class="line">        (&apos;bfSize&apos;, DWORD),  # file size in bytes</div><div class="line">        (&apos;bfReserved1&apos;, WORD),  # must be zero</div><div class="line">        (&apos;bfReserved2&apos;, WORD),  # must be zero</div><div class="line">        (&apos;bfOffBits&apos;, DWORD),  # byte offset to the pixel array</div><div class="line">    ]</div><div class="line">SIZEOF_BITMAPFILEHEADER = ctypes.sizeof(BITMAPFILEHEADER)</div><div class="line"></div><div class="line">class BITMAPINFOHEADER(ctypes.Structure):</div><div class="line">    _pack_ = 1  # structure field byte alignment</div><div class="line">    _fields_ = [</div><div class="line">        (&apos;biSize&apos;, DWORD),</div><div class="line">        (&apos;biWidth&apos;, LONG),</div><div class="line">        (&apos;biHeight&apos;, LONG),</div><div class="line">        (&apos;biPLanes&apos;, WORD),</div><div class="line">        (&apos;biBitCount&apos;, WORD),</div><div class="line">        (&apos;biCompression&apos;, DWORD),</div><div class="line">        (&apos;biSizeImage&apos;, DWORD),</div><div class="line">        (&apos;biXPelsPerMeter&apos;, LONG),</div><div class="line">        (&apos;biYPelsPerMeter&apos;, LONG),</div><div class="line">        (&apos;biClrUsed&apos;, DWORD),</div><div class="line">        (&apos;biClrImportant&apos;, DWORD)</div><div class="line">    ]</div><div class="line">SIZEOF_BITMAPINFOHEADER = ctypes.sizeof(BITMAPINFOHEADER)</div><div class="line"></div><div class="line">win32clipboard.OpenClipboard()</div><div class="line">try:</div><div class="line">    if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_DIB):</div><div class="line">        data = win32clipboard.GetClipboardData(win32clipboard.CF_DIB)</div><div class="line">    else:</div><div class="line">        print(&apos;clipboard does not contain an image in DIB format&apos;)</div><div class="line">        sys.exit(1)</div><div class="line">finally:</div><div class="line">    win32clipboard.CloseClipboard()</div><div class="line"></div><div class="line">bmih = BITMAPINFOHEADER()</div><div class="line">ctypes.memmove(ctypes.pointer(bmih), data, SIZEOF_BITMAPINFOHEADER)</div><div class="line"></div><div class="line">if bmih.biCompression != BI_BITFIELDS:  # RGBA?</div><div class="line">    print(&apos;insupported compression type &#123;&#125;&apos;.format(bmih.biCompression))</div><div class="line">    sys.exit(1)</div><div class="line"></div><div class="line">bmfh = BITMAPFILEHEADER()</div><div class="line">ctypes.memset(ctypes.pointer(bmfh), 0, SIZEOF_BITMAPFILEHEADER)  # zero structure</div><div class="line">bmfh.bfType = ord(&apos;B&apos;) | (ord(&apos;M&apos;) &lt;&lt; 8)</div><div class="line">bmfh.bfSize = SIZEOF_BITMAPFILEHEADER + len(data)  # file size</div><div class="line">SIZEOF_COLORTABLE = 0</div><div class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</div><div class="line"></div><div class="line">bmp_filename = &apos;clipboard.bmp&apos;</div><div class="line">with open(bmp_filename, &apos;wb&apos;) as bmp_file:</div><div class="line">    bmp_file.write(bmfh)</div><div class="line">    bmp_file.write(data)</div><div class="line"></div><div class="line">print(&apos;file &quot;&#123;&#125;&quot; created from clipboard image&apos;.format(bmp_filename))</div></pre></td></tr></table></figure></p>
</blockquote>
<p>经过测试，这一段代码成功的实现了读取剪贴板的图片并保存到本地。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这段代码使用ctypes库来实现指针的功能，从而在内存中操作数据。这里定义了两个结构体，<code>BITMAPFILEHEADER</code> 和<code>BITMAPINFOHEADER</code>，于是，使用sizeof获取到了他们的大小。那么使用指针，从使用<code>GetClipboardData()</code>获取到的数据的头部开始移动，分别移动这两个结构体的大小，也就获取到了这两个结构体在内存中的数据。</p>
<p>代码中使用了<code>memmove</code>和<code>memset</code>两个内存操作的方法。从ctypes的官方文档上，我们可以看到这两个方法有如下的定义：</p>
<blockquote>
<p><code>ctypes.memmove(dst, src, count)</code></p>
<p>Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers.</p>
<p><code>ctypes.memset(dst, c, count)</code></p>
<p>Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address, or a ctypes instance.</p>
</blockquote>
<p>所以可以看出，代码里面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bmih = BITMAPINFOHEADER()</div><div class="line">ctypes.memmove(ctypes.pointer(bmih), data, SIZEOF_BITMAPINFOHEADER)</div></pre></td></tr></table></figure></p>
<p>从内存中拷贝出来了<code>BITMAPINFOHEADER</code>这么大的一块的数据，并保存到了<code>bmih</code>这个变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bmfh = BITMAPFILEHEADER()</div><div class="line">ctypes.memset(ctypes.pointer(bmfh), 0,     SIZEOF_BITMAPFILEHEADER)</div></pre></td></tr></table></figure></p>
<p>这一段在内存中开辟出了<code>BITMAPFILEHEADER</code>这么大一块区域，并全部填充为0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bmfh.bfType = ord(&apos;B&apos;) | (ord(&apos;M&apos;) &lt;&lt; 8)</div></pre></td></tr></table></figure></p>
<p>这一行代码使用了位操作。首先<code>ord(&#39;B&#39;)</code>的值为66，换成二进制就是<code>1000010</code>；<code>ord(&#39;M&#39;)</code>的值为77，换成二进制就是<code>1001101</code>，然后向左移动8位，得到<code>100110100000000</code>，这个值再与<code>1000010</code>取位或，得到<code>100110101000010</code>。</p>
<p>最后，使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bmfh.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE</div></pre></td></tr></table></figure></p>
<p>拼装出头部的大小。然后以二进制方式，首先写文件头, 再写剪贴板获取到的字符串到本地的<code>.bmp</code>文件中，完成图片的生成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python一些轮子确实非常好的提高了开发效率，例如PIL，三行代码实现了我的需求。Python在快速开发方面确实非常的方便，但是涉及到底层的一些操作的时候，还是不得不使用C语言的一些接口来进行内存的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://jikexueyuan.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;极客学院&lt;
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Win32Api" scheme="https://kingname.info/tags/Win32Api/"/>
    
  </entry>
  
  <entry>
    <title>对Java与设计模式态度的转变</title>
    <link href="https://kingname.info/2015/12/02/opinionchange/"/>
    <id>https://kingname.info/2015/12/02/opinionchange/</id>
    <published>2015-12-01T16:03:08.000Z</published>
    <updated>2016-11-30T13:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直自诩自己是Java一生黑。也从来不屑于设计模式这种东西，因为我一直认为，设计模式是为了解决Java的一些缺陷才存在的。对于Python来说，设计模式并不重要。不过最近在做一个新功能开发的时候对Java的态度有了一些改变。<more></more></p>
<p>事情的起因是在一个大概有十万行代码的框架中重构他的写Log方式。这个框架原来的Log模块是原作者自己写的，通过打开关闭文件来写Log。现在需要更换成Python的logging模块。对于一个设计相当糟糕的系统来说，要重构是很麻烦的事情。</p>
<p>在原来的Log方式中，文件的句柄通过参数的形式到处传，常常十多个文件句柄同时打开，还会互相影响，相当的混乱。最后由于需要一个地方来将所有模块的Log统一起来，还给系统的入口再加了一个入口，新的入口使用subprocess来执行</p>
<pre><code>`python xxxx`
</code></pre><p>调用原来的系统模块，并将控制台的输出重定向到文件。</p>
<p>重构的过程相当的痛苦，花了我几乎整个Sprint的时间，细节我会在后续的文章中讲到。今天我要讲的是单例模式让我对设计模式看法的一些改变。</p>
<p>对Python来说，是可以将一个类的实例通过参数的形式直接传递的，所以看起来似乎Python并不需要单例模式。对于新写的代码来说，这当然没有什么问题。但是对已有的代码添加新的功能的时候，这个方法就不太适用了。</p>
<p>如果原来一个方法，它的参数已经有七八个了，这个时候你在加一个参数上去，并不确定会产生什么样的影响。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def foo(a, b, c):</div><div class="line">		do()</div><div class="line">		some()</div><div class="line">		thing()</div></pre></td></tr></table></figure>
<p>如果想加一个新的参数，但是又不影响其他的已经在调用这个方法的地方，当然可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> def foo(a, b, c, d=None):</div><div class="line">do()</div><div class="line">some()</div><div class="line">thing()</div></pre></td></tr></table></figure>
<p>如果代码量不大，当然没有问题，但是如果代码量大起来了，这样就会出问题。</p>
<p>例如，现在有一个实例instanceA 在module1 中初始化了，而module3如果想使用instanceA，就必须想办法让instanceA 传递到module3去。但是原本module3和module1并没有什么关系，现在因为需要这个instanceA, 怎么办呢？这个时候发现instanceA 被传递到了module2, 然后又从module2传递到了module4, 最后在module4里面终于找到了一个地方，可以强行把instanceA和module3联系在一起。这样一来，这几个module他们被强制耦合在了一起。</p>
<p>对于程序来说，耦合程度应该越低越好，所以这样的做法，非常不妥。</p>
<p>于是，这个时候单例模式就出现了。</p>
<p>对于module3来说，如果他想要instanceA, 他完全可以再重新new一个，由于是单例模式，于是新的instance 和instanceA是完全一样的。这样就并没有增加多余的耦合关系。</p>
<p>另外，在极客学院录课的时候，最近有涉及到程序集之间通信。这个时候偶然发现设计模式里面的观察者模式可以对我的设计起到相当大的帮助。</p>
<p>就像以前某人说的，你要讨厌一个东西，你必须要比喜欢这个东西的人更了解它。而我以前讨厌Java仅仅是因为Java看起来太罗嗦，太多冗余代码。而我不屑于设计模式，更是因为它是从Java来的。</p>
<p>现在看起来，态度真的应该改变一下了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直自诩自己是Java一生黑。也从来不屑于设计模式这种东西，因为我一直认为，设计模式是为了解决Java的一些缺陷才存在的。对于Python来说，设计模式并不重要。不过最近在做一个新功能开发的时候对Java的态度有了一些改变。&lt;more&gt;&lt;/more&gt;&lt;/p&gt;
&lt;p&gt;事情的
    
    </summary>
    
      <category term="态度" scheme="https://kingname.info/categories/%E6%80%81%E5%BA%A6/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="Java" scheme="https://kingname.info/tags/Java/"/>
    
      <category term="设计模式" scheme="https://kingname.info/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用etree.HTML的编码问题</title>
    <link href="https://kingname.info/2015/10/07/lxmlencoding/"/>
    <id>https://kingname.info/2015/10/07/lxmlencoding/</id>
    <published>2015-10-07T09:56:47.000Z</published>
    <updated>2016-11-30T13:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>今天指导一个学生爬取新浪体育手机版的时候，发现lxml.etree.HTML处理网页源代码会默认修改编码，导致打印出来的内容为乱码。爬取的网址为：<a href="http://sports.sina.cn/nba/rockets/2015-10-07/detail-ifximrxn8235561.d.html?vt=4&amp;pos=10" title="http://sports.sina.cn/nba/rockets/2015-10-07/detail-ifximrxn8235561.d.html?vt=4&amp;pos=10" target="_blank" rel="external">http://sports.sina.cn/nba/rockets/2015-10-07/detail-ifximrxn8235561.d.html?vt=4&amp;pos=10</a></p>
<p>首先导入我们需要用到的库文件，然后设置环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#-*_coding:utf8-*-</div><div class="line">import requests</div><div class="line">from lxml import etree</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&quot;utf-8&quot;)</div></pre></td></tr></table></figure>
<p>然后获取网页的源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">r = requests.get(url=&apos;http://sports.sina.cn/nba/rockets/2015-10-07/detail-ifximrxn8235561.d.html?vt=4&amp;pos=10&apos;)# 最基本的GET请求</div><div class="line">r.encoding = &apos;utf-8&apos;</div><div class="line">r = r.content</div><div class="line">print r</div></pre></td></tr></table></figure></p>
<p>打印出网页源代码，发现中文是乱码，如图：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding1.gif" alt=""></p>
<p>这是小问题，使用<a href="http://blog.kingname.info/2014/12/14/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%AF%B9%E4%B8%87%E8%83%BD%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" target="_blank" rel="external">Python字符编码的一个相对万能的处理方法</a>这篇文章中讲解的方法，轻松解决。</p>
<p>将：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = r.content</div></pre></td></tr></table></figure></p>
<p>修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = r.content.decode(&apos;utf-8&apos;).encode(&apos;gbk&apos;)</div></pre></td></tr></table></figure></p>
<p>可以正常显示中文，如图：<br><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding2.png" alt=""></p>
<p>接下来，使用etree.HTML处理源代码，然后使用Xpath提取内容，一切似乎看起来轻车熟路。</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding3.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">contentTree = etree.HTML(r)</div><div class="line">title = contentTree.xpath(<span class="string">'//h1[@class="art_title_h1"]/text()'</span>)</div><div class="line"><span class="keyword">print</span> title[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>但是当我打印出来，才发现问题没有这么简单。如图：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding4.png" alt=""></p>
<p>这个时候，我发现使用<a href="http://blog.kingname.info/2014/12/14/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%AF%B9%E4%B8%87%E8%83%BD%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" target="_blank" rel="external">Python字符编码的一个相对万能的处理方法</a>讲到的办法已经不能解决问题了。</p>
<p>通过调试，我发现抓取到的内容是乱码：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding5.png" alt=""></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="使用Scrapy"><a href="#使用Scrapy" class="headerlink" title="使用Scrapy"></a>使用Scrapy</h3><p>使用Scrapy的Xpath，正常提取需要的内容：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding6.png" alt=""></p>
<h3 id="继续用etree"><a href="#继续用etree" class="headerlink" title="继续用etree"></a>继续用etree</h3><p>实际上，Scrapy的Xpath底层还是调用的lxml,那为什么它可以，而我直接使用lxml的etree.HTML处理源代码然后Xpath提取内容就出乱码呢？</p>
<p>显然这应该是编码的问题，在使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">etree.HTML(r)</div></pre></td></tr></table></figure>
<p>处理源文件的时候，由于没有指定编码，所以它使用了一个默认编码，从而导致和UTF-8冲突，产生乱码。</p>
<p>经过查阅lxml.etree.HTML的文档，我发现etree.HTML有一个参数是parser,这个参数不是必须的，因此省略以后它就会自动使用一个默认的parser。既然如此，那我手动指定一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contentTree = etree.HTML(r, parser=etree.HTMLParser(encoding=<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<p>这里我指定了etree.HTMLParser来作为一个parser,同时，etree.HTMLParser可以接受编码作为参数。于是我指定为UTF-8。</p>
<p>运行看看效果：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding7.png" alt=""></p>
<p>继续报错，但是出错信息改变了，提示utf8不能解码。请注意第11行，现在源代码是gbk编码，所以使用UTF-8不能解码。于是可以把第11行重新改回原来的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = r.content</div></pre></td></tr></table></figure>
<p>再一次运行，发现正常抓取信息：</p>
<p><img src="http://7sbpmp.com1.z0.glb.clouddn.com/lxmlencoding8.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一次的问题提示我们：遇到问题，通过经验解决不了的时候，请回归文档。</p>
<p><em>原文发表在：<a href="http://blog.kingname.info/2015/10/07/lxmlencoding/" target="_blank" rel="external">http://blog.kingname.info/2015/10/07/lxmlencoding/</a>转载请注明出处！</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;出现问题&quot;&gt;&lt;a href=&quot;#出现问题&quot; class=&quot;headerlink&quot; title=&quot;出现问题&quot;&gt;&lt;/a&gt;出现问题&lt;/h2&gt;&lt;p&gt;今天指导一个学生爬取新浪体育手机版的时候，发现lxml.etree.HTML处理网页源代码会默认修改编码，导致打印出来的内容
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="lxml" scheme="https://kingname.info/tags/lxml/"/>
    
      <category term="Xpath" scheme="https://kingname.info/tags/Xpath/"/>
    
  </entry>
  
  <entry>
    <title>我的编码规范</title>
    <link href="https://kingname.info/2015/07/19/mycodestyle/"/>
    <id>https://kingname.info/2015/07/19/mycodestyle/</id>
    <published>2015-07-19T08:31:54.000Z</published>
    <updated>2016-11-30T13:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇闲扯"><a href="#开篇闲扯" class="headerlink" title="开篇闲扯"></a>开篇闲扯</h2><p>距离上一次更新已经有快三个月了，这三个月我都在干什么呢？首先是继续实习，因为一些原因，本来计划的三个月实习变成了四个月。在实习的过程中逐步接手了一些维护的工作，并提交了不少代码。7月6号正式入职以后，我加入了一个Amazing的新项目的创建，目前我们做出来的Demo真是非常的Amazing。不过可惜的是，这样一个项目在最近几年是不会对外公布的。</p>
<p>在6月之前，每晚回家就是做毕设了，这段时间休息的都比较晚，头发都白了很多。</p>
<p>还有就是给极客学院录课，第一个系列课程《定向爬虫入门》已经全部录制完毕了，一共8课，大家可以在about me 里面找到前7课的链接，最后一课目前正在后期制作当中，上线以后会更新链接。接下来我会讲解远程控制软件的编写，欢迎大家在极客学院关注我，我的名字叫kingname~</p>
<p>闲话完毕，那我们开始正题。</p>
<p>##本题由来<br>其实以前我是不太注意编码风格的，觉得程序可以运行了就行。甚至网上还有一种说法：</p>
<blockquote>
<p>如果你急急忙忙写一个程序，都没有注重编码规范，程序可能一次就跑通了；但是如果你仔细编码，而且还把单元测试做的非常完善，很有可能程序会出现大bug,而且还难以找到原因。</p>
</blockquote>
<p>然而在我实习的过程中，读了公司的很多代码，才发现编码规范是如此的重要，以至于可以显著影响对代码的理解。而且由于在部门里面code review做的比较严格，因此代码的风格不统一的话，是不能merge的，于是在多次提交代码以后渐渐的总结出了一些规律。</p>
<p>##变量命名<br>在我大一学编程的时候，老师告诉我们变量命名最后使用匈牙利命名法，例如，经常出现hszStr、istuNum之类的变量名，如果对代码不熟悉的话，都不知道是什么意思。</p>
<p>现在我们并不使用匈牙利命名法，而是直接将变量的含义通过单纯完整拼写处理。例如：</p>
<blockquote>
<p>deviceSerialDict： 用于保存设备串号的字典<br>deviceSerialDictList： 用于保存设备串号字典的列表<br>unusedSerialNumList： 未使用的序列号列表</p>
</blockquote>
<p>我们约定：</p>
<ul>
<li>变量名首字母小写</li>
<li>多个单词的构成的变量，从第二个开始首字母大写</li>
<li>缩写词做单词处理，例如ACM在变量名中应该写为Acm而不是ACM</li>
<li>常量大写，每个单词使用_下划线分割</li>
<li>不允许出现Magic Number</li>
<li>使用名词或者动宾结构</li>
</ul>
<p>##类与方法</p>
<p>使用面向对象编程，这一点在我做毕业设计的程序时，帮了我大忙，大大减轻了我的工作压力。</p>
<p>我们的风格其实有点像Java了，文件名和类名相同，如果一个文件里面有多个类，那文件名与主要的类名相同。</p>
<p>我们约定：</p>
<ul>
<li>非私有的方法，首字母小写，动宾结构，例如getSerialNum</li>
<li>对于和类本身没有什么大关系的方法，要使用@staticmethod</li>
<li>只有类自己使用的方法需要设为私有，也就是名称前加两个下划线</li>
</ul>
<p>##代码细节</p>
<ul>
<li>逗号后面要有一个空格</li>
<li>每一行代码后面不能有空格</li>
<li>文件的最后要有一个空行</li>
<li>等号左右都需要有空格，但是作为参数的时候不需要空格</li>
<li>方法的参数大于6个，则使用列表或者字典来传递</li>
</ul>
<p>##总结</p>
<p>挂一漏万，以上的规范使用Pylint都可以帮忙检查出来。没有说到的地方请大家补充，除了以上的规范以外，还有Python自己本身的编码规范，请戳-&gt;<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">https://www.python.org/dev/peps/pep-0008/</a>。 </p>
<p>最近重构了MCC,请大家对比</p>
<p><a href="https://github.com/kingname/MCC" target="_blank" rel="external">https://github.com/kingname/MCC</a> </p>
<p>与 重构之前 </p>
<p><a href="https://github.com/kingname/MCC/tree/c806c3ccfd0c0585d51caa9f85e6867e0f3ee8cb" target="_blank" rel="external">https://github.com/kingname/MCC/tree/c806c3ccfd0c0585d51caa9f85e6867e0f3ee8cb</a></p>
<p>的区别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开篇闲扯&quot;&gt;&lt;a href=&quot;#开篇闲扯&quot; class=&quot;headerlink&quot; title=&quot;开篇闲扯&quot;&gt;&lt;/a&gt;开篇闲扯&lt;/h2&gt;&lt;p&gt;距离上一次更新已经有快三个月了，这三个月我都在干什么呢？首先是继续实习，因为一些原因，本来计划的三个月实习变成了四个月。在实
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="CodeStyle" scheme="https://kingname.info/tags/CodeStyle/"/>
    
  </entry>
  
  <entry>
    <title>requests的content与text导致lxml的解析问题</title>
    <link href="https://kingname.info/2015/04/29/lxmloldbug/"/>
    <id>https://kingname.info/2015/04/29/lxmloldbug/</id>
    <published>2015-04-29T14:49:31.000Z</published>
    <updated>2016-11-30T13:56:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近实习工作任务比较重，又在做数据挖掘的教学工作，同时还在做毕设，所以博客更新比较慢。不过最近肯定会有大动作。</p>
<p>闲话毕，转正题。在制作新浪微博模拟登录的部分时，遇到了一些问题。</p>
<p>我使用requests获取了新浪微博的源代码，通过lxml库的etree.HTML来处理一段网页源代码，从而生成一个可以被xpath解析的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selector = etree.HTML(html)</div></pre></td></tr></table></figure></p>
<p>遇到报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">selector = etree.HTML(html)</div><div class="line">  File &quot;lxml.etree.pyx&quot;, line 2953, in lxml.etree.HTML (src\lxml\lxml.etree.c:66734)</div><div class="line">  File &quot;parser.pxi&quot;, line 1780, in lxml.etree._parseMemoryDocument (src\lxml\lxml.etree.c:101591)</div><div class="line">ValueError: Unicode strings with encoding declaration are not supported. Please use bytes input or XML fragments without declaration.</div></pre></td></tr></table></figure></p>
<p>根据报错信息推测，可能是因为不支持编码声明的Unicode字符串。Google发现这个问题在2012年就已经有人提交给作者了，但是一直没有被修复。地址在-&gt;<a href="https://gist.github.com/karlcow/3258330" target="_blank" rel="external">https://gist.github.com/karlcow/3258330</a></p>
<p>不过下面的人也给出了解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">html = bytes(bytearray(html, encoding=&apos;utf-8&apos;))</div><div class="line">selector = etree.HTML(html)</div></pre></td></tr></table></figure></p>
<p>首先将源代码转化成比特数组，然后再将比特数组转化成一个比特对象。这样就可以绕过这个bug。</p>
<p>然而，又有人认为这不是一个bug, 所以一直没有被修复。这是由于，我获取源代码是使用r.text<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html = requests.get(&apos;xxxxxx&apos;,cookies=cookies).text</div></pre></td></tr></table></figure></p>
<p>而如果使用r.content：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html = requests.get(&apos;xxxxxx&apos;,cookies=cookies).content</div></pre></td></tr></table></figure></p>
<p>就不会报错。</p>
<p>那r.text与r.content有什么区别呢？分析requests的源代码发现，r.text返回的是Unicode型的数据，而使用r.content返回的是bytes型的数据。也就是说，在使用r.content的时候，他已经只带了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">html = bytes(bytearray(html, encoding=&apos;utf-8&apos;))</div></pre></td></tr></table></figure></p>
<p>这样一个转化了。</p>
<p>最近CentOS都声明放弃Python2了，编码问题确实浪费了很多时间，等空下来转Python3吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近实习工作任务比较重，又在做数据挖掘的教学工作，同时还在做毕设，所以博客更新比较慢。不过最近肯定会有大动作。&lt;/p&gt;
&lt;p&gt;闲话毕，转正题。在制作新浪微博模拟登录的部分时，遇到了一些问题。&lt;/p&gt;
&lt;p&gt;我使用requests获取了新浪微博的源代码，通过lxml库的etr
    
    </summary>
    
      <category term="经验" scheme="https://kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="lxml" scheme="https://kingname.info/tags/lxml/"/>
    
      <category term="etree" scheme="https://kingname.info/tags/etree/"/>
    
  </entry>
  
  <entry>
    <title>Python的单元测试（二）</title>
    <link href="https://kingname.info/2015/03/04/pythonunittest2/"/>
    <id>https://kingname.info/2015/03/04/pythonunittest2/</id>
    <published>2015-03-04T11:08:20.000Z</published>
    <updated>2017-01-09T13:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://kingname.info/2015/02/27/Python%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">Python的单元测试（一）</a>中，我们讲了单元测试的概念以及一个简单的单元测试例子。</p>
<p>在这个例子中，只有三个函数，于是可以把每个函数的输出结果打印到屏幕上，再用肉眼去看结果是否符合预期。然而假设有一个程序，有二十个类，每个类又有几十个函数，有些函数的输出结果还多达几十行，在这种情况下，肉眼如何看得出？</p>
<p>当然你可以使用if判断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> 输出结果 == 预期结果:</div><div class="line">	<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">	<span class="keyword">print</span> <span class="string">u'不相等'</span></div></pre></td></tr></table></figure></p>
<p>这个时候，你发现，程序有几个函数，后三行就要重复几次，本着代码简洁的原则，你把这个判断的过程写到一个函数中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isequal</span><span class="params">(output,right_output)</span>:</span></div><div class="line">	<span class="keyword">if</span> output == right_output:</div><div class="line">		<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">print</span> <span class="string">u'不相等'</span></div></pre></td></tr></table></figure></p>
<p>那么恭喜你，你步入正规了，然而，这一切已经有人为你做好了。欢迎unittest模块出场。</p>
<blockquote>
<p>unittest supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework. The unittest module provides classes that make it easy to support these qualities for a set of tests.</p>
</blockquote>
<p>Python的官方文档这样写到，unittest支持自动化测试，测试的安装分享和关闭代码……</p>
<p>一句话说来，就是，unittest很好用。</p>
<p>还是用上一次的readandadd.py来演示unittest的基本用法,首先介绍unittest的一个函数，assertEqual(first,second),这个函数的作用是检查变量first的值与second的值是否相等，如果不相等就抛出错误。 </p>
<p>先创建utest.py文件，输入以下代码并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#-*-coding:utf-8-*-</div><div class="line">import unittest</div><div class="line">import readandadd</div><div class="line"></div><div class="line">class basictest(unittest.TestCase): #类名可以随便取</div><div class="line">    def testread(self): #每个函数都要以test开头</div><div class="line">        output = readandadd.read(&apos;1.txt&apos;)</div><div class="line">        self.assertEqual(output,&apos;2,3&apos;)</div><div class="line"></div><div class="line">    def testgetnum(self):</div><div class="line">        output = readandadd.getnum(&apos;2,3&apos;)</div><div class="line">        self.assertEqual(output,[&apos;2&apos;, &apos;3&apos;])</div><div class="line"></div><div class="line">    def testaddnum(self):</div><div class="line">        output = readandadd.addnum([2,3])</div><div class="line">        self.assertEqual(output,5)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 3 tests <span class="keyword">in</span> 0.001s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>你也许会说，就一个ok，什么都没有啊。那我先把testread()函数下面的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.assertEqual(output,<span class="string">'2,3'</span>)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.assertEqual(output,<span class="string">'2,4'</span>)</div></pre></td></tr></table></figure></p>
<p>在运行utest.py看看输出结果如何：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">..F</div><div class="line">======================================================================</div><div class="line">FAIL: testread (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"E:/mystuff/unitest/utest.py"</span>, line 8, <span class="keyword">in</span> testread</div><div class="line">    self.assertEqual(output,<span class="string">'2,4'</span>)</div><div class="line">AssertionError: <span class="string">'2,3'</span> != <span class="string">'2,4'</span></div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 3 tests <span class="keyword">in</span> 0.000s</div><div class="line"></div><div class="line">FAILED (failures=1)</div></pre></td></tr></table></figure></p>
<p>这里准确的找出了错误的位置和错误的具体内容。注意看最上面，有个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">..F</div></pre></td></tr></table></figure></p>
<p>猜测它可能是标示错误的位置。保持testread的错误不改，再把testgetnum()函数中的以下内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'3'</span>])</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'6'</span>])</div></pre></td></tr></table></figure></p>
<p>再运行utest.py程序，输出结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">.FF</div><div class="line">======================================================================</div><div class="line">FAIL: testgetnum (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"E:/mystuff/unitest/utest.py"</span>, line 12, <span class="keyword">in</span> testgetnum</div><div class="line">    self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'6'</span>])</div><div class="line">AssertionError: Lists differ: [<span class="string">'2'</span>, <span class="string">'3'</span>] != [<span class="string">'2'</span>, <span class="string">'6'</span>]</div><div class="line"></div><div class="line">First differing element 1:</div><div class="line">3</div><div class="line">6</div><div class="line"></div><div class="line">- [<span class="string">'2'</span>, <span class="string">'3'</span>]</div><div class="line">?        ^</div><div class="line"></div><div class="line">+ [<span class="string">'2'</span>, <span class="string">'6'</span>]</div><div class="line">?        ^</div><div class="line"></div><div class="line"></div><div class="line">======================================================================</div><div class="line">FAIL: testread (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"E:/mystuff/unitest/utest.py"</span>, line 8, <span class="keyword">in</span> testread</div><div class="line">    self.assertEqual(output,<span class="string">'2,4'</span>)</div><div class="line">AssertionError: <span class="string">'2,3'</span> != <span class="string">'2,4'</span></div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 3 tests <span class="keyword">in</span> 0.001s</div><div class="line"></div><div class="line">FAILED (failures=2)</div></pre></td></tr></table></figure></p>
<p>可以看出，这里分别把两个错误显示了出来。并且第一行变成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.FF</div></pre></td></tr></table></figure></p>
<p>所以，第一行的内容应该从右往左读，它标明错误函数在所有函数的相对位置。</p>
<p>现在再把testread()和testgetnum()改回去，再看看全部正确的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 3 tests in 0.000s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>印证了那句话，没有消息就是最好的消息。</p>
<p>这篇文章介绍了单元测试模块unittest的assertEqual的基本用法，下一篇文章将要更加全面的介绍unittest模块。</p>
<hr>
<p>本文首发地址:<a href="http://kingname.info/2015/03/04/pythonunittest2/">http://kingname.info/2015/03/04/pythonunittest2/</a></p>
<p>作者：青南　</p>
<p>转载请注明出处。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://kingname.info/2015/02/27/Python%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/&quot;&gt;Python的单元测试（一）&lt;/a&gt;中，我们讲了单元测试的概念以及一个简单的单元测
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="单元测试" scheme="https://kingname.info/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python的单元测试（一）</title>
    <link href="https://kingname.info/2015/02/27/Python%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://kingname.info/2015/02/27/Python的单元测试/</id>
    <published>2015-02-27T14:50:47.000Z</published>
    <updated>2016-11-30T13:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>测试驱动的软件开发方式可以强迫程序员在开发程序的时候使程序的函数之间实现高内聚，低耦合。这样的方式可以降低函数之间的依赖性，方便后续的修改，增加功能和维护。</p>
<p>说<strong>一个函数</strong>高内聚，就是指这个函数专注于实现单一的任务，不会做除了生产这个任务以外的其他事情。可以想象一个人，他把自己关在一个小房子里面生产东西，只留两扇窗户，他需要什么材料，你就从小窗户给他送进去（参数），他做好了东西，就给你从另一个窗户里面送出来（return），他不会说，我要生产一个轮子，但是我首先需要一个女人进来，他不会说，这是计划的一部分。</p>
<p>说<strong>几个函数</strong>是低耦合的，就是指他们的依赖性小。他们就像是葫芦娃，每个都有自己独特的能力，可以自己单干，在关键的时候还可以合体，变成小金刚。他们就像积木一样，各有各的功能，需要使用的时候直接组合在一起就可以了。</p>
<p>使用测试驱动开发，每一个测试只测试一个功能，这样就可以迫使函数把自己独立出来，尽量减少和其他函数的依赖。</p>
<p>例如，有一个文件1.txt，他的内容是两个数字，使用逗号隔开。形如“2,4”（不包括外侧双引号，下同）。我要写一个程序readandadd.py，读取硬盘上的1.txt文件，然后把这个文件的内容打印到屏幕上。</p>
<p>不规范的写法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f= open(&apos;1.txt&apos;,&apos;r&apos;)</div><div class="line">b = f.read().split(&apos;,&apos;)</div><div class="line">f.close()</div><div class="line">print int(b[0])+int(b[1])</div></pre></td></tr></table></figure></p>
<p>不规范写法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def A():</div><div class="line">	f= open(&apos;1.txt&apos;,&apos;r&apos;)</div><div class="line">	b = f.read().split(&apos;,&apos;)</div><div class="line">	f.close()</div><div class="line">	print int(b[0])+int(b[1])</div><div class="line">A()</div></pre></td></tr></table></figure></p>
<p>比较规范的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def read(filename):</div><div class="line">    f= open(filename,&apos;r&apos;)</div><div class="line">    info = f.read()</div><div class="line">    f.close()</div><div class="line">    return info</div><div class="line"></div><div class="line">def getnum(info):</div><div class="line">    twonum = info.split(&apos;,&apos;)</div><div class="line">    return twonum</div><div class="line"></div><div class="line">def addnum(twonum):</div><div class="line">    return int(twonum[0])+int(twonum[1])</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">        info = read(&apos;1.txt&apos;)</div><div class="line">        twonum = getnum(info)</div><div class="line">        result = addnum(twonum)</div><div class="line">		print result</div></pre></td></tr></table></figure></p>
<p>这样写的好处是，如果想测试读文件的功能，就只需要测试read()函数，如果想测试把两个数分开的功能，就只需要测试getnum()函数。而相反，在不规范写法二中，虽然只想测试两个数字相加的功能，可是却不得不首先打开文件并读取文件然后把数字分开。</p>
<p>继续回到比较规范的写法当中，我相信很多人写完read()函数以后，肯定会输入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def read(filename):</div><div class="line">    f= open(filename,&apos;r&apos;)</div><div class="line">    info = f.read()</div><div class="line">    f.close()</div><div class="line">    return info</div><div class="line"></div><div class="line">print read(&apos;1.txt&apos;)</div></pre></td></tr></table></figure></p>
<p>然后运行程序，发现正常打印出’2,3’以后，再开始写getnum()函数。写完getnum以后，测试getnum()函数没问题以后再开始写然后测试addnum()函数。最后测试整个程序的功能。</p>
<p>其实这个过程，已经就是在做单元测试了。然而这样操作的弊端是什么？如果整体程序已经写好了，之前做测试点代码也就删除了。那么如果突然把程序做了修改。例如1.txt里面数字的分隔从1个逗号变成了空格，或者变成了3个数字，那必然要修改getnum()，但是又如何测试修改的部分呢？还要把不相干的代码给注释掉。不仅麻烦，而且容易出错。</p>
<p>现在，把测试的代码单独独立出来。会有什么效果呢？尝试创建一个test.py程序，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import readandadd</div><div class="line"></div><div class="line">def testread():</div><div class="line">    print &apos;read:&apos;,readandadd.read(&apos;1.txt&apos;)</div><div class="line"></div><div class="line">def testgetnum():</div><div class="line">    print &apos;getnum:&apos;,readandadd.getnum(&apos;2,3&apos;)</div><div class="line"></div><div class="line">def testaddnum():</div><div class="line">    print &apos;addnum:&apos;,readandadd.addnum([2,3])</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    testread()</div><div class="line">    testgetnum()</div><div class="line">    testaddnum()</div></pre></td></tr></table></figure></p>
<p>运行test.py以后输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">read: 2,3</div><div class="line">getnum: [&apos;2&apos;, &apos;3&apos;]</div><div class="line">addnum: 5</div></pre></td></tr></table></figure></p>
<p>每一个函数的输出结果一目了然，而且在修改了readandadd.py的函数以后，重新运行test.py就可以知道输出结果有没有符合预期。</p>
<p>当然，这里这个例子非常的简单，因此可以人工通过观察test.py的输出结果来确定是否符合预期，那对于大量的函数的测试，难道也要让肉眼来看吗？当然不是。于是，下一篇文章将会介绍Python的单元测试unittest。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试驱动的软件开发方式可以强迫程序员在开发程序的时候使程序的函数之间实现高内聚，低耦合。这样的方式可以降低函数之间的依赖性，方便后续的修改，增加功能和维护。&lt;/p&gt;
&lt;p&gt;说&lt;strong&gt;一个函数&lt;/strong&gt;高内聚，就是指这个函数专注于实现单一的任务，不会做除了生产
    
    </summary>
    
      <category term="Python" scheme="https://kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://kingname.info/tags/Python/"/>
    
      <category term="单元测试" scheme="https://kingname.info/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
