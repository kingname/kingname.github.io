<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2019-07-13T05:32:27.004Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么Python 3.6以后字典有序并且效率更高？</title>
    <link href="https://www.kingname.info/2019/07/13/python-dict/"/>
    <id>https://www.kingname.info/2019/07/13/python-dict/</id>
    <published>2019-07-13T05:30:47.000Z</published>
    <updated>2019-07-13T05:32:27.004Z</updated>
    
    <content type="html"><![CDATA[<p>在Python 3.5（含）以前，字典是不能保证顺序的，键值对A先插入字典，键值对B后插入字典，但是当你打印字典的Keys列表时，你会发现B可能在A的前面。</p>
<p>但是从Python 3.6开始，字典是变成有顺序的了。你先插入键值对A，后插入键值对B，那么当你打印Keys列表的时候，你就会发现B在A的后面。</p>
<p>不仅如此，从Python 3.6开始，下面的三种遍历操作，效率要高于Python 3.5之前：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> 字典</div><div class="line"></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> 字典.values()</div><div class="line"></div><div class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> 字典.items()</div></pre></td></tr></table></figure>
<p>从Python 3.6开始，字典占用内存空间的大小，视字典里面键值对的个数，只有原来的30%~95%。</p>
<p>Python 3.6到底对字典做了什么优化呢？为了说明这个问题，我们需要先来说一说，在Python 3.5（含）之前，字典的底层原理。</p>
<p>当我们初始化一个空字典的时候，CPython的底层会初始化一个二维数组，这个数组有8行，3列，如下面的示意图所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">my_dict = &#123;&#125;</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">[[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---]]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>现在，我们往字典里面添加一个数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">my_dict[<span class="string">'name'</span>] = <span class="string">'kingname'</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">[[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[1278649844881305901, 指向name的指针, 指向kingname的指针],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---]]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>这里解释一下，为什么添加了一个键值对以后，内存变成了这个样子：</p>
<p>首先我们调用Python 的<code>hash</code>函数，计算<code>name</code>这个字符串在<strong>当前运行时</strong>的hash值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'name'</span>)</div><div class="line"><span class="number">1278649844881305901</span></div></pre></td></tr></table></figure>
<p>特别注意，我这里强调了『当前运行时』，这是因为，Python自带的这个<code>hash</code>函数，和我们传统上认为的Hash函数是不一样的。Python自带的这个<code>hash</code>函数计算出来的值，只能保证在每一个运行时的时候不变，但是当你关闭Python再重新打开，那么它的值就可能会改变，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-12-21-49-44.png" alt=""></p>
<p>假设在某一个运行时里面，<code>hash(&#39;name&#39;)</code>的值为<code>1278649844881305901</code>。现在我们要把这个数对8取余数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1278649844881305901</span> % <span class="number">8</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>余数为5，那么就把它放在刚刚初始化的二维数组中，下标为5的这一行。由于<code>name</code>和<code>kingname</code>是两个字符串，所以底层C语言会使用两个字符串变量存放这两个值，然后得到他们对应的指针。于是，我们这个二维数组下标为5的这一行，第一个值为<code>name</code>的hash值，第二个值为<code>name</code>这个字符串所在的内存的地址（指针就是内存地址），第三个值为<code>kingname</code>这个字符串所在的内存的地址。</p>
<p>现在，我们再来插入两个键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">my_dict[<span class="string">'age'</span>] = <span class="number">26</span></div><div class="line">my_dict[<span class="string">'salary'</span>] = <span class="number">999999</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">[[-4234469173262486640, 指向salary的指针, 指向999999的指针],</div><div class="line">[1545085610920597121, 执行age的指针, 指向26的指针],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---],</div><div class="line">[1278649844881305901, 指向name的指针, 指向kingname的指针],</div><div class="line">[---, ---, ---],</div><div class="line">[---, ---, ---]]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>那么字典怎么读取数据呢？首先假设我们要读取<code>age</code>对应的值。</p>
<p>此时，Python先计算在当前运行时下面，<code>age</code>对应的Hash值是多少：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'age'</span>)</div><div class="line"><span class="number">1545085610920597121</span></div></pre></td></tr></table></figure>
<p>现在这个hash值对8取余数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1545085610920597121</span> % <span class="number">8</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>余数为1，那么二维数组里面，下标为1的这一行就是需要的键值对。直接返回这一行第三个指针对应的内存中的值，就是<code>age</code>对应的值<code>26</code>。</p>
<p>当你要循环遍历字典的Key的时候，Python底层会遍历这个二维数组，如果当前行有数据，那么就返回Key指针对应的内存里面的值。如果当前行没有数据，那么就跳过。所以总是会遍历整个二位数组的每一行。</p>
<p>每一行有三列，每一列占用8byte的内存空间，所以每一行会占用24byte的内存空间。</p>
<p>由于Hash值取余数以后，余数可大可小，所以字典的Key并不是按照插入的顺序存放的。</p>
<blockquote>
<p>注意，这里我省略了与本文没有太大关系的两个点：</p>
<ol>
<li>开放寻址，当两个不同的Key，经过Hash以后，再对8取余数，可能余数会相同。此时Python为了不覆盖之前已有的值，就会使用<code>开放寻址</code>技术重新寻找一个新的位置存放这个新的键值对。</li>
<li>当字典的键值对数量超过当前数组长度的2/3时，数组会进行扩容，8行变成16行，16行变成32行。长度变了以后，原来的余数位置也会发生变化，此时就需要移动原来位置的数据，导致插入效率变低。</li>
</ol>
</blockquote>
<p>在Python 3.6以后，字典的底层数据结构发生了变化，现在当你初始化一个空的字典以后，它在底层是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my_dict = &#123;&#125;</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">indices = [None, None, None, None, None, None, None, None]</div><div class="line"></div><div class="line">entries = []</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>当你初始化一个字典以后，Python单独生成了一个长度为8的一维数组。然后又生成了一个空的二维数组。</p>
<p>现在，我们往字典里面添加一个键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my_dict[<span class="string">'name'</span>] = <span class="string">'kingname'</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">indices = [None, 0, None, None, None, None, None, None]</div><div class="line"></div><div class="line">entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针]]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>为什么内存会变成这个样子呢？我们来一步一步地看：</p>
<p>在当前运行时，<code>name</code>这个字符串的hash值为<code>-5954193068542476671</code>，这个值对8取余数是1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'name'</span>)</div><div class="line"><span class="number">-5954193068542476671</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'name'</span>) % <span class="number">8</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>所以，我们把<code>indices</code>这个一维数组里面，下标为1的位置修改为0。</p>
<p>这里的0是什么意思呢？0是二位数组<code>entries</code>的索引。现在<code>entries</code>里面只有一行，就是我们刚刚添加的这个键值对的三个数据：<code>name</code>的hash值、指向<code>name</code>的指针和指向<code>kinganme</code>的指针。所以<code>indices</code>里面填写的数字0，就是刚刚我们插入的这个键值对的数据在二位数组里面的行索引。</p>
<p>好，现在我们再来插入两条数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">my_dict[<span class="string">'address'</span>] = <span class="string">'xxx'</span></div><div class="line">my_dict[<span class="string">'salary'</span>] = <span class="number">999999</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">此时的内存示意图</div><div class="line">indices = [1, 0, None, None, None, None, 2, None]</div><div class="line"></div><div class="line">entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针],</div><div class="line">          [9043074951938101872, 指向address的指针，指向xxx的指针],</div><div class="line">          [7324055671294268046, 指向salary的指针, 指向999999的指针]</div><div class="line">         ]</div><div class="line">'''</div></pre></td></tr></table></figure>
<p>现在如果我要读取数据怎么办呢？假如我要读取<code>salary</code>的值，那么首先计算<code>salary</code>的hash值，以及这个值对8的余数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'salary'</span>)</div><div class="line"><span class="number">7324055671294268046</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'salary'</span>) % <span class="number">8</span></div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure>
<p>那么我就去读<code>indices</code>下标为6的这个值。这个值为2.</p>
<p>然后再去读entries里面，下标为2的这一行的数据，也就是salary对应的数据了。</p>
<p>新的这种方式，当我要插入新的数据的时候，始终只是往<code>entries</code>的后面添加数据，这样就能保证插入的顺序。当我们要遍历字典的Keys和Values的时候，直接遍历<code>entries</code>即可，里面每一行都是有用的数据，不存在跳过的情况，减少了遍历的个数。</p>
<p>老的方式，当二维数组有8行的时候，即使有效数据只有3行，但它占用的内存空间还是 8 <em> 24 = 192 byte。但使用新的方式，如果只有三行有效数据，那么<code>entries</code>也就只有3行，占用的空间为3 </em> 24 =72 byte，而<code>indices</code>由于只是一个一维的数组，只占用8 byte，所以一共占用 80 byte。内存占用只有原来的41%。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python 3.5（含）以前，字典是不能保证顺序的，键值对A先插入字典，键值对B后插入字典，但是当你打印字典的Keys列表时，你会发现B可能在A的前面。&lt;/p&gt;
&lt;p&gt;但是从Python 3.6开始，字典是变成有顺序的了。你先插入键值对A，后插入键值对B，那么当你打印K
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用uwsgi部署Flask，不使用Unix套接字连接Nginx</title>
    <link href="https://www.kingname.info/2019/07/08/deploy-flask-uwsgi-without-nginx/"/>
    <id>https://www.kingname.info/2019/07/08/deploy-flask-uwsgi-without-nginx/</id>
    <published>2019-07-08T13:27:50.000Z</published>
    <updated>2019-07-08T13:38:52.071Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在Google或者百度或者某些技术社区上面搜索<code>uwsgi + Flask</code>，你会发现大量的文章，是教你如何使用<code>uwsgi + flask + Nginx</code>搭建网站。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-08-20-31-12.png" alt=""></p>
<h2 id="怪现状"><a href="#怪现状" class="headerlink" title="怪现状"></a>怪现状</h2><p>而且这些文章，全部都像是约定俗成一样，一定会首先用命令行启动uwsgi，测试uwsgi与Flask运行是否正常，然后写uwsgi的配置文件。然后使用<code>Unix 套接字</code>沟通uwsgi与Nginx。所以uwsgi的配置文件里面一定会写成类似于下面这样：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">socket</span> = /xxx/yyy/zzz.sock</div></pre></td></tr></table></figure>
<p>Nginx的配置一定有类似于下面这一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">        include uwsgi_params;</div><div class="line">        uwsgi_pass unix:///xxx/yyy/zzz.sock;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>他们为什么要这样写？因为他们看的别的博客上就是这样写的！他们知其然，但是不知其所以然。</p>
<a id="more"></a>
<h3 id="有什么问题？"><a href="#有什么问题？" class="headerlink" title="有什么问题？"></a>有什么问题？</h3><p>这种写法本身没有问题，甚至Flask的官方文档里面也是这样写的，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-08-20-43-07.png" alt=""></p>
<p>但是他们这样写，有一个基本前提——就是Flask程序、uwsgi、Nginx三个东西运行在同一个服务器上。如果用Docker，那么这三个东西甚至需要运行到一个容器里面。</p>
<p>如果是一个小网站，服务器资源足够，那么这样写没有问题，Unix套接字安全性高，速度也快。</p>
<p>那么如果你同一个服务器上有三个Docker容器，每一个容器都有一个不同的网站，是不是每个容器里面都需要安装一个Nginx？</p>
<p>对于大一些的网站，Nginx需要做负载均衡，如果把Nginx和网站放在同一台服务器上，无论是Nginx拖垮了服务器，还是网站拖垮了服务器，都会导致很严重的问题。</p>
<p>能不能实现，一个服务器上直接安装Nginx，然后服务器上的三个网站分别在三个Docker容器里面，每个容器里面只有Flask和uwsgi，没有Nginx？</p>
<p>如果你的网站大一些，你在A服务器安装Nginx，在B、C、D、E、F服务器上不安装Nginx，只安装uwsgi + Flask，又怎么做？</p>
<p>所以进入我们今天的主题，<code>安装uwsgi + Flask(或者Django)，但是不安装Nginx（Deploy Flask with uwsgi but without Nginx）</code></p>
<h2 id="不使用Unix套接字的uwsgi"><a href="#不使用Unix套接字的uwsgi" class="headerlink" title="不使用Unix套接字的uwsgi"></a>不使用Unix套接字的uwsgi</h2><p>Unix套接字，本质上是一个文件（Unix/Linux哲学：一切皆文件），Nginx和uwsgi通过这个文件来进行通信。所以需要Nginx与uwsgi放在同一个机器上。</p>
<p>但实际上，uwsgi本身就是一个服务器，A服务器上的Nginx与B服务器上的uwsgi之间是可以通过http进行通信的。</p>
<p>要让uwsgi使用http进行通信，我们可以修改uwsgi的配置文件xxx.ini：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="section">[uwsgi]</span></div><div class="line"><span class="attr">module</span> = wsgi:app</div><div class="line"><span class="attr">master</span> = <span class="literal">true</span></div><div class="line"><span class="attr">process</span> = <span class="number">5</span></div><div class="line"><span class="attr">threads</span> = <span class="number">100</span></div><div class="line"><span class="attr">gevent</span> = <span class="number">100</span></div><div class="line"><span class="attr">async</span> = <span class="number">100</span></div><div class="line"><span class="attr">http-socket</span> = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5001</span></div><div class="line"><span class="attr">virtualenv</span> = /Users/kingname/.local/share/virtualenvs/ActiveScoreApi-Ax_h-Y5w</div></pre></td></tr></table></figure>
<p>其他参数的意义不是本文的重点，我们要关心的是<code>http-socket = 0.0.0.0:5001</code>。它的作用把网站部署在本机的5001端口，并允许外网通过http访问。</p>
<p>写了这个配置文件以后，通过以下命令来启动uwsgi：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --ini xxx.ini</div></pre></td></tr></table></figure>
<p>然后你使用<code>IP:5001</code>就可以访问你的网站了。此时，如果你有Nginx，那么只需要在Nginx上设置反向代理，把80端口的请求代理到5001端口即可。</p>
<p>同理，把uwsgi和网站放在Docker镜像里面，容器开放5001端口。宿主机或者其他机器上的Nginx直接通过IP:端口 就可以访问容器里面的uwsgi，不再需要设置Unix套接字了。</p>
<p>另外，如果你阅读过uwsgi的官方文档，你还会发现，除了<code>http-socket = 0.0.0.0:5001</code>外，你也可以把它改成<code>http = 0.0.0.0:5001</code>。那么这两种写法是否一样呢？</p>
<p>在官方文档里面特别区分了它们的使用场景：</p>
<blockquote>
<p>The http and http-socket options are entirely different beasts. The first one spawns an additional process forwarding requests to a series of workers (think about it as a form of shield, at the same level of apache or nginx), while the second one sets workers to natively speak the http protocol. TL/DR: if you plan to expose uWSGI directly to the public, use –http, if you want to proxy it behind a webserver speaking http with backends, use –http-socket.</p>
</blockquote>
<p>简言之，如果你直接把uwsgi作为服务器，uwsgi启动以后，直接就把IP:端口拿给别人访问，那么你就可以使用<code>http</code>；如果你的uwsgi前面还挡了一个Nginx，那么你就使用<code>http-socket</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你在Google或者百度或者某些技术社区上面搜索&lt;code&gt;uwsgi + Flask&lt;/code&gt;，你会发现大量的文章，是教你如何使用&lt;code&gt;uwsgi + flask + Nginx&lt;/code&gt;搭建网站。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-08-20-31-12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;怪现状&quot;&gt;&lt;a href=&quot;#怪现状&quot; class=&quot;headerlink&quot; title=&quot;怪现状&quot;&gt;&lt;/a&gt;怪现状&lt;/h2&gt;&lt;p&gt;而且这些文章，全部都像是约定俗成一样，一定会首先用命令行启动uwsgi，测试uwsgi与Flask运行是否正常，然后写uwsgi的配置文件。然后使用&lt;code&gt;Unix 套接字&lt;/code&gt;沟通uwsgi与Nginx。所以uwsgi的配置文件里面一定会写成类似于下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;socket&lt;/span&gt; = /xxx/yyy/zzz.sock&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Nginx的配置一定有类似于下面这一段：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;location / &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        include uwsgi_params;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        uwsgi_pass unix:///xxx/yyy/zzz.sock;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;他们为什么要这样写？因为他们看的别的博客上就是这样写的！他们知其然，但是不知其所以然。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Flask" scheme="https://www.kingname.info/tags/Flask/"/>
    
      <category term="uwsgi" scheme="https://www.kingname.info/tags/uwsgi/"/>
    
      <category term="Nginx" scheme="https://www.kingname.info/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>跟着Kenneth Reitz大神学习读取类属性的三种方法</title>
    <link href="https://www.kingname.info/2019/07/07/three-in-one/"/>
    <id>https://www.kingname.info/2019/07/07/three-in-one/</id>
    <published>2019-07-07T14:48:41.000Z</published>
    <updated>2019-07-07T14:51:00.151Z</updated>
    
    <content type="html"><![CDATA[<p>在看Kenneth Reitz大神的<a href="https://github.com/kennethreitz/records" target="_blank" rel="external">Records项目</a>时，注意到在Readme中，读取数据有三种写法：</p>
<blockquote>
<p>Values can be accessed many ways: row.user_email, row[‘user_email’], or row[3]</p>
</blockquote>
<p>假设一个数据表如下所示：</p>
<table>
<thead>
<tr>
<th>username</th>
<th>active</th>
<th>name</th>
<th>user_email</th>
<th>timezone</th>
</tr>
</thead>
<tbody>
<tr>
<td>model-t</td>
<td>True</td>
<td>Henry Ford</td>
<td>model-t@gmail.com</td>
<td>2016-02-06 22:28:23.894202</td>
</tr>
</tbody>
</table>
<p>那么，当你想读取user_email这一列的时候，除了可以使用<code>row.user_email</code>和<code>row[&#39;user_email&#39;]</code>以外，由于<code>user_email</code>在第3列（username是第0列），所以还可以使用<code>row[3]</code>来读取。</p>
<p>今天我们就来研究一下，他是如何实现这个功能的。</p>
<p>假设我们现在有一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'i am walk'</span>)</div></pre></td></tr></table></figure>
<p>基于这个类初始化一个对象kingname:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kingname = People(<span class="string">'kingname'</span>, <span class="number">26</span>)</div><div class="line">print(kingname.age)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-02-56.png" alt=""></p>
<p>可以看到，我们已经实现了类似于records项目中的<code>row.user_email</code>的写法。</p>
<p>但是当我们想像字典一样取读取的时候，就会报错，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-04-11.png" alt=""></p>
<p>此时，为了让一个对象可以像字典一样被读取，我们需要实现它的<code>__getitem__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self.info = &#123;<span class="string">'name'</span>: name,</div><div class="line">                     <span class="string">'age'</span>: age&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'i am walk'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.info.get(key, <span class="string">'不存在'</span>)</div></pre></td></tr></table></figure>
<p>此时就可以像字典一样去读取了，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-10-00.png" alt=""></p>
<p>但新的问题又来了，不能直接读取使用<code>kinganme.age</code>读取数据了，这样写会导致报错，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-10-57.png" alt=""></p>
<p>为了解决这个问题，我们再来实现这个类的<code>__getattr__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self.info = &#123;<span class="string">'name'</span>: name,</div><div class="line">                     <span class="string">'age'</span>: age&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'i am walk'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.info.get(key, <span class="string">'不存在'</span>)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.info.get(key, <span class="string">'不存在'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-13-11.png" alt=""></p>
<p>那么如何实现records里面的<code>row[3]</code>这种写法呢？这就需要先解释一下，records这个库是用来做什么的，以及它的数据是如何存放的。</p>
<p>K大写的records这个库，是用于来更加方便地读写SQL数据库，避免繁琐地写各种SQL语句。</p>
<p>这个库的源代码只有一个文件：<a href="https://github.com/kennethreitz/records/blob/master/records.py" target="_blank" rel="external">源代码</a></p>
<p>我们今天要研究的这个写法，在<code>Record</code>这个类里面。这个类用来保存MySQL中的一行数据。<code>Record</code>这个类包含两个属性，分别为<code>_keys</code>和<code>_values</code>，其中<code>_keys</code>用于记录所有的字段名，<code>_values</code>用于记录一行的所有值。字段名和值是按顺序一一对应的。</p>
<p>例如<code>_keys</code>里面下标为3表示字段名<code>user_email</code>，那么<code>_values</code>里面下标为3的数据就是<code>user_email</code>的值。</p>
<p>正式由于这样一个一一对应的关系，所以<code>row[3]</code>才能实现<code>row[&#39;user_email&#39;]</code>、<code>row.user_email</code>相同的效果。</p>
<p>回到我们的People类，为了实现相同的目的，我们再次修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self._keys = [<span class="string">'name'</span>, <span class="string">'age'</span>]</div><div class="line">        self._values = [name, age]</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'i am walk'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(key, int):</div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= key &lt; len(self._keys):</div><div class="line">                <span class="keyword">return</span> self._values[key]</div><div class="line">            <span class="keyword">return</span> <span class="string">'索引超出边界'</span></div><div class="line"></div><div class="line">        index = self._keys.index(key)</div><div class="line">        <span class="keyword">if</span> index == <span class="number">-1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">'Key不存在'</span></div><div class="line">        <span class="keyword">return</span> self._values[index]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__getitem__(key)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-07-07-22-25-28.png" alt=""></p>
<p>需要说明的是，无论是使用<code>kingname[&#39;key&#39;]</code>还是<code>kingname[1]</code>，他们都会进入到<code>__getitem__</code>方法中去。</p>
<p>我这里给出的例子相较于<code>records</code>项目的代码做了简化，不过关键的部分都已经囊括了进来。</p>
<p>最后，推荐有兴趣的同学通读records这个项目的源代码，你将会从K大的代码中学到非常多的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看Kenneth Reitz大神的&lt;a href=&quot;https://github.com/kennethreitz/records&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Records项目&lt;/a&gt;时，注意到在Readme中，读取数据有三种写法：&lt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>请不要再用re.compile了！</title>
    <link href="https://www.kingname.info/2019/06/25/dont-use-re-compile/"/>
    <id>https://www.kingname.info/2019/06/25/dont-use-re-compile/</id>
    <published>2019-06-25T05:02:01.000Z</published>
    <updated>2019-06-25T05:03:27.467Z</updated>
    
    <content type="html"><![CDATA[<p>如果大家在网上搜索<code>Python 正则表达式</code>，你将会看到大量的垃圾文章会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">'正则表达式'</span>)</div><div class="line">text = <span class="string">'一段字符串'</span></div><div class="line">result = pattern.findall(text)</div></pre></td></tr></table></figure>
<p>这些文章的作者，可能是被其他语言的坏习惯影响了，也可能是被其他垃圾文章误导了，不假思索拿来就用。</p>
<p><strong>在Python里面，真的不需要使用re.compile!</strong></p>
<p>为了证明这一点，我们来看Python的源代码。</p>
<p>在PyCharm里面输入:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">re.search</div></pre></td></tr></table></figure>
<p>然后Windows用户按住键盘上的Ctrl键，鼠标左键点击<code>search</code>，Mac用户按住键盘上的Command键，鼠标左键点击<code>search</code>，PyCharm会自动跳转到Python的re模块。在这里，你会看到我们常用的正则表达式方法，无论是<code>findall</code>还是<code>search</code>还是<code>sub</code>还是<code>match</code>，全部都是这样写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_compile(pattern, flag).对应的方法(string)</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">findall</span><span class="params">(pattern, string, flags=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">"""Return a list of all non-overlapping matches in the string.</span></div><div class="line"></div><div class="line">    If one or more capturing groups are present in the pattern, return</div><div class="line">    a list of groups; this will be a list of tuples if the pattern</div><div class="line">    has more than one group.</div><div class="line"></div><div class="line">    Empty matches are included in the result."""</div><div class="line">    <span class="keyword">return</span> _compile(pattern, flags).findall(string)</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-06-25-12-41-18.png" alt=""></p>
<p>然后我们再来看<code>compile</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span><span class="params">(pattern, flags=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">"Compile a regular expression pattern, returning a Pattern object."</span></div><div class="line">    <span class="keyword">return</span> _compile(pattern, flags)</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-06-25-12-43-19.png" alt=""></p>
<p>看出问题来了吗？</p>
<p>我们常用的正则表达式方法，都已经自带了<code>compile</code>了！</p>
<p>根本没有必要多此一举先<code>re.compile</code>再调用正则表达式方法。</p>
<p>此时，可能会有人反驳：</p>
<p>如果我有一百万条字符串，使用某一个正则表达式去匹配，那么我可以这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">texts = [包含一百万个字符串的列表]</div><div class="line">pattern = re.compile(<span class="string">'正则表达式'</span>)</div><div class="line"><span class="keyword">for</span> text <span class="keyword">in</span> texts:</div><div class="line">    pattern.search(text)</div></pre></td></tr></table></figure>
<p>这个时候，<code>re.compile</code>只执行了1次，而如果你像下面这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">texts = [包含一百万个字符串的列表]</div><div class="line"><span class="keyword">for</span> text <span class="keyword">in</span> texts:</div><div class="line">    re.search(<span class="string">'正则表达式'</span>, text)</div></pre></td></tr></table></figure>
<p>相当于你在底层对同一个正则表达式执行了100万次<code>re.compile</code>。</p>
<p>Talk is cheap, show me the code.</p>
<p>我们来看源代码，正则表达式<code>re.compile</code>调用的是<code>_compile</code>，我们就去看<code>_compile</code>的源代码，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-06-25-12-49-36.png" alt=""></p>
<p>红框中的代码，说明了<code>_compile</code>自带缓存。它会自动储存最多512条由type(pattern), pattern, flags)组成的Key，只要是同一个正则表达式，同一个flag，那么调用两次_compile时，第二次会直接读取缓存。</p>
<p>综上所述，请你不要再手动调用<code>re.compile</code>了，这是从其他语言（对的，我说的就是Java）带过来的陋习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果大家在网上搜索&lt;code&gt;Python 正则表达式&lt;/code&gt;，你将会看到大量的垃圾文章会这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python读取包里面的数据文件的三种方法</title>
    <link href="https://www.kingname.info/2019/05/26/read-data-file-in-package/"/>
    <id>https://www.kingname.info/2019/05/26/read-data-file-in-package/</id>
    <published>2019-05-26T14:44:08.000Z</published>
    <updated>2019-05-26T14:47:13.027Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，写Python代码的时候，如果一个包（package）里面的一个模块要导入另一个模块，那么我们可以使用相对导入：</p>
<p>假设当前代码结构如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-21-58-25.png" alt=""></p>
<p>其中<code>test_1</code>是一个包，在util.py里面想导入同一个包里面的<code>read.py</code>中的<code>read</code>函数，那么代码可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> .read <span class="keyword">import</span> read</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">util</span><span class="params">()</span>:</span></div><div class="line">    read()</div></pre></td></tr></table></figure>
<p>其中的<code>.read</code>表示当前包目录下的<code>read.py</code>文件。此时<code>read.py</code>文件中的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'阅读文件'</span>)</div></pre></td></tr></table></figure>
<p>通过包外面的main.py运行代码，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-01-32.png" alt=""></p>
<p>现在，我们增加一个数据文件，<code>data.txt</code>，它的内容如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-02-14.png" alt=""></p>
<p>并且想通过read.py去读取这个数据文件并打印出来。</p>
<p>修改read.py，试图使用相对路径来打开这个文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'./data.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">        text = f.read()</div><div class="line">        print(text)</div></pre></td></tr></table></figure>
<p>运行代码发现报错：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-04-19.png" alt=""></p>
<p>这个原因很简单，就是如果数据文件的地址写为：<code>./data.txt</code>，那么Python就会从当前工作区文件夹里面寻找<code>data.txt</code>。由于我们运行的是<code>main.py</code>，那么当前工作区就是<code>main.py</code>所在的文件夹，而不是<code>test_1</code>文件夹。所以就会出现找不到文件的情况。</p>
<p>为了解决这个问题，我们有三种解决方式。</p>
<ul>
<li>使用绝对路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/kingname/Project/DataFileExample/test_1/data.txt'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">        text = f.read()</div><div class="line">        print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-08-26.png" alt=""></p>
<ul>
<li>先获取<code>read.py</code>文件的绝对路径，再拼接出数据文件的绝对路径：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    basepath = os.path.abspath(__file__)</div><div class="line">    folder = os.path.dirname(basepath)</div><div class="line">    data_path = os.path.join(folder, <span class="string">'data.txt'</span>)</div><div class="line">    <span class="keyword">with</span> open(data_path, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">        text = f.read()</div><div class="line">        print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-11-20.png" alt=""></p>
<ul>
<li>使用pkgutil库</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pkgutil</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></div><div class="line">    data_bytes = pkgutil.get_data(__package__, <span class="string">'data.txt'</span>)</div><div class="line">    data_str = data_bytes.decode()</div><div class="line">    print(data_str)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-13-36.png" alt=""></p>
<p><code>pkgutil</code>是Python自带的用于包管理相关操作的库，<code>pkgutil</code>能根据包名找到包里面的数据文件，然后读取为bytes型的数据。如果数据文件内容是字符串，那么直接<code>decode()</code>以后就是正文内容了。</p>
<blockquote>
<p>为什么pkgutil读取的数据文件是bytes型的内容而不直接是字符串类型?<br>这是因为并不是所有数据文件都是字符串，如果某些数据文件是二进制文件或者图片，那么以字符串方式打开就会导致报错。所以为了通用，pkgutil会以bytes型方式读入数据，这相当于open函数的“rb”读取方式。</p>
</blockquote>
<p>使用<code>pkgutil</code>还有一个好处，就是只要知道包名就可以找到对应包下面的数据文件，数据文件并不一定要在当前包里面。</p>
<p>例如修改代码结构如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-18-12.png" alt=""></p>
<p>另一个包<code>test_2</code>里面有一个数据文件<code>data2.txt</code>。此时如果要在<code>teat_1</code>包的<code>read.py</code>中读取<code>data2.txt</code>中的内容，那么只需要修改<code>pkgutil.get_data</code>的第一个参数为<code>test_2</code>和数据文件的名字即可，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-05-26-22-20-35.png" alt=""></p>
<p>而前两种方法都不如<code>pkgutil</code>简单。</p>
<p>所以使用<code>pkgutil</code>可以大大简化读取包里面的数据文件的代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，写Python代码的时候，如果一个包（package）里面的一个模块要导入另一个模块，那么我们可以使用相对导入：&lt;/p&gt;
&lt;p&gt;假设当前代码结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-c
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>先找到爱的人，再写出优秀的代码</title>
    <link href="https://www.kingname.info/2019/05/20/iloveyun/"/>
    <id>https://www.kingname.info/2019/05/20/iloveyun/</id>
    <published>2019-05-20T14:15:35.000Z</published>
    <updated>2019-05-22T14:22:08.048Z</updated>
    
    <content type="html"><![CDATA[<p>过去的你只会在代码里消磨每个周末，现在的你有她一起探索生活里的小惊喜；过去的你是一个死宅，现在的你想陪她拿着相机看遍世界的景色。</p>
<a id="more"></a>
<h2 id="她会让你成长，但她不会把你变成另一个人。"><a href="#她会让你成长，但她不会把你变成另一个人。" class="headerlink" title="她会让你成长，但她不会把你变成另一个人。"></a>她会让你成长，但她不会把你变成另一个人。</h2><p>我曾经为某个著名的开源项目贡献过代码。这个项目的编码之规范、测试之完整、文档之清晰在我见过的开源项目中名列前茅。</p>
<p>它曾经是我代码编写过程中的参考标准。我的编码规范，代码风格，都是从这个项目中学到的。现在，我将会为它添砖加瓦。</p>
<p>我修改的部分只有十几行代码，但我前前后后修改了七八次。因为我怕我的代码增加了这个项目的熵。让这个项目变得不够完美。</p>
<p>软件开发中有一个著名的熵增加定理——随着代码复杂度的增加，系统的混乱程度也会成倍增加。</p>
<p>所以，我在提交代码时，会确保自己的编码风格和已有的风格保持一致；确保单元测试能够测到新增代码的全部情况；确保注释清楚表达了我的逻辑；确保更新了这一段代码对应的文档；确保这一段代码看起来和它周围的代码就像是来自于同一个开发者。</p>
<p>曾经有朋友说，Github上活跃的一些大佬，都有自己的编码风格，只要看到他们的代码，就能知道出自谁之手。为什么你在给开源项目提交代码的时候，总是会模仿已有代码的写法，而隐藏自己的风格？</p>
<p>因为这是受到我女朋友的影响吧。一个优秀的女朋友，会让你希望和她一起成长，但又不会让她改变本来的样子。</p>
<p>我们都是自己生活的主角，他人生活里的NPC。我们能在自己的生活里活出自己的风格，我们试图让所有东西都朝着我们期望的方向发展。</p>
<p>但有一天，当你看到了一个人，你会怀疑，她应该才是这部戏的主角吧。这个时候，你突然发现你之前的幻想全都实现了。你不敢去触碰，害怕眼前的人像是水里的倒影，轻轻触碰就碎成一片一片。</p>
<p>你会发现自己变了，你做了之前下了无数次决心又无数次拖延的事情，过去的你跑不了一千米，现在你能在跑步机上坚持5公里；过去的你只会在代码里消磨每个周末，现在的你有她一起探索生活里的小惊喜；过去的你是一个死宅，现在的你想陪她拿着相机看遍世界的景色。你似乎变得不一样了，但你知道你还是你自己。你迷失在她的话语里，你清醒于她的眼眸中。</p>
<h2 id="背对背，面对360度的世界"><a href="#背对背，面对360度的世界" class="headerlink" title="背对背，面对360度的世界"></a>背对背，面对360度的世界</h2><p>在一些祖传代码里面，每一个函数开头几行一定是检查传入参数的合法性。他们怀疑一切传入的参数，即使调用这些函数之前已经充分检查。</p>
<p>有人说这是防御性编程，对所有第三方的接口都不能完全信任，要做好接口故障的准备。但在同一个项目中的优秀开发们，应该充分相信自己的伙伴。</p>
<p>滥用异常捕获，会让代码臃肿不堪，一个函数50行代码，其中49行都在捕获异常。Shit of Mountain就是这样来的。</p>
<p>优秀的开发者，只在合适的地方捕获异常，他充分信任同伴的代码，他写的代码也会让同伴放心使用。</p>
<p>一个优秀的女朋友，可以让你把后背完全信任地交给她。你专注于自己最擅长的事情，给她的后背以安全，而她擅长的，你也会完全相信她会处理得很好。</p>
<h2 id="产品经理和开发的相处模式"><a href="#产品经理和开发的相处模式" class="headerlink" title="产品经理和开发的相处模式"></a>产品经理和开发的相处模式</h2><p>写代码的人分成很多种，码畜，码农，程序员和工程师。</p>
<p>码畜又叫调参侠、调包侠。自己写不出几行代码。只会调用别人写好的模块，改几个参数反复尝试。</p>
<p>码农是代码翻译员，把精确到每一步的逻辑翻译成对应的语言。</p>
<p>程序员把业务逻辑转写成代码逻辑。</p>
<p>工程师把现实世界映射到代码世界。</p>
<p>产品经理没有这么多等级，但差的产品经理分为两种，一种只管提需求，不考虑开发能不能实现。一种恨不得亲自帮开发写代码。</p>
<p>好的产品经理只有一种。她知道什么任务能做，什么任务不能做。她会挡在开发和需求方的面前，帮开发挡开不合理的需求。</p>
<p>优秀的女朋友会帮助你成为一个优秀的工程师，她会给你合理的目标，然后给你足够的自由，让你自己决定怎么做。她知道什么时候应该提什么需求，一切都恰到好处。你们的生活，就在她的指引下，你的建设下，逐渐迭代出新的版本。</p>
<h2 id="Hello-World；你好，另一半。"><a href="#Hello-World；你好，另一半。" class="headerlink" title="Hello World；你好，另一半。"></a>Hello World；你好，另一半。</h2><p>你让我对明天有所期许，希望你能和我一起生活在明天里。</p>
<p>大家520快乐~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去的你只会在代码里消磨每个周末，现在的你有她一起探索生活里的小惊喜；过去的你是一个死宅，现在的你想陪她拿着相机看遍世界的景色。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员" scheme="https://www.kingname.info/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="产品经理" scheme="https://www.kingname.info/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
      <category term="程序员" scheme="https://www.kingname.info/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>奇技淫巧：使用Python的or关键字实现多重选择</title>
    <link href="https://www.kingname.info/2019/04/11/use-or-smarter/"/>
    <id>https://www.kingname.info/2019/04/11/use-or-smarter/</id>
    <published>2019-04-11T15:24:59.000Z</published>
    <updated>2019-04-11T15:25:48.695Z</updated>
    
    <content type="html"><![CDATA[<p>在Python开发过程中，我们难免会遇到多重条件判断的情况的情况，此时除了用很多的<code>if...elif...else</code>以外，还可以巧用<code>or</code>关键字实现。</p>
<p>例如，我们要获取天气信息，现在有三个api接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">api_1()</div><div class="line">api_2()</div><div class="line">api_3()</div></pre></td></tr></table></figure>
<p>其中<code>api_1()</code>的数据又详细又好，但是接口不稳定，可能随时会掉线。</p>
<p><code>api_2()</code>返回的结果比<code>api_1()</code>稍微差一点，但是稳定性还不错。</p>
<p><code>api_3()</code>接口返回的是兜底数据，就是在前两个接口都故障的情况下才会使用。</p>
<p>如果前两个接口正常工作时返回字典，故障时他们都会返回<code>None</code>。</p>
<p>现在我们要获取天气信息，你可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">weather = api_1()</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> weather:</div><div class="line">    weather = api_2()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> weather:</div><div class="line">        weather = api_3()</div></pre></td></tr></table></figure>
<p>代码这样写，功能自然是没有问题，但是非常难看。</p>
<p>实际上，代码可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weather = api_1() <span class="keyword">or</span> api_2() <span class="keyword">or</span> api_3()</div></pre></td></tr></table></figure>
<p>只需要1行代码就能实现自动选择。如果<code>api_1()</code>返回的是一个非空字典，那么由于<code>短路效应</code>，后面的两个函数都不会运行。当<code>api_1</code>返回None时，<code>api_2()</code>才会运行。并且如果<code>api_2()</code>返回非空字典，那么<code>api_3()</code>依然不会运行。</p>
<p>我们现在在Jupyter里面测试一下，首先看看如果<code>api_1()</code>直接返回非空字典的情况，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-04-11-23-06-44.png" alt=""></p>
<p>可以看到，在<code>api_2()</code>和<code>api_3()</code>里面的两行<code>print</code>语句都没有执行。</p>
<p>接下来我们看看<code>api_1()</code>故障时候的情况。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-04-11-23-07-44.png" alt=""></p>
<p>此时先运行<code>api_1()</code>返回None，再运行<code>api_2()</code>返回非空字典。符合预期。</p>
<p>当前两个函数都返回None的时候，第三个函数才会运行，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-04-11-23-09-07.png" alt=""></p>
<p>除了做多重条件判断外，还可以用来自己和自己取或操作，实现重试。</p>
<p>例如<code>api_1()</code>可能成功也可能失败，所以需要尝试运行3次，那么代码可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weather = api_1() <span class="keyword">or</span> api_1() <span class="keyword">or</span> api_1()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python开发过程中，我们难免会遇到多重条件判断的情况的情况，此时除了用很多的&lt;code&gt;if...elif...else&lt;/code&gt;以外，还可以巧用&lt;code&gt;or&lt;/code&gt;关键字实现。&lt;/p&gt;
&lt;p&gt;例如，我们要获取天气信息，现在有三个api接口。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>懂博弈论的产品小姐姐的民主妙计</title>
    <link href="https://www.kingname.info/2019/04/05/vote-is-not-always-true/"/>
    <id>https://www.kingname.info/2019/04/05/vote-is-not-always-true/</id>
    <published>2019-04-05T01:24:30.000Z</published>
    <updated>2019-04-05T12:36:11.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我们来投票吧"><a href="#我们来投票吧" class="headerlink" title="我们来投票吧"></a>我们来投票吧</h2><p>产品小姐姐召集了项目组的五位开发同学，宣布一项重要的决定。</p>
<p>“作为一个产品，一定要与开发一起对项目有深入的沟通和交流，才能让项目做的更好。所以，今天我们来做一个不记名投票，确定哪几位同学可以和我一起讨论产品的设计方向。”</p>
<p>“现在给到大家的是大老板L叔为大家的产品能力评分，最低1分，最高5分，每人都不一样。大家都只知道自己的得分，互相不知道别人的得分”</p>
<p>“我们的投票规则，是大家一起讨论，不低于几分的人可以和产品一起讨论项目的设计方案。然后独立不记名投赞成票或者反对票”</p>
<p>“首先，1分能力太差，所以不低于2分的人能和产品一起讨论，大家投票。”</p>
<p>“不出所料，1票反对，4票赞成。”</p>
<p>“那分数提高一点，不低于3分的人可以和产品一起讨论项目。大家投票。”</p>
<p>“咦，也是1票反对，4票赞成。”</p>
<p>“那我们看看大于等于4分，才能和产品讨论。”</p>
<p>“也是1票反对4票赞成。”</p>
<p>“那5分呢。”</p>
<p>“还是一票反对，四票赞成。”</p>
<p>“6分呢。”</p>
<p>“还是一票反对，4票赞成。”</p>
<p>“那么好的，经过民主投票，少数服从多数，大多数人都赞成产品能力为6分的人才能跟我一起讨论产品，由于没有人超过6分，所以这个项目我说了算。散会。”</p>
<a id="more"></a>
<h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>可能有人还没有反应过来发生了什么事情。那么我们从上帝视角来看看，当进行少数服从多数的独立不记名投票时，五个程序员都在想什么。</p>
<p>由于5个程序员的产品能力分别为1-5分，在第一次以2分为基准来投票时，出现1票反对4票赞成，显然投反对票的是产品能力为1分的程序员。因为自己不能加入产品决策，所以肯定不会同意这个方案。而得分为2-5分的程序员都能参与产品决策，所以他们没有理由反对这个方案。因此出现了1票赞成4票反对。</p>
<p>接下来，产品小姐姐把基准分数提高到了3分，为什么也会出现1票反对4票赞成？</p>
<p>首先对于得分为3、4、5的三个程序员，他们不受此决策的影响，显然会选择赞成。</p>
<p>对于得分为2分的程序员，由于刚刚在2分为基准时自己是可以参与决策的，现在提高到了3分，自己失去了决策的资格。他非常生气，于是投了反对票，合情合理。</p>
<p>那么原来得分为1分的程序员为什么会赞成呢？因为无论他反对还是赞成，他都没有机会参与产品决策。假设他反对了，碰巧另外还有2个人反对。那么3分基准无效，以2分为基准，此时1分程序员仍然没有机会参与产品决策。但是如果他赞成，由于得分为2的人也没法参与决策，那么其他人看到有两个人都不能参与决策的时候，并不知道谁的产品能力最差，这样还可以为自己挽回一些颜面。所以他会赞成这个方案。</p>
<p>同理，以4分为基准的时候，得分为4、5的程序员没有理由反对。得分为3分的程序员由于失去了机会，必定会反对。得分为1、2的程序员无论同意还是反对都没有机会参与决策，但如果赞成这个提案，还可以拉个人垫背，让人更加猜不出自己的产品水平，所以会赞成这个提案。</p>
<p>以5分为基准的时候同理。</p>
<p>最后以六分为基准的时候，显然产品能力最高的程序员会反对，但剩下四个程序员无论赞成还是反对，都对自己没有影响，所以会赞成。最后依然会以1票反对4票同意通过。</p>
<p>最终的结果就是所有人都失去了与产品小姐姐一起讨论项目需求的资格。</p>
<h2 id="现实中的例子"><a href="#现实中的例子" class="headerlink" title="现实中的例子"></a>现实中的例子</h2><p>肯定有人觉得上面这个故事是编出来的，现实中怎么可能会有这种智障程序员。当3分、4分、5分都出现一票反对四票赞成的时候，明眼人一定就能看出来产品小姐姐在耍心机，不可能一遍又一遍地参与投票。要是你自己在现场，肯定当场就摔桌子走人了。</p>
<p>1989年，美国国会就是使用这种方案投票决定要不要给自己加薪50%。结果就遇到了这种情况。</p>
<p>每一个议员从个人的角度来看，显然都愿意加薪。但是如果被民众知道了自己想加薪这个事情，就会获得不好的名声。毕竟你当官竟然是为了钱，而不是出于为人民服务的目的，民众是很难接受的。</p>
<p>所以对议员来说，最佳的方案应该是，自己投反对票，但是最后提案却通过了。这种情况下，一方面自己加薪了，另一方面，又向民众展示出一个清官的样子——我是不同意加薪的，我只想全心全意为人民服务，奈何其他贪官都想加薪，我的反对无效，被迫加薪。</p>
<p>可是，大多数议员都是这样想的，这下到底会有多少人投反对票？万一反对的人超过一半怎么办？<br>此时议员又想，如果我投票赞成加薪，可最后方案没有通过，那岂不是我钱没有拿到，还落得个一心为钱的坏名声？保险起见，反对加薪比较好。</p>
<p>所以虽然每个人都想加薪，但是最终加薪方案以压倒性优势被反对。</p>
<p>假如一个行动是一点一点推进的，那么随着推进过程逐步进行，每一步在绝大多数人眼里都很有吸引力，但最后的结果，可能让每个人都落得不如原来的下场。</p>
<p>原因在于少数服从多数的投票，忽略了偏好的强度。在产品小姐姐的例子里面，投反对票的人是强烈反对，但投赞成票的人可能是可赞成可反对，稍稍偏赞成一点点。在加薪法案里面，投赞成票的人是强烈赞成，但投反对票的人是可赞成可反对，偏向反对一点点。</p>
<h2 id="另一个启示"><a href="#另一个启示" class="headerlink" title="另一个启示"></a>另一个启示</h2><p>在产品小姐姐的产品交流投票中，之所以4分为基准点时候，1、2分的程序员会投票赞成，因为他们无论赞成还是反对，对他们来说都没有什么大的区别。每个人投票的时候是独立投票的，假设他们反对4分，另外可能还有2个人以上反对4分，那么最终3分的人能够获得资格。但这资格也落不到他们1、2分的头上。所以不如赞成提高到4分，这样自己落选是因为标准太严格，而不是因为自己能力不行。</p>
<p>你应该还记得，当你还在上学的时候，你身边会有一些同学，成绩很差，但考试之前从不复习。因为对他来说，复习不复习都会挂科，但如果不复习挂科了，他还可以给自己找理由：我挂科是因为没有复习，不是因为我笨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;我们来投票吧&quot;&gt;&lt;a href=&quot;#我们来投票吧&quot; class=&quot;headerlink&quot; title=&quot;我们来投票吧&quot;&gt;&lt;/a&gt;我们来投票吧&lt;/h2&gt;&lt;p&gt;产品小姐姐召集了项目组的五位开发同学，宣布一项重要的决定。&lt;/p&gt;
&lt;p&gt;“作为一个产品，一定要与开发一起对项目有深入的沟通和交流，才能让项目做的更好。所以，今天我们来做一个不记名投票，确定哪几位同学可以和我一起讨论产品的设计方向。”&lt;/p&gt;
&lt;p&gt;“现在给到大家的是大老板L叔为大家的产品能力评分，最低1分，最高5分，每人都不一样。大家都只知道自己的得分，互相不知道别人的得分”&lt;/p&gt;
&lt;p&gt;“我们的投票规则，是大家一起讨论，不低于几分的人可以和产品一起讨论项目的设计方案。然后独立不记名投赞成票或者反对票”&lt;/p&gt;
&lt;p&gt;“首先，1分能力太差，所以不低于2分的人能和产品一起讨论，大家投票。”&lt;/p&gt;
&lt;p&gt;“不出所料，1票反对，4票赞成。”&lt;/p&gt;
&lt;p&gt;“那分数提高一点，不低于3分的人可以和产品一起讨论项目。大家投票。”&lt;/p&gt;
&lt;p&gt;“咦，也是1票反对，4票赞成。”&lt;/p&gt;
&lt;p&gt;“那我们看看大于等于4分，才能和产品讨论。”&lt;/p&gt;
&lt;p&gt;“也是1票反对4票赞成。”&lt;/p&gt;
&lt;p&gt;“那5分呢。”&lt;/p&gt;
&lt;p&gt;“还是一票反对，四票赞成。”&lt;/p&gt;
&lt;p&gt;“6分呢。”&lt;/p&gt;
&lt;p&gt;“还是一票反对，4票赞成。”&lt;/p&gt;
&lt;p&gt;“那么好的，经过民主投票，少数服从多数，大多数人都赞成产品能力为6分的人才能跟我一起讨论产品，由于没有人超过6分，所以这个项目我说了算。散会。”&lt;/p&gt;
    
    </summary>
    
      <category term="博弈论" scheme="https://www.kingname.info/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="博弈论" scheme="https://www.kingname.info/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>为什么你需要少看垃圾博客以及如何在Python里精确地四舍五入</title>
    <link href="https://www.kingname.info/2019/03/31/real-truth-of-round/"/>
    <id>https://www.kingname.info/2019/03/31/real-truth-of-round/</id>
    <published>2019-03-31T04:30:42.000Z</published>
    <updated>2019-03-31T04:32:48.667Z</updated>
    
    <content type="html"><![CDATA[<p>今天又有一个Python初学者被中文技术博客中的垃圾文章给误导了。</p>
<p>这位初学者的问题是：</p>
<blockquote>
<p>在Python中，如何精确地进行浮点数的四舍五入，保留两位小数？</p>
</blockquote>
<a id="more"></a>
<p>如果你在Google或者百度上搜索，你会发现大量的来自CSDN或者简书上面的文章讲到这一点，但是他们的说法无外乎下面几种：</p>
<h2 id="连例子都不举的垃圾文章"><a href="#连例子都不举的垃圾文章" class="headerlink" title="连例子都不举的垃圾文章"></a>连例子都不举的垃圾文章</h2><p>如下图所示，懒得吐槽。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-30-23-51-43.png" alt=""></p>
<h2 id="使用round函数"><a href="#使用round函数" class="headerlink" title="使用round函数"></a>使用round函数</h2><p>他们举的例子为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.234</span>, <span class="number">2</span>)</div><div class="line"><span class="number">1.23</span></div></pre></td></tr></table></figure>
<p>这种文章，他只演示了<code>四舍</code>，但是却没有演示<code>五入</code>。所以如果你代码稍作修改，就会发现有问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">11.245</span>, <span class="number">2</span>)</div><div class="line"><span class="number">11.24</span></div></pre></td></tr></table></figure>
<h2 id="先放大再缩小"><a href="#先放大再缩小" class="headerlink" title="先放大再缩小"></a>先放大再缩小</h2><p>这种文章稍微好一点，知道多举几个例子：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-30-23-53-12.png" alt=""></p>
<p>然而这种文章也是漏洞百出，只要你多尝试几个数字就会发现问题，在Python 2和Python 3下面，效果是不一样的。先来看看Python 2下面的运行效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-11-03-02.png" alt=""></p>
<p>在Python 2里面，直接使用<code>round</code>，<code>1.125</code>精确到两位小数后为<code>1.13</code>，而<code>1.115</code>精确到两位小数后是<code>1.11</code>。</p>
<p>再来看看Python 3下面的效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-11-04-32.png" alt=""></p>
<p>在Python 3下面，<code>1.125</code>在精确到两位小数以后是<code>1.12</code>。</p>
<p>他举的例子，在Python 3中先放大再缩小，也并不总是正确。</p>
<h3 id="装逼货"><a href="#装逼货" class="headerlink" title="装逼货"></a>装逼货</h3><p>还有一种装逼货，文章和先放大再缩小差不多，但是他还知道<code>decimal</code>这个模块。</p>
<p>不过他的使用方法，大家看他吧</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-00-12-22.png" alt=""></p>
<p><code>具体原因不详</code> ？？？？</p>
<p><code>不推荐使用这个方法</code>？？？</p>
<p>这种人要先装个逼，表示自己知道有这样一个库，但是用起来发现有问题，而且不知道原因，所以不建议大家使用。</p>
<p>decimal是专门为高精度计算用的模块，他竟然说不建议大家使用？？？</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-09-36-51.png" alt=""></p>
<h2 id="round到底出了什么问题？"><a href="#round到底出了什么问题？" class="headerlink" title="round到底出了什么问题？"></a>round到底出了什么问题？</h2><p>骂完了，我们来说说，在Python 3里面，<code>round</code>这个内置的函数到底有什么问题。</p>
<p>网上有人说，因为在计算机里面，小数是不精确的，例如<code>1.115</code>在计算机中实际上是<code>1.1149999999999999911182</code>，所以当你对这个小数精确到小数点后两位的时候，实际上小数点后第三位是<code>4</code>，所以四舍五入，因此结果为<code>1.11</code>。</p>
<p>这种说法，对了一半。</p>
<p>因为并不是所有的小数在计算机中都是不精确的。例如<code>0.125</code>这个小数在计算机中就是精确的，它就是<code>0.125</code>，没有省略后面的值，没有近似，它确确实实就是<code>0.125</code>。</p>
<p>但是如果我们在Python中把<code>0.125</code>精确到小数点后两位，那么它的就会变成<code>0.12</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.125</span>, <span class="number">2</span>)</div><div class="line"><span class="number">0.12</span></div></pre></td></tr></table></figure>
<p>为什么在这里<code>四舍</code>了？</p>
<p>还有更奇怪的，另一个在计算机里面能够精确表示的小数<code>0.375</code>，我们来看看精确到小数点后两位是多少：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.375</span>, <span class="number">2</span>)</div><div class="line"><span class="number">0.38</span></div></pre></td></tr></table></figure>
<p>为什么这里又<code>五入</code>了？</p>
<p>因为在Python 3里面，<code>round</code>对小数的精确度采用了<code>四舍六入五成双</code>的方式。</p>
<p>如果你写过大学物理的实验报告，那么你应该会记得老师讲过，直接使用四舍五入，最后的结果可能会偏高。所以需要使用<code>奇进偶舍</code>的处理方法。</p>
<p>例如对于一个小数<code>a.bcd</code>，需要精确到小数点后两位，那么就要看小数点后第三位：</p>
<ol>
<li>如果<code>d</code>小于5，直接舍去</li>
<li>如果<code>d</code>大于5，直接进位</li>
<li>如果<code>d</code>等于5：<ol>
<li><code>d</code>后面没有数据，且c为<code>偶数</code>，那么不进位，保留c</li>
<li><code>d</code>后面没有数据，且c为<code>奇数</code>，那么进位，c变成(c + 1)</li>
<li>如果<code>d</code>后面还有非0数字，例如实际上小数为<code>a.bcdef</code>，此时一定要进位，c变成(c + 1)</li>
</ol>
</li>
</ol>
<p>关于奇进偶舍，有兴趣的同学可以在维基百科搜索这两个词条：<code>数值修约</code>和<code>奇进偶舍</code>。</p>
<p>所以，<code>round</code>给出的结果如果与你设想的不一样，那么你需要考虑两个原因：</p>
<ol>
<li>你的这个小数在计算机中能不能被精确储存？如果不能，那么它可能并没有达到四舍五入的标准，例如<code>1.115</code>，它的小数点后第三位实际上是<code>4</code>，当然会被舍去。</li>
<li>如果你的这个小数在计算机中能被精确表示，那么，<code>round</code>采用的进位机制是<code>奇进偶舍</code>，所以这取决于你要保留的那一位，它是奇数还是偶数，以及它的下一位后面还有没有数据。</li>
</ol>
<h2 id="如何正确进行四舍五入"><a href="#如何正确进行四舍五入" class="headerlink" title="如何正确进行四舍五入"></a>如何正确进行四舍五入</h2><p>如果要实现我们数学上的四舍五入，那么就需要使用decimal模块。</p>
<p>如何正确使用decimal模块呢？</p>
<p>看官方文档，不要看中文垃圾博客！！！</p>
<p>看官方文档，不要看中文垃圾博客！！！</p>
<p>看官方文档，不要看中文垃圾博客！！！</p>
<p>不要担心看不懂英文，Python已经推出了官方中文文档（有些函数的使用方法还没有翻译完成）。</p>
<p>我们来看一下：<a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal.quantize" target="_blank" rel="external">https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal.quantize</a></p>
<p>官方文档给出了具体的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;Decimal(<span class="string">'1.41421356'</span>).quantize(Decimal(<span class="string">'1.000'</span>))</div><div class="line">Decimal(<span class="string">'1.414'</span>)</div></pre></td></tr></table></figure>
<p>那么我们来测试一下，<code>0.125</code>和<code>0.375</code>分别保留两位小数是多少：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">'0.125'</span>).quantize(Decimal(<span class="string">'0.00'</span>))</div><div class="line">Decimal(<span class="string">'0.12'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">'0.375'</span>).quantize(Decimal(<span class="string">'0.00'</span>))</div><div class="line">Decimal(<span class="string">'0.38'</span>)</div></pre></td></tr></table></figure>
<p>怎么结果和<code>round</code>一样？我们来看看文档中<code>quantize</code>的函数原型和文档说明：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-10-27-41.png" alt=""></p>
<p>这里提到了可以通过指定<code>rounding</code>参数来确定进位方式。如果没有指定<code>rounding</code>参数，那么默认使用上下文提供的进位方式。</p>
<p>现在我们来查看一下默认上下文中的进位方式是什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> getcontext</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getcontext().rounding</div><div class="line"><span class="string">'ROUND_HALF_EVEN'</span></div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-10-29-31.png" alt=""></p>
<p><code>ROUND_HALF_EVEN</code>实际上就是<code>奇进偶舍</code>！如果要指定真正的四舍五入，那么我们需要在<code>quantize</code>中指定进位方式为<code>ROUND_HALF_UP</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, ROUND_HALF_UP</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">'0.375'</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'0.38'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">'0.125'</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'0.13'</span>)</div></pre></td></tr></table></figure>
<p>现在看起来一切都正常了。</p>
<p>那么会不会有人进一步追问一下，如果Decimal接收的参数不是字符串，而是浮点数会怎么样呢？</p>
<p>来实验一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.375</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'0.38'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.125</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'0.13'</span>)</div></pre></td></tr></table></figure>
<p>那是不是说明，在Decimal的第一个参数，可以直接传浮点数呢？</p>
<p>我们换一个数来测试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">11.245</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'11.24'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">'11.245'</span>).quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">Decimal(<span class="string">'11.25'</span>)</div></pre></td></tr></table></figure>
<p>为什么浮点数<code>11.245</code>和字符串<code>&#39;11.245&#39;</code>，传进去以后，结果不一样？</p>
<p>我们继续在文档在寻找答案。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-10-36-13.png" alt=""></p>
<p>官方文档已经很清楚地说明了，如果你传入的参数为浮点数，并且这个浮点值在计算机里面不能被精确存储，那么它会先被转换为一个不精确的二进制值，然后再把这个不精确的二进制值转换为<code>等效的十进制值</code>。</p>
<p>对于不能精确表示的小数，当你传入的时候，Python在拿到这个数前，这个数就已经被转成了一个不精确的数了。所以你虽然参数传入的是<code>11.245</code>，但是Python拿到的实际上是<code>11.244999999999...</code>。</p>
<p>但是如果你传入的是字符串<code>&#39;11.245&#39;</code>，那么Python拿到它的时候，就能知道这是<code>11.245</code>，不会提前被转换为一个不精确的值，所以，建议给<code>Decimal</code>的第一个参数传入字符串型的浮点数，而不是直接写浮点数。</p>
<p>总结，如果想实现精确的四舍五入，代码应该这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal, ROUND_HALF_UP</div><div class="line"></div><div class="line">origin_num = Decimal(<span class="string">'11.245'</span>)</div><div class="line">answer_num = origin_num.quantize(Decimal(<span class="string">'0.00'</span>), rounding=ROUND_HALF_UP)</div><div class="line">print(answer_num)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-31-10-44-23.png" alt=""></p>
<p>特别注意，一旦要做精确计算，那么就不应该再单独使用浮点数，而是应该总是使用<code>Decimal(&#39;浮点数&#39;)</code>。否则，当你赋值的时候，精度已经被丢失了，建议全程使用Decimal举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = Decimal(&apos;0.1&apos;)</div><div class="line">b = Decimal(&apos;0.2&apos;)</div><div class="line">c = a + b</div><div class="line">print(c)</div></pre></td></tr></table></figure>
<p>最后，如果有同学想知道为什么0.125和0.375能被精确的储存，而1.115、11.245不能被精确储存，请在这篇文章下面留言，如果想知道的同学多，我就写一篇文章来说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又有一个Python初学者被中文技术博客中的垃圾文章给误导了。&lt;/p&gt;
&lt;p&gt;这位初学者的问题是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Python中，如何精确地进行浮点数的四舍五入，保留两位小数？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一种字符串的两种显示方式</title>
    <link href="https://www.kingname.info/2019/03/19/repr/"/>
    <id>https://www.kingname.info/2019/03/19/repr/</id>
    <published>2019-03-19T13:18:19.000Z</published>
    <updated>2019-03-19T13:20:47.386Z</updated>
    
    <content type="html"><![CDATA[<p>如果你经常使用Python的命令行交互环境，你一定遇到过下面这个现象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &apos;test&apos;</div><div class="line">&gt;&gt;&gt; a</div><div class="line">&apos;test&apos;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">test</div></pre></td></tr></table></figure>
<p>首先定义一个变量<code>a</code>，它的值为字符串<code>test</code>。现在，当你在命令行交互环境直接输入变量名再回车的时候，你看到的是<code>&#39;test&#39;</code>，当你输入<code>print(a)</code>的时候，你看到的却是<code>test</code>。</p>
<a id="more"></a>
<p>直接输入变量名回车，字符串会被单引号包起来。而使用<code>print</code>函数打印变量，字符串又没有引号。</p>
<p>如果说引号只是一个小问题的话，再来看看反斜杠会怎么样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = &apos;D:\game\pal4&apos;</div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;D:\\game\\pal4&apos;</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">D:\game\pal4</div></pre></td></tr></table></figure>
<p>在这里，<code>b</code>变量的值为Windows下面的一个文件夹路径。在定义的时候，我使用的是单根反斜杠。</p>
<p>当我输入变量名，然后回车时，看到的结果是<code>&#39;D:\\game\\pal4&#39;</code>，不仅有最外层的引号，而且反斜杠全部变成了两根。</p>
<p>但是当我使用<code>print</code>函数打印出来的时候，一切又正常了。</p>
<p>觉得很诡异吗？</p>
<p>实际上，输入变量名，回车以后，你看到的才是这个字符串真正的样子，因为在Python里面是不存在单根反斜杠的。当你要表示反斜杠本身的时候，就应该是<code>\\</code>这种写法。</p>
<p>当然在定义的时候你可以只写单根反斜杠，在大多数情况下，Python会理解你的意图，所以它会自动把单根反斜杠转换为两个反斜杠。</p>
<p>而使用<code>print</code>关键字打印出来的，是经过Python优化，更便于人类阅读的样子。</p>
<p>当然，使用<code>print</code>函数也能看到字符串真正的样子，不过需要修改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = &apos;D:\game\pal4&apos;</div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;D:\\game\\pal4&apos;</div><div class="line">&gt;&gt;&gt; print(repr(b))</div><div class="line">&apos;D:\\game\\pal4&apos;</div></pre></td></tr></table></figure>
<p>当你使用<code>repr</code>函数先处理字符串，再打印时，它的效果就和直接输入变量名回车是一样的了。</p>
<p>在Python中，<code>repr(对象)</code>本质上是调用了对象的<code>__repr__</code>这个方法。而如果直接<code>print(对象)</code>，实际上是打印了对象<code>__str__</code>方法返回的内容。</p>
<p>我们来做一个实验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'hello world！'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'为什么我总是对你说你好，因为你是我的世界啊，傻瓜'</span></div><div class="line"></div><div class="line">you = Test()</div></pre></td></tr></table></figure>
<p>动手测试一下，输入<code>you</code>然后直接回车显示的是什么内容。输入<code>print(you)</code>显示的又是什么内容。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-18-21-10-57.png" alt=""></p>
<p>从上面的例子可以看出，直接输入变量名回车和直接用<code>print</code>函数打印调用的是对象的不同方法。所以他们当然可以不一样。</p>
<p>回到昨天的问题上来。在PyCharm的调试模式中，你看到的内容实际上是变量对象的<code>__repr__</code>方法返回的内容，这里的内容是字符串在Python里面的真正的样子，所以斜杠会变多。</p>
<p>上面说到，当你输入Windows路径的时候，大多数情况下，Python能够理解你的意图，把单根反斜杠转成双反斜杠。不过也有例外的情况，例如：</p>
<p>假设有一个文件夹的名字叫做<code>u6211</code>。它在<code>pal4</code>文件夹里面。</p>
<p>那么，路径应该是：<code>D:\game\pal4\u6211</code></p>
<p>如果在Python里面执行，会出现什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = &apos;D:\game\pal4\u6211&apos;</div><div class="line">&gt;&gt;&gt; c</div><div class="line">&apos;D:\\game\\pal4我&apos;</div><div class="line">&gt;&gt;&gt; print(c)</div><div class="line">D:\game\pal4我</div></pre></td></tr></table></figure>
<p>怎么和前面的pal4拼在一起了？因为<code>\u6211</code>是一个Unicode编码，表示中文<code>我</code>。</p>
<p>这种情况下，你有两种解决方式：</p>
<ol>
<li>手动使用双反斜杠：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = &apos;D:\game\pal4\\u6211&apos;</div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;D:\\game\\pal4\\u6211&apos;</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">D:\game\pal4\u6211</div></pre></td></tr></table></figure>
<ol>
<li>在定义变量的时候，字符串左侧引号的左边加上字母<code>r</code>：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = r&apos;D:\game\pal4\u6211&apos;</div><div class="line">&gt;&gt;&gt; b</div><div class="line">&apos;D:\\game\\pal4\\u6211&apos;</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">D:\game\pal4\u6211</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你经常使用Python的命令行交互环境，你一定遇到过下面这个现象：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = &amp;apos;test&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;apos;test&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; print(a)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先定义一个变量&lt;code&gt;a&lt;/code&gt;，它的值为字符串&lt;code&gt;test&lt;/code&gt;。现在，当你在命令行交互环境直接输入变量名再回车的时候，你看到的是&lt;code&gt;&amp;#39;test&amp;#39;&lt;/code&gt;，当你输入&lt;code&gt;print(a)&lt;/code&gt;的时候，你看到的却是&lt;code&gt;test&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>你一定在Python中遇到过的反斜杠数量问题</title>
    <link href="https://www.kingname.info/2019/03/19/back-slash/"/>
    <id>https://www.kingname.info/2019/03/19/back-slash/</id>
    <published>2019-03-19T13:18:10.000Z</published>
    <updated>2019-03-19T13:20:34.833Z</updated>
    
    <content type="html"><![CDATA[<p>大家在开发Python的过程中，一定会遇到很多反斜杠的问题，很多人被反斜杠的数量搞得头大。</p>
<a id="more"></a>
<p>首先我们写一段非常简单的Python代码，它的作用是把一个字段先转换为JSON格式的字符串，然后把这个字符串再转换为JSON格式的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'kingname'</span>, <span class="string">'address'</span>: <span class="string">'杭州'</span>, <span class="string">'salary'</span>: <span class="number">99999</span>&#125;</div><div class="line">info_json = json.dumps(info)</div><div class="line"></div><div class="line"><span class="comment"># 第一次转换以后，打印出来</span></div><div class="line">print(info_json)</div><div class="line"></div><div class="line">info_json_json = json.dumps(info_json)</div><div class="line"></div><div class="line"><span class="comment"># 第二次转换以后，再打印出来</span></div><div class="line">print(info_json_json)</div></pre></td></tr></table></figure>
<p>它的运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-17-22-44-51.png" alt=""></p>
<p>第一次，字典转成JSON格式的字符串，只有中文<code>杭州</code>变成了Unicode编码<code>\u676d\u5dde</code>，其余地方没有出现反斜杠。</p>
<p>在Python里面，反斜杠不能单独出现，这里<code>\u676d\u5dde</code>中的两根反斜杠，实际上应该是<code>\u</code>。表示这两个编码是Unicode编码。</p>
<p>接下来，把第一次生成的JSON字符串：<code>{&quot;name&quot;: &quot;kingname&quot;, &quot;address&quot;: &quot;\u676d\u5dde&quot;, &quot;salary&quot;: 99999}</code>再一次转成JSON格式的字符串，这一次变成了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"&#123;\"name\": \"kingname\", \"address\": \"\\u676d\\u5dde\", \"salary\": 99999&#125;"</span></div></pre></td></tr></table></figure>
<p>为什么突然出现了这么多反斜杠？这是因为，JSON格式的字符串本身是使用双引号来表示字符串的。如果原来的字符串里面本身就有双引号，那就会导致混淆。此时，Python需要把原来字符串的双引号变成普通的字符，失去双引号的作用。因此使用<code>\&quot;</code>让双引号变成普通的字符。</p>
<p>这就相当于在Python中，可以这样定义一个包含双引号的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &quot;跟我说：\&quot;你好\&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">跟我说：&quot;你好&quot;</div></pre></td></tr></table></figure>
<p>这里，<code>你好</code>两侧的双引号都加上了反斜杠，让它成为普通的字符，防止它们提前与最外层的双引号配对。</p>
<p>如果不加反斜杠，就会导致字符串里面的双引号提前与外层的双引号配对，引起语法错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = &quot;跟我说：&quot;你好&quot;&quot;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</div><div class="line">    b = &quot;跟我说：&quot;你好&quot;&quot;</div><div class="line">               ^</div><div class="line">SyntaxError: invalid syntax</div></pre></td></tr></table></figure>
<p>这里，<code>&quot;跟我说：&quot;</code>成为了一个字符串，末尾的<code>&quot;&quot;</code>成为了一个空字符串。那么中间的<code>你好</code>就变成了一个没有定义的变量。而Python里面，是不存在<code>字符串未定义的变量字符串</code>这种写法的，所以会报语法错误。</p>
<p>而JSON格式的字符串，本质上也是字符串，所以自然而然也需要遵循这样的规则。因此，字符串原来自带的双引号左侧就被加上了反斜杠。</p>
<p>那么，原来的<code>\u676d\u5dde</code>为什么变成了<code>\\u676d\\u5dde</code>？</p>
<p>这是因为，当第二次执行<code>json.dumps</code>的时候，传入的参数是一个JSON格式的字符串，本质就是字符串。而一个字符串里面如果自带反斜杠，那么JSON在对他再次转换的时候，需要标记这是一个普通的字符串形式的反斜杠，不是一个有特殊意义的反斜杠，所以使用<code>\\</code>表示一个普通的反斜杠。</p>
<p>好了，那么你可以猜一下，如果把<code>info_json_json</code>再<code>json.dumps</code>一下会怎么样？</p>
<p>会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;\&quot;&#123;\\\&quot;name\\\&quot;: \\\&quot;kingname\\\&quot;, \\\&quot;address\\\&quot;: \\\&quot;\\\\u676d\\\\u5dde\\\&quot;, \\\&quot;salary\\\&quot;: 99999&#125;\&quot;&quot;</div></pre></td></tr></table></figure>
<p>为什么出现了三个反斜杠连用和四个反斜杠连用的问题？</p>
<p>实际上非常简单，当你对<code>info_json_json</code>执行<code>json.dumps</code>的时候，Python是怎么转换的？</p>
<p>我们来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;&#123;\&quot;name\&quot;: \&quot;kingname\&quot;, \&quot;address\&quot;: \&quot;\\u676d\\u5dde\&quot;, \&quot;salary\&quot;: 99999&#125;&quot;</div></pre></td></tr></table></figure>
<p>对<code>字符串</code>执行<code>json.dumps</code>的时候，记住一个关键方法——从左到右，一个字符一个字符的转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 第一个字符是双引号，所以变成\&quot;</div><div class="line">2. 第二个字符是&#123;，不是特殊符号，保留</div><div class="line">3. 第三个字符是\，把它变成\\</div><div class="line">4. 第四个字符是&quot;，把它变成\&quot;</div><div class="line">5. ……</div></pre></td></tr></table></figure>
<p>全部执行完成了，由于这次转换是把一个字符串转换为JSON格式的字符串，所以最外侧加上双引号。</p>
<p>于是就得到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;\&quot;&#123;\\\&quot;name\\\&quot;: \\\&quot;kingname\\\&quot;, \\\&quot;address\\\&quot;: \\\&quot;\\\\u676d\\\\u5dde\\\&quot;, \\\&quot;salary\\\&quot;: 99999&#125;\&quot;&quot;</div></pre></td></tr></table></figure>
<p>我们在爬虫开发过程中，可能会遇到上面这种经过多次JSON转换后的字符串，此时，千万不要轻易使用字符串的<code>.replace</code>方法把多个反斜杠替换为空或者把两个反斜杠替换为一个反斜杠。那样做只会导致你的数据更难解析。</p>
<p>正确的做法应该是尝试对数据一层一层使用<code>json.loads</code>，把它一层一层还原，还原到最初的<code>{&#39;name&#39;: &#39;kingname&#39;, &#39;address&#39;: &#39;杭州&#39;, &#39;salary&#39;: 99999}</code>这种简单形式。</p>
<p>好了，今天的介绍就到这里，最后留一个思考题：</p>
<p>还是上面的代码，现在把PyCharm的调试模式打开，然后数一数<code>info_json</code>和<code>info_json_json</code>里面反斜杠的个数，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-17-23-38-30.png" alt=""></p>
<p>为什么在<code>info_json</code>里面，出现了<code>\\u676d\\u5dde</code>，为什么在<code>info_json_json</code>里面双引号前是两根反斜杠，而<code>\&quot;\\u676d\\u5dde\&quot;</code>竟然变成了<code>\\&quot;\\\\u676d\\\\u5dde</code>。</p>
<p>请关注公众号，下一篇文章为你解答。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在开发Python的过程中，一定会遇到很多反斜杠的问题，很多人被反斜杠的数量搞得头大。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何在文章中隐藏版权信息</title>
    <link href="https://www.kingname.info/2019/03/10/hide-text/"/>
    <id>https://www.kingname.info/2019/03/10/hide-text/</id>
    <published>2019-03-10T09:08:52.000Z</published>
    <updated>2019-03-19T13:20:36.541Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章，首先会让你越看越糊涂，然后再让你越看越清醒。请坚持看完。</p>
<a id="more"></a>
<p>首先，我们来看一段文字：</p>
<blockquote>
<p>一我日是一青技南是我一是个青每南天我更是新青的南栏我目是，青希南望我做是到青在南每我天是几青分南钟我让是你青获南得我提是高青。南</p>
</blockquote>
<p>看完以后，你有什么想法？你会不会觉得我是自恋狂？神经病？复读机？脸滚键盘？</p>
<p>很好，那么再看下面这一句话：</p>
<blockquote>
<p>一‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌日‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌一‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍技‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌是‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌一‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌个‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍每‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌天‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌更‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌新‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍的‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌栏‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌目‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌，‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍希‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌望‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌做‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌到‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍在‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌每‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌天‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌几‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍分‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌钟‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌让‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌你‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍获‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌得‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌提‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌高‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍。‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌</p>
</blockquote>
<p>是不是正常多了？</p>
<p>但是如果我说这两段话，实际上是一样的，你信不信？</p>
<p>现在有4个中文汉字：<code>我是青南</code>，首先介绍Python的<code>ord</code>函数，它可以查询Unicode字符对应的Unicode码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; ord(&apos;我&apos;)</div><div class="line">25105</div><div class="line">&gt;&gt;&gt; ord(&apos;是&apos;)</div><div class="line">26159</div><div class="line">&gt;&gt;&gt; ord(&apos;青&apos;)</div><div class="line">38738</div><div class="line">&gt;&gt;&gt; ord(&apos;南&apos;)</div><div class="line">21335</div></pre></td></tr></table></figure>
<p>接下来，介绍另一个函数<code>chr</code>。它的作用是把Unicode编码转换为Unicode字符。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; chr(21335)</div><div class="line">&apos;南&apos;</div><div class="line">&gt;&gt;&gt; chr(38738)</div><div class="line">&apos;青&apos;</div></pre></td></tr></table></figure>
<p>最后，介绍<code>bin</code>函数，它可以把十进制数字转换为二进制数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bin(6)</div><div class="line">&apos;0b110&apos;</div><div class="line">&gt;&gt;&gt; bin(57)</div><div class="line">&apos;0b111001&apos;</div></pre></td></tr></table></figure>
<p>以上就是本文涉及到的全部知识。下面，开始转换。</p>
<p>由于Unicode是十进制数字，那么就能进一步转换为二进制数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bin(25105)</div><div class="line">&apos;0b110001000010001&apos;</div></pre></td></tr></table></figure>
<p>把前面的<code>0b</code>去掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bin(25105)[2:]</div><div class="line">&apos;110001000010001&apos;</div></pre></td></tr></table></figure>
<p>那么，<code>我是青南</code>转换为二进制以后，分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for char in &apos;我是青南&apos;:</div><div class="line">...  print(char, bin(ord(char))[2:])</div><div class="line">...</div><div class="line">我 110001000010001</div><div class="line">是 110011000101111</div><div class="line">青 1001011101010010</div><div class="line">南 101001101010111</div></pre></td></tr></table></figure>
<p>那么原来那个看起来很混乱的句子是怎么生成的呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line"></div><div class="line">signature = <span class="string">'我是青南'</span></div><div class="line">text = <span class="string">'一日一技是一个每天更新的栏目，希望做到在每天几分钟让你获得提高。'</span></div><div class="line">complex_text = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> word, sig <span class="keyword">in</span> zip(text, cycle(signature)):</div><div class="line">    complex_text = complex_text + word + sig</div><div class="line">print(complex_text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-16-34-49.png" alt=""></p>
<p>那么如果把<code>我是青南</code>先转换为他们对应的二进制字符串，然后再穿插到原文中，效果就会变成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line"></div><div class="line">signature_bin_list = [<span class="string">'110001000010001'</span>,</div><div class="line">                      <span class="string">'110011000101111'</span>,</div><div class="line">                      <span class="string">'1001011101010010'</span>,</div><div class="line">                      <span class="string">'101001101010111'</span>]</div><div class="line">text = <span class="string">'一日一技是一个每天更新的栏目，希望做到在每天几分钟让你获得提高。'</span></div><div class="line">complex_text = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> word, sig <span class="keyword">in</span> zip(text, cycle(signature_bin_list)):</div><div class="line">    complex_text = complex_text + word + sig</div><div class="line">print(complex_text)</div></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-16-40-56.png" alt=""></p>
<p>到目前为止，你肯定不知道我在干什么。</p>
<p>下面，我将会介绍两个神奇的数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">8204</div><div class="line">8205</div></pre></td></tr></table></figure>
<p>如果我使用<code>chr</code>把这两个数字转换为Unicode字符会怎么样？</p>
<p>我们来试一试：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-16-54-15.png" alt=""></p>
<p>很奇怪对吧？什么东西都没有？难道这两个数字转换为Unicode字符以后，都是空格？？</p>
<p>没事，我们把字符串形式的二进制数字中的<code>1</code>替换为<code>chr(8204)</code>，把<code>0</code>替换为<code>chr(8025)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line"></div><div class="line">signature_bin_list = [<span class="string">'110001000010001'</span>,</div><div class="line">                      <span class="string">'110011000101111'</span>,</div><div class="line">                      <span class="string">'1001011101010010'</span>,</div><div class="line">                      <span class="string">'101001101010111'</span>]</div><div class="line">text = <span class="string">'一日一技是一个每天更新的栏目，希望做到在每天几分钟让你获得提高。'</span></div><div class="line">complex_text = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> word, sig <span class="keyword">in</span> zip(text, cycle(signature_bin_list)):</div><div class="line">    complex_text = complex_text + word + sig.replace(<span class="string">'1'</span>, chr(<span class="number">8204</span>)).replace(<span class="string">'0'</span>, chr(<span class="number">8205</span>))</div><div class="line">print(complex_text)</div></pre></td></tr></table></figure>
<p>运行效果是什么样的？请看下面这张图：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-16-57-26.png" alt=""></p>
<p>奇奇怪怪的符号没有了，一切都变得干干净净，就像下面这样：</p>
<blockquote>
<p>一‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌日‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌一‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍技‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌是‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌一‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌个‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍每‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌天‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌更‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌新‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍的‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌栏‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌目‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌，‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍希‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌望‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌做‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌到‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍在‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌每‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌天‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌几‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍分‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌钟‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌让‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌你‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍获‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌得‌‌‍‍‍‌‍‍‍‍‌‍‍‍‌提‌‌‍‍‌‌‍‍‍‌‍‌‌‌‌高‌‍‍‌‍‌‌‌‍‌‍‌‍‍‌‍。‌‍‌‍‍‌‌‍‌‍‌‍‌‌‌</p>
</blockquote>
<p>现在，你在电脑上把这一段话复制下来，存到记事本里面，效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-17-02-40.png" alt=""></p>
<p>看起来很正常对吧。那么现在，用vim把它打开，你看到的将会是这样的：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-10-17-03-38.png" alt=""></p>
<p>在网页上面，一切都正常，但是一旦有人复制了你的内容，直接转载到了它自己的网站上。那么你可以到法院去起诉他了，因为这些没有宽度的符号，就是证据。</p>
<p>在下一次的文章中，我将会讲到，如何把本文的过程你过来，把隐藏的信息提取出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章，首先会让你越看越糊涂，然后再让你越看越清醒。请坚持看完。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>三年写了两本书，这是我的时间管理实践</title>
    <link href="https://www.kingname.info/2019/03/08/my-story-with-my-book/"/>
    <id>https://www.kingname.info/2019/03/08/my-story-with-my-book/</id>
    <published>2019-03-08T14:47:28.000Z</published>
    <updated>2019-03-09T14:46:47.806Z</updated>
    
    <content type="html"><![CDATA[<p>“听说你出了两本书，说说你现在是什么感觉。”</p>
<p>“感觉啊，感觉就像是坐了三年牢，终于放出来。”</p>
<a id="more"></a>
<p>2019年2月，我的第二本书在京东上架。至此，历时3年的写书计划圆满落下帷幕。</p>
<p>在这三年里面，我经历了情绪的起起伏伏，我实践了多种不同的时间管理方法——有效的，无效的，前期立竿见影却后劲不足的，前期效果一般但越用越顺手的……并成功找到了最适合自己的方法。</p>
<p>在这里，我想把这三年的经历写出来。权作为这两本书的结尾。这一篇，讲讲我的时间管理实践。</p>
<h2 id="你爷爷是写过书的人"><a href="#你爷爷是写过书的人" class="headerlink" title="你爷爷是写过书的人"></a>你爷爷是写过书的人</h2><p>与出版社的接洽事宜略去不谈。</p>
<p>书第1，2章的撰写工作非常顺利，因为新鲜感和热情都在。我晚上做梦，也常常梦到——当我老了，我会对我的孙子说，你看，这是爷爷年轻时候写的书。</p>
<p>于是这个阶段，不需要任何的时间管理方案，只要有空闲时间，自动就会去写。生产力max。</p>
<p>约稿合同规定的写稿时间将近一年。如果我一周写完一章，那么写完13章，只需要3个月的时间。所以，不着急。</p>
<p>然后我的生产力就丧失了。</p>
<p>第一波热情消散以后，就不得不依靠一些时间管理的手段来维持自己的持续产出。</p>
<h2 id="精确到小时的枷锁"><a href="#精确到小时的枷锁" class="headerlink" title="精确到小时的枷锁"></a>精确到小时的枷锁</h2><p>“我现在手上有10个Offer，凭什么我要离开成都千里迢迢来北京，进你们公司？你们钱给得也不多，又是小公司前途未卜，北京房价还那么贵……”</p>
<p>“我们不相信996，我们只定Deadline和目标。任何时间到公司都可以，任何时间离开公司都可以。我们公司隔壁，有至少400个单身小姐姐……”</p>
<p>“你不用说了。我下个月就来上班。”</p>
<p>假设我每天10点半到公司，18点下班，那么剩下的时间，可以充分利用起来完成我的书。我需要制定详细的时间计划。</p>
<p>时不我待，时间管理是一个必需要立刻做起来的事情，于是我拿出手机，使用自带的提醒事项订好了每天的计划：</p>
<ul>
<li>1月7日，9:00-12:00，完成第三章第1、2节</li>
<li>1月8日，13:00-17:00，完成第三章配套示例代码的编写。</li>
<li>1月9日，18:00-23:00，完成第三章第3、4小节的编写。</li>
<li>1月10日，9:00-11:00，……</li>
</ul>
<p>1月7日-月14日，一周的计划满满当当，有条有理，嗯，一本满足。</p>
<p>1月8日：</p>
<blockquote>
<p>某君：青南，听说你提离职了？你不知道HR小姐姐可伤心了，她说要请你吃饭。<br>我：毋需多言，只需要告诉我几点钟在哪里。</p>
</blockquote>
<p>1月8日的任务没有完成。1月9日周一需要完成1月8日的任务，可是周日的计划是一整天，周一号并没有一整天的空闲时间，那么一部分任务需要排到周二，原来周二的任务又要排到周三……</p>
<p>1月10日，尝试待办事项计划，半途而废。</p>
<h2 id="有限度的自由"><a href="#有限度的自由" class="headerlink" title="有限度的自由"></a>有限度的自由</h2><p>事实证明，通过制定时间表来规划任务，现阶段对我来说还不太适合。由于这是我第一次写书，时间并不能很好的把控。一旦其中一个时间段的事情没有做完，必然会影响到下一个时间段的任务。一个任务的时间延迟，后面全都得延迟。越堆越多，计划崩溃。</p>
<p>于是我花了一整天的时间来思考这个问题，如果我其中一个任务耗时超过预期怎么办？我应该提前终止吗？提前终止之后，先去完成后面的任务，等一天的安排都做完了，晚上再回过头来做上午没有做完的任务，这样可行吗？</p>
<p>我得出一个结论，如果使用通过制定时间表的方式来安排，那么这是不现实的。</p>
<p>这个时候，我遇到了一个App，Todoist。它的出现让我眼前一亮。Todoist也是一个待办事项工具，但是它有意弱化了提醒的功能。</p>
<p>这就给我了一个提示，如果我完成任务的安排是以天为单位，只需要确定一天要完成哪些任务，会不会安排起来更加灵活呢？不用精确到小时这个粒度，只要能把一天的任务做完，具体几点做都没有关系。</p>
<p>于是我继续用第一本书的第四章来实践这种计划方式，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-08-23-42-29.png" alt=""></p>
<p>实时证明这是一种行之有效的办法，因为自己的行为不再被限制到小时里面，整个人突然之间变得自由了。于是第四章非常顺利地在一周内完成了。</p>
<p>如果用小时为单位来规划任务，会把任务限制得太死，那么就以天为单位吧。</p>
<h2 id="依赖、优先级、整体"><a href="#依赖、优先级、整体" class="headerlink" title="依赖、优先级、整体"></a>依赖、优先级、整体</h2><p>通过书稿的第四章和第五章的练习，我发现了另外一个问题。如果每个写作任务都是单独的，用Todoist来安排自然是够了。但是，倘若不同的写作任务之间有依赖关系，有优先级。这种情况下，某些任务就比另一些任务更重要。而我完成各个任务的过程，就出现了依赖关系。如果我需要在一个月内写完3章，那么哪些章节先下，哪些代码先写，哪些步骤后做，自然就需要特别重视起来。</p>
<p>说到优先级，说到依赖关系，我立刻想到了甘特图。</p>
<p>正好书稿第九章的撰写工作存在不少依赖关系，那么我刚好可以通过甘特图来规划一下。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-09-00-31-13.png" alt=""></p>
<p>通过在甘特图上面安排任务的过程，我明确地知道了哪些任务需要先做，哪些任务随时都可以做。哪些任务依赖于前面的任务，哪些任务被其他任务依赖，因此必需按时完成。</p>
<p>第九章在甘特图的帮助下，非常快速地撰写完成了，时间与计划一天不差。此时是2月20日，距离前往北京，还剩4天时间。</p>
<p>小姐姐们，我来了。</p>
<h2 id="别跟我说话，我的番茄正在滚动"><a href="#别跟我说话，我的番茄正在滚动" class="headerlink" title="别跟我说话，我的番茄正在滚动"></a>别跟我说话，我的番茄正在滚动</h2><p>新的风暴已经出现，怎么能够停滞不前。</p>
<p>入职当天中午，我拒绝了老板的吃饭邀约，这个时候哪里有心情吃饭。先去公司隔壁看看。</p>
<p>啊，真的几百个单身小姐姐……或者说……小妹妹？？？</p>
<p>和平里第四小学？？？</p>
<p>好了，现在我可以心无旁骛地写书和工作了……</p>
<p>化失望为力量吧。把力量注入到写书和新的工作中。</p>
<p>码字：“在使用mitmproxy的时候,我们可以通过……”</p>
<p>思绪：“妈的气死老子了，我远赴他乡,离家几千里是为了什么……不行不行,思绪拉回来,继续码字.”</p>
<p>码字: “我们可以通过Python来自定义mitmproxy的行为,从而实现……”</p>
<p>思绪: “我还是咽不下这口气,老子被骗了……啊啊啊不能想不想想,专心工作!”</p>
<p>……</p>
<p>现在完全不能专心写作，写着写着就会想到其他事情上去。</p>
<p>“咚、咚、咚，小哥哥要不要吃番茄？”</p>
<p>“吃番茄？好啊。”</p>
<p>等等，番茄？啊，不如试一试番茄工作法吧~</p>
<p>于是，我开始使用番茄工作法。</p>
<p>现在的状态，坚持写书一小时都不容易。那如果只坚持25分钟呢？然后专门拿五分钟来想各种奇奇怪怪的事情。然后再写25分钟。然后再拿5分钟来做其他事情。</p>
<p>果然写书的效率高了很多。</p>
<p>于是，在甘特图、Todoist，番茄工作法的帮助下，转眼到了2017年底。</p>
<p>第一本书已经交付给了出版社，而我也早已经走出了失望的阴影。</p>
<p>第一本书的审核周期将会长达一年（为什么我会提前知道？）。而在等待的这个时间窗口里，我去了另外一家公司，并开始了另一个计划。</p>
<h2 id="晚上跟我一起加班吧？不，我要回家写文档"><a href="#晚上跟我一起加班吧？不，我要回家写文档" class="headerlink" title="晚上跟我一起加班吧？不，我要回家写文档"></a>晚上跟我一起加班吧？不，我要回家写文档</h2><p>就像阳光穿过黑夜，黎明悄悄划破天边。</p>
<p>在新的公司里面，我遇到了P酱。P酱想跟我学数据库，于是我开始写数据库相关的文档。</p>
<p>在写第一本书的过程中，我发现通过写书，把知识系统梳理，对自己有极大的好处。于是，数据库的文档，我也用写书的标准来分篇章撰写。</p>
<p>“师傅，晚上跟我一起加班吧？”有一天P酱过来跟我说。</p>
<p>“不行，我得回家写书。”</p>
<p>第一本书的撰写经验告诉我，在时间管理中，三点一线并不一定是不好的东西。我已经养成这样一个生活节奏：</p>
<ol>
<li>早上7点起床，写1小时，去楼下买一根煮玉米</li>
<li>写到10点，上班</li>
<li>18:00下班</li>
<li>18:30写到23点</li>
<li>睡觉</li>
</ol>
<p>经过几个月每天养成的习惯，现在每一个动作，都变成了条件反射，时间到了，自动做这个事情，不需要特别用脑袋去想，不需要特别去关注时间。</p>
<p>看起来和之前尝试的时间表很像，但是效果完全不一样了。通过习惯来管理时间，于是时间就不用特别管理，因为它自动就被管理了。</p>
<p>但是弊端也很明显，就是有一天没有按照这个固定的习惯做完，就会浑身不舒服，感觉少了什么东西。所以为了不打断习惯，我拒接了很多的邀约。</p>
<p>后来P酱成了别人的女朋友。</p>
<h2 id="you-walk-I-walk"><a href="#you-walk-I-walk" class="headerlink" title="you walk, I walk."></a>you walk, I walk.</h2><p>失去P酱以后，另一个出版社找到我，问我要不要再写一本书。我想到了之前写给P酱的文档，于是就同意了。</p>
<p>此时已经是2018年4月，我前往了杭州。机缘巧合认识了和P酱长得非常像的H酱。</p>
<p>有一天，H酱问我：“听说你在写书，你能把我写进你的书里面吗？就像Jack和Rose那样。”</p>
<p>我：“我这是技术书，不是小说。而且Jack是画家，我书看得多，你不要骗我。”</p>
<p>H酱：“那你的书还剩多少啊.你写完了我请你看电影吧~”</p>
<p>我:“无功不受禄,为什么要请看电影?”</p>
<p>H酱:“因为这样我就可以让你送我一本啊~”</p>
<p>于是,在H酱的激励下,我的第二本书很快就完成了.</p>
<p>当有一个正向激励,那么什么时间管理技巧都不重要了,因为你自己就成了一个永动机.</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>上面只是段子，真正的原因实际上是因为我是一个费曼学习法的实践者，我相信只有我把别人讲懂了，才能说明我自己学会了。</p>
<p>事情起始于2016年。那时我已经在极客学院开设爬虫视频课程。在视频课程的录制过程中，我发现我对爬虫的开发经验来自于多年的工作积累。虽然能够处理各种问题，但当我给新人介绍的时候，却不能很清晰的把我的思考过程表述出来。这反应出我对这门技术的掌握却不够系统，条例不清。</p>
<p>而彼时，人民邮电出版社教育分社恰好找到我，希望我能够出版一本爬虫书，用于作为高校的爬虫教材。于是一拍即合，不仅能够完成对我自己知识的梳理，还能顺便出版一本书。</p>
<p>于是，我开始写我的第一本书。</p>
<p>不止一个人问我，写书很赚钱吗？</p>
<p>实际上写书不能赚钱，而且费时间费精力，在这个过程中作者需要放弃很多东西。如果要说最大的收获，那就是作者所写的内容，会给作者的认知更上一层楼吧（笑）。</p>
<p>好了，下一篇文章，我将会讲到这三年里面，我内心的痛苦挣扎。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“听说你出了两本书，说说你现在是什么感觉。”&lt;/p&gt;
&lt;p&gt;“感觉啊，感觉就像是坐了三年牢，终于放出来。”&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="https://www.kingname.info/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="https://www.kingname.info/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用倒排索引极速提高字符串搜索效率</title>
    <link href="https://www.kingname.info/2019/03/02/inverted-index/"/>
    <id>https://www.kingname.info/2019/03/02/inverted-index/</id>
    <published>2019-03-02T04:05:45.000Z</published>
    <updated>2019-03-02T06:30:52.173Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，如果要判断一个字符串是否在另一个字符串里面，我们可以使用<code>in</code>关键字，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &apos;你说我是买苹果电脑，还是买windows电脑呢？&apos;</div><div class="line">&gt;&gt;&gt; if &apos;苹果&apos; in a:</div><div class="line">...  print(&apos;苹果这个词在a字符串里面&apos;)</div><div class="line">...</div><div class="line">苹果这个词在a字符串里面</div></pre></td></tr></table></figure>
<p>如果有多个句子和多个关键字，那么可以使用<code>for</code>循环来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sentences = [<span class="string">'你说我是买苹果电脑，还是买windows电脑呢？'</span>, </div><div class="line">             <span class="string">'人生苦短我用Python'</span>, </div><div class="line">             <span class="string">'你TM一天到晚只知道得瑟'</span>,</div><div class="line">             <span class="string">'不不不，我不是说你，我是说在座的各位都是垃圾。'</span></div><div class="line">             <span class="string">'我CNM你个大SB'</span></div><div class="line">            ]</div><div class="line">keywords = [<span class="string">'垃圾'</span>, <span class="string">'CNM'</span>, <span class="string">'SB'</span>, <span class="string">'TM'</span>]</div><div class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentences:</div><div class="line">    <span class="keyword">for</span> keyword <span class="keyword">in</span> keywords:</div><div class="line">        <span class="keyword">if</span> keyword <span class="keyword">in</span> sentence:</div><div class="line">            print(f<span class="string">'句子: 【&#123;sentence&#125;】包含脏话：【&#123;keyword&#125;】'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-02-12-18-39.png" alt=""></p>
<p>现在如果有100000000个句子，有1000个关键字，那么你需要对比1000亿次才能全部查询完成。这个时间代价太大了，如果Python一秒钟能运行500万次查询（实际上没有这么快），那么1000亿次查询需要20000秒，接近6小时。而且，由于<code>in</code>关键字的时间复杂度为<code>O(n)</code>，如果有大量长句子，查询时间会更长。</p>
<a id="more"></a>
<p>例如，我们要从下面的句子里面寻找<code>CNM</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sentences = [&apos;你说我是买苹果电脑，还是买windows电脑呢？&apos;, </div><div class="line">             &apos;人生苦短我用Python&apos;, </div><div class="line">             &apos;你TM一天到晚只知道得瑟&apos;,</div><div class="line">             &apos;不不不，我不是说你，我是说在座的各位都是垃圾。&apos;,</div><div class="line">             &apos;我CNM你个大SB&apos;,</div><div class="line">             &apos;各位同学，Good Morning！&apos;,</div><div class="line">             &apos;网络这个单词，它的英文为Network&apos;,</div><div class="line">             &apos;我不想听到有人说CNM！&apos;</div><div class="line">            ]</div></pre></td></tr></table></figure>
<p>如果使用常规方法，那么我们的做法是：</p>
<ol>
<li><code>CNM</code>在<code>你说我是买苹果电脑，还是买windows电脑呢？</code>中吗？不在！</li>
<li><code>CNM</code>在<code>人生苦短我用Python</code>吗？不在！</li>
<li>……</li>
<li>……</li>
<li><code>CNM</code>在<code>我CNM你个大SB</code>吗？<strong>在</strong>！</li>
<li><code>CNM</code>在<code>各位同学，Good Morning！</code>吗？不在！</li>
<li><code>CMN</code>在<code>网络这个单词，它的英文为Network</code>吗？不在！</li>
<li><code>CNM</code>在<code>我不想听到有人说CNM！</code>吗？<strong>在</strong>！</li>
</ol>
<p>于是就知道了，<code>CNM</code>在sentences列表下标为4和7的这两个句子中。</p>
<p>下面，我们换一个看起来更笨的办法：</p>
<p>要找到<code>CNM</code>在哪几句里面，可以变成：寻找<code>C</code>、<code>N</code>、<code>M</code>这三个字母在哪几句里面。然后，再找到同时有这三个字母的句子:</p>
<ol>
<li><code>C</code>在4, 7句</li>
<li><code>N</code>在4，6，7句</li>
<li><code>M</code>在2, 4，5，7句</li>
</ol>
<p>所以，{4, 7} 与 {4, 6, 7} 与 {4, 5, 7}做交集，得到{4, 7}说明<code>CNM</code>这个词很有可能是在第4句和第7句。</p>
<p>为什么说很可能呢？因为假如再添加一句话：<code>今天我们学习三个单词：Cat, Network, Morning</code>。这一句也会被认为包含<code>CNM</code>这个词，但实际上它只是同时包含了<code>C</code>、<code>N</code>、<code>M</code>三个字母而已。</p>
<p>接下来，有人会问了：原来直接查询<code>CNM</code>的时候，只需要查询8次就可以了。现在你分别查询<code>C</code> <code>N</code> <code>M</code>要查询24次。你是修复了查询时间太短的bug吗？</p>
<p>回答这个问题之前，我们再来看另一个问题。</p>
<p>Python里面，当我要判断字母<code>C</code>是不是在句子<code>我不想听到有人说CNM！</code>里面时，Python是如何工作的？</p>
<p>实际上，它的工作原理可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sentence = <span class="string">'我不想听到有人说CNM！'</span></div><div class="line"><span class="keyword">for</span> char <span class="keyword">in</span> sentence:</div><div class="line">    <span class="keyword">if</span> char == <span class="string">'C'</span>:</div><div class="line">        print(<span class="string">'C在这个字符串中'</span>)</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>如果要判断<code>C</code>、<code>N</code>、<code>M</code>是不是都在这个字符串<code>我不想听到有人说CNM！</code>中，同一个字符串会被遍历3次。有没有办法减少这种看起来多余的遍历操作呢？</p>
<p>如果我们把<code>我不想听到有人说CNM！</code>这个句子转成字典会怎么样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sentence = &apos;我不想听到有人说CNM！&apos;</div><div class="line">sentence_dict = &#123;char: 1 for char in sentence&#125;</div><div class="line">for letter in &apos;CNM&apos;:</div><div class="line">    if letter in sentence_dict:</div><div class="line">        print(f&apos;字母&#123;letter&#125;在句子中！&apos;)</div></pre></td></tr></table></figure>
<p>这样一来，只需要在生成字典的时候遍历句子一次，减少了2次冗余遍历。并且，判断一个元素是否在字典里面，时间复杂度为<code>O(1)</code>，速度非常快。</p>
<p><code>我不想听到有人说CNM！</code>生成的字典为<code>{&#39;我&#39;: 1, &#39;不&#39;: 1, &#39;想&#39;: 1, &#39;听&#39;: 1, &#39;到&#39;: 1, &#39;有&#39;: 1, &#39;人&#39;: 1, &#39;说&#39;: 1, &#39;C&#39;: 1, &#39;N&#39;: 1, &#39;M&#39;: 1, &#39;！&#39;: 1}</code>。那么如果要把列表里面的所有句子都这样处理，又怎么存放呢？此时，字典的Key就是每一个字符，而Value可以是每一句话在原来列表中的索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">sentences = [<span class="string">'你说我是买苹果电脑，还是买windows电脑呢？'</span>, </div><div class="line">             <span class="string">'人生苦短我用Python'</span>, </div><div class="line">             <span class="string">'你TM一天到晚只知道得瑟'</span>,</div><div class="line">             <span class="string">'不不不，我不是说你，我是说在座的各位都是垃圾。'</span>,</div><div class="line">             <span class="string">'我CNM你个大SB'</span>,</div><div class="line">             <span class="string">'各位同学，Good Morning！'</span>,</div><div class="line">             <span class="string">'网络这个单词，它的英文为Network'</span>,</div><div class="line">             <span class="string">'我不想听到有人说CNM！'</span>]</div><div class="line">index_dict = &#123;&#125;</div><div class="line"><span class="keyword">for</span> index, line <span class="keyword">in</span> enumerate(sentences):</div><div class="line">    print(index, line)</div><div class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> line:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> char.strip():</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> index_dict:</div><div class="line">            index_dict[char].add(index)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            index_dict[char] = &#123;index&#125;</div></pre></td></tr></table></figure>
<p>生成的字典为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">&#123;&apos;B&apos;: &#123;4&#125;,</div><div class="line"> &apos;C&apos;: &#123;4, 7&#125;,</div><div class="line"> &apos;G&apos;: &#123;5&#125;,</div><div class="line"> &apos;M&apos;: &#123;2, 4, 5, 7&#125;,</div><div class="line"> &apos;N&apos;: &#123;4, 6, 7&#125;,</div><div class="line"> &apos;P&apos;: &#123;1&#125;,</div><div class="line"> &apos;S&apos;: &#123;4&#125;,</div><div class="line"> &apos;T&apos;: &#123;2&#125;,</div><div class="line"> &apos;d&apos;: &#123;0, 5&#125;,</div><div class="line"> &apos;e&apos;: &#123;6&#125;,</div><div class="line"> &apos;g&apos;: &#123;5&#125;,</div><div class="line"> &apos;h&apos;: &#123;1&#125;,</div><div class="line"> &apos;i&apos;: &#123;0, 5&#125;,</div><div class="line"> &apos;k&apos;: &#123;6&#125;,</div><div class="line"> &apos;n&apos;: &#123;0, 1, 5&#125;,</div><div class="line"> &apos;o&apos;: &#123;0, 1, 5, 6&#125;,</div><div class="line"> &apos;r&apos;: &#123;5, 6&#125;,</div><div class="line"> &apos;s&apos;: &#123;0&#125;,</div><div class="line"> &apos;t&apos;: &#123;1, 6&#125;,</div><div class="line"> &apos;w&apos;: &#123;0, 6&#125;,</div><div class="line"> &apos;y&apos;: &#123;1&#125;,</div><div class="line"> &apos;。&apos;: &#123;3&#125;,</div><div class="line"> &apos;一&apos;: &#123;2&#125;,</div><div class="line"> &apos;不&apos;: &#123;3, 7&#125;,</div><div class="line"> &apos;个&apos;: &#123;4, 6&#125;,</div><div class="line"> &apos;为&apos;: &#123;6&#125;,</div><div class="line"> &apos;买&apos;: &#123;0&#125;,</div><div class="line"> &apos;人&apos;: &#123;1, 7&#125;,</div><div class="line"> &apos;位&apos;: &#123;3, 5&#125;,</div><div class="line"> &apos;你&apos;: &#123;0, 2, 3, 4&#125;,</div><div class="line"> &apos;到&apos;: &#123;2, 7&#125;,</div><div class="line"> &apos;单&apos;: &#123;6&#125;,</div><div class="line"> &apos;只&apos;: &#123;2&#125;,</div><div class="line"> &apos;各&apos;: &#123;3, 5&#125;,</div><div class="line"> &apos;同&apos;: &#123;5&#125;,</div><div class="line"> &apos;听&apos;: &#123;7&#125;,</div><div class="line"> &apos;呢&apos;: &#123;0&#125;,</div><div class="line"> &apos;在&apos;: &#123;3&#125;,</div><div class="line"> &apos;圾&apos;: &#123;3&#125;,</div><div class="line"> &apos;垃&apos;: &#123;3&#125;,</div><div class="line"> &apos;大&apos;: &#123;4&#125;,</div><div class="line"> &apos;天&apos;: &#123;2&#125;,</div><div class="line"> &apos;学&apos;: &#123;5&#125;,</div><div class="line"> &apos;它&apos;: &#123;6&#125;,</div><div class="line"> &apos;座&apos;: &#123;3&#125;,</div><div class="line"> &apos;得&apos;: &#123;2&#125;,</div><div class="line"> &apos;想&apos;: &#123;7&#125;,</div><div class="line"> &apos;我&apos;: &#123;0, 1, 3, 4, 7&#125;,</div><div class="line"> &apos;文&apos;: &#123;6&#125;,</div><div class="line"> &apos;是&apos;: &#123;0, 3&#125;,</div><div class="line"> &apos;晚&apos;: &#123;2&#125;,</div><div class="line"> &apos;有&apos;: &#123;7&#125;,</div><div class="line"> &apos;果&apos;: &#123;0&#125;,</div><div class="line"> &apos;瑟&apos;: &#123;2&#125;,</div><div class="line"> &apos;生&apos;: &#123;1&#125;,</div><div class="line"> &apos;用&apos;: &#123;1&#125;,</div><div class="line"> &apos;电&apos;: &#123;0&#125;,</div><div class="line"> &apos;的&apos;: &#123;3, 6&#125;,</div><div class="line"> &apos;知&apos;: &#123;2&#125;,</div><div class="line"> &apos;短&apos;: &#123;1&#125;,</div><div class="line"> &apos;络&apos;: &#123;6&#125;,</div><div class="line"> &apos;网&apos;: &#123;6&#125;,</div><div class="line"> &apos;脑&apos;: &#123;0&#125;,</div><div class="line"> &apos;苦&apos;: &#123;1&#125;,</div><div class="line"> &apos;英&apos;: &#123;6&#125;,</div><div class="line"> &apos;苹&apos;: &#123;0&#125;,</div><div class="line"> &apos;词&apos;: &#123;6&#125;,</div><div class="line"> &apos;说&apos;: &#123;0, 3, 7&#125;,</div><div class="line"> &apos;还&apos;: &#123;0&#125;,</div><div class="line"> &apos;这&apos;: &#123;6&#125;,</div><div class="line"> &apos;道&apos;: &#123;2&#125;,</div><div class="line"> &apos;都&apos;: &#123;3&#125;,</div><div class="line"> &apos;！&apos;: &#123;5, 7&#125;,</div><div class="line"> &apos;，&apos;: &#123;0, 3, 5, 6&#125;,</div><div class="line"> &apos;？&apos;: &#123;0&#125;&#125;</div></pre></td></tr></table></figure>
<p>生成的字典这么长，看起来非常可怕。但是别慌，毕竟不是你人肉寻找。对Python来说，字典里面无论有多少个Key，它的查询时间都是一样的。</p>
<p>现在，我们要寻找<code>C</code>、<code>N</code>、<code>M</code>，于是代码可以写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">index_list = []</div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'CNM'</span>:</div><div class="line">    index_list.append(index_dict.get(letter, &#123;&#125;))</div><div class="line"></div><div class="line">common_index = set.intersection(*index_list)  <span class="comment"># 对包含各个字母的索引做交集，得到同时包含3个字母的句子</span></div><div class="line">print(f<span class="string">'这几个句子里面同时含有`C`、`N`、`M`：&#123;common_index&#125;'</span>)</div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> common_index:</div><div class="line">    print(sentences[index])</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-02-13-50-58.png" alt=""></p>
<p>所以，对于一组需要被查询的关键字，也可以这样搜索：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">keywords = [<span class="string">'垃圾'</span>, <span class="string">'CNM'</span>, <span class="string">'SB'</span>, <span class="string">'TM'</span>]</div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> keywords:</div><div class="line">    index_list = []</div><div class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> word:</div><div class="line">        index_list.append(index_dict.get(letter, &#123;&#125;))</div><div class="line"></div><div class="line">    common_index = set.intersection(*index_list)</div><div class="line">    print(f<span class="string">'&gt;&gt;这几个句子里面同时含有：&#123;word&#125;'</span>)</div><div class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> common_index:</div><div class="line">        print(sentences[index])</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-02-14-05-33.png" alt=""></p>
<p>看完这篇文章以后，你已经学会了倒排索引（Inverted-index）。这是Google搜索的核心算法之一。</p>
<p>可以看出，对于少量数据的搜索，倒排索引并不会比常规方法节约多少时间。但是当你有100000000条句子，1000个关键词的时候，用倒排索引实现搜索，所需要的时间只有常规方法的1/10甚至更少。</p>
<p>最后回到前面遇到的一个问题，当句子里面同时含有字母<code>C</code>、<code>N</code>、<code>M</code>，虽然这三个字母并不是组合在一起的，也会被搜索出来。这就涉及到搜索引擎的另一个核心技术——<code>分词</code>了。对于英文而言，使用空格来切分单词就好了。但是对于中文来说，不同的汉字组合在一起构成的词语，字数是不一样的。甚至有些专有名词，可能七八个字，但是也要作为整体来搜索。</p>
<p>分词的具体做法，又是另外一个故事了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中，如果要判断一个字符串是否在另一个字符串里面，我们可以使用&lt;code&gt;in&lt;/code&gt;关键字，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = &amp;apos;你说我是买苹果电脑，还是买windows电脑呢？&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; if &amp;apos;苹果&amp;apos; in a:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...  print(&amp;apos;苹果这个词在a字符串里面&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;苹果这个词在a字符串里面&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果有多个句子和多个关键字，那么可以使用&lt;code&gt;for&lt;/code&gt;循环来实现：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sentences = [&lt;span class=&quot;string&quot;&gt;&#39;你说我是买苹果电脑，还是买windows电脑呢？&#39;&lt;/span&gt;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&#39;人生苦短我用Python&#39;&lt;/span&gt;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&#39;你TM一天到晚只知道得瑟&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&#39;不不不，我不是说你，我是说在座的各位都是垃圾。&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&#39;我CNM你个大SB&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;keywords = [&lt;span class=&quot;string&quot;&gt;&#39;垃圾&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;CNM&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;SB&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;TM&#39;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; sentence &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sentences:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; keyword &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; keywords:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; keyword &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sentence:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            print(f&lt;span class=&quot;string&quot;&gt;&#39;句子: 【&amp;#123;sentence&amp;#125;】包含脏话：【&amp;#123;keyword&amp;#125;】&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-03-02-12-18-39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在如果有100000000个句子，有1000个关键字，那么你需要对比1000亿次才能全部查询完成。这个时间代价太大了，如果Python一秒钟能运行500万次查询（实际上没有这么快），那么1000亿次查询需要20000秒，接近6小时。而且，由于&lt;code&gt;in&lt;/code&gt;关键字的时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;，如果有大量长句子，查询时间会更长。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据工程师妹子养成手记——数据库篇</title>
    <link href="https://www.kingname.info/2019/02/23/do-not-waste-time-in-setup-env/"/>
    <id>https://www.kingname.info/2019/02/23/do-not-waste-time-in-setup-env/</id>
    <published>2019-02-23T05:25:32.000Z</published>
    <updated>2019-02-23T05:46:25.393Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章没有代码，请放心阅读。</p>
<p>程序员最宝贵的东西是生命，生命属于程序员只有一次。一个程序员的一生应该这样度过：当她回首往事的时候，她不会因为搭建环境浪费时间而悔恨，也不会因为集群无法运行而羞耻。这样，在她开发的时候，她能够说：“我的整个生命和全部精力，都已经献给了开发中最重要的事情——设计程序，实现程序和调Bug。” ——P酱。</p>
<p>P酱是公司新来的实习生妹子。听说是一个文科生。文科生应该会去文案组或者策划组吧。什么？来数据组？让我来带？</p>
<p>于是我和P酱<del>生活</del>工作在了一起。</p>
<a id="more"></a>
<h2 id="P酱你会些什么？"><a href="#P酱你会些什么？" class="headerlink" title="P酱你会些什么？"></a>P酱你会些什么？</h2><p>“我叫P酱，在XX大学读研二，爱好是拍照和被拍，大家可以在B站找到我跳舞的视频，比如av170001。我的另外一个爱好是写代码……”</p>
<p>当一个文科妹子说自己喜欢写代码的时候，整个办公室热闹了起来。</p>
<p>“P酱，听说你喜欢写代码，那你写过什么东西吗？”新人介绍会议结束以后，我问P酱。</p>
<p>“一般都是各种分析程序，我们的专业要做很多调查报告，他们都是用Excel来计算的。我喜欢用Python来把这些统计过程自动化。后来也写过自动写诗的程序、鬼畜视频生成器等等。”</p>
<p>“真不敢相信你是文科生。这么说你的兴趣是数据分析方向咯？”</p>
<p>“其实我对师父你做的爬虫很有兴趣。但是听说会经常和网站发生对抗？女孩子还是不要打打杀杀的好~”</p>
<p>于是我让P酱负责对爬虫的原始数据进行清洗、整理并做简单的分析。</p>
<h2 id="一种船新的数据储存方式"><a href="#一种船新的数据储存方式" class="headerlink" title="一种船新的数据储存方式"></a>一种船新的数据储存方式</h2><p>“P酱，爬虫抓到的原始数据是存放在MongoDB里面的，你的Python还不错吧，你试一试用Python来读写MongoDB看看。”</p>
<p>“MongoDB是什么呀？”</p>
<p>“是一个和MySQL不太一样的数据库。”</p>
<p>“MySQL我知道，MongoDB和MySQL有什么不一样呢？”</p>
<p>“我举个例子，当你要插入数据的时候，你需要做的，就是‘插入’。咳咳，你不要脸红，我是指你不需要写SQL语句、不需要建表、不需要提前定义字段。仅仅只需要一行代码就能够实现了。我这里给你写了一篇文档，讲到了MongoDB的增删改查，你试一试。数据库已经给你搭建好了，你直接连上去用吧”</p>
<p>半天以后。</p>
<p>“师父，我已经会使用MongoDB啦。”</p>
<p>“你读爬虫的原始数据，主要涉及到的就是查询操作，为了巩固插入、修改和删除的操作，再给你一个小任务吧。试一试写一个人员管理系统吧。”</p>
<h2 id="既然有关系，就整整齐齐放在一起看吧"><a href="#既然有关系，就整整齐齐放在一起看吧" class="headerlink" title="既然有关系，就整整齐齐放在一起看吧"></a>既然有关系，就整整齐齐放在一起看吧</h2><p>“P酱，你看起来很高兴的样子啊。”</p>
<p>“因为我觉得MongoDB比起MySQL太简单了啊~”</p>
<p>“你确定？那我看看你怎么对整行数据去重的？”</p>
<p>“师父，我知道distinct关键字可以对一个字段去重。但是整行数据我是读出来用Python来去重的。”</p>
<p>“这个时候你就要用到MongoDB的聚合查询了。文档已经给你写好了，拿去看吧。”</p>
<p>“还有还有，这里你把店铺信息和菜单信息放在了两个集合里面，我怎么样才能把他们联表查询出来呢？”</p>
<p>“联表查询是MySQL里面的操作，在MongoDB里面，没有<code>表</code>，只有<code>集合</code>，所以叫做<code>联集合查询</code>更恰当一些。这也是要用到聚合查询，也在这个文档里面了。”</p>
<h2 id="再给你一个玩具吧。"><a href="#再给你一个玩具吧。" class="headerlink" title="再给你一个玩具吧。"></a>再给你一个玩具吧。</h2><p>“P酱，之前让你做的爬虫数据监控系统怎么样了？”</p>
<p>“功能已经做好了，但是有一个地方查询起来特别慢。我已经加过索引了，但还是很慢。怀疑是同时联了四个集合的数据造成的。”</p>
<p>“这边的数据实际上每小时才更新一次，你没有必要每次刷新页面都去查询MongoDB的。我觉得是时候让你用一下Redis做缓存了。”</p>
<p>“Redis就是那个内存数据库吗？我知道我知道。”</p>
<p>“给你写了一份文档，包含Redis里面的各种数据类型和使用方式。你试一试把Redis和MongoDB结合起来看看能不能提高速度。”</p>
<h2 id="你怎么擅自加功能啊！"><a href="#你怎么擅自加功能啊！" class="headerlink" title="你怎么擅自加功能啊！"></a>你怎么擅自加功能啊！</h2><p>“P酱，你怎么在爬虫监控系统的网页上加了一个广播窗口？”</p>
<p>“呀，被师父发现了。因为我想到同一个爬虫可能会被几个人监控，所以就用Redis的发布订阅功能做出来了这个广播的功能。一旦爬虫状态发生改变，所有人都能收到推送。”</p>
<p>“既然你这么闲，那不如加上账号登录功能，把权限验证也做上去？不同的人只能看到自己负责的爬虫。顺便你可以试一试用Redis实现……”</p>
<p>“实现布隆过滤器和Session管理是吗？”</p>
<p>“你怎么知道我要说什么？”</p>
<p>“因为我早上看到你在文档上面更新了布隆过滤器和Session管理相关的内容啊~”</p>
<h2 id="红色的锁？"><a href="#红色的锁？" class="headerlink" title="红色的锁？"></a>红色的锁？</h2><p>“师父师父，你知道什么是RedLock吗？”</p>
<p>“你学得这么快？都知道RedLock了？RedLock是Redis官方给出的分布式锁的算法。已经有很多编程语言实现它了。”</p>
<p>“原来RedLock只是一个算法啊……”</p>
<h2 id="为什么我学的这么快呢？"><a href="#为什么我学的这么快呢？" class="headerlink" title="为什么我学的这么快呢？"></a>为什么我学的这么快呢？</h2><p>“师父师父，我觉得很奇怪啊，为什么MongoDB和Redis我学得这么快呢？难道是因为他们本来就简单？还是因为我太聪明了？”</p>
<p>“为什么你不说是因为你师父教的好呢？“</p>
<p>“因为这是事实啊~不用我说出来~”</p>
<p>“咳咳，实际上是因为两个原因。一是你一直通过项目驱动来学习，先有需求，然后再去学习实现这个需求所要涉及到的技能。所以你知道你学的东西能用来干什么，自然就能学得快……”</p>
<p>“那第二个原因是什么呢？”</p>
<p>“第二个原因，我先问你一个问题，你会搭建Redis集群吗？会搭建MongoDB集群吗？知道什么叫做哨兵吗？你知道如何优化MongoDB的启动参数吗？”</p>
<p>“这…………好像都不知道额…………”</p>
<p>“因为你的角色是数据工程师，不是数据库工程师，所以数据库搭建、底层优化这些内容我都给你跳过了。”</p>
<p>“这些听起来都很重要啊，师父你会教我吗？”</p>
<p>“你想经常值夜班吗？想半夜3点被人打电话叫起来修数据库吗？认清自己的定位啊，数据库工程师的技能当然很重要，但你是要成为数据工程师的人，技能树应该点在合适的方向。”</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来，P酱成了别人的女朋友。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-02-22-22-33-30.png" alt=""></p>
<p>幸好我还有左手和右手，于是我把我给P酱总结的文档编撰成了《左手MongoDB，右手Redis——从入门到商业实战》这本书。本书现在已经在京东、亚马逊、淘宝上架。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-02-23-13-22-19.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-02-23-13-22-45.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-02-23-13-23-29.png" alt=""></p>
<p>这本书的定位是MongoDB和Redis的应用，所以有意弱化了数据库的搭建、维护和底层优化。所以本书可能不适合数据库工程师。</p>
<p>希望本书能够给那些一直想掌握MongoDB、Redis，但是又不知道从何处下手的读者，提供一个学习的方向。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章没有代码，请放心阅读。&lt;/p&gt;
&lt;p&gt;程序员最宝贵的东西是生命，生命属于程序员只有一次。一个程序员的一生应该这样度过：当她回首往事的时候，她不会因为搭建环境浪费时间而悔恨，也不会因为集群无法运行而羞耻。这样，在她开发的时候，她能够说：“我的整个生命和全部精力，都已经献给了开发中最重要的事情——设计程序，实现程序和调Bug。” ——P酱。&lt;/p&gt;
&lt;p&gt;P酱是公司新来的实习生妹子。听说是一个文科生。文科生应该会去文案组或者策划组吧。什么？来数据组？让我来带？&lt;/p&gt;
&lt;p&gt;于是我和P酱&lt;del&gt;生活&lt;/del&gt;工作在了一起。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.kingname.info/categories/MongoDB/"/>
    
      <category term="Redis" scheme="https://www.kingname.info/categories/MongoDB/Redis/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="MongoDB" scheme="https://www.kingname.info/tags/MongoDB/"/>
    
      <category term="Redis" scheme="https://www.kingname.info/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>一行js代码识别Selenium+Webdriver及其应对方案</title>
    <link href="https://www.kingname.info/2019/02/12/hide-webdriver/"/>
    <id>https://www.kingname.info/2019/02/12/hide-webdriver/</id>
    <published>2019-02-12T07:11:14.000Z</published>
    <updated>2019-02-12T12:51:18.450Z</updated>
    
    <content type="html"><![CDATA[<p>有不少朋友在开发爬虫的过程中喜欢使用Selenium + Chromedriver，以为这样就能做到不被网站的反爬虫机制发现。</p>
<p>先不说淘宝这种基于用户行为的反爬虫策略，仅仅是一个普通的小网站，使用一行Javascript代码，就能轻轻松松识别你是否使用了Selenium + Chromedriver模拟浏览器。</p>
<p>我们来看一个例子。</p>
<a id="more"></a>
<p>使用下面这一段代码启动Chrome窗口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</div><div class="line"></div><div class="line">driver = Chrome()</div></pre></td></tr></table></figure>
<p>现在，在这个窗口中打开开发者工具，并定位到Console选项卡，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499558287238.jpg" alt=""></p>
<p>现在，在这个窗口输入如下的js代码并按下回车键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.navigator.webdriver</div></pre></td></tr></table></figure>
<p>可以看到，开发者工具返回了<code>true</code>。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499559010932.jpg" alt=""></p>
<p>但是，如果你打开一个普通的Chrome窗口，执行相同的命令，可以发现这行代码的返回值为<code>undefined</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499560533146.jpg" alt=""></p>
<p>所以，如果网站通过js代码获取这个参数，返回值为<code>undefined</code>说明是正常的浏览器，返回<code>true</code>说明用的是Selenium模拟浏览器。一抓一个准。这里给出一个检测Selenium的js代码例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">webdriver = <span class="built_in">window</span>.navigator.webdriver;</div><div class="line"><span class="keyword">if</span>(webdriver)&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'你这个傻逼你以为使用Selenium模拟浏览器就可以了？'</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'正常浏览器'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>网站只要在页面加载的时候运行这个js代码，就可以识别访问者是不是用的Selenium模拟浏览器。如果是，就禁止访问或者触发其他反爬虫的机制。</p>
<p>那么对于这种情况，在爬虫开发的过程中如何防止这个参数告诉网站你在模拟浏览器呢？</p>
<p>可能有一些会js的朋友觉得可以通过覆盖这个参数从而隐藏自己，但实际上这个值是不能被覆盖的：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499566165239.jpg" alt=""></p>
<p>对js更精通的朋友，可能会使用下面这一段代码来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperties(navigator, &#123;<span class="attr">webdriver</span>:&#123;<span class="attr">get</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="literal">undefined</span>&#125;&#125;);</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499575706517.jpg" alt=""></p>
<p>确实修改成功了。这种写法就万无一失了吗？并不是这样的，如果此时你在模拟浏览器中通过点击链接、输入网址进入另一个页面，或者开启新的窗口，你会发现，<code>window.navigator.webdriver</code>又变成了<code>true</code>。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499577743175.jpg" alt=""></p>
<p>那么是不是可以在每一个页面都打开以后，再次通过webdriver执行上面的js代码，从而实现在每个页面都把<code>window.navigator.webdriver</code>设置为<code>undefined</code>呢？也不行。</p>
<p>因为当你执行：<code>driver.get(网址)</code>的时候，浏览器会打开网站，加载页面并运行网站自带的js代码。所以在你重设<code>window.navigator.webdriver</code>之前，实际上网站早就已经知道你是模拟浏览器了。</p>
<p>接下来，又有朋友提出，可以通过编写Chrome插件来解决这个问题，让插件里面的js代码在网站自带的所有js代码之前执行。</p>
<p>这样做当然可以，不过有更简单的办法，只需要设置Chromedriver的启动参数即可解决问题。</p>
<p>在启动Chromedriver之前，为Chrome开启实验性功能参数<code>excludeSwitches</code>，它的值为<code>[&#39;enable-automation&#39;]</code>，完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Chrome</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</div><div class="line"></div><div class="line">option = ChromeOptions()</div><div class="line">option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])</div><div class="line">driver = Chrome(options=option)</div></pre></td></tr></table></figure>
<p>此时启动的Chrome窗口，在右上角会弹出一个提示，不用管它，不要点击<code>停用</code>按钮。</p>
<p>再次在开发者工具的Console选项卡中查询<code>window.navigator.webdriver</code>，可以发现这个值已经自动变成<code>undefined</code>了。并且无论你打开新的网页，开启新的窗口还是点击链接进入其他页面，都不会让它变成<code>true</code>。运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/15499583523223.jpg" alt=""></p>
<p>截至2019年02月12日20:46分，本文所讲的方法可以用来登录知乎。如果使用 Selenium 直接登录知乎，会弹出验证码；先使用本文的方法再登录知乎，能够成功伪装成真实的浏览器，不会弹出验证码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少朋友在开发爬虫的过程中喜欢使用Selenium + Chromedriver，以为这样就能做到不被网站的反爬虫机制发现。&lt;/p&gt;
&lt;p&gt;先不说淘宝这种基于用户行为的反爬虫策略，仅仅是一个普通的小网站，使用一行Javascript代码，就能轻轻松松识别你是否使用了Selenium + Chromedriver模拟浏览器。&lt;/p&gt;
&lt;p&gt;我们来看一个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Selenium" scheme="https://www.kingname.info/tags/Selenium/"/>
    
      <category term="Chromedriver" scheme="https://www.kingname.info/tags/Chromedriver/"/>
    
  </entry>
  
  <entry>
    <title>在Python中，a += b并不总是等价于a = a + b</title>
    <link href="https://www.kingname.info/2019/01/29/iadd/"/>
    <id>https://www.kingname.info/2019/01/29/iadd/</id>
    <published>2019-01-29T13:19:55.000Z</published>
    <updated>2019-01-29T13:24:43.546Z</updated>
    
    <content type="html"><![CDATA[<p>大家经常在一些博客中看到这样的说法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a += 1</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = a + 1</div></pre></td></tr></table></figure>
<p>这种说法实际上并不准确。</p>
<p>我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; a += (4,)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">[1, 2, 3, 4]</div><div class="line"></div><div class="line">&gt;&gt;&gt; a = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; a = a + (4,)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: can only concatenate list (not &quot;tuple&quot;) to list</div></pre></td></tr></table></figure>
<p>这里报错了，说明<code>a += b</code>和<code>a = a + b</code>并不是完全等价的。</p>
<a id="more"></a>
<p>实际上，这是由于<code>+=</code>会首先调用左边这个对象的<code>__iadd__</code>方法，如果没有<code>__iadd__</code>方法，就会调用<code>__add__</code>方法。但是如果直接使用<code>+</code>号，就会直接调用<code>__add__</code>方法。而对于字符串、数字、浮点数这种不可变对象，他们没有<code>__iadd__</code>方法，所以对他们来说，<code>a += b</code> 与 <code>a = a + b</code>是等价的。</p>
<p>但是列表是一个可变的容器，它内部是有<code>__iadd__</code>这个方法。对于列表来说，它的<code>__iadd__</code>方法的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def __iadd__(self, values):</div><div class="line">    self.extend(values)</div><div class="line">    return self</div></pre></td></tr></table></figure>
<p>这一段代码你可以在这里看到：<a href="https://github.com/python/cpython/blob/1b5f9c9653f348b0aa8b7ca39f8a9361150f7dfc/Lib/_collections_abc.py" target="_blank" rel="external">https://github.com/python/cpython/blob/1b5f9c9653f348b0aa8b7ca39f8a9361150f7dfc/Lib/_collections_abc.py</a></p>
<p>所以说，当你使用<code>+=</code>连接列表和元组的时候，本质上是列表使用<code>extend</code>把元组的内容添加进去。这样是不会报错的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.extend((<span class="number">4</span>,))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家经常在一些博客中看到这样的说法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;a += 1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;a = a + 1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种说法实际上并不准确。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a += (4,)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[1, 2, 3, 4]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = a + (4,)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;TypeError: can only concatenate list (not &amp;quot;tuple&amp;quot;) to list&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里报错了，说明&lt;code&gt;a += b&lt;/code&gt;和&lt;code&gt;a = a + b&lt;/code&gt;并不是完全等价的。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Airtest中如何使用无线模式控制手机</title>
    <link href="https://www.kingname.info/2019/01/28/wireless-mode-of-poco/"/>
    <id>https://www.kingname.info/2019/01/28/wireless-mode-of-poco/</id>
    <published>2019-01-28T13:48:20.000Z</published>
    <updated>2019-01-28T14:08:30.839Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.kingname.info/2019/01/19/use-airtest/">使用Airtest超快速开发App爬虫</a>文章的最后，我们留了一个尾巴：如何启动Airtest的无线模式，不用USB线就能控制手机？</p>
<p>本文将会讲到具体的做法。做法分为两种：第一种是在Airtest的IDE中控制手机。第二种是在Python代码里面控制远程手机。</p>
<a id="more"></a>
<h2 id="启动开启手机上的adb端口"><a href="#启动开启手机上的adb端口" class="headerlink" title="启动开启手机上的adb端口"></a>启动开启手机上的adb端口</h2><p>无论使用哪种方式，要远程控制手机，就需要首先把手机上的adb端口打开。这一步必需先用USB线把手机连上电脑。</p>
<p>在终端里面执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb tcpip 48887</div></pre></td></tr></table></figure>
<p>其中的端口号48887你可以自行设定为其他的端口号，但不能和已有的端口冲突。</p>
<p>命令执行完成以后，你就可以拔下USB线了。接下来就是远程控制手机。</p>
<h2 id="在AirtestIDE中无线遥控手机"><a href="#在AirtestIDE中无线遥控手机" class="headerlink" title="在AirtestIDE中无线遥控手机"></a>在AirtestIDE中无线遥控手机</h2><p>打开Airtest，点击下图红框框住的 remote connection:</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-28-21-56-01.png" alt=""></p>
<p>在弹出来的输入框中，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb connect 手机IP:端口</div></pre></td></tr></table></figure>
<p>其中手机的IP你可以在无线路由器中找到，也可以在手机的系统设置中找到。端口就是上一条命令设定的端口。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb connect 192.168.0.102:48887</div></pre></td></tr></table></figure>
<p>如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-28-21-57-21.png" alt=""></p>
<p>点击<code>connect</code>，此时手机就会在上方的 Device列表中出现。双击它就可以无线连接手机并看到手机屏幕了。</p>
<h2 id="在Python中控制手机"><a href="#在Python中控制手机" class="headerlink" title="在Python中控制手机"></a>在Python中控制手机</h2><p>首先说明，Airtest的官方文档有问题，如果你跟着文档来写代码，一定会失败。</p>
<p>官方文档中，在<a href="https://airtest.readthedocs.io/zh_CN/latest/README_MORE.html#connect-android-device" target="_blank" rel="external">https://airtest.readthedocs.io/zh_CN/latest/README_MORE.html#connect-android-device</a>有一段介绍如何连接远程安卓手机的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">本地设备</div><div class="line"><span class="comment"># connect a remote device using custom params</span></div><div class="line">connect_device(<span class="string">"android://adbhost:adbport/1234566?cap_method=javacap&amp;touch_method=adb"</span>)</div></pre></td></tr></table></figure>
<p>这个代码看起来，你可能会把Python代码写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> airtest.core.api <span class="keyword">import</span> *</div><div class="line">device_1 = connect_device(<span class="string">'android://192.168.0.100:48887/手机串号?cap_method=javacap&amp;touch_method=adb'</span>)</div></pre></td></tr></table></figure>
<p>如果你这样写，<strong>你一定无法连上手机</strong>。</p>
<p>正确的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from airtest.core.api import *</div><div class="line"></div><div class="line">device_1 = connect_device(&apos;android:///192.168.0.100:48887?cap_method=javacap&amp;touch_method=adb&apos;)</div></pre></td></tr></table></figure>
<p>只有按我这里的写法才能正确控制手机。如下面的gif所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/correct_method_of_connect.gif" alt=""></p>
<p>动图中涉及到的完整代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> airtest.core.api <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> poco.drivers.android.uiautomation <span class="keyword">import</span> AndroidUiautomationPoco</div><div class="line"></div><div class="line">device_1 = connect_device(<span class="string">'android:///192.168.0.100:48887?cap_method=javacap&amp;touch_method=adb'</span>)</div><div class="line"></div><div class="line">poco = AndroidUiautomationPoco(device_1, use_airtest_input=<span class="keyword">True</span>, screenshot_each_action=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"></div><div class="line">poco(text=<span class="string">"知乎"</span>).click()</div><div class="line">poco(name=<span class="string">"com.zhihu.android:id/input"</span>).click()</div><div class="line">poco(name=<span class="string">"com.zhihu.android:id/input"</span>).set_text(<span class="string">'古剑奇谭三'</span>)</div><div class="line"></div><div class="line">time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line">poco(name=<span class="string">'com.zhihu.android:id/magi_title'</span>, textMatches=<span class="string">'^古剑奇谭三.*$'</span>).click()</div><div class="line">poco.swipe([<span class="number">0.5</span>, <span class="number">0.8</span>], [<span class="number">0.5</span>, <span class="number">0.2</span>])</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://www.kingname.info/2019/01/19/use-airtest/&quot;&gt;使用Airtest超快速开发App爬虫&lt;/a&gt;文章的最后，我们留了一个尾巴：如何启动Airtest的无线模式，不用USB线就能控制手机？&lt;/p&gt;
&lt;p&gt;本文将会讲到具体的做法。做法分为两种：第一种是在Airtest的IDE中控制手机。第二种是在Python代码里面控制远程手机。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Airtest" scheme="https://www.kingname.info/tags/Airtest/"/>
    
  </entry>
  
  <entry>
    <title>使用Airtest超快速开发App爬虫</title>
    <link href="https://www.kingname.info/2019/01/19/use-airtest/"/>
    <id>https://www.kingname.info/2019/01/19/use-airtest/</id>
    <published>2019-01-19T04:46:41.000Z</published>
    <updated>2019-01-19T12:04:42.140Z</updated>
    
    <content type="html"><![CDATA[<p>想开发网页爬虫，发现被反爬了？想对 App 抓包，发现数据被加密了？不要担心，使用 Airtest 开发 App 爬虫，只要人眼能看到，你就能抓到，最快只需要2分钟，兼容 Unity3D、Cocos2dx-*、Android 原生 App、iOS App、Windows Mobile……。</p>
<a id="more"></a>
<p>Airtest是网易开发的手机UI界面自动化测试工具，它原本的目的是通过所见即所得，截图点击等等功能，简化手机App图形界面测试代码编写工作。</p>
<p>爬虫开发本着天下工具为我所用，能让我获取数据的工具都能用来开发爬虫这一信念，决定使用Airtest来开发手机App爬虫。</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>由于本文的目的是介绍如何使用Airtest来开发App爬虫，那么Airtest作为测试开发工具的方法介绍将会一带而过，仅仅说明如何安装并进行基本的操作。</p>
<h3 id="安装Airtest"><a href="#安装Airtest" class="headerlink" title="安装Airtest"></a>安装Airtest</h3><p>从Airtest官网：<a href="https://airtest.netease.com" target="_blank" rel="external">https://airtest.netease.com</a>下载Airtest，然后像安装普通软件一样安装即可。安装过程没有什么需要特别说明的地方。Airtest已经帮你打包好了开发需要的全部环境，所以安装完成Airtest以后就能够直接使用了。</p>
<p>Airtest运行以后的界面如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-10-30.png" alt=""></p>
<h3 id="连接手机"><a href="#连接手机" class="headerlink" title="连接手机"></a>连接手机</h3><p>以Android手机为例，由于Airtest会通过adb命令安装两个辅助App到手机上，再用adb命令通过控制这两个辅助App进而控制手机，因此首先需要确保手机的<code>adb调试</code>功能是打开的，并允许通过adb命令安装App到手机上。</p>
<p>启动Airtest以后，把Android手机连接到电脑上，点击下图方框中的<code>refresh ADB</code>：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-16-45.png" alt=""></p>
<p>此时在Airtest界面右上角应该能够看到手机的信息，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-17-51.png" alt=""></p>
<p>点击<code>connect</code>按钮，此时可以在界面上看到手机的界面，并且当你手动操作手机屏幕时，Airtest中的手机画面实时更新。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-21-40.png" alt=""></p>
<p>对于某些手机，例如小米，在第一次使用Airtest时，请注意手机上将会弹出提示，询问你是否允许安装App，此时需要点击允许按钮。</p>
<h3 id="打开微信"><a href="#打开微信" class="headerlink" title="打开微信"></a>打开微信</h3><p>先通过一个简单的例子，来看看如何快速上手Airtest，稍后再来详解。</p>
<p>例如我现在想使用电脑控制手机，打开微信。</p>
<p>此时，点击下图中方框框住的<code>touch</code>按钮：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-27-32.png" alt=""></p>
<p>此时，把鼠标移动到Airtest右边的手机屏幕区域，鼠标会变成十字型。在微信图标的左上角按下鼠标左键不放，并拖到微信右下角松开鼠标。此时请注意中间代码区域发生了什么变化，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-30-15.png" alt=""></p>
<p>好了。以上就是你需要使用电脑打开微信所要进行的全部操作。</p>
<p>点击上方工具栏中的三角形图标，运行代码，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-13-32-29.png" alt=""></p>
<p>代码运行完成以后，微信被打开了。</p>
<h3 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h3><p>在有了一个直观的使用以后，我们再来介绍一下Airtest的界面，将会更加有针对性。</p>
<p>Airtest的界面如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-04-37.png" alt=""></p>
<p>这里，我把Airtest分成了A-F6个区域，他们的功能如下：</p>
<ul>
<li>A区：常用操作功能区</li>
<li>B区：Python代码编写区</li>
<li>C区：运行日志区</li>
<li>D区：手机屏幕区</li>
<li>E区：App页面布局信息查看区</li>
<li>F区：工具栏</li>
</ul>
<p>A区是常用的<code>基于图像识别</code>的屏幕操作功能，例如：</p>
<ul>
<li><code>touch</code>: 点击屏幕元素</li>
<li><code>swipe</code>: 滑动屏幕</li>
<li><code>exists</code>: 判断屏幕元素是否存在</li>
<li><code>text</code>: 在输入框中输入文字</li>
<li><code>snashot</code>: 截图</li>
<li>……</li>
</ul>
<p>一般来说，是点击A区里面的某一个功能，然后在D区屏幕上进行框选操作，B区就会自动生成相应的操作代码。</p>
<p>B区用来显示和编写Python代码。在多数情况下，不需要手动写代码，因为代码会根据你在手机屏幕上面的操作自动生成。只有一些需要特别定制化的动作才需要修改代码。</p>
<p>D区显示了手机屏幕，当你操作手机真机时，这个屏幕会实时刷新。你也可以直接在D区屏幕上使用鼠标操作手机，你的操作动作会被自动在真机上执行。</p>
<p>F区是一些常用工具，从左到右，依次为：</p>
<ol>
<li>新建项目</li>
<li>打开项目</li>
<li>保存项目</li>
<li>运行代码</li>
<li>停止代码</li>
<li>查看运行报告</li>
</ol>
<p>其中1-5很好理解，那么什么是查看运行报告呢？</p>
<p>当你至少运行了一次以后，点击这个功能，会自动给你打开一个网页。网页如下图所示，这是你的代码的运行报告，详细到每一步操作了什么元素。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/launch_report.png" alt=""></p>
<p>通过截图功能操作手机虽然方便，但是截图涉及到分辨率的问题，代码不能在不同的手机上通用。所以对于A区的功能，做点简单操作即可，不用深入了解。</p>
<p>更高级的功能，需要通过E区实现。</p>
<h2 id="基于App布局信息操作手机"><a href="#基于App布局信息操作手机" class="headerlink" title="基于App布局信息操作手机"></a>基于App布局信息操作手机</h2><h3 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h3><p>App的布局信息就像网页的HTML一样，保存了App上面各个元素的相对位置和各个参数。对于一个App而言，在不同分辨率的手机上，可能相同的元素有着不同的坐标点，但是这个元素的属性参数一般是不会变的。因此，如果使用元素的属性参数来寻找并控制这个元素，就能实现在不同分辨率手机上的精确定位。</p>
<p>App的布局信息的格式与App的开发环境有关。点击F区的下拉菜单，可以看到这里能够指定不同的App开发环境。其中的<code>Unity</code>、<code>Cocos-*</code>等等一般是做游戏用的，<code>Android</code>是安卓原生App，<code>iOS</code>是苹果的App……如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-17-32.png" alt=""></p>
<p>以手机版知乎为例，由于它是Android原生的App，所以在F区下拉菜单选择<code>Android</code>，此时注意B区弹出提示，询问你是否要插入poco初始代码到当前输入光标的位置，点击<code>Yes</code>，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-25-17.png" alt=""></p>
<p>此时，B区自动插入了一段代码，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-27-11.png" alt=""></p>
<h3 id="定位并点击"><a href="#定位并点击" class="headerlink" title="定位并点击"></a>定位并点击</h3><p>现在，点击E区的锁形图标，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-39-30.png" alt=""></p>
<p>锁形图标激活以后，你再操作D区的屏幕，点击<code>知乎</code>App下面的<code>知乎</code>两个字，会发现屏幕上被点击的App并不会打开。但E区和C区却发生了变化，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-45-24.png" alt=""></p>
<p>其中E区显示的树状结构就是当前屏幕的布局信息，这与Chrome开发者工具里面显示的HTML结构如出一辙。C区显示的是当前被我点中的元素的信息。</p>
<p>请注意在这些元素信息中，有一个<code>text</code>属性，它的值为<code>知乎</code>。那么，这个属性就可以作为一个定位元素，于是可以在B区编写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(text=<span class="string">"知乎"</span>).click()</div></pre></td></tr></table></figure>
<p>写完代码以后运行程序，可以看到知乎App被打开了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-14-48-47.png" alt=""></p>
<blockquote>
<p>注意，如果你发现手机真机显示的界面与Airtest屏幕显示的手机界面不一致，可能是因为Airtest的屏幕被你锁定了。在F区点一下锁形图标，取消锁定，Airtest中的手机屏幕就会更新了。</p>
</blockquote>
<h3 id="定位并输入"><a href="#定位并输入" class="headerlink" title="定位并输入"></a>定位并输入</h3><p>打开知乎以后，我想使用知乎的搜索功能，那么继续，把锁形图标激活，然后点击知乎顶部的搜索框，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-06-41.png" alt=""></p>
<p>继续看C区显示的搜索框属性，可以看到这里有一个<code>name</code>属性，它的值是<code>com.zhihu.android:id/input</code>，还有一个<code>text</code>属性，它的值为<code>蔡徐坤任 NBA 新春贺岁大使</code>。能不能像前面打开知乎一样，使用<code>text</code>这个属性呢？也行，也不行。说它行，是因为你这么做确实现在能工作；说它不行，因为这是知乎的热门搜索关键词，随时会改变。你今天使用这一句话成功了，明天热门关键词变化了，那么你的代码就无法使用了。所以此时需要使用<code>name</code>这个属性。</p>
<p>常见的基本上不会变化的属性包含但不限于：<code>name</code> <code>type</code> <code>resourceId</code> <code>package</code>。</p>
<p>另外还有一点，知乎首页的这个搜索框，实际上是不能输入内容的，当你点击以后，会跳转到另一个页面，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-11-17.png" alt=""></p>
<p>因此你需要先点击一下这个输入框，跳转到真正的搜索界面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=&quot;com.zhihu.android:id/input&quot;).click()</div></pre></td></tr></table></figure>
<p>在真正的搜索界面如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-12-50.png" alt=""></p>
<p>可以看到，<code>name</code>属性的值依然是<code>com.zhihu.android:id/input</code>，此时就可以输入内容了。</p>
<p>输入内容使用的方法为<code>set_text</code>，用法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=<span class="string">"com.zhihu.android:id/input"</span>).set_text(<span class="string">'古剑奇谭三'</span>)</div></pre></td></tr></table></figure>
<h3 id="定位并筛选"><a href="#定位并筛选" class="headerlink" title="定位并筛选"></a>定位并筛选</h3><p>输入了搜索关键词以后，再来看看当前页面，搜索出现了三个结果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-17-58.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-18-36.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-19-14.png" alt=""></p>
<p>通过对比这三个结果的属性信息，发现他们的<code>name</code>属性都是相同的，而<code>text</code>不同。如果像下面这样写点击动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=&apos;com.zhihu.android:id/magi_title&apos;).click()</div></pre></td></tr></table></figure>
<p>那么默认就会点击第一个搜索结果。</p>
<p>如果我想点击第二个搜索结果怎么办呢？可以这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=&apos;com.zhihu.android:id/magi_title&apos;, text=&apos;古剑奇谭（电视剧）&apos;).click()</div></pre></td></tr></table></figure>
<p>或者你也可以像列表一样使用索引定位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=<span class="string">'com.zhihu.android:id/magi_title'</span>)[<span class="number">1</span>].click()</div></pre></td></tr></table></figure>
<p>这两种写法的前提，都是我们已经知道了每个结果分别是什么。假设现在我就想搜索<code>古剑奇谭三</code>，但我不知道搜索结果是第几项，又应该怎么办呢？此时还可以使用正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(name=<span class="string">'com.zhihu.android:id/magi_title'</span>, textMatches=<span class="string">'^古剑奇谭三.*$'</span>).click()</div></pre></td></tr></table></figure>
<h3 id="滑动屏幕"><a href="#滑动屏幕" class="headerlink" title="滑动屏幕"></a>滑动屏幕</h3><p>进入搜索结果以后，需要查看下面的各种问题，此时就需要不断向上滑动屏幕。这里有一点需要特别注意，Airtest只能获取当前屏幕上的元素布局信息，不在屏幕上的内容是无法获取的。这一点和Selenium是不一样的。</p>
<p>滑动屏幕使用的命令为<code>swipe</code>，滑动屏幕需要使用坐标信息。但这种坐标和屏幕分辨率无关。这里的<code>坐标</code>定义为：(x, y)，其中x为横坐标，y为纵坐标。屏幕左上角为(0, 0)，屏幕右下角为(1, 1)，从左向右，横坐标从0逐渐增大到1，从上到下，纵坐标从0逐渐增大到1。</p>
<p>现在我要把屏幕向上滑动，那么在真机上面，我是先按住屏幕下方，然后把屏幕向上滑动，所以代码可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># poco.swipe(起点坐标，终点左边)</div><div class="line">poco.swipe([0.5, 0.8], [0.5, 0.2])</div></pre></td></tr></table></figure>
<p>方向示意图如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-42-43.png" alt=""></p>
<p>在一般情况下：</p>
<ul>
<li>向上滑动，只需要改动纵坐标，且起点值大于终点值</li>
<li>向下滑动，只需要改动纵坐标，且起点值小于终点值</li>
<li>向左滑动，只需要改动横坐标，且起点值大于终点值</li>
<li>向右滑动，只需要改动横坐标，且起点值小于终点值</li>
</ul>
<p>在爬虫开发中，涉及到的Airtest操作基本上已经介绍完毕。</p>
<h3 id="单独使用Python控制手机"><a href="#单独使用Python控制手机" class="headerlink" title="单独使用Python控制手机"></a>单独使用Python控制手机</h3><p>在Airtest操作手机虽然方便，但是不可能在每一台电脑上都安装Airtest吧。所以需要想办法把代码从Airtest这个程序中分离出来。</p>
<p>Airtest基于Python的一个开源库Poco开发，而在Airtest的B区写的Python代码，实际上就是Poco的代码。所以只要安装Poco库，就可以在Python中直接控制手机。</p>
<p>安装Poco库的命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pocoui</div></pre></td></tr></table></figure>
<p>这个库依赖的东西有点多，安装稍稍慢一些。安装完成以后，我们把代码复制到PyCharm中，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-16-59-52.png" alt=""></p>
<p>运行这段代码，如果是Linux或者macOS的用户，请注意看运行结果是不是有报错，提示adb没有运行权限。这是因为随Poco安装的adb没有运行权限，需要给它添加权限，在终端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># chmod +x 报错信息中给出的adb地址</div><div class="line"></div><div class="line">chmod +x /Users/kingname/.local/share/virtualenvs/ZhihuSpider/lib/python3.7/site-packages/airtest/core/android/static/adb/mac/adb(实际执行时请换成你的地址)</div></pre></td></tr></table></figure>
<p>命令运行完成以后再次执行代码，可以看到代码运行成功，手机被成功控制了，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-00-50.png" alt=""></p>
<h3 id="如何获取屏幕文字"><a href="#如何获取屏幕文字" class="headerlink" title="如何获取屏幕文字"></a>如何获取屏幕文字</h3><p>由于Airtest的编辑器中的代码运行后无法正常打印出中文，因此后面的代码都直接在PyCharm中执行。</p>
<p>既然要做爬虫，就需要获取手机上的文字内容。回到搜索页面，我想知道“古剑奇谭”三这个关键字能搜索出多少条结果，每条结果有多少个讨论，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-50-43.png" alt=""></p>
<p>此时我们需要做两件事情：</p>
<ol>
<li>分别查看每一个搜索结果</li>
<li>获取屏幕上的文字</li>
</ol>
<p>E区的树状结构如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-15-54-25.png" alt=""></p>
<p>每一个搜索结果的标题作为text属性的值，在<code>name=&#39;com.zhihu.android:id/magi_title&#39;</code>对应的元素中；每一个搜索结果的讨论数作为text属性的值，在<code>name=&#39;com.zhihu.android:id/magi_count&#39;</code>对应的元素中。</p>
<p>最直接的做法就是分别获取三个标题和三个讨论数，然后把它们合并在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">title_obj_list = poco(name=<span class="string">'com.zhihu.android:id/magi_title'</span>)</div><div class="line">title_list = [title.get_text() <span class="keyword">for</span> title <span class="keyword">in</span> title_obj_list]</div><div class="line"></div><div class="line">discuss_obj_list = poco(name=<span class="string">'com.zhihu.android:id/magi_count'</span>)</div><div class="line">discuss_list = [discuss.get_text() <span class="keyword">for</span> discuss <span class="keyword">in</span> discuss_obj_list]</div><div class="line"></div><div class="line"><span class="keyword">for</span> title, discuss <span class="keyword">in</span> zip(title_list, discuss_list):</div><div class="line">    print(title, discuss)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-05-27.png" alt=""></p>
<p>但是这种做法实际上是很危险的，假设会有某一个很生僻的搜索结果，只有标题没有讨论数，那么这样分开抓取再组合的做法，就会导致最后匹配错位。所以合理的做法是先抓大再抓小。每一组标题和讨论数，他们都有自己的父节点，如下图箭头所指向的三个<code>android.widget.LinearLayout</code>:</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-16-07-11.png" alt=""></p>
<p>那么现在，使用先抓大再抓小的技巧，先把每一组结果的父节点抓下来，再到每一个结果里面分别获取标题和讨论数。</p>
<p>然而这个父节点又怎么获取呢？如下图所示，这个父节点每一个属性值都没有什么特殊的，写任何一个都有可能与别的节点撞上。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-15-07.png" alt=""></p>
<p>此时，最简单的办法，就是在E区，双击父节点。定位代码就会自动添加，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-16-51.png" alt=""></p>
<p>这个定位代码看起来非常复杂，但实际上它的内在逻辑非常简单，就是从顶层一层一层往下找而已。</p>
<p>自动生成的定位代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(&quot;android.widget.LinearLayout&quot;).offspring(&quot;com.zhihu.android:id/action_bar_root&quot;).offspring(&quot;com.zhihu.android:id/parent_fragment_content_id&quot;).offspring(&quot;android.support.v7.widget.RecyclerView&quot;).child(&quot;android.widget.LinearLayout&quot;)[0]</div></pre></td></tr></table></figure>
<p>在这个自动生成的定位代码中，我们看到了<code>offspring</code>、<code>child</code>这两种方法。其中<code>child</code>代表子节点，<code>offspring</code>代表孙节点、孙节点的子节点、孙节点的孙节点……。简言之，使用<code>child</code>只会在子节点中搜索需要的内容，而使用<code>offspring</code>会像文件夹递归一样把里面的所有节点都遍历一次，直到找到符合条件的属性为止。显然，offspring速度会比child慢。</p>
<p>实际上，我们可以对这个定位代码做一些精简：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">poco(&quot;com.zhihu.android:id/parent_fragment_content_id&quot;).offspring(&quot;android.support.v7.widget.RecyclerView&quot;).child(&quot;android.widget.LinearLayout&quot;)[0]</div></pre></td></tr></table></figure>
<p>这个精简的方法，与从Chrome复制的XPath中进行精简是一样的逻辑，根本原则就是找到“独一无二”的属性值，然后用这个属性值来进行定位。</p>
<p>由于我点击的是第一个搜索结果，所以定位代码的最后有一个<code>[0]</code>。现在由于需要获得所有搜索结果的内容，所以应该去掉<code>[0]</code>而使用for循环展开，然后获取里面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">result_obj = poco(&quot;com.zhihu.android:id/parent_fragment_content_id&quot;).offspring(&quot;android.support.v7.widget.RecyclerView&quot;).child(&quot;android.widget.LinearLayout&quot;)</div><div class="line">for result in result_obj:</div><div class="line">    title = result.child(name=&apos;com.zhihu.android:id/magi_title&apos;).get_text()</div><div class="line">    count = result.child(name=&apos;com.zhihu.android:id/magi_count&apos;).get_text()</div><div class="line">    print(title, count)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-30-30.png" alt=""></p>
<h2 id="控制多台手机"><a href="#控制多台手机" class="headerlink" title="控制多台手机"></a>控制多台手机</h2><p>当我们在电脑上插入多个Android手机时，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices -l</div></pre></td></tr></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-37-16.png" alt=""></p>
<p>每个手机都会被列出来。在最左边的编号就是手机串号。使用这个串号可以指定多个手机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from airtest.core.api import auto_setup</div><div class="line">from airtest.core.android import Android</div><div class="line">from poco.drivers.android.uiautomation import AndroidUiautomationPoco</div><div class="line">auto_setup(__file__)</div><div class="line"></div><div class="line">device_1 = Android(&apos;76efadf3a7ce4&apos;)</div><div class="line">device_2 = Android(&apos;adfasdfasf23&apos;)</div><div class="line">device_3 = Android(&apos;adifu39ernla&apos;)</div><div class="line"></div><div class="line">poco_1 = AndroidUiautomationPoco(device_1, use_airtest_input=True, screenshot_each_action=False)</div><div class="line">poco_2 = AndroidUiautomationPoco(device_2, use_airtest_input=True, screenshot_each_action=False)</div><div class="line">poco_3 = AndroidUiautomationPoco(device_3, use_airtest_input=True, screenshot_each_action=False)</div></pre></td></tr></table></figure>
<p>通过这种方式，在一台电脑上使用USBHub，连上二三十台手机是完全没有问题的。</p>
<h2 id="无线模式"><a href="#无线模式" class="headerlink" title="无线模式"></a>无线模式</h2><p>Airtest支持无线模式，不需要USB，只要电脑和手机连接同一个WIFI就能控制：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wireless_control.gif" alt=""></p>
<p>如果大家对如何开启无线模式有兴趣，请留言，我就会继续写。</p>
<h2 id="搭建手机爬虫集群"><a href="#搭建手机爬虫集群" class="headerlink" title="搭建手机爬虫集群"></a>搭建手机爬虫集群</h2><p>一台电脑可以连接三十台手机，那么如果有很多电脑和很多手机，就可以实现手机爬虫集群，其运行效果如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-19-17-44-57.png" alt=""></p>
<p>关于如何搭建爬虫集群，已经超出本文的范围了。如果大家有兴趣，可以阅读我的书：<a href="https://item.jd.com/12436581.html?dist=jd" target="_blank" rel="external">Python爬虫开发 从入门到实战</a>第十章对于如何搭建手机爬虫集群有详细的说明和注意事项。</p>
<p>如果对我的书有兴趣，请关注我的微信公众号与我交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想开发网页爬虫，发现被反爬了？想对 App 抓包，发现数据被加密了？不要担心，使用 Airtest 开发 App 爬虫，只要人眼能看到，你就能抓到，最快只需要2分钟，兼容 Unity3D、Cocos2dx-*、Android 原生 App、iOS App、Windows Mobile……。&lt;/p&gt;
    
    </summary>
    
      <category term="Airtest" scheme="https://www.kingname.info/categories/Airtest/"/>
    
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Airtest" scheme="https://www.kingname.info/tags/Airtest/"/>
    
  </entry>
  
  <entry>
    <title>为什么Python中“2 == 2 &gt; 1”结果为True？</title>
    <link href="https://www.kingname.info/2019/01/10/chained-comparisons/"/>
    <id>https://www.kingname.info/2019/01/10/chained-comparisons/</id>
    <published>2019-01-10T14:00:04.000Z</published>
    <updated>2019-01-10T14:16:01.668Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，你可能会发现这样一个奇怪的现象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> == <span class="number">2</span> &gt; <span class="number">1</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span> == <span class="number">2</span>) &gt; <span class="number">1</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> == (<span class="number">2</span> &gt; <span class="number">1</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>为什么会出现<code>2 == 2 &gt; 1</code>的结果为<code>True</code>？如果说这是运算符的优先级问题，那么后两个式子为什么又都是<code>False</code>？</p>
<p>实际上这涉及到了Python的<code>链式对比(Chained Comparisons)</code>。在其他语言中，有一个变量<code>x</code>，如果要判断x是否大于1，小于5，可能需要这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (1 &lt; x and x &lt; 5)</div></pre></td></tr></table></figure>
<p>但是在Python中，可以这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; x &lt; <span class="number">5</span></div></pre></td></tr></table></figure>
<p>Python能够正确处理这个链式对比的逻辑。</p>
<p>回到最开始的问题上，<code>==</code>等于符号和<code>&lt;</code>小于符号，本质没有什么区别。所以实际上<code>2==2&gt;1</code>也是一个链式对比的式子，它相当于<code>2==2 and 2&gt;1</code>。此时，这个式子就等价于<code>True and True</code>。所以返回的结果为True。</p>
<p>关于链式对比，可以看官方文档：<a href="https://docs.python.org/3/reference/expressions.html#comparisons" target="_blank" rel="external">https://docs.python.org/3/reference/expressions.html#comparisons</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中，你可能会发现这样一个奇怪的现象：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;li
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
</feed>
