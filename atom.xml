<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢乾坤 | Kingname</title>
  <subtitle>给时光以生命。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingname.info/"/>
  <updated>2019-11-03T02:10:08.035Z</updated>
  <id>https://www.kingname.info/</id>
  
  <author>
    <name>谢乾坤 | Kingname</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 yield 压平多层字典列表混合嵌套数据</title>
    <link href="https://www.kingname.info/2019/11/03/flat-dict-with-list/"/>
    <id>https://www.kingname.info/2019/11/03/flat-dict-with-list/</id>
    <published>2019-11-03T02:08:53.000Z</published>
    <updated>2019-11-03T02:10:08.035Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章里面，我们讲到了如何使用Python的<code>yield</code>关键字简化代码，压平多层嵌套字典的。</p>
<p>那么如果我们的数据不仅仅有字典，还有列表，是一个字典列表多层嵌套的数据怎么办呢？例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nest_dict = &#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b'</span>: &#123;</div><div class="line">        <span class="string">'c'</span>: <span class="number">2</span>,</div><div class="line">        <span class="string">'d'</span>: <span class="number">3</span>,</div><div class="line">        <span class="string">'e'</span>: &#123;<span class="string">'f'</span>: <span class="number">4</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'g'</span>: &#123;<span class="string">'h'</span>: <span class="number">5</span>&#125;,</div><div class="line">    <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line">    <span class="string">'j'</span>: &#123;<span class="string">'k'</span>: &#123;<span class="string">'l'</span>: &#123;<span class="string">'m'</span>: <span class="number">8</span>&#125;&#125;&#125;,</div><div class="line">    <span class="string">'n'</span>: [<span class="number">1</span>, &#123;<span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'p'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  <span class="string">'q'</span>: &#123;<span class="string">'r'</span>: &#123;<span class="string">'s'</span>: <span class="number">100</span>&#125;&#125;&#125;, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">5</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，请停下来，敲一敲代码，想想如何把处理列表的逻辑添加进去。</p>
<p>首先，我们来看一下最终被压平以后的数据长什么样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'b_c'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'b_d'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'b_e_f'</span>: <span class="number">4</span>,</div><div class="line"> <span class="string">'g_h'</span>: <span class="number">5</span>,</div><div class="line"> <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line"> <span class="string">'j_k_l_m'</span>: <span class="number">8</span>,</div><div class="line"> <span class="string">'n_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_o'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_p_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_1_p_1'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'n_1_p_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_1_q_r_s'</span>: <span class="number">100</span>,</div><div class="line"> <span class="string">'n_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_3_0'</span>: <span class="number">1</span>,</div><div class="line"> <span class="string">'n_3_1'</span>: <span class="number">2</span>,</div><div class="line"> <span class="string">'n_3_2'</span>: <span class="number">3</span>,</div><div class="line"> <span class="string">'n_4'</span>: <span class="number">5</span>&#125;</div></pre></td></tr></table></figure>
<p>对于<code>&#39;n&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>这种形式的数据，我们把它转换为： <code>{&#39;n_0&#39;: &#39;a&#39;, &#39;n_1&#39;: &#39;b&#39;, &#39;n_2&#39;: &#39;c&#39;}</code></p>
<a id="more"></a>
<p>我们原来的核心代码是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">if</span> isinstance(value, dict):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>你的第一反应，是不是这样修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">if</span> isinstance(value, dict):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">elif</span> isinstance(value, list):</div><div class="line">            <span class="string">"一大堆处理列表的代码"</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>如果你使用<code>return</code>和递归，你可能确实需要这样写。</p>
<p>但如果你使用<code>yield</code>关键字，那么，你虽然也要修改代码，可是修改的地方却不是这里。我们要修改的地方在<code>for key, value in x.items()</code>。</p>
<p>因为<code>.items()</code>这个方法是字典的方法，列表没有这个方法。所以我们需要写一个通用的迭代生成器，支持字典和列表，所以我们增加一个函数：<code>iter_x</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_x</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> isinstance(x, dict):</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">            <span class="keyword">yield</span> (key, value)</div><div class="line">    <span class="keyword">elif</span> isinstance(x, list):</div><div class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(x):</div><div class="line">            <span class="keyword">yield</span> (index, value)</div></pre></td></tr></table></figure>
<p>现在，我们在原来的代码中调用这段个新的生成器函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> iter_x(x):</div><div class="line">        <span class="keyword">if</span> isinstance(value, (dict, list)):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>其中，<code>isinstance(value, (dict, list))</code>，相当于<code>isinstance(value, dict) or isinstance(value, list)</code>。</p>
<p>我们来看一下运行效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-02-22-25-08.png" alt=""></p>
<p>掌握<code>yield</code>关键字，你的编程思路和想问题的方式会发生一个重大的转变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章里面，我们讲到了如何使用Python的&lt;code&gt;yield&lt;/code&gt;关键字简化代码，压平多层嵌套字典的。&lt;/p&gt;
&lt;p&gt;那么如果我们的数据不仅仅有字典，还有列表，是一个字典列表多层嵌套的数据怎么办呢？例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;nest_dict = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;g&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;j&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;k&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;l&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;n&#39;&lt;/span&gt;: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;: [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],  &lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，请停下来，敲一敲代码，想想如何把处理列表的逻辑添加进去。&lt;/p&gt;
&lt;p&gt;首先，我们来看一下最终被压平以后的数据长什么样：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;b_e_f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;g_h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;j_k_l_m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_o&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_1&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_p_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_1_q_r_s&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_0&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_1&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_3_2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;string&quot;&gt;&#39;n_4&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于&lt;code&gt;&amp;#39;n&amp;#39;: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]&lt;/code&gt;这种形式的数据，我们把它转换为： &lt;code&gt;{&amp;#39;n_0&amp;#39;: &amp;#39;a&amp;#39;, &amp;#39;n_1&amp;#39;: &amp;#39;b&amp;#39;, &amp;#39;n_2&amp;#39;: &amp;#39;c&amp;#39;}&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="yield" scheme="https://www.kingname.info/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>使用 yield 压平嵌套字典有多简单？</title>
    <link href="https://www.kingname.info/2019/11/03/flat-deep-dict/"/>
    <id>https://www.kingname.info/2019/11/03/flat-deep-dict/</id>
    <published>2019-11-03T02:07:53.000Z</published>
    <updated>2019-11-03T02:08:40.750Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常遇到各种字典套字典的数据，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">nest_dict = &#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b'</span>: &#123;</div><div class="line">        <span class="string">'c'</span>: <span class="number">2</span>,</div><div class="line">        <span class="string">'d'</span>: <span class="number">3</span>,</div><div class="line">        <span class="string">'e'</span>: &#123;<span class="string">'f'</span>: <span class="number">4</span>&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'g'</span>: &#123;<span class="string">'h'</span>: <span class="number">5</span>&#125;,</div><div class="line">    <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line">    <span class="string">'j'</span>: &#123;<span class="string">'k'</span>: &#123;<span class="string">'l'</span>: &#123;<span class="string">'m'</span>: <span class="number">8</span>&#125;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有没有什么简单的办法，把它<code>压扁</code>，变成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b_c'</span>: <span class="number">2</span>,</div><div class="line">    <span class="string">'b_d'</span>: <span class="number">3</span>,</div><div class="line">    <span class="string">'b_e_f'</span>: <span class="number">4</span>,</div><div class="line">    <span class="string">'g_h'</span>: <span class="number">5</span>,</div><div class="line">    <span class="string">'i'</span>: <span class="number">6</span>,</div><div class="line">    <span class="string">'j_k_l_m'</span>: <span class="number">8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>你肯定想到了使用递归来解决这个问题，那么你可以试一试，看看你的递归函数有多少行代码。</p>
<p>今天，我们使用<code>yield</code>关键字来实现这个需求，在<code>不炫技</code>的情况下，只需要8行代码。在炫技的情况下，只需要3行代码。</p>
<p>要快速地把这个嵌套字典压扁，我们需要从下网上来处理字段。例如对于<code>b-&gt;e-&gt;f-&gt;4</code>这条路径，我们首先把最里面的<code>{&#39;f&#39;: 4}</code>转换为一个元组<code>(&#39;f&#39;, 4)</code>。然后，把这个元组向上抛出，于是得到了元组<code>(&#39;e&#39;, (&#39;f&#39;, 4))</code>。我们把 <code>e</code>拼接到<code>f</code>的前面，变为：<code>(&#39;e_f&#39;, 4)</code>，继续往上抛出，得到<code>(&#39;b&#39;, (&#39;e_f&#39;, 4))</code>。再把<code>b</code>拼接到<code>e_f</code>上面，得到<code>(&#39;b_e_f&#39;, 4)</code>。完成一条线路的组装。</p>
<p>这个逻辑如果使用<code>yield</code>关键字来实现，就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> x.items():</div><div class="line">        <span class="keyword">if</span> isinstance(value, dict):</div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> flat(value):</div><div class="line">                k = f<span class="string">'&#123;key&#125;_&#123;k&#125;'</span></div><div class="line">                <span class="keyword">yield</span> (k, v)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">yield</span> (key, value)</div></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-31-22-14-24.png" alt=""></p>
<p>通过使用 <code>yield</code>关键字，字典的<code>key</code>会像是在流水线上一样，一层一层从内向外进行组装，从而形成完整的路径。</p>
<p>在下一篇文章中，我们继续使用<code>yield</code>关键字来解决字典与列表混合嵌套的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常遇到各种字典套字典的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;nest_dict = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;g&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;j&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;k&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;l&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有没有什么简单的办法，把它&lt;code&gt;压扁&lt;/code&gt;，变成：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b_c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b_d&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;b_e_f&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;g_h&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;i&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;j_k_l_m&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="yield" scheme="https://www.kingname.info/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>为什么你应该学习 Python 的生成器？</title>
    <link href="https://www.kingname.info/2019/10/30/you-should-learn-yield/"/>
    <id>https://www.kingname.info/2019/10/30/you-should-learn-yield/</id>
    <published>2019-10-30T14:43:37.000Z</published>
    <updated>2019-10-30T14:44:12.075Z</updated>
    
    <content type="html"><![CDATA[<p>写过一段时间代码的同学，应该对这一句话深有体会：程序的时间利用率和空间利用率往往是矛盾的，可以用时间换空间，可以用空间换时间，但很难同时提高一个程序的时间利用率和空间利用率。</p>
<p>但如果你尝试使用生成器来重构你的代码，也许你会发现，在一定程度上，你可以既提高时间利用率，又提高空间利用率。</p>
<a id="more"></a>
<p>我们以一个数据清洗的简单项目为例，来说明生成器如何让你的代码运行起来更加高效。</p>
<blockquote>
<p>在 Redis 中，有一个列表<code>datalist</code>，里面有很多的数据，这些数据可能是<code>纯阿拉伯数字</code>，<code>中文数字</code>，<code>字符串&quot;敏感信息&quot;</code>。现在我们需要实现：从 Redis 中读取所有的数据，把所有的字符串<code>敏感信息</code>全部丢掉，把所有中文数字全部转换为阿拉伯数字，以<code>{&#39;num&#39;: 12345, &#39;date&#39;: &#39;2019-10-30 18:12:14&#39;}</code>这样的格式插入到 MongoDB 中。</p>
</blockquote>
<p>示例数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">41234213424</div><div class="line">一九八八七二六三</div><div class="line">8394520342</div><div class="line">七二三六二九六六</div><div class="line">敏感信息</div><div class="line">80913408120934</div><div class="line">敏感信息</div><div class="line">敏感信息</div><div class="line">95352345345</div><div class="line">三三七四六</div><div class="line">999993232</div><div class="line">234234234</div><div class="line">三六八八七七</div><div class="line">敏感信息</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-30-19-27-35.png" alt=""></p>
<p>如果让你来写这个转换程序，你可能会这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line">handler = pymongo.MongoClient().data_list.num</div><div class="line"></div><div class="line">CHINESE_NUM_DICT = &#123;</div><div class="line">    <span class="string">'一'</span>: <span class="string">'1'</span>,</div><div class="line">    <span class="string">'二'</span>: <span class="string">'2'</span>,</div><div class="line">    <span class="string">'三'</span>: <span class="string">'3'</span>,</div><div class="line">    <span class="string">'四'</span>: <span class="string">'4'</span>,</div><div class="line">    <span class="string">'五'</span>: <span class="string">'5'</span>,</div><div class="line">    <span class="string">'六'</span>: <span class="string">'6'</span>,</div><div class="line">    <span class="string">'七'</span>: <span class="string">'7'</span>,</div><div class="line">    <span class="string">'八'</span>: <span class="string">'8'</span>,</div><div class="line">    <span class="string">'九'</span>: <span class="string">'9'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></div><div class="line">    datas = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        data = client.lpop(<span class="string">'datalist'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        datas.append(data.decode())</div><div class="line">    <span class="keyword">return</span> datas</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_sensitive_data</span><span class="params">(datas)</span>:</span></div><div class="line">    clear_data = []</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'敏感信息'</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        clear_data.append(data)</div><div class="line">    <span class="keyword">return</span> clear_data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranfer_chinese_num</span><span class="params">(datas)</span>:</span></div><div class="line">    number_list = []</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            num = int(data)</div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            num = <span class="string">''</span>.join(CHINESE_NUM_DICT[x] <span class="keyword">for</span> x <span class="keyword">in</span> data)</div><div class="line">        number_list.append(num)</div><div class="line">    <span class="keyword">return</span> number_list</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(number_list)</span>:</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</div><div class="line">        data = &#123;<span class="string">'num'</span>: number, <span class="string">'date'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</div><div class="line">        handler.insert_one(data)</div><div class="line"></div><div class="line">raw_data = get_data()</div><div class="line">safe_data = remove_sensitive_data(raw_data)</div><div class="line">number_list = tranfer_chinese_num(safe_data)</div><div class="line">save_data(number_list)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-30-19-45-36.png" alt=""></p>
<p>这段代码，看起来很 Pythonic，一个函数只做一件事，看起来也满足编码规范。最后运行结果也正确。能有什么问题？</p>
<p>问题在于，这段代码，每个函数都会创建一个列表存放处理以后的数据。如果 Redis 中的数据多到超过了你当前电脑的内存怎么办？对同一批数据多次使用 for 循环，浪费了大量的时间，能不能只循环一次？</p>
<p>也许你会说，你可以把移除<code>敏感信息</code>，中文数字转阿拉伯数字的逻辑全部写在<code>get_data</code>函数的 <code>while</code>循环中，这样不就只循环一次了吗？</p>
<p>可以是可以，但是这样一来，<code>get_data</code>就做了不止一件事情，代码也显得非常混乱。如果以后要增加一个新的数据处理逻辑：</p>
<blockquote>
<p>转换为数字以后，检查所有奇数位的数字相加之和与偶数位数字相加之和是否相等，丢弃所有相等的数字。</p>
</blockquote>
<p>那么你就要修改<code>get_data</code>的代码。</p>
<p>在开发软件的时候，我们应该面向扩展开放，面向修改封闭，所以不同的逻辑，确实应该分开，所以上面把每个处理逻辑分别写成函数的写法，在软件工程上没有问题。但是如何做到处理逻辑分开，又不需要对同一批数据进行多次 for 循环呢？</p>
<p>这个时候，就要依赖于我们的生成器了。</p>
<p>我们先来看看下面这一段代码的运行效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_num</span><span class="params">()</span>:</span></div><div class="line">    nums = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        print(f<span class="string">'生成数据：&#123;i&#125;'</span>)</div><div class="line">        nums.append(i)</div><div class="line">    <span class="keyword">return</span> nums</div><div class="line">nums = gen_num()</div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">    print(f<span class="string">'打印数据：&#123;num&#125;'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-30-20-04-14.png" alt=""></p>
<p>现在，我们对代码做一下修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_num</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        print(f<span class="string">'生成数据：&#123;i&#125;'</span>)</div><div class="line">        <span class="keyword">yield</span> i</div><div class="line">nums = gen_num()</div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">    print(f<span class="string">'打印数据：&#123;num&#125;'</span>)</div></pre></td></tr></table></figure>
<p>其运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-30-20-05-33.png" alt=""></p>
<p>大家对比上面两张插图。前一张插图，先生成10个数据，然后再打印10个数据。后一张图，生成一个数据，打印一个数据，再生成一个数据，再打印一个数据……</p>
<p>如果以代码的行号来表示运行运行逻辑，那么代码是按照这个流程运行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1-&gt;5-&gt;6-&gt;2-&gt;3-&gt;4-&gt;6-&gt;7-&gt;6-&gt;2-&gt;3-&gt;4-&gt;6-&gt;7-&gt;6-&gt;2-&gt;3-&gt;4-&gt;6-&gt;7....</div></pre></td></tr></table></figure>
<p>大家可以把这段代码写在 PyCharm 中，然后使用单步调试来查看它每一步运行的是哪一行代码。</p>
<p>程序运行到<code>yield</code>就会把它后面的数字<code>抛出</code>到外面给 for 循环， 然后进入外面 for 循环的循环体，外面的 for 循环执行完成后，又会进入<code>gen_num</code>函数里面的 <code>yield i</code>后面的一行，开启下一次 for 循环，继续生成新的数字……</p>
<p>整个过程中，不需要额外创建一个列表来保存中间的数据，从而达到节约内存空间的目的。而整个过程中，虽然代码写了两个 for 循环，但是如果你使用单步调试，你就会发现实际上真正的循环只有<code>for i in range(10)</code>。而外面的<code>for num in nums</code>仅仅是实现了函数内外的切换，并没有新增循环。</p>
<p>回到最开始的问题，我们如何使用生成器来修改代码呢？实际上你几乎只需要把<code>return 列表</code>改成<code>yield 每一个元素</code>即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line">handler = pymongo.MongoClient().data_list.num_yield</div><div class="line"></div><div class="line">CHINESE_NUM_DICT = &#123;</div><div class="line">    <span class="string">'一'</span>: <span class="string">'1'</span>,</div><div class="line">    <span class="string">'二'</span>: <span class="string">'2'</span>,</div><div class="line">    <span class="string">'三'</span>: <span class="string">'3'</span>,</div><div class="line">    <span class="string">'四'</span>: <span class="string">'4'</span>,</div><div class="line">    <span class="string">'五'</span>: <span class="string">'5'</span>,</div><div class="line">    <span class="string">'六'</span>: <span class="string">'6'</span>,</div><div class="line">    <span class="string">'七'</span>: <span class="string">'7'</span>,</div><div class="line">    <span class="string">'八'</span>: <span class="string">'8'</span>,</div><div class="line">    <span class="string">'九'</span>: <span class="string">'9'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        data = client.lpop(<span class="string">'datalist'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">yield</span> data.decode()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_sensitive_data</span><span class="params">(datas)</span>:</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'敏感信息'</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">yield</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tranfer_chinese_num</span><span class="params">(datas)</span>:</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            num = int(data)</div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            num = <span class="string">''</span>.join(CHINESE_NUM_DICT[x] <span class="keyword">for</span> x <span class="keyword">in</span> data)</div><div class="line">        <span class="keyword">yield</span> num</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(number_list)</span>:</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</div><div class="line">        data = &#123;<span class="string">'num'</span>: number, <span class="string">'date'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)&#125;</div><div class="line">        handler.insert_one(data)</div><div class="line"></div><div class="line">raw_data = get_data()</div><div class="line">safe_data = remove_sensitive_data(raw_data)</div><div class="line">number_list = tranfer_chinese_num(safe_data)</div><div class="line">save_data(number_list)</div></pre></td></tr></table></figure>
<p>代码如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-30-20-21-57.png" alt=""></p>
<p>如果你开启 PyCharm 调试模式，你会发现，数据的流向是这样的：</p>
<ol>
<li>从 Redis 获取1条数据</li>
<li>这一条数据传给remove_sensitive_data</li>
<li>第2步处理以后的数据传给tranfer_chinese_num</li>
<li>第3步处理以后，传给 save_data</li>
<li>回到第1步</li>
</ol>
<p>整个过程就像是一条流水线一样，数据一条一条地进行处理和存档。不需创建额外的列表，有多少条数据就循环多少次，不做多余的循环。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写过一段时间代码的同学，应该对这一句话深有体会：程序的时间利用率和空间利用率往往是矛盾的，可以用时间换空间，可以用空间换时间，但很难同时提高一个程序的时间利用率和空间利用率。&lt;/p&gt;
&lt;p&gt;但如果你尝试使用生成器来重构你的代码，也许你会发现，在一定程度上，你可以既提高时间利用率，又提高空间利用率。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="生成器" scheme="https://www.kingname.info/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何在Python代码里面调用 pip安装第三方库</title>
    <link href="https://www.kingname.info/2019/10/29/pip-in-code/"/>
    <id>https://www.kingname.info/2019/10/29/pip-in-code/</id>
    <published>2019-10-29T14:42:38.000Z</published>
    <updated>2019-10-30T14:43:13.334Z</updated>
    
    <content type="html"><![CDATA[<p>说到安装 Python 的第三方库，会 Python 的同学都知道，在终端使用<code>pip install xxx</code>即可。</p>
<p>那么如果我想在代码里面安装第三方库怎么办呢？可能有人想到使用 <code>os</code> 模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">package_name = <span class="string">'requests'</span></div><div class="line">os.system(f<span class="string">'pip install &#123;package_name&#125;'</span>)</div></pre></td></tr></table></figure>
<p>这种方法确实可行，并且即使你在虚拟环境中使用这种方式安装，也确实不会安装到系统的 Python 环境中。</p>
<a id="more"></a>
<p>但是这种方式总感觉有点奇怪。而且如果这个<code>package_name</code>字符串经过精心构造，可以执行任意系统命令，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">package_name = <span class="string">'requests &amp;&amp; rm -rf *'</span></div><div class="line">os.system(f<span class="string">'pip install &#123;package_name&#125;'</span>)</div></pre></td></tr></table></figure>
<p>为了防止这种情况发生，我们可以直接调用<code>pip</code>这个 Python 包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pip._internal <span class="keyword">import</span> main</div><div class="line"></div><div class="line">main.main([<span class="string">'install'</span>, <span class="string">'第三方库名'</span>])</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-29-21-52-23.png" alt=""></p>
<p>命令行下面的参数都可以通过转换为列表的形式执行，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pip._internal <span class="keyword">import</span> main</div><div class="line"></div><div class="line">main.main([<span class="string">'install'</span>, <span class="string">'-r'</span>, <span class="string">'requirements.txt'</span>])</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到安装 Python 的第三方库，会 Python 的同学都知道，在终端使用&lt;code&gt;pip install xxx&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;那么如果我想在代码里面安装第三方库怎么办呢？可能有人想到使用 &lt;code&gt;os&lt;/code&gt; 模块：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;package_name = &lt;span class=&quot;string&quot;&gt;&#39;requests&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;os.system(f&lt;span class=&quot;string&quot;&gt;&#39;pip install &amp;#123;package_name&amp;#125;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法确实可行，并且即使你在虚拟环境中使用这种方式安装，也确实不会安装到系统的 Python 环境中。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用 Linux 自带的 logrotate 管理你的所有日志</title>
    <link href="https://www.kingname.info/2019/10/24/logrotate/"/>
    <id>https://www.kingname.info/2019/10/24/logrotate/</id>
    <published>2019-10-24T14:41:27.000Z</published>
    <updated>2019-10-30T14:42:11.542Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发的过程中，会创建非常多的日志，对日志进行 rotate 是一个基本要求。</p>
<p>所谓的<code>rotate</code>，可以理解为对日志按照一定的规则进行切分。例如，每天晚上0点生成一个新的日志文件，并把老的文件归档。又或者每个日志文件超过多少 MB 以后就自动切分，并把老的内容单独存档或者压缩。存档以后的日志文件保存多少个。超过数量以后先删除老日志再删除新日志。</p>
<p>如果我们使用的是 Python，那么我们可以使用自带的<code>logging</code>模块或者第三方的<code>logoru</code>来写日志。但如果我们使用像是 MongoDB这种第三方的软件，那么要对日志进行 rotate 就非常麻烦了。如果不加以管理，MongoDB 的日志很容易就达到几十GB。</p>
<p>还有其他软件，他们的日志散落在系统的各个位置，我们应该如何替他们 rotate 呢？</p>
<a id="more"></a>
<p>如果你的系统是 Linux，那么主流发行版一般都会自带一个软件，叫做<code>logrotate</code>，通过简单的配置，就能让它帮你管理系统中各个地方的日志。</p>
<p>我们以 MongoDB 为例来进行说明。</p>
<p>MongoDB 的日志默认放在<code>/var/log/mongodb</code>文件夹中，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-24-22-13-14.png" alt=""></p>
<p>如果不干涉，那么所有的日志内容会无限制追加到这一个<code>mongod.log</code>文件中。并且，如果你的 MongoDB 正在运行，即使你使用<code>rm</code>命令删除了这个文件，它占用的空间也不会释放。</p>
<p>但使用<code>logrotate</code>来管理这个文件以后，它能通过<code>truncate</code>操作清空这个文件，从而实现释放空间的目的。</p>
<p><code>logrotate</code>的配置文件地址有两个，第一个主配置文件地址为<code>/etc/logrotate.conf</code>，其内容如下：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-24-22-16-26.png" alt=""></p>
<p>另一个专门用于存放配置文件的地址为<code>/etc/logrotate.d/</code>，它里面的每一个文件都是一个配置文件，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-24-22-17-28.png" alt=""></p>
<p>我们要使用<code>logrotate</code>来管理 MongoDB，所以就在<code>/etc/logrotate.d/</code>文件夹中创建一个<code>mongodb</code>文件（文件名可以任意取），内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/var/log/mongodb/*.log &#123;</div><div class="line">    rotate 5</div><div class="line">    copytruncate</div><div class="line">    missingok</div><div class="line">    compress</div><div class="line">    maxsize 200M</div><div class="line">    daily</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-24-22-20-04.png" alt=""></p>
<p>这个配置文件的意义如下：</p>
<p>*第一行用于指定 MongoDB 日志文件的地址为<code>/var/log/mongodb/</code>文件夹下面所有以<code>.log</code>结尾的文件。</p>
<ul>
<li><code>rotate 5</code>表示保留5份日志文件</li>
<li>copytruncate 表示，日志满足要求以后，先复制一份，然后把原来的日志文件清空</li>
<li>missingok 表示如果这个文件夹下面为空，也没关系，自动忽略</li>
<li>compress 表示要把日志进行压缩</li>
<li>maxsize 200M 表示每个日志最多200MB，达到200MB 以后，就进行 rotate。</li>
<li>daily 表示每天检查一次</li>
</ul>
<p>保存这个文件，<code>logrotate</code>将会每天自动检查 MongoDB 的日志文件，如果发现它大小达到了200MB，那么首先会把这个日志复制出来一份（此时将会占用400MB 空间），然后把原来的日子文件内容清空（此时恢复200MB 空间占用）。被复制出来的日志文件会被压缩，并存放在当前文件夹中。当日志数量达到5个的时候，第六个日志文件生成，最开始压缩的那个文件被删除。从而保证 MongoDB 的日志及其备份总共占用空间不超过1GB。</p>
<p><code>logrotate</code>非常强大，还有非常多的配置参数用于实现各种日志管理的操作，大家可以执行命令<code>man logrotate</code>查看它的帮助文档。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开发的过程中，会创建非常多的日志，对日志进行 rotate 是一个基本要求。&lt;/p&gt;
&lt;p&gt;所谓的&lt;code&gt;rotate&lt;/code&gt;，可以理解为对日志按照一定的规则进行切分。例如，每天晚上0点生成一个新的日志文件，并把老的文件归档。又或者每个日志文件超过多少 MB 以后就自动切分，并把老的内容单独存档或者压缩。存档以后的日志文件保存多少个。超过数量以后先删除老日志再删除新日志。&lt;/p&gt;
&lt;p&gt;如果我们使用的是 Python，那么我们可以使用自带的&lt;code&gt;logging&lt;/code&gt;模块或者第三方的&lt;code&gt;logoru&lt;/code&gt;来写日志。但如果我们使用像是 MongoDB这种第三方的软件，那么要对日志进行 rotate 就非常麻烦了。如果不加以管理，MongoDB 的日志很容易就达到几十GB。&lt;/p&gt;
&lt;p&gt;还有其他软件，他们的日志散落在系统的各个位置，我们应该如何替他们 rotate 呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.kingname.info/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.kingname.info/tags/Linux/"/>
    
      <category term="Log" scheme="https://www.kingname.info/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>使用迭代器接收数据并自动停止</title>
    <link href="https://www.kingname.info/2019/10/23/iter-and-stop/"/>
    <id>https://www.kingname.info/2019/10/23/iter-and-stop/</id>
    <published>2019-10-23T14:40:12.000Z</published>
    <updated>2019-10-30T14:40:58.895Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个 Redis 集合，里面有 N 条数据，你不停从里面<code>lpop</code>数据，直到某一条数据的值为<code>&#39;Stop&#39;</code>字符串为止(已知里面必有一条数据为<code>&#39;Stop&#39;</code>字符串，但其位置不知道)。</p>
<a id="more"></a>
<p>这个需求看起来很简单，于是你立刻就着手写出了代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></div><div class="line">    datas = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        data = client.lpop().decode()</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        datas.append(data)</div><div class="line">    <span class="keyword">return</span> datas</div></pre></td></tr></table></figure>
<p>现在问题来了，如果 Redis 里面的数据非常多，已经超过了你的内存容量怎么办？数据全部放在<code>datas</code>列表里面再返回显然是不可取的做法。</p>
<p>好在，这些数据读取出来以后，会传给一个<code>parse</code>函数，并且这个函数是一条一条处理数据的，它处理完成以后，就可以把数据丢弃了。</p>
<p>于是你可能会这样改写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        data = client.lpop().decode()</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        parse(data)</div></pre></td></tr></table></figure>
<p>但我们知道，在编码规范和软件工程里面，建议一个函数，它应该只做一件事情，而现在<code>read_data()</code>函数却做了两件事情：1. 从 Redis 里面读取数据。2.调用<code>parse()</code>函数。</p>
<p>那么我们有没有办法把他们区分开来呢？如何让<code>read_data</code>能返回数据，但是又不会把内存撑爆呢？</p>
<p>这个时候，我们就可以使用生成器来解决问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        data = client.lpop().decode()</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">yield</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> read_data():</div><div class="line">        parse(data)</div></pre></td></tr></table></figure>
<p>在这个代码里面，<code>read_data</code>变成了生成器函数，它返回一个生成器，对生成器进行迭代的时候，每次返回一条数据，这一条数据立即传给<code>parse()</code>函数。整个过程源源不断，生生不息。不需要额外创建一个列表用来存放数据。</p>
<p>那么代码还能不能继续简化呢？此时我们就可以使用<code>iter</code>关键字了。</p>
<p>使用了<code>iter</code>关键字的效果如下图所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></div><div class="line">    data = client.lpop().decode()</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> iter(read_data, <span class="string">'Stop'</span>):</div><div class="line">        parse(data)</div></pre></td></tr></table></figure>
<p>其中，<code>read_data</code>现在每运行一次只会返回列表最左边的数据。但是当我们直接使用<code>iter(read_data, &#39;Stop&#39;)</code>的时候，就会得到一个<code>迭代器</code>。对这个迭代器进行迭代，相当于在<code>While True</code>里面不停运行<code>read_data</code>函数，直到某一次迭代的时候，<code>read_data</code>函数返回了<code>Stop</code>，就停止。</p>
<p>当然如果你想炫技的话，还可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">client = redis.Redis()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: client.lpop().decode(), <span class="string">'Stop'</span>):</div><div class="line">        parse(data)</div></pre></td></tr></table></figure>
<p>当然，我是不推荐这样写的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有一个 Redis 集合，里面有 N 条数据，你不停从里面&lt;code&gt;lpop&lt;/code&gt;数据，直到某一条数据的值为&lt;code&gt;&amp;#39;Stop&amp;#39;&lt;/code&gt;字符串为止(已知里面必有一条数据为&lt;code&gt;&amp;#39;Stop&amp;#39;&lt;/code&gt;字符串，但其位置不知道)。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="迭代器" scheme="https://www.kingname.info/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何通过字符串导入 Python 模块</title>
    <link href="https://www.kingname.info/2019/10/22/import-by-str/"/>
    <id>https://www.kingname.info/2019/10/22/import-by-str/</id>
    <published>2019-10-22T14:39:01.000Z</published>
    <updated>2019-10-30T14:45:03.867Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时导入第三方模块的时候，一般使用的是<code>import</code>关键字，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"><span class="keyword">from</span> scrapy.spider <span class="keyword">import</span> Spider</div></pre></td></tr></table></figure>
<p>但是如果各位同学看过 Scrapy 的<code>settings.py</code>文件，就会发现里面会通过字符串的方式来指定pipeline 和 middleware，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">DOWNLOADER_MIDDLEWARES = &#123;</div><div class="line">    <span class="string">'Test.middlewares.ExceptionRetryMiddleware'</span>: <span class="number">545</span>,</div><div class="line">    <span class="string">'Test.middlewares.BOProxyMiddlewareV2'</span>: <span class="number">543</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"> SPIDER_MIDDLEWARES = &#123;</div><div class="line">   <span class="string">'Test.middlewares.LoggingRequestMiddleware'</span>: <span class="number">543</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，这里的<code>Test.middlewares.ExceptionRetryMiddleware</code>实际上对应了根目录下面的<code>Test</code>文件夹里面的<code>middlewares.py</code>文件中的<code>ExceptionRetryMiddleware</code>类。那么 Scrapy 是如何根据这个字符串，导入这个类的呢？</p>
<a id="more"></a>
<p>在 Scrapy 源代码中，我们可以找到<a href="https://github.com/scrapy/scrapy/blob/master/scrapy/utils/misc.py#L33" target="_blank" rel="external">相关的代码</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_object</span><span class="params">(path)</span>:</span></div><div class="line">    <span class="string">"""Load an object given its absolute object path, and return it.</span></div><div class="line">    object can be a class, function, variable or an instance.</div><div class="line">    path ie: 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        dot = path.rindex(<span class="string">'.'</span>)</div><div class="line">    <span class="keyword">except</span> ValueError:</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Error loading object '%s': not a full path"</span> % path)</div><div class="line"></div><div class="line">    module, name = path[:dot], path[dot+<span class="number">1</span>:]</div><div class="line">    mod = import_module(module)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        obj = getattr(mod, name)</div><div class="line">    <span class="keyword">except</span> AttributeError:</div><div class="line">        <span class="keyword">raise</span> NameError(<span class="string">"Module '%s' doesn't define any object named '%s'"</span> % (module, name))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj</div></pre></td></tr></table></figure>
<p>根据这段代码，我们知道，它使用了<code>importlib</code>模块的<code>import_module</code>函数：</p>
<ol>
<li>首先根据字符串路径最右侧的<code>.</code>把字符串路径分成两个部分，例如：<code>Test.middlewares.LoggingRequestMiddleware</code>分成<code>Test.middlewares</code>和<code>LoggingRequestMiddleware</code></li>
<li>使用<code>import_module</code>导入左边的部分</li>
<li>从左边部分通过<code>getattr</code>获得具体的类</li>
</ol>
<p>现在我们来测试一下。我们创建的测试文件结构如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-22-22-27-25.png" alt=""></p>
<p>其中，<code>pipelines.py</code>文件的内容如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-22-22-27-57.png" alt=""></p>
<p><code>main.py</code>文件的内容如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-22-22-31-23.png" alt=""></p>
<p>运行<code>main.py</code>，可以看到<code>pipelines.py</code>中的<code>Pipeline</code>类被成功执行了，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-22-22-33-39.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时导入第三方模块的时候，一般使用的是&lt;code&gt;import&lt;/code&gt;关键字，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; scrapy&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.spider &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Spider&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是如果各位同学看过 Scrapy 的&lt;code&gt;settings.py&lt;/code&gt;文件，就会发现里面会通过字符串的方式来指定pipeline 和 middleware，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;DOWNLOADER_MIDDLEWARES = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;Test.middlewares.ExceptionRetryMiddleware&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;545&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;Test.middlewares.BOProxyMiddlewareV2&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;543&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; SPIDER_MIDDLEWARES = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;string&quot;&gt;&#39;Test.middlewares.LoggingRequestMiddleware&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;543&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们知道，这里的&lt;code&gt;Test.middlewares.ExceptionRetryMiddleware&lt;/code&gt;实际上对应了根目录下面的&lt;code&gt;Test&lt;/code&gt;文件夹里面的&lt;code&gt;middlewares.py&lt;/code&gt;文件中的&lt;code&gt;ExceptionRetryMiddleware&lt;/code&gt;类。那么 Scrapy 是如何根据这个字符串，导入这个类的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何用 Python让自己变成天选之子</title>
    <link href="https://www.kingname.info/2019/10/21/become-lucky-one/"/>
    <id>https://www.kingname.info/2019/10/21/become-lucky-one/</id>
    <published>2019-10-21T14:38:03.000Z</published>
    <updated>2019-10-30T14:45:02.237Z</updated>
    
    <content type="html"><![CDATA[<p>请大家猜一猜下面这段代码的运行效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">people = [<span class="string">'kingname'</span>, <span class="string">'王小一'</span>, <span class="string">'李小二'</span>, <span class="string">'张小三'</span>, <span class="string">'刘小四'</span>, <span class="string">'卢小五'</span>, <span class="string">'马小六'</span>, <span class="string">'周小七'</span>, <span class="string">'丁小八'</span>, <span class="string">'朱小九'</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</div><div class="line">    lucky_guy = random.choice(people)</div><div class="line">    print(f<span class="string">'第&#123;i&#125;次抽奖，中奖用户：&#123;lucky_guy&#125;'</span>)</div><div class="line">    time.sleep(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>你是不是以为这段代码运行以后，结果如下图所示？</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-21-50-47.png" alt=""></p>
<p>但实际上，我可以让输出结果根据我的意愿随意变动，例如像下面这个 gif ，所有输出结果都是我：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/fakerandom.gif" alt=""></p>
<p>你可以先不要往下看，放下手机，自己写一下代码，试一试 如何才能实现 gif 中的效果。</p>
<a id="more"></a>
<p>下面来为大家解密。</p>
<p>要实现这个效果，只需要两个知识点：</p>
<ol>
<li>Python自带模块是可以被覆盖的</li>
<li>Python 的 import 在同一个运行时只会导入一次</li>
</ol>
<p>首先来看第一个知识点。Python 的自带模块是可以被覆盖的，所以我们先来定义一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span><span class="params">(option)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'kingname'</span></div></pre></td></tr></table></figure>
<p>接下来，使用这个函数覆盖<code>random.choice</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line">random.choice = choice</div></pre></td></tr></table></figure>
<p>现在，无论给<code>random.choice</code>传入什么参数，它始终都会返回<code>kingname</code>，运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-21-58-38.png" alt=""></p>
<p>这个时候，你可能会说，那别人写代码的时候，又重新<code>import random</code>怎么办呢？<code>random.choice</code>不是又被改回去了吗？</p>
<p>实际上并不会，因为Python 的包导入机制决定了，在每个运行时内部，每个包只有第一次导入的时候有效，所以只要还在当前运行时，那么后续的所有<code>import random</code>都是无效的。</p>
<p>所以，即使重新导入了 random 模块，<code>random.choice</code>依然是你修改以后的代码。所以当你再次执行的时候，会发现返回的还是你想要的数据，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-22-02-38.png" alt=""></p>
<p>可能有人会说这样容易被识破啊，别人只要先随便写一些测试数据，运行一次<code>random.choice([123, 456])</code>，发现返回的竟然是<code>kingname</code>，这不就露馅了吗？</p>
<p>实际上完全不用担心，我们可以这样操作：</p>
<ol>
<li>如果备选列表里面不包含<code>kingname</code>，那么就使用原生的 <code>random.choice</code></li>
<li>如果备选列表里面包含<code>kingname</code>，那么就以60%的概率返回<code>kingname</code></li>
</ol>
<p>要实现这样的功能，我们可以这样写代码：</p>
<p>首先重启当前 Jupyter 内核，让 random 恢复成默认的，然后编码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">origin_choice = random.choice</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span><span class="params">(option)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'kingname'</span> <span class="keyword">not</span> <span class="keyword">in</span> option <span class="keyword">or</span> random.randint(<span class="number">1</span>, <span class="number">10</span>) &gt; <span class="number">6</span>:</div><div class="line">        <span class="keyword">return</span> origin_choice(option)</div><div class="line">    <span class="keyword">return</span> <span class="string">'kingname'</span></div><div class="line"></div><div class="line">random.choice = choice</div></pre></td></tr></table></figure>
<p>这样替换以后，当有<code>kingname</code>在备选列表中时，<code>kingname</code>被有60%的概率被选中，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-22-13-06.png" alt=""></p>
<p>当<code>kingname</code>不在备选列表中时，一切正常，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-22-13-51.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请大家猜一猜下面这段代码的运行效果：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; random&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;people = [&lt;span class=&quot;string&quot;&gt;&#39;kingname&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;王小一&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;李小二&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;张小三&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;刘小四&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;卢小五&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;马小六&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;周小七&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;丁小八&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;朱小九&#39;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    lucky_guy = random.choice(people)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(f&lt;span class=&quot;string&quot;&gt;&#39;第&amp;#123;i&amp;#125;次抽奖，中奖用户：&amp;#123;lucky_guy&amp;#125;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    time.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你是不是以为这段代码运行以后，结果如下图所示？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-21-21-50-47.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但实际上，我可以让输出结果根据我的意愿随意变动，例如像下面这个 gif ，所有输出结果都是我：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/fakerandom.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以先不要往下看，放下手机，自己写一下代码，试一试 如何才能实现 gif 中的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何正确获取 MongoDB 集合里面的最后一条数据</title>
    <link href="https://www.kingname.info/2019/10/19/get-last-data/"/>
    <id>https://www.kingname.info/2019/10/19/get-last-data/</id>
    <published>2019-10-19T14:37:12.000Z</published>
    <updated>2019-10-30T14:45:00.072Z</updated>
    
    <content type="html"><![CDATA[<p>在我们使用 Python 查询 MongoDB 的时候，一般会使用MongoDB 的集合（collection）对象的 <code>find()</code>方法或者<code>find_one()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line">handler = pymongo.MongoClient().chapter_7.example_data_4</div><div class="line"></div><div class="line"><span class="comment"># 获得一个游标操作对象，并迭代</span></div><div class="line">rows = handler.find()</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</div><div class="line">    print(row)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 查询第一条数据</span></div><div class="line">row = handler.find_one()</div><div class="line">print(row)</div></pre></td></tr></table></figure>
<p>其中，<code>find()</code>方法返回的是一个游标对象，我们可以直接对这个对象进行迭代，从而按顺序获取每一条数据。</p>
<a id="more"></a>
<p>这个游标对象还有一个<code>sort()</code>方法，可以对迭代返回的数据进行排序，例如想对数据按照<code>_id</code>倒序显示，那么可以把代码写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rows = handler.find().sort(<span class="string">'_id'</span>, <span class="number">-1</span>)</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</div><div class="line">    print(row)  <span class="comment"># 此时会倒序输出内容</span></div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-19-22-14-59.png" alt=""></p>
<p>需要注意，对游标对象执行了<code>sort()</code>方法以后，返回的依然是游标对象。所以如果我们只想获取最后一条数据怎么办呢？有如下2种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rows = handler.find().sort(<span class="string">'_id'</span>, <span class="number">-1</span>).limit(<span class="number">1</span>)  <span class="comment"># 倒序以后，只返回1条数据</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:  <span class="comment"># 这个循环只会执行1次</span></div><div class="line">    print(row)</div></pre></td></tr></table></figure>
<p>或者我们可以使用第二种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rows = handler.find().sort(<span class="string">'_id'</span>, <span class="number">-1</span>)</div><div class="line">row = next(rows)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-19-22-16-07.png" alt=""></p>
<p>这是由于游标对象是一个可迭代对象，所以可以使用<code>next</code>函数获取它第一次迭代的值。</p>
<p>我们平时使用<code>find_one()</code>时，返回的都是第一个满足条件的数据，那么有办法返回最后一个满足条件的数据呢？</p>
<p>由于 <code>find_one()</code>返回的数据是<code>None</code>或者一个字典。他们都没有<code>sort()</code>方法，所以不能使用下面这种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">row = handler.find_one().sort(<span class="string">'_id'</span>, <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>正确的写法，是把<code>sort</code>作为参数写在<code>find_one()</code>方法里面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">row = handler.find_one(sort=[(<span class="string">'_id'</span>, <span class="number">-1</span>)])</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-19-22-20-48.png" alt=""></p>
<p>作为参数的<code>sort</code>，它的值是一个列表，列表里面的每一个元素都是元组，元组的第一个值为需要被排序的字段名，第二个值为1或者-1，1表示正序，-1表示倒序。如果列表里面有多个元组，那么先按第一个元组对应的字段排序，第一次排序的结果里面，值相同的再按第二个元组对应的字段排序，以此类推。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们使用 Python 查询 MongoDB 的时候，一般会使用MongoDB 的集合（collection）对象的 &lt;code&gt;find()&lt;/code&gt;方法或者&lt;code&gt;find_one()&lt;/code&gt;方法：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pymongo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler = pymongo.MongoClient().chapter_7.example_data_4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 获得一个游标操作对象，并迭代&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rows = handler.find()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; rows:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(row)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查询第一条数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;row = handler.find_one()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(row)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;find()&lt;/code&gt;方法返回的是一个游标对象，我们可以直接对这个对象进行迭代，从而按顺序获取每一条数据。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.kingname.info/categories/MongoDB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="MongoDB" scheme="https://www.kingname.info/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>你的代码是如何被炫技毁掉的</title>
    <link href="https://www.kingname.info/2019/10/17/do-not-show/"/>
    <id>https://www.kingname.info/2019/10/17/do-not-show/</id>
    <published>2019-10-17T14:36:16.000Z</published>
    <updated>2019-10-30T14:45:14.276Z</updated>
    
    <content type="html"><![CDATA[<p>你的代码是如何被炫技毁掉的？</p>
<a id="more"></a>
<p>假设有这样一个例子：</p>
<p>一个函数接收两个参数，第一个参数为一个字典，第二个参数为一个列表，我们要把列表中的每一个元素去查字典，如果能够查询到，那么就获取值，如果不能查询到，就跳过。</p>
<p>例如：</p>
<p>输入：<code>{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</code>和<code>[&#39;a&#39;, &#39;d&#39;, &#39;c&#39;]</code>，那么打印：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=<span class="number">1</span></div><div class="line">c=<span class="number">3</span></div></pre></td></tr></table></figure>
<p>我们可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">referer_dict</span><span class="params">(target, keys)</span>:</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> keys:</div><div class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> target:</div><div class="line">            print(f<span class="string">'&#123;k&#125;=&#123;target[k]&#125;'</span>)</div></pre></td></tr></table></figure>
<p>那么有没有可能把判断<code>k</code>是否在 <code>target</code>这个操作去掉呢？也可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">referer_dict</span><span class="params">(target, keys)</span>:</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> keys:</div><div class="line">        values = target.get(k, <span class="keyword">None</span>)</div><div class="line">        values <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> print(f<span class="string">'&#123;k&#125;=&#123;target[k]&#125;'</span>)</div></pre></td></tr></table></figure>
<p>但这种写法实际上并没有节省代码行数，不如这样改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">referer_dict</span><span class="params">(target, keys)</span>:</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> keys:</div><div class="line">        k <span class="keyword">not</span> <span class="keyword">in</span> target <span class="keyword">or</span> print(f<span class="string">'&#123;k&#125;=&#123;target[k]&#125;'</span>)</div></pre></td></tr></table></figure>
<p>接下来还可以继续优化成一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">referer_dict</span><span class="params">(target, keys)</span>:</span></div><div class="line">    [print(f<span class="string">'&#123;k&#125;=&#123;target[k]&#125;'</span>) <span class="keyword">for</span> k <span class="keyword">in</span> keys <span class="keyword">if</span> k <span class="keyword">in</span> target]</div></pre></td></tr></table></figure>
<p>停。</p>
<p>再这样魔改下去这个函数都可以去掉。总共只需要1行代码。但是这样炫技并不可取。代码可读性和可维护性比炫技重要一万倍。</p>
<p>第四种写法，纯粹就是为了凑出这个打印结果而强行使用了列表推导式，毫无可读性，别人接手这个代码也难以维护。</p>
<p>保持 Python 的自文档性，优秀的 Python 代码，本身就是最好的文档，连注释都不需要就能让人理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的代码是如何被炫技毁掉的？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Jupyter 中如何重新导入特定的 Python 文件？</title>
    <link href="https://www.kingname.info/2019/10/12/reimport-in-jupyter/"/>
    <id>https://www.kingname.info/2019/10/12/reimport-in-jupyter/</id>
    <published>2019-10-12T14:34:58.000Z</published>
    <updated>2019-10-30T14:45:28.936Z</updated>
    
    <content type="html"><![CDATA[<p>Jupyter 是数据分析领域非常有名的开发环境，使用 Jupyter 写数据分析相关的代码会大大节约开发时间。</p>
<p>设想这样一个场景：别的部门的同事传给你一个数据分析的模块，用于实现对数据的高级分析。模块里面有上百个函数。</p>
<a id="more"></a>
<p>如果直接写 Python 文件来调用数据分析模块，那么使用方法非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> analyze <span class="keyword">import</span> FathersAnalyzer</div><div class="line"></div><div class="line">data = [...]</div><div class="line">father = FathersAnalyzer(data)</div><div class="line">result = father.analyze()</div><div class="line">print(f<span class="string">'分析结果为：&#123;result&#125;'</span>)</div></pre></td></tr></table></figure>
<p>现在，你需要使用 Jupyter 来调用这个分析模块。你应该怎么在 Jupyter里面调用？</p>
<p>你可能会觉得，这还不简单吗？直接把这个模块的代码与 Jupyter Notebook 的 <code>.ipynb</code> 文件放在一起，然后在 Jupyter 里面像导入普通模块那样导入即可，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-12-22-34-24.png" alt=""></p>
<p>那么现在问题来了，如果我此时修改了 <code>analyze.py</code>文件，会出现什么情况呢？</p>
<p>我们改一下看看，如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-12-22-36-31.png" alt=""></p>
<p>重新运行这个 Cell 中的代码，代码中虽然有<code>from analyze import FathersAnalyzer</code>，看起来像是重新导入了这个模块，但是运行却发现，它运行的是修改之前的代码。</p>
<p>这是因为，一个 Jupyter Notebook 中的所有代码，都是在同一个运行时中运行的代码，当你多次导入同一个模块时，Python 的包管理机制会自动忽略后面的导入，始终只使用第一次导入的结果（所以使用这种方式也可以实现单例模式）。</p>
<p>那么如果我在修改了被导入的包以后，想重新导入它怎么办呢？有3种方案：</p>
<ul>
<li>重启整个 Notebook。但这样会导致当前运行时里面的所有变量全部丢失。</li>
<li>使用<code>importlib</code>:</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-12-22-43-46.png" alt=""></p>
<p>但这种方案弊端也很明显——除非你按顺序运行每一个 Cell，否则，你的代码会变成下图这样：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-12-22-49-50.png" alt=""></p>
<p>在每一个 Cell 里面都需要 重新加载一次分析模块，否则，很有可能在你单独运行某一个 Cell 的时候，用的是老的代码，就会导致难以察觉的 bug。</p>
<ul>
<li>使用 Jupyter 自带的<code>%autoreload</code>:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">1</span></div><div class="line">%aimport analyze </div><div class="line"></div><div class="line">data = <span class="number">123</span></div><div class="line">importlib.reload(analyze)</div><div class="line">father = analyze.FathersAnalyzer(data)</div><div class="line">result = father.analyze()</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-10-12-22-53-57.png" alt=""></p>
<p>其中关键的代码有三行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">1</span></div><div class="line">%aimport analyze</div></pre></td></tr></table></figure>
<p>这三行代码只有在 Jupyter 里面才能正常运行，在 普通的.py 文件里面这样写会报错。它们的作用是：第1行启动<code>autoreload</code>机制。第2行，设置自动加载通过<code>%aimport</code>导入的模块。第3行使用<code>%aimport</code>导入<code>analyze</code>模块。</p>
<p>这样写以后，任意一个 Cell 运行，所有被<code>%aimport</code>导入的模块都会被重新加载一次。从而让你每次都使用最新的代码。</p>
<p>当然，你还可以进一步偷懒，把特殊代码缩减为2行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%load_ext autoreload</div><div class="line">%autoreload <span class="number">2</span></div></pre></td></tr></table></figure>
<p><code>%autoreload</code>后面的参数被设置为2时，每次运行任意一个 Cell，都会自动重新加载所有<code>import xxx</code>导入的模块。这样做的代价是，运行会慢一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jupyter 是数据分析领域非常有名的开发环境，使用 Jupyter 写数据分析相关的代码会大大节约开发时间。&lt;/p&gt;
&lt;p&gt;设想这样一个场景：别的部门的同事传给你一个数据分析的模块，用于实现对数据的高级分析。模块里面有上百个函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="Jupyter" scheme="https://www.kingname.info/tags/Jupyter/"/>
    
  </entry>
  
  <entry>
    <title>更优雅地在 Python 中写日志</title>
    <link href="https://www.kingname.info/2019/09/29/log-gracefully/"/>
    <id>https://www.kingname.info/2019/09/29/log-gracefully/</id>
    <published>2019-09-29T14:33:34.000Z</published>
    <updated>2019-10-30T14:45:46.655Z</updated>
    
    <content type="html"><![CDATA[<p>原来我们在 Python 中写日志，使用的是 Python 自带的 logging 模块，要实现既在终端输出，又能写文件，并且日志文件还能 rotate ，代码需要十多行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</div><div class="line"></div><div class="line">os.makedirs(<span class="string">'Logs'</span>, exists_ok=<span class="keyword">True</span>)</div><div class="line">logger = logging.getLogger(<span class="string">'Robot'</span>)</div><div class="line">handler = logging.StreamHandler()</div><div class="line">handler.setLevel(logging.DEBUG)</div><div class="line">file_handler = RotatingFileHandler(os.path.join(<span class="string">'Logs'</span>, <span class="string">'robot.log'</span>),</div><div class="line">maxBytes=<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>,</div><div class="line">backupCount=<span class="number">10</span>,</div><div class="line">encoding=<span class="string">'utf-8'</span>)</div><div class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</div><div class="line">handler.setFormatter(formatter)</div><div class="line">file_handler.setFormatter(formatter)</div><div class="line">logger.addHandler(handler)</div><div class="line">logger.addHandler(file_handler)</div><div class="line">logger.setLevel(logging.DEBUG)</div><div class="line"></div><div class="line">logger.info(<span class="string">'终于可以写日志了...'</span>)</div></pre></td></tr></table></figure>
<p>那有没有什么简单好用，<code>for human</code>的写日志方案呢？</p>
<a id="more"></a>
<p>当然有，那就是使用<a href="https://github.com/Delgan/loguru" target="_blank" rel="external">loguru</a>这个模块。</p>
<p>它有多好用呢？我们用一段代码来演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</div><div class="line">logger.add(<span class="string">'logs/z_project.log'</span>,</div><div class="line">           level=<span class="string">'DEBUG'</span>,</div><div class="line">           format=<span class="string">'&#123;time:YYYY-MM-DD  :mm:ss&#125; - &#123;level&#125; - &#123;file&#125; - &#123;line&#125; - &#123;message&#125;'</span>,</div><div class="line">           rotation=<span class="string">"10 MB"</span>)</div><div class="line">logger.info(<span class="string">'可以写日志了'</span>)</div></pre></td></tr></table></figure>
<p>不需要提前创建文件夹。不需要设置奇奇怪怪的<code>handler</code>。</p>
<p>甚至你可以直接把它当做装饰器使用，当一个函数报错的时候，自动记录日志：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@logger.catch</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'a'</span> + <span class="number">1</span></div></pre></td></tr></table></figure>
<p>函数报错时，自动记录报错信息到日志中。</p>
<p>他记录的报错信息有多准确呢？我们来看这个图：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-29-22-03-54.png" alt=""></p>
<p>每个变量的值都给你标出来了。</p>
<p>使用 loguru 也只需要定义一次格式。只需要在入口文件定义好格式，在同一个项目中的其他文件中，直接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</div><div class="line">logger.info(<span class="string">'可以用了'</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原来我们在 Python 中写日志，使用的是 Python 自带的 logging 模块，要实现既在终端输出，又能写文件，并且日志文件还能 rotate ，代码需要十多行：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; logging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; logging.handlers &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; RotatingFileHandler&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;os.makedirs(&lt;span class=&quot;string&quot;&gt;&#39;Logs&#39;&lt;/span&gt;, exists_ok=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger = logging.getLogger(&lt;span class=&quot;string&quot;&gt;&#39;Robot&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler = logging.StreamHandler()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler.setLevel(logging.DEBUG)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;file_handler = RotatingFileHandler(os.path.join(&lt;span class=&quot;string&quot;&gt;&#39;Logs&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;robot.log&#39;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;maxBytes=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;backupCount=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;encoding=&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;formatter = logging.Formatter(&lt;span class=&quot;string&quot;&gt;&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler.setFormatter(formatter)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;file_handler.setFormatter(formatter)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.addHandler(handler)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.addHandler(file_handler)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.setLevel(logging.DEBUG)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.info(&lt;span class=&quot;string&quot;&gt;&#39;终于可以写日志了...&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那有没有什么简单好用，&lt;code&gt;for human&lt;/code&gt;的写日志方案呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="loguru" scheme="https://www.kingname.info/tags/loguru/"/>
    
      <category term="logging" scheme="https://www.kingname.info/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>使用Pymongo实现更新并返回数据</title>
    <link href="https://www.kingname.info/2019/09/28/pymongo-update-return/"/>
    <id>https://www.kingname.info/2019/09/28/pymongo-update-return/</id>
    <published>2019-09-28T14:32:03.000Z</published>
    <updated>2019-10-30T14:46:03.020Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一个业务场景：</p>
<p>我有100篇故事，放在 MongoDB 里面。我做了一个 web 接口，每次请求返回一篇故事。希望能够实现：</p>
<p>每次请求返回的故事都不一样，在100次请求里面，每篇故事都需要返回。直到100篇故事全部返回完成。第101次与第1次相同，第102次与第2次相同……</p>
<a id="more"></a>
<p>为了实现这个目的，在 MongoDB 里面每一篇故事有3个字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"title"</span>: <span class="string">"故事标题"</span>, <span class="string">"content"</span>: <span class="string">"故事正文"</span>, <span class="string">"count"</span>: <span class="string">"请求计数"</span>&#125;</div></pre></td></tr></table></figure>
<p>如果只有一个人请求这个接口，并且他会等着上一次请求返回完成了再请求下一次，那么关键代码可以这样写：</p>
<ul>
<li>一开始，所有故事的 <code>count</code>字段都是0</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line">handler = pymongo.MongoClient().story_project.story</div><div class="line"></div><div class="line">story = list(handler.find().sort(<span class="string">'count'</span>, <span class="number">1</span>).limit(<span class="number">1</span>))[<span class="number">0</span>]</div><div class="line">_id = story[<span class="string">'_id'</span>]</div><div class="line">handler.update_one(&#123;<span class="string">'_id'</span>: _id&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'count'</span>: <span class="number">1</span>&#125;&#125;)</div></pre></td></tr></table></figure>
<p>每次查询都取 count 最小的这一条。查询完成以后，就更新 count 字段。</p>
<p>但是，如果有很多人同时访问这个 web 接口，那么就会出现并发读写冲突的问题。当第一个人读取了一篇故事，还没有来得及更新 count 时，另一个人又访问接口，这样他们两人就会得到同一篇故事。</p>
<p>为了解决这个问题，就需要把查询和更新作为一个原子操作来执行。此时，就要用到 pymongo 的<code>find_one_and_update</code>方法。它根据特定条件查询一条记录，同时更新这条记录的 count 值。这两个行为是通过一条命令完成的，即时多个人同时请求也不会出现并发冲突的情况。</p>
<p><code>find_one_and_update</code>的使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line">handler.find_one_and_update(&#123;&#125;,</div><div class="line">                         &#123;<span class="string">'$inc'</span>:&#123;<span class="string">'count'</span>: <span class="number">1</span>&#125;&#125;,</div><div class="line">                         sort=[(<span class="string">'count'</span>, <span class="number">1</span>)])</div></pre></td></tr></table></figure>
<p>其中，第一个参数表示查询条件，跟<code>find</code>的第一个参数一致。第二个参数表示更新的内容，与<code>update_one</code>的第二个参数一致。<code>sort</code>表示排序方式，它的值是一个包含元组的列表，元组的第一个元素为被排序的字段名，第二个元素为1表示升序，为-1表示降序。</p>
<p><code>update_one_and_update</code>还有其他参数，可以参考它的<a href="https://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one_and_update" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一个业务场景：&lt;/p&gt;
&lt;p&gt;我有100篇故事，放在 MongoDB 里面。我做了一个 web 接口，每次请求返回一篇故事。希望能够实现：&lt;/p&gt;
&lt;p&gt;每次请求返回的故事都不一样，在100次请求里面，每篇故事都需要返回。直到100篇故事全部返回完成。第101次与第1次相同，第102次与第2次相同……&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://www.kingname.info/categories/MongoDB/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="MongoDB" scheme="https://www.kingname.info/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>在 Python 中，is 并不一定包含==</title>
    <link href="https://www.kingname.info/2019/09/26/is-not-always-equal/"/>
    <id>https://www.kingname.info/2019/09/26/is-not-always-equal/</id>
    <published>2019-09-26T14:31:10.000Z</published>
    <updated>2019-10-30T14:46:18.157Z</updated>
    
    <content type="html"><![CDATA[<p>在我们日常使用 Python 时，大家可能有这样一种认识：</p>
<ul>
<li>a == b 为 <code>True</code>，a is b 不一定为 <code>True</code></li>
<li>a is b 为 <code>True</code>，则 a == b 一定为 <code>True</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = &apos;abc!&apos;</div><div class="line">&gt;&gt;&gt; b = &apos;abc!&apos;</div><div class="line">&gt;&gt;&gt; a == b</div><div class="line">True</div><div class="line">&gt;&gt;&gt; a is b</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c = a</div><div class="line">&gt;&gt;&gt; a is c</div><div class="line">True</div><div class="line">&gt;&gt;&gt; a == c</div><div class="line">True</div></pre></td></tr></table></figure>
<p>这是因为 <code>==</code> 只比较值，而 <code>is</code> 同时比较值和内存地址。简单来说:你左手边有一个人，右手边有一个人，两个人长得一模一样，那么<code>左手边的人==右手边的人</code>；你左手边有一个人，一分钟以后这个人走到了你的右手边，那么<code>刚才左手边的人 is 现在右手边的人</code></p>
<p>但凡事总有意外，情况下面的代码：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-26-22-17-41.png" alt=""></p>
<p>为什么会出现这种情况？<code>a is b</code>为 True，<code>a == b</code>却为 <code>False</code>。</p>
<p>你可以先停在这里，猜一下a 和 b 里面的值到底是什么东西。</p>
<p>现在来揭开答案，我们来网上看两行：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-26-22-23-43.png" alt=""></p>
<p>a 和 b 的值为<code>♂</code>，它的意思是<code>Not a Number</code>，非数。</p>
<p><code>♂</code>与任何数，包括它自己比较，结果都是 False，这是<a href="https://zh.wikipedia.org/wiki/IEEE_754#%E7%89%B9%E6%AE%8A%E5%80%BC" target="_blank" rel="external">IEEE-754</a>规定的：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-26-22-27-06.png" alt=""></p>
<p>Python 在实现这个数据的时候，根据 IEEE-754的要求，也做了限制：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-26-22-30-08.png" alt=""></p>
<p>相关的文档地址详见 Python 的 <a href="https://docs.python.org/3/library/math.html" target="_blank" rel="external">math 库</a></p>
<p>所以，这里 a == b 为 False，是一种特殊情况。并不是 Python 出现了错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们日常使用 Python 时，大家可能有这样一种认识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a == b 为 &lt;code&gt;True&lt;/code&gt;，a is b 不一定为 &lt;code&gt;True&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a is b 为 &lt;code&gt;True&lt;/code&gt;，则
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch批量插入时，存在就不插入</title>
    <link href="https://www.kingname.info/2019/09/25/es-not-insert-if-exists/"/>
    <id>https://www.kingname.info/2019/09/25/es-not-insert-if-exists/</id>
    <published>2019-09-25T14:29:29.000Z</published>
    <updated>2019-10-30T14:46:40.874Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用 Elasticsearch-py 批量插入数据到 ES 的时候，我们常常使用它的 <code>helpers</code>模块里面的<code>bulk</code>函数。其使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> helpers, Elasticsearch</div><div class="line"></div><div class="line">es = Elasticsearch(xxx)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">yield</span> &#123;</div><div class="line">            <span class="string">'_id'</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="string">'_source'</span>: &#123;</div><div class="line">                <span class="string">'age'</span>: data</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">helpers.bulk(es,</div><div class="line">index=<span class="string">'xxx'</span>,</div><div class="line">generator(),</div><div class="line">doc_type=<span class="string">'doc'</span>,)</div></pre></td></tr></table></figure>
<p>但这种方式有一个问题，它默认相当于<code>upsert</code>操作。如果<code>_id</code> 对应的文档已经在 ES 里面了，那么数据会被更新。如果<code>_id</code> 对应的文档不在 ES 中，那么就插入。</p>
<a id="more"></a>
<p>如果我想实现，不存在就插入，存在就跳过怎么办？此时就需要在文档里面添加<code>_op_type</code>指定操作类型为<code>create</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> helpers, Elasticsearch</div><div class="line"></div><div class="line">es = Elasticsearch(xxx)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</div><div class="line">        <span class="keyword">yield</span> &#123;</div><div class="line">            <span class="string">'_op_type'</span>: <span class="string">'create'</span>,</div><div class="line">            <span class="string">'_id'</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="string">'_source'</span>: &#123;</div><div class="line">                <span class="string">'age'</span>: data</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">helpers.bulk(es,</div><div class="line">generator(),</div><div class="line">index=<span class="string">'xxx'</span>,</div><div class="line">doc_type=<span class="string">'doc'</span>)</div></pre></td></tr></table></figure>
<p>此时，如果<code>_id</code> 对应的文档不在 ES 中，那么就会正常插入，如果<code>ES</code>里面已经有<code>_id</code>对应的数据了，那么就会报错。由于<code>bulk</code>一次性默认插入500条数据，假设其中有2条数据已经存在了，那么剩下的498条会被正常插入。然后程序报错退出，告诉你有两条写入失败，因为已经存在。</p>
<p>如果你不想让程序报错终止，那么可以增加2个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">helpers.bulk(es,</div><div class="line">    generator(),</div><div class="line">    index=<span class="string">'xxx'</span>,</div><div class="line">    doc_type=<span class="string">'doc'</span>,</div><div class="line">    raise_on_exception=<span class="keyword">False</span>,               raise_on_error=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>其中<code>raise_on_exception=False</code>表示在插入数据失败时，不需要抛出异常。<code>raise_on_error=False</code>表示不抛出<code>BulkIndexError</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们使用 Elasticsearch-py 批量插入数据到 ES 的时候，我们常常使用它的 &lt;code&gt;helpers&lt;/code&gt;模块里面的&lt;code&gt;bulk&lt;/code&gt;函数。其使用方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; elasticsearch &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; helpers, Elasticsearch&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;es = Elasticsearch(xxx)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    datas = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; data &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; datas:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;_id&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;_source&#39;&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;: data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;helpers.bulk(es,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;index=&lt;span class=&quot;string&quot;&gt;&#39;xxx&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;generator(),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;doc_type=&lt;span class=&quot;string&quot;&gt;&#39;doc&#39;&lt;/span&gt;,)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但这种方式有一个问题，它默认相当于&lt;code&gt;upsert&lt;/code&gt;操作。如果&lt;code&gt;_id&lt;/code&gt; 对应的文档已经在 ES 里面了，那么数据会被更新。如果&lt;code&gt;_id&lt;/code&gt; 对应的文档不在 ES 中，那么就插入。&lt;/p&gt;
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://www.kingname.info/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://www.kingname.info/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>GNE 预处理技术——如何移除特定标签但是保留文字到父标签</title>
    <link href="https://www.kingname.info/2019/09/22/remove-tag-without-text/"/>
    <id>https://www.kingname.info/2019/09/22/remove-tag-without-text/</id>
    <published>2019-09-22T10:28:02.000Z</published>
    <updated>2019-09-22T10:31:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>在开发新闻网页正文通用抽取器<a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="external">GNE</a>的过程中，需要对目标网页的源代码进行一些预处理，从而提高正文抓取的准确性。其中之一就是把 <code>&lt;p&gt;</code>标签内部的 <code>&lt;span&gt;</code>标签中的文本，合并到<code>&lt;p&gt;</code>标签中，再删除 <code>&lt;span&gt;</code> 标签。</p>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>演示合并节点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好,<span class="tag">&lt;<span class="name">span</span>&gt;</span>世界;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>你好，<span class="tag">&lt;<span class="name">span</span>&gt;</span>产品经理<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>需要转换为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>演示合并节点<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好,世界;你好，产品经理<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在原来做定向爬虫的时候，这本不是什么问题，因为使用 XPath 可以直接提取所有内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</div><div class="line">selector = fromstring(html)</div><div class="line">text = <span class="string">''</span>.join(selector.xpath(<span class="string">'//p//text()'</span>))</div><div class="line">print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-22-17-03-43.png" alt=""></p>
<p>但在通用新闻抽取器里面不能这样写。因为并不是所有的<code>&lt;p&gt;</code>标签中的内容都是新闻正文。GNE 有一套算法来计算并寻找全部包含真正有效内容的<code>&lt;p&gt;</code>标签。这就要求在预处理阶段，需要把 <code>&lt;p&gt;</code>标签里面的<code>&lt;span&gt;</code>标签合并到<code>&lt;p&gt;</code>标签里面。</p>
<p>可能有人的第一反应是：先把 <code>&lt;p&gt;</code> 标签里面的内容提取出来，然后再把 <code>&lt;span&gt;</code> 标签里面的内容提取出来，并添加到 <code>&lt;p&gt;</code> 标签中。这不就解决问题了吗？</p>
<p>但实际上并没有这么简单。以上面的 HTML 代码为了，如果按照这种简单的解法，那么分别提取以后会得到如下内容：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-22-17-11-59.png" alt=""></p>
<p>现在问题来了，你怎么知道 <code>&lt;span&gt;</code> 标签中提取出来的这两个字符串<code>世界</code>, <code>产品经理</code>，分别应该插入到 <code>&lt;p&gt;</code> 标签结果列表中的哪个位置？所以这种方案并不可取。</p>
<p>那么又有人问，能不能使用 XPath 的<code>string</code>关键字把 <code>&lt;p&gt;</code> 标签下面的所有文本直接提取出来，再作处理呢？这样不就可以忽略标签差异了吗？在上面的 html 代码中，这种方案是可行的：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-22-17-16-53.png" alt=""></p>
<p>但是，这种方案不能应用到 GNE 中。这是由于这种做法，会无差别移除所有的标签。但是<code>&lt;p&gt;</code> 标签下面的<code>&lt;a&gt;</code>标签是有用的，它在用于过滤导航栏或者推荐新闻这种类型的干扰内容中会起到很大的作用。所以<code>&lt;a&gt;</code>标签必需保留。</p>
<p>那么，本文标题提到的问题：<code>如何移除指定标签，但是保留它的文本，合并到父标签中？</code>应该如何解决呢？</p>
<p>实际上，这个问题在 lxml 中有现成的办法解决，他就是<code>etree.strip_tags</code></p>
<p>使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> etree</div><div class="line"></div><div class="line">etree.strip_tags(element, <span class="string">'标签1'</span>, <span class="string">'标签2'</span>, <span class="string">'标签3'</span>)</div></pre></td></tr></table></figure>
<p>在本文的例子中，解决方案如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring, etree</div><div class="line"></div><div class="line"></div><div class="line">selector = fromstring(html)</div><div class="line">p_tag_list = selector.xpath(<span class="string">'//p'</span>)</div><div class="line"><span class="keyword">for</span> p_tag <span class="keyword">in</span> p_tag_list:</div><div class="line">    etree.strip_tags(p_tag, <span class="string">'span'</span>)</div><div class="line"></div><div class="line">text = <span class="string">''</span>.join(selector.xpath(<span class="string">'//p/text()'</span>))</div><div class="line">print(text)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-22-17-26-23.png" alt=""></p>
<p>需要注意的是，<code>etree.strip_tags()</code>会直接修改原始Dom 树，不需要返回修改结果。</p>
<p>GNE 的其他关键技术，将会在接下来的文章中逐一放出，你也可以访问GNE 的 Github 主页：<a href="https://github.com/kingname/GeneralNewsExtractor" target="_blank" rel="external">https://github.com/kingname/GeneralNewsExtractor</a>，提前阅读项目源代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发新闻网页正文通用抽取器&lt;a href=&quot;https://github.com/kingname/GeneralNewsExtractor&quot;&gt;GNE&lt;/a&gt;的过程中，需要对目标网页的源代码进行一些预处理，从而提高正文抓取的准确性。其中之一就是把 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签内部的 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;标签中的文本，合并到&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签中，再删除 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>新闻类网页正文通用抽取器（一）——项目介绍</title>
    <link href="https://www.kingname.info/2019/09/09/generalnewsextractor/"/>
    <id>https://www.kingname.info/2019/09/09/generalnewsextractor/</id>
    <published>2019-09-09T07:20:29.000Z</published>
    <updated>2019-09-22T10:32:13.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目起源"><a href="#项目起源" class="headerlink" title="项目起源"></a>项目起源</h2><p>开发这个项目，源自于我在知网发现了一篇关于自动化抽取新闻类网站正文的算法论文——<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2019&amp;filename=GWDZ201908029&amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=" target="_blank" rel="external">《基于文本及符号密度的网页正文提取方法》</a>）</p>
<p>这篇论文中描述的算法看起来简洁清晰，并且符合逻辑。但由于论文中只讲了算法原理，并没有具体的语言实现，所以我使用 Python 根据论文实现了这个抽取器。并分别使用今日头条、网易新闻、游民星空、观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻做了测试，发现提取效果非常出色，几乎能够达到100%的准确率。</p>
<a id="more"></a>
<h2 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h2><p>在论文中描述的正文提取基础上，我增加了标题、发布时间和文章作者的自动化探测与提取功能。</p>
<p>最后的输出效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-08-22-02-04.png" alt=""></p>
<p>目前这个项目是一个非常非常早期的 Demo，发布出来是希望能够尽快得到大家的使用反馈，从而能够更好地有针对性地进行开发。</p>
<p>本项目取名为<code>抽取器</code>，而不是<code>爬虫</code>，是为了规避不必要的风险，因此，本项目的输入是 HTML，输出是一个字典。请自行使用恰当的方法获取目标网站的 HTML。</p>
<p><strong>本项目现在不会，将来也不会提供主动请求网站 HTML 的功能。</strong></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>本项目使用 <code>Pipenv</code>管理 Python 的第三方库。如果你不知道 <code>Pipenv</code> 是什么，请<a href="https://github.com/pypa/pipenv" target="_blank" rel="external">点我跳转</a>。</p>
<p>安装完成<code>Pipenv</code>以后，按照如下步骤运行代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/kingname/GeneralNewsExtractor.git</div><div class="line"><span class="built_in">cd</span> GeneralNewsExtractor</div><div class="line">pipenv install</div><div class="line">pipenv shell</div><div class="line">python3 GeneralNewsCrawler.py</div></pre></td></tr></table></figure>
<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><p>项目代码中的<code>GeneralNewsCrawler.py</code>提供了本项目的基本使用示例。</p>
<ul>
<li>本项目的测试代码在<code>test</code>文件夹中</li>
<li>本项目的输入 HTML 为经过 JavaScript 渲染以后的 HTML，而不是普通的网页源代码。所以无论是后端渲染、Ajax 异步加载都适用于本项目。</li>
<li>如果你要手动测试新的目标网站或者目标新闻，那么你可以在 Chrome 浏览器中打开对应页面，然后开启<code>开发者工具</code>，如下图所示：</li>
</ul>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-08-22-20-33.png" alt=""></p>
<p>在<code>Elements</code>标签页定位到<code>&lt;html&gt;</code>标签，并右键，选择<code>Copy</code>-<code>Copy OuterHTML</code>，如下图所示</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-09-08-22-21-49.png" alt=""></p>
<ul>
<li><p>当然，你可以使用 Puppeteer/Pyppeteer、Selenium 或者其他任何方式获取目标页面的<code>JavaScript渲染后的</code>源代码。</p>
</li>
<li><p>获取到源代码以后，通过如下代码提取信息：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> GeneralNewsCrawler <span class="keyword">import</span> GeneralNewsExtractor</div><div class="line"></div><div class="line">extractor = GeneralNewsExtractor()</div><div class="line">html = <span class="string">'你的目标网页正文'</span></div><div class="line">result = extractor.extract(html)</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>对大多数新闻页面而言，以上的写法就能够解决问题了。</p>
<p>但某些新闻网页下面会有评论，评论里面可能存在长篇大论，它们会看起来比真正的新闻正文更像是正文，因此<code>extractor.extract()</code>方法还有一个默认参数<code>noise_mode_list</code>，用于在网页预处理时提前把评论区域整个移除。</p>
<p><code>noise_mode_list</code>的值是一个列表，列表里面的每一个元素都是 XPath，对应了你需要提前移除的，可能会导致干扰的目标标签。</p>
<p>例如，<code>观察者网</code>下面的评论区域对应的Xpath 为<code>//div[@class=&quot;comment-list&quot;]</code>。所以在提取观察者网时，为了防止评论干扰，就可以加上这个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = extractor.extract(html, noise_node_list=[<span class="string">'//div[@class="comment-list"]'</span>])</div></pre></td></tr></table></figure>
<p><code>test</code>文件夹中的网页的提取结果，请查看<code>result.txt</code>。</p>
<h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><p><a href="https://github.com/kingname/GeneralNewsExtractor/wiki/GeneralNewsExtractor-Q&amp;A" target="_blank" rel="external">GNE 常见问题 Q&amp;A</a></p>
<h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ol>
<li>目前本项目只适用于新闻页的信息提取。如果目标网站不是新闻页，或者是今日头条中的相册型文章，那么抽取结果可能不符合预期。</li>
<li>可能会有一些新闻页面出现抽取结果中的作者为空字符串的情况，这可能是由于文章本身没有作者，或者使用了已有正则表达式没有覆盖到的情况。</li>
</ol>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul>
<li>使用一个配置文件来存放常量数据，而不是直接 Hard Code 写在代码中。</li>
<li>允许自定义时间、作者的提取Pattern</li>
<li>新闻文章列表页提取</li>
<li>对于多页的新闻，允许传入一个 HTML 列表，GNE 解析以后，自动拼接为完整的新闻正文</li>
<li>优化内容提取速度</li>
<li>测试更多新闻网站</li>
<li>……</li>
</ul>
<h2 id="交流沟通"><a href="#交流沟通" class="headerlink" title="交流沟通"></a>交流沟通</h2><p>如果您觉得GNE对您的日常开发或公司有帮助，请加作者微信 mxqiuchen（或扫描下方二维码） 并注明”GNE”，作者会将你拉入群。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_3729_2.JPG" alt=""></p>
<p>验证消息：<code>GNE</code></p>
<h2 id="论文修订"><a href="#论文修订" class="headerlink" title="论文修订"></a>论文修订</h2><p>在使用 Python 实现这个抽取器的过程中，我发现论文里面的公式和方法存在一些纰漏，会导致部分节点报错。我将会单独写几篇文章来介绍这里的修改。请关注我的微信公众号：未闻Code：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目起源&quot;&gt;&lt;a href=&quot;#项目起源&quot; class=&quot;headerlink&quot; title=&quot;项目起源&quot;&gt;&lt;/a&gt;项目起源&lt;/h2&gt;&lt;p&gt;开发这个项目，源自于我在知网发现了一篇关于自动化抽取新闻类网站正文的算法论文——&lt;a href=&quot;https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;amp;dbname=CJFDLAST2019&amp;amp;filename=GWDZ201908029&amp;amp;v=MDY4MTRxVHJXTTFGckNVUkxPZmJ1Wm5GQ2poVXJyQklqclBkTEc0SDlqTXA0OUhiWVI4ZVgxTHV4WVM3RGgxVDM=&quot;&gt;《基于文本及符号密度的网页正文提取方法》&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;这篇论文中描述的算法看起来简洁清晰，并且符合逻辑。但由于论文中只讲了算法原理，并没有具体的语言实现，所以我使用 Python 根据论文实现了这个抽取器。并分别使用今日头条、网易新闻、游民星空、观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻做了测试，发现提取效果非常出色，几乎能够达到100%的准确率。&lt;/p&gt;
    
    </summary>
    
      <category term="GNE" scheme="https://www.kingname.info/categories/GNE/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="通用爬虫" scheme="https://www.kingname.info/tags/%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB/"/>
    
      <category term="新闻爬虫" scheme="https://www.kingname.info/tags/%E6%96%B0%E9%97%BB%E7%88%AC%E8%99%AB/"/>
    
      <category term="GNE" scheme="https://www.kingname.info/tags/GNE/"/>
    
  </entry>
  
  <entry>
    <title>在Pyppeteer中正确隐藏window.navigator.webdriver</title>
    <link href="https://www.kingname.info/2019/08/18/hide-webdriver-in-pyppeteer/"/>
    <id>https://www.kingname.info/2019/08/18/hide-webdriver-in-pyppeteer/</id>
    <published>2019-08-18T01:36:25.000Z</published>
    <updated>2019-08-18T01:37:56.500Z</updated>
    
    <content type="html"><![CDATA[<p>在我以前的一篇文章：<a href="https://mp.weixin.qq.com/s/TqL3OawPe9zW_nneyXvefQ" target="_blank" rel="external">一日一技：如何正确移除Selenium中window.navigator.webdriver的值</a>，我讲到了如何在Selenium启动的Chrome中，通过设置启动参数隐藏<code>window.navigator.webdriver</code>，驳斥了网上垃圾文章中流传的使用JavaScript注入的弊端。</p>
<p>由于Selenium启动的Chrome中，有几十个特征可以被识别，所以在爬虫界已经没有以前那么受欢迎了。模拟浏览器的新秀Puppeteer异军突起，逐渐受到了爬虫界的关注。Puppeteer需要使用JavaScript来控制，如果你是用Python，那么就需要使用Pyppeteer.</p>
<p>如果你使用模拟浏览器爬淘宝，你会发现，无论怎么修改参数，Selenium总是可以立刻被识别。但是如果你使用了本文的方法，用Pyppeteer抓取淘宝，你就会发现另外一个广阔的天地。</p>
<p>今天，我们来讲讲如何在Pyppeteer中隐藏<code>window.navigator.webdriver</code></p>
<a id="more"></a>
<p>首先，我们使用下面的代码，通过Pyppeteer打开浏览器窗口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    browser = <span class="keyword">await</span> launch(executablePath=<span class="string">'/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'</span>,</div><div class="line">                           headless=<span class="keyword">False</span>)</div><div class="line">    page = <span class="keyword">await</span> browser.newPage()</div><div class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://exercise.kingname.info'</span>)</div><div class="line">    input(<span class="string">'测试完成以后回到这里按下回车...'</span>)</div><div class="line">    <span class="keyword">await</span> browser.close()</div><div class="line"></div><div class="line">asyncio.get_event_loop().run_until_complete(main())</div></pre></td></tr></table></figure>
<p>代码运行以后，会打开Chrome浏览器，并访问<code>http://exercise.kingname.info/</code>(这是我写的爬虫练习网站，大家可以用这个网站练习爬虫开发，里面有几道题挺难^_^)</p>
<p>在这个浏览器中，我们打开开发者工具，查询<code>window.navigator.webdriver</code>会发现它的值为<code>true</code>。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-20-52-06.png" alt=""></p>
<p>网上的代码，无外乎注入JavaScript，在网页自带的JavaScript加载之前，提前运行一段JavaScript，修改查询<code>window.navigator.webdriver</code>的接口。</p>
<p>这种方式每开一个新页面都要执行一次，繁琐，愚蠢！</p>
<p>那么正确的办法是什么呢？</p>
<p>我写这篇文章的时候（2019-08-15），Pyppeteer的最新版本为0.0.25，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-08-18.png" alt=""></p>
<p>此时，你可以在PyCharm中，按住Command键（Windows、Linux用户按住Ctrl键），鼠标左键点击<code>from pyppeteer import launch</code>中的<code>launch</code>，自动跳转到Pyppeteer源代码中的<code>launcher.py</code>文件。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-10-30.png" alt=""></p>
<p>把代码往上翻，在第60行左右，找到如下图方框框住的代码：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-10-59.png" alt=""></p>
<p>把<code>--enable-automation</code>这一行注释掉。此时PyCharm会提示你是否修改源代码，选择OK。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-11-33.png" alt=""></p>
<p>修改完成以后的代码如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-12-38.png" alt=""></p>
<p>以上就是你需要做的全部修改。</p>
<p>重新运行刚才的代码，你会发现，<code>window.navigator.webdriver</code>已经是<code>undefined</code>了。如下图所示。</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-14-09.png" alt=""></p>
<p>在Pyppeteer即将发布的0.0.26版本的功能里面，我看到了如下图方框框住的一项：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-15-21-15-39.png" alt=""></p>
<p>所以，等0.0.26版本发布以后，我们就可以直接通过传递参数来禁用<code>--enable-automation</code>了，不再需要修改源代码了。</p>
<p>题外话：官方文档和源代码是你的好朋友，如果官方文档找不到你想要的功能，源代码又看不懂，那么就来关注我的公众号吧。长按下面的二维码关注我：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我以前的一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/TqL3OawPe9zW_nneyXvefQ&quot;&gt;一日一技：如何正确移除Selenium中window.navigator.webdriver的值&lt;/a&gt;，我讲到了如何在Selenium启动的Chrome中，通过设置启动参数隐藏&lt;code&gt;window.navigator.webdriver&lt;/code&gt;，驳斥了网上垃圾文章中流传的使用JavaScript注入的弊端。&lt;/p&gt;
&lt;p&gt;由于Selenium启动的Chrome中，有几十个特征可以被识别，所以在爬虫界已经没有以前那么受欢迎了。模拟浏览器的新秀Puppeteer异军突起，逐渐受到了爬虫界的关注。Puppeteer需要使用JavaScript来控制，如果你是用Python，那么就需要使用Pyppeteer.&lt;/p&gt;
&lt;p&gt;如果你使用模拟浏览器爬淘宝，你会发现，无论怎么修改参数，Selenium总是可以立刻被识别。但是如果你使用了本文的方法，用Pyppeteer抓取淘宝，你就会发现另外一个广阔的天地。&lt;/p&gt;
&lt;p&gt;今天，我们来讲讲如何在Pyppeteer中隐藏&lt;code&gt;window.navigator.webdriver&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="爬虫" scheme="https://www.kingname.info/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Pyppeteer" scheme="https://www.kingname.info/tags/Pyppeteer/"/>
    
  </entry>
  
  <entry>
    <title>回《驳 &lt;Python正则表达式，请不要再用re.compile了！！！&gt;》</title>
    <link href="https://www.kingname.info/2019/08/18/dont-use-re-compile-again/"/>
    <id>https://www.kingname.info/2019/08/18/dont-use-re-compile-again/</id>
    <published>2019-08-17T16:10:03.000Z</published>
    <updated>2019-08-18T01:31:54.699Z</updated>
    
    <content type="html"><![CDATA[<p>知乎用户<a href="https://www.zhihu.com/people/li-zhe-ao/posts" target="_blank" rel="external">@Manjusaka
</a>在阅读了我的文章<a href="https://zhuanlan.zhihu.com/p/70680488" target="_blank" rel="external">《Python正则表达式，请不要再用re.compile了！！！》</a>以后，写了一篇驳文<a href="https://zhuanlan.zhihu.com/p/78265675" target="_blank" rel="external">《驳 <python正则表达式，请不要再用re.compile了！！！>》</python正则表达式，请不要再用re.compile了！！！></a></p>
<p>今天，我在这里回应一下这篇驳文。首先标题里面，我用的是<code>回</code>，意为回复，而不是继续驳斥@Manjusaka的文章。因为没有什么好驳斥的，他的观点没有什么问题。</p>
<p>首先说明，我自己在公司的代码里面，也会使用<code>re.compile</code>。但是，我现在仍然坚持我的观点，让看这篇文章的人，不要用<code>re.compile</code>。</p>
<a id="more"></a>
<h2 id="你真的在意这点性能？"><a href="#你真的在意这点性能？" class="headerlink" title="你真的在意这点性能？"></a>你真的在意这点性能？</h2><p>在公司里面，我使用<code>re.compile</code>的场景是这样的：</p>
<p>每两小时从10亿条字符串中，筛选出所有不符合特定正则表达式的字符串。</p>
<p>这个程序可以简化为如下结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">regex_list = [<span class="string">'恭喜玩家：(.*?)获得'</span>, <span class="string">'欢迎(.*?)回家'</span>, <span class="string">'组队三缺一'</span>]</div><div class="line">sentence_list = [<span class="string">'字符串1'</span>, <span class="string">'字符串2'</span>, ..., <span class="string">'字符串10亿'</span>]</div><div class="line">useful_sentence = []</div><div class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentence_list:</div><div class="line">    <span class="keyword">for</span> regex <span class="keyword">in</span> regex_list:</div><div class="line">        <span class="keyword">if</span> re.search(regex, sentence):</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        useful_sentence.append(sentence)</div></pre></td></tr></table></figure>
<p>在这个场景下面，对于10亿个字符串，3个正则表达式，需要循环30亿次。虽然读取正则表达式缓存的时间很短，假设只有1毫秒，那么也会浪费833小时。为了实现2小时内处理10亿条数据，我做了很多优化，其中之一就是提前<code>re.compile</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">regex_list = [<span class="string">'恭喜玩家：(.*?)获得'</span>, <span class="string">'欢迎(.*?)回家'</span>, <span class="string">'组队三缺一'</span>]</div><div class="line">sentence_list = [<span class="string">'字符串1'</span>, <span class="string">'字符串2'</span>, ..., <span class="string">'字符串10亿'</span>]</div><div class="line">compiled_regex_list = [re.compile(x) <span class="keyword">for</span> x <span class="keyword">in</span> regex_list]</div><div class="line">useful_sentence = []</div><div class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentence_list:</div><div class="line">    <span class="keyword">for</span> regex <span class="keyword">in</span> compiled_regex_list:</div><div class="line">        <span class="keyword">if</span> regex.search(sentence):</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        useful_sentence.append(sentence)</div></pre></td></tr></table></figure>
<p>在这样的场景下，这样的数据量级下面，你是用<code>re.compile</code>，当然可以。</p>
<p>然而，你日常接触到的工作，都是这个量级吗？知乎上流行一句话：</p>
<blockquote>
<p>抛开剂量谈毒性，都是耍流氓。</p>
</blockquote>
<p>同样的，在数据处理上也适用：</p>
<blockquote>
<p>抛开量级谈性能差异，都是耍流氓</p>
</blockquote>
<p>处理几百条数据，还需要担心读取缓存字典的这点小小的性能开销？</p>
<p>我在另一篇文章<a href="https://zhuanlan.zhihu.com/p/73426505" target="_blank" rel="external">为什么Python 3.6以后字典有序并且效率更高？</a>中提到，从Python 3.6开始，字典不会再提前申请更多空间了，同时也变得有序了，作为代价就是从字典读取值的过程多了一步。多出来的这一步实际上也会有性能开销，因为它需要先查询<code>indices</code>，然后再查询<code>entries</code>。为什么Python愿意放弃性能而要让字典有序？因为新的实现方式，在整体迭代、空间利用率上面都更高。</p>
<h2 id="维护自文档性"><a href="#维护自文档性" class="headerlink" title="维护自文档性"></a>维护自文档性</h2><p>回到正则表达式的例子来，Python区别于其他语言的一个非常重要的点是什么？是它的自文档性。</p>
<p>网上有这样一个段子：</p>
<blockquote>
<p>问：如何把伪代码改写为Python代码？<br>答：把.txt改成.py即可。</p>
</blockquote>
<p>Python的自文档性非常好，即便完全不懂编程的人，看到Python的代码，也能猜的出代码想实现什么功能。</p>
<p>请大家对比下面两种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.findall(<span class="string">'密码: (.*?)$'</span>, sentence)</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">regex = re.compile(<span class="string">'密码: (.*?)$'</span>)</div><div class="line">regex.findall(sentence)</div></pre></td></tr></table></figure>
<p>如果让一个完全不会编程的人来看，他看到第一段代码，会猜测：“findall是查找全部，这段代码可能是要从sentence找什么东西”。</p>
<p>而如果让他看第二段代码，他肯定会先问一句：“compile？编译？什么是编译？编写翻译吗？”</p>
<p>而对于刚刚学编程的人来说，如果他看的Python正则表达式入门的文档里面用了<code>re.compile</code>，他也会很疑惑，为什么要<code>compile</code>？编译成了什么东西？为什么不能直接查询？于是新人可能会过早去研究底层的东西。</p>
<p>但如果他看的文章直接是<code>re.findall</code>，那么语义非常明确：<code>正则表达式.查询所有</code>，一目了然，轻轻松松就能理解并学会。</p>
<h2 id="以官方文档的实例入门"><a href="#以官方文档的实例入门" class="headerlink" title="以官方文档的实例入门"></a>以官方文档的实例入门</h2><p>当我们学习一门新的语言的时候，第一应该参考的就是它的官方文档。在正则表达式官方文档<a href="https://docs.python.org/3/library/re.html#finding-all-adverbs" target="_blank" rel="external">https://docs.python.org/3/library/re.html#finding-all-adverbs</a>的例子中，无论是<code>search</code>还是<code>findall</code>都是使用<code>re.xxx</code>的形式。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-22-57-21.png" alt=""></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-22-57-43.png" alt=""></p>
<p>所以网上那些首先使用<code>pattern = re.compile</code>，再<code>pattern.xxx</code>的人，要不就是直接从其他语言把先<code>compile</code>再查询的思维定势带到了Python中，要不就是做正则表达式调优做太久了，思维僵化了，一抬手就是<code>re.compile</code>。</p>
<h2 id="面向接口编程还是面向人类编程？"><a href="#面向接口编程还是面向人类编程？" class="headerlink" title="面向接口编程还是面向人类编程？"></a>面向接口编程还是面向人类编程？</h2><p>在我文章的评论里面，有人说，应该面向接口编程，而不是面向实现编程。</p>
<p>对这些人，我想跟你们讲：你们对面向接口编程，理解得太狭隘了！</p>
<p>我们来看看，在Python著名的http库<code>requests</code>出来之前，使用<code>urllib2</code>发起一个请求是怎么写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line">gh_url = <span class="string">'https://api.github.com'</span></div><div class="line">req = urllib2.Request(gh_url)</div><div class="line">password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()</div><div class="line">password_manager.add_password(<span class="keyword">None</span>, gh_url, <span class="string">'user'</span>, <span class="string">'pass'</span>)</div><div class="line">auth_manager = urllib2.HTTPBasicAuthHandler(password_manager)</div><div class="line">opener = urllib2.build_opener(auth_manager)</div><div class="line">urllib2.install_opener(opener)</div><div class="line">handler = urllib2.urlopen(req)</div></pre></td></tr></table></figure>
<p>有了<code>requests</code>以后，实现同样的功能，我们是这样写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">r = requests.get(<span class="string">'https://api.github.com'</span>, auth=(<span class="string">'user'</span>, <span class="string">'pass'</span>))</div></pre></td></tr></table></figure>
<p>大家自己品位一下，<code>req = urllib2.Request(gh_url)</code>如果类比为<code>pattern = re.compile(&#39;xxxx&#39;)</code>，<code>handler = urllib2.urlopen(req)</code>类比为<code>pattern.findall(sentence)</code> 那么，<code>requests.get(xxx)</code>就是<code>re.findall</code>。</p>
<p>为什么我们现在愿意使用<code>requests</code>而不愿意使用<code>urllib2</code>？</p>
<p>因为<code>requests</code>是<strong>for human</strong>，而<code>urllib</code>是<code>for interface</code>.</p>
<h2 id="不是问题的问题"><a href="#不是问题的问题" class="headerlink" title="不是问题的问题"></a>不是问题的问题</h2><p>在评论里面，竟然有人质疑我使用<code>re.findall</code>，正则表达式不好维护？</p>
<p>@Manjusaka竟然举出了下面这样的例子：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-17-23-24-58.png" alt=""></p>
<p>为什么使用<code>re.findall</code>，就一定要把正则表达式复制粘贴很多遍？</p>
<p>我单独定义一个文件不行吗：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># regex_str.py</span></div><div class="line"></div><div class="line">NAME_REGEX = <span class="string">'name:(.*?),'</span></div><div class="line">AGE_REGEX = <span class="string">'age:(\d+)'</span></div><div class="line">ADDRESS_REGEX = <span class="string">'address:(.*?),'</span></div></pre></td></tr></table></figure>
<p>然后我要使用正则表达式的地方直接导入进来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> regex_str</div><div class="line"></div><div class="line">name = re.findall(regex_str.NAME_REGEX, sentence)</div><div class="line">age = re.findall(regex_str.AGE_REGEX, sentence)</div></pre></td></tr></table></figure>
<p>请问哪里不好维护了？根本不会出现@Manjusaka说的那种情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我的观点如下：</p>
<ol>
<li>re.compile很重要，也有用。但是大多数时候你不需要使用它。</li>
<li>对于初学者，请直接使用<code>re.findall</code> <code>re.search</code>，不要使用<code>re.compile</code>。</li>
<li>对于有经验的工程师，在开发项目的时候，请首先使用<code>re.findall</code> <code>re.search</code>等等上层函数，直到你需要考虑优化正则表达式查询性能的时候，再考虑先<code>re.compile</code>。因为很多时候，你的代码性能，还不至于需要靠几行<code>re.compile</code>来提高。</li>
<li>有人问正则表达式默认缓存512条，这个数字没有写在文档里面，如果哪天改了怎么办？我的回答是：看看你写过的代码，涉及到的正则表达式有几次超过了100条？</li>
<li>正则表达式基于DFA，在它的原理上，compile这一步确实是必需的。但这并不意味着，在写代码的时候，我们一定要自己手动写compile. 毕竟封装、抽象才是高级语言的一大特征，直接。在其他编程语言里面，没有把compile和查询封装成一个整体接口，但是在Python里面这样做了。那么我们就应该用这个更上层的接口。而不是手动compile再查询。</li>
<li>为什么Java程序员常常加班，而Python程序员常常提前完成任务？正是因为这种Language Specific的特性提高了生产效率，屏蔽了前期不需要太早关心的实现细节。如果抱着写代码要语言无关，要通用而故意放弃了一些语言特性，那为什么不直接写1010？那才是真正的语言无关，所有语言都是建立于二进制的1010上的。</li>
</ol>
<h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>以下内容与本次讨论的re.compile无关。</p>
<p>@Manjusaka给出了一个compile需要3秒钟的大型正则表达式，并以此作为例子说明re.compile的合理性。</p>
<p>首先这种情况下，确实需要提前re.compile。</p>
<p>但我所想表达的是，在这种情况下，就不应该使用正则表达式。既然要做Redis的语法校验，那么就应该使用有限状态机。这种使用很多的f表达式拼出来的正则表达式，才是真正的难以维护，难以阅读。</p>
<p>否则为什么里面需要用一个csv文件来存放命令呢？为什么不直接写在正则表达式里面呢？使用CSV文件每行一个命令尚且可以理解，但是<code>SLOT</code>/<code>SLOTS</code>/<code>NODE</code>/<code>NEWKWY</code>这些正则表达式，可就说不过去了。或条件连接的每一段都要加上这些东西，如果直接写进去，这个正则表达式你们自己都看不下去了，所以才会需要使用拼接的方式生成。</p>
<p>我在读这段代码的时候，首先看到正则表达式里面的<code>t[xxx]</code>，会先去找<code>t</code>是什么东西，发现t是一个字典，字典是在<code>commands_csv_loader.py</code>中生成的，然后去到这个文件里面，发现它读的是一个存放Redis命令的CSV文件。然后去项目根目录读取这个csv文件的内容，知道了它的结构，于是推测出t的结构。然后再回到正则表达式里面，继续看这个超大的正则表达式。整个过程会非常费时间和脑子。</p>
<p>但是，我又不能直接打印REDIS_COMMANDS这个变量，因为它多且乱，不同命令长短不一，拼出来以后再打印出来根本没法看。</p>
<p>这个正则表达式只有两位维护者知道什么意思，如果别人想贡献新的Redis命令，那么理解这个超大正则表达式都需要花很久的时间。</p>
<p>如果换成有限状态机，并且t使用Python的data class来表示，而不是使用字典，那么就会简洁很多。有限状态机的一个特点是，只需要关注当前状态、转移条件和目标状态，可能一开始写起来有点麻烦，但是以后维护和新增，都是直接定位目标，直接修改，不用担心会影响不想干的其他地方。</p>
<p>算上维护时间，正则表达式真是一个非常糟糕的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知乎用户&lt;a href=&quot;https://www.zhihu.com/people/li-zhe-ao/posts&quot;&gt;@Manjusaka
&lt;/a&gt;在阅读了我的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/70680488&quot;&gt;《Python正则表达式，请不要再用re.compile了！！！》&lt;/a&gt;以后，写了一篇驳文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78265675&quot;&gt;《驳 &lt;Python正则表达式，请不要再用re.compile了！！！&gt;》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天，我在这里回应一下这篇驳文。首先标题里面，我用的是&lt;code&gt;回&lt;/code&gt;，意为回复，而不是继续驳斥@Manjusaka的文章。因为没有什么好驳斥的，他的观点没有什么问题。&lt;/p&gt;
&lt;p&gt;首先说明，我自己在公司的代码里面，也会使用&lt;code&gt;re.compile&lt;/code&gt;。但是，我现在仍然坚持我的观点，让看这篇文章的人，不要用&lt;code&gt;re.compile&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="正则表达式" scheme="https://www.kingname.info/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>4种方法解决MongoDB游标超时的问题</title>
    <link href="https://www.kingname.info/2019/08/15/solve-cursor-timeout/"/>
    <id>https://www.kingname.info/2019/08/15/solve-cursor-timeout/</id>
    <published>2019-08-15T13:32:31.000Z</published>
    <updated>2019-08-15T13:33:36.840Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用Python从MongoDB里面读取数据时，可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"></div><div class="line">handler = pymongo.MongoClient().db.col</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> handler.find():</div><div class="line">    parse_data(row)</div></pre></td></tr></table></figure>
<p>短短4行代码，读取MongoDB里面的每一行数据，然后传入<code>parse_data</code>做处理。处理完成以后再读取下一行。逻辑清晰而简单，能有什么问题？只要parse_data(row)不报错，这一段代码就完美无缺。</p>
<p>但事实并非这样。</p>
<a id="more"></a>
<p>你的代码可能会在<code>for row in handler.find()</code>这一行报错。它的原因，说来话长。</p>
<p>要解释这个问题，我们首先就需要知道，<code>handler.find()</code>返回的并不是数据库里面的数据，而是一个<code>游标（cursor）对象</code>。如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-14-21-46-36.png" alt=""></p>
<p>只有当你使用for循环开始迭代它的时候，游标才会真正去数据库里面读取数据。</p>
<p>但是，如果每一次循环都连接数据库，那么网络连接会浪费大量时间。</p>
<p>所以pymongo会一次性获取100行，<code>for row in handler.find()</code>循环第一次的时候，它会连上MongoDB，读取一百条数据，缓存到内存中。于是第2-100次循环，数据都是直接从内存里面获取，不会再连接数据库。</p>
<p>当循环进行到底101次的时候，再一次连接数据库，再读取第101-200行内容……</p>
<p>这个逻辑非常有效地降低了网络I/O耗时。</p>
<p>但是，MongoDB默认游标的超时时间是10分钟。10分钟之内，必需再次连接MongoDB读取内容刷新游标时间，否则，就会导致游标超时报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pymongo.errors.CursorNotFound: cursor id 211526444773 not found</div></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-14-21-47-33.png" alt=""></p>
<p>所以，回到最开始的代码中来，如果<code>parse_data</code>每次执行的时间超过6秒钟，那么它执行100次的时间就会超过10分钟。此时，当程序想读取第101行数据的时候，程序就会报错。</p>
<p>为了解决这个问题，我们有4种办法：</p>
<ol>
<li>修改MongoDB的配置，延长游标超时时间，并重启MongoDB。由于生产环境的MongoDB不能随便重启，所以这个方案虽然有用，但是排除。</li>
<li>一次性把数据全部读取下来，再做处理：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">all_data = [row <span class="keyword">for</span> row <span class="keyword">in</span> handler.find()]</div><div class="line"></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> all_data:</div><div class="line">    parse(row)</div></pre></td></tr></table></figure>
<p>这种方案的弊端也很明显，如果数据量非常大，你不一定能全部放到内存里面。即使能够全部放到内存中，但是列表推导式遍历了所有数据，紧接着for循环又遍历一次，浪费时间。</p>
<ol>
<li>让游标每次返回的数据小于100条，这样消费完这一批数据的时间就会小于10分钟：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 每次连接数据库，只返回50行数据</span></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> handler.find().batch_size(<span class="number">50</span>): </div><div class="line">    parse_data(row)</div></pre></td></tr></table></figure>
<p>但这种方案会增加数据库的连接次数，从而增加I/O耗时。</p>
<ol>
<li>让游标永不超时。通过设定参数<code>no_cursor_timeout=True</code>，让游标永不超时：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">cursor = handler.find(no_cursor_timeout=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">    parse_data(row)</div><div class="line">cursor.close()  <span class="comment"># 一定要手动关闭游标</span></div></pre></td></tr></table></figure>
<p>然而这个操作非常危险，因为如果你的Python程序因为某种原因意外停止了，这个游标就再也无法关闭了！除非重启MongoDB，否则这些游标会一直留在MongoDB上，占用资源。</p>
<p>当然可能有人会说，使用<code>try...except</code>把读取数据的地方包住，只要抛出了异常，在处理异常的时候关闭游标即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cursor = handler.find(no_cursor_timeout=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">        parse_data(row)</div><div class="line"><span class="keyword">except</span> Exception:</div><div class="line">    parse_exception()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    cursor.close()  <span class="comment"># 一定要手动关闭游标</span></div></pre></td></tr></table></figure>
<p>其中<code>finally</code>里面的代码，无论有没有异常，都会执行。</p>
<p>但这样写会让代码非常难看。为了解决这个问题，我们可以使用游标的上下文管理器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> handler.find(no_cursor_timeout=<span class="keyword">True</span>) <span class="keyword">as</span> cursor:</div><div class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">        parse_data(row)</div></pre></td></tr></table></figure>
<p>只要程序退出了with的缩进，游标自动就会关闭。如果程序中途报错，游标也会关闭。</p>
<p>它的原理可以用下面两段代码来解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.x = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'进入上下文'</span>)</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        print(<span class="string">'退出上下文'</span>)</div><div class="line">        </div><div class="line"><span class="keyword">with</span> Test() <span class="keyword">as</span> t:</div><div class="line">    t.echo()</div><div class="line">print(<span class="string">'退出缩进'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-14-21-58-00.png" alt=""></p>
<p>接下来在<code>with</code>的缩进里面人为制造异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.x = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'进入上下文'</span>)</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        print(<span class="string">'退出上下文'</span>)</div><div class="line">        </div><div class="line"><span class="keyword">with</span> Test() <span class="keyword">as</span> t:</div><div class="line">    t.echo()</div><div class="line">    <span class="number">1</span> + <span class="string">'a'</span>  <span class="comment"># 这里一定会报错</span></div><div class="line">print(<span class="string">'退出缩进'</span>)</div></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-14-21-48-58.png" alt=""></p>
<p>无论在<code>with</code>的缩进里面发生了什么，<code>Test</code>这个类中的<code>__exit__</code>里面的代码始终都会运行。</p>
<p>我们来看看pymongo的游标对象里面，<code>__exit__</code>是怎么写的，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-08-14-21-49-46.png" alt=""></p>
<p>可以看到，这里正是关闭游标的操作。</p>
<p>因此，如果我们使用上下文管理器，就可以放心大胆地使用<code>no_cursor_timeout=True</code>参数了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们使用Python从MongoDB里面读取数据时，可能会这样写代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pymongo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler = pymongo.MongoClient().db.col&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; handler.find():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    parse_data(row)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;短短4行代码，读取MongoDB里面的每一行数据，然后传入&lt;code&gt;parse_data&lt;/code&gt;做处理。处理完成以后再读取下一行。逻辑清晰而简单，能有什么问题？只要parse_data(row)不报错，这一段代码就完美无缺。&lt;/p&gt;
&lt;p&gt;但事实并非这样。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.kingname.info/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.kingname.info/tags/Python/"/>
    
      <category term="MongoDB" scheme="https://www.kingname.info/tags/MongoDB/"/>
    
  </entry>
  
</feed>
